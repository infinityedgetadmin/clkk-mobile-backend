This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
docs/
  single-table-design.md
graphQl/
  cybrid/
    resolvers/
      getBalance.js
      updateBalance.js
  lambdas/
    clkk-business/
      currencyService.ts
      getBusinessTransaction.ts
      getBusinessTransactions.ts
      index.ts
      package.json
      tsconfig.json
    getFinancialData.ts
    package.json
    tsconfig.json
  resolvers/
    clkk-business/
      getBusinessTransaction.js
      getBusinessTransactions.js
    getFinancialData.js
  schema.graphql
iac/
  appSync/
    app-sync.yaml
  checkbook/
    checkbook-stack.yaml
  cybrid/
    cybrid-stack.yaml
    transfer-stack.yaml
  graphql/
    graphql-stack.yaml
  nmi/
    nmi-stack.yaml
  plaid/
    plaid-stack.yaml
  prove/
    identity-stack.yaml
  shared/
    deploy-test-bucket.sh
    domain-stack.yaml
    iam-policies.yaml
    networking.yaml
    shared-stack.yaml
    test-data-bucket.yaml
  users/
    users-stack.yaml
  database-stack.yaml
lambdas/
  appsync-authorizer/
    index.ts
    package.json
    tsconfig.json
  checkbook/
    config/
      index.ts
    constants/
      checkbook-keys.ts
    services/
      checkbook-base-service.ts
      checkbook-card-service.ts
      checkbook-payment-service.ts
      checkbook-service.ts
      payment-security-service.ts
    types/
      card.ts
      checkbook.ts
      payment.ts
      request-types.ts
    validators/
      card-validator.ts
      digital-check-validator.ts
      request-validator.ts
      schemas.ts
    webhooks/
      types.ts
      webhook-handler.ts
      webhook-receiver.ts
    card-encryption.ts
    card-test.js
    card.ts
    checkbook.ts
    package.json
    payment.ts
    README-client-encryption.md
    simple-card-encrypt.js
    tsconfig.json
  clerk-users/
    auth/
      clerk-authorizer.ts
      package.json
    services/
      auth/
        auth-service.ts
        clerk-provider.ts
      userService.ts
    types/
      auth.ts
    utils/
      verifySignature.ts
    clerk-webhook.ts
    package.json
    tsconfig.json
  cybrid/
    accounts/
      create-account.ts
      cybrid-accounts.ts
    auth/
      clerk-authorizer.ts
    customers/
      create-business-customer.ts
      cybrid-customers.ts
    externalAccounts/
      verifyAccounts/
        app.ts
      app.ts
    identities/
      app.ts
      business-identity-verification.ts
      check-business-verification-status.ts
      complete-business-verification.ts
      get-business-identity.ts
      get-identity.ts
      list-business-files.ts
      tsconfig.json
      upload-business-file.ts
      upload-file.ts
    quotes/
      services/
        package.json
        quote-service.ts
        transaction-service.ts
        tsconfig.json
      types/
        user.types.ts
      app.ts
      types.ts
    services/
      auth/
        auth-service.ts
        clerk-provider.ts
      cybrid/
        cybrid-provider.ts
      email/
        email-templates.ts
      queues/
        sqsService.ts
      business-verification-service.ts
      file-upload-service.ts
      userService.ts
    streams/
      fiat-account-stream.ts
    tests/
      unit/
        clerk-users/
          auth-service.test.ts
          clerk-users.test.ts
        cybrid/
          accounts.test.ts
        test-handler.test.ts
    transfers/
      webhooks/
        transfer-processor.ts
      app.ts
    types/
      auth.ts
      index.ts
    utils/
      constants.ts
      getSecret.ts
      personaUrl.ts
      plaidService.ts
      plaidTokenService.ts
      single-table-keys.ts
      verifySignature.ts
    webhooks/
      types/
        auth.ts
        index.ts
      webhook-handler.ts
      webhook-processor.ts
    app.ts
    package.json
    processPlatformFee.ts
    tsconfig.json
  dynamo-stream-processor/
    index.ts
    package.json
    tsconfig.json
  dynamo-updater/
    dynamo-updater.ts
    package.json
  graphql-business-transactions/
    currencyService.ts
    getBusinessTransaction.ts
    getBusinessTransactions.ts
    index.ts
    package.json
    single-table-keys.ts
    tsconfig.json
  graphql-financial-data/
    index.ts
    package.json
    single-table-keys.ts
    tsconfig.json
  nmi/
    config/
      index.ts
      paths.ts
    handlers/
      config/
        index.ts
        paths.ts
      services/
        nmi-service.ts
        secrets-service.ts
        webhook-service.ts
      types/
        nmi.ts
        request-types.ts
        webhook.ts
      validators/
        request-validator.ts
        schemas.ts
      nmi.ts
      package.json
      tsconfig.json
    services/
      nmi-service.ts
      secrets-service.ts
      webhook-service.ts
    types/
      nmi.ts
      request-types.ts
      webhook.ts
    validators/
      request-validator.ts
      schemas.ts
    webhooks/
      config/
        index.ts
        paths.ts
      services/
        book-transfer-service.ts
        nmi-service.ts
        secrets-service.ts
        unified-transaction-service.ts
        webhook-service.ts
      types/
        nmi.ts
        request-types.ts
        transaction.types.ts
        webhook.ts
      utils/
        date-util.ts
        dynamodb.ts
        single-table-keys.ts
      package.json
      README.md
      tsconfig.json
      webhook-processor.ts
      webhook-receiver.ts
    package.json
  notifications/
    services/
      tsconfig.json
    package.json
    push-notification.ts
    saveDeviceToken.ts
    tsconfig.json
    user-notifications.ts
  plaid/
    data/
      app.ts
    identity/
      app.ts
    services/
      plaidService.ts
    types/
      index.ts
    utils/
      auth.ts
      config.ts
      constants.ts
      getSecret.ts
      plaid.ts
      single-table-keys.ts
    verificationStatus/
      app.ts
    app.ts
    package.json
    tsconfig.json
  prove/
    handlers/
      identity.ts
    identity-verification/
      (constants).ts
      (definitions).ts
      (models).ts
    integrations/
      prove-backend-sdk/
        (constants).ts
        index.ts
      (definitions).ts
      prove-backend-sdk.ts
    services/
      ProveIdentityService.ts
    validators/
      request-validator.ts
      schemas.ts
    identity.ts
    package.json
    README.md
  search/
    app.ts
    package.json
  services/
    currencyService.ts
    feeService.ts
    package.json
    tsconfig.json
  shared/
    services/
      AdminFirebaseService.ts
      book-transfer-service.ts
      tsconfig.json
      unified-transaction-service.test.ts
      unified-transaction-service.ts
    types/
      transaction.types.ts
    utils/
      date-util.ts
      dynamodb.ts
      single-table-keys.ts
    package.json
    tsconfig.json
  streams/
    transaction-processor/
      app.ts
      package.json
      tsconfig.json
  transactions/
    services/
      package.json
      quote-service.ts
      transaction-service.ts
      tsconfig.json
    utils/
      single-table-keys.ts
    package.json
    processPlatformFee.ts
    tsconfig.json
  user/
    details/
      app.ts
      package.json
      tsconfig.json
      types.ts
    profile/
      app.ts
      package.json
      tsconfig.json
    search/
      app.ts
      package.json
      search-entity.ts
      types.ts
    transactions/
      app.ts
      package.json
layers/
  commons/
    data/
      entities/
        __tests__/
          entity.mock.ts
          entity.test.ts
          money.test.ts
        balance-ledger.test.ts
        balance-ledger.ts
        entity.ts
        fee.test.ts
        fee.ts
        money.test.ts
        money.ts
        provider-transaction.test.ts
        provider-transaction.ts
        provider.ts
        revenue.ts
        transaction.test.ts
        transaction.ts
        wallet.test.ts
        wallet.ts
      base.ts
      client.ts
      README.md
      utils.ts
    dynamodb/
      db-client.ts
      db-operations.ts
      dynamodb-types.ts
    services/
      cybrid/
        cybrid-service.ts
      nmi/
        nmi-customer.ts
      email.service.ts
      KmsService.ts
      snsService.ts
    types/
      cybrid/
        cybrid.i.ts
      f-labs/
        index.ts
      records/
        dynamoRecords.i.ts
      shared/
        graphql.ts
      users/
        entities.i.ts
      identities.i.ts
      index.ts
    utils/
      api-responses.ts
      config.ts
      constants.ts
      cybrid-auth.ts
      cybrid.ts
      date.ts
      dynamo.ts
      dynamoUtils.ts
      getSecret.ts
      logger_v2.ts
      logger.ts
      responseBuilder.ts
      secretManager.ts
      sqsService.ts
      variables.ts
    index.ts
    Makefile
    package.json
    tsconfig.json
  prove-identity/
    package.json
stacks/
  services/
    clerk/
      hello-world/
        tests/
          unit/
            test-handler.test.ts
        app.ts
tasks/
  cybrid-transaction-integration-prd.md
types/
  users.ts
.eslintignore
.eslintrc.js
.gitignore
.npmignore
.prettierrc.js
CLAUDE.local.md
CLAUDE.md
jest.config.ts
package.json
README.md
samconfig.toml
template.yaml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(grep:*)",
      "Bash(find:*)",
      "Bash(mkdir:*)",
      "Bash(cp:*)"
    ],
    "deny": []
  }
}
</file>

<file path="docs/single-table-design.md">
# Single Table Design for Cybrid Services

## Overview
This document outlines the single table design patterns for migrating Cybrid multi-table structure to the unified single table (`clkk-app-table`).

## Key Design Patterns

### 1. User Entity (replaces ENTITIES table)
```
PK: USER#<userId>
SK: USER#<userId>
Attributes: All user profile data (firstName, lastName, email, clkktag, kyc, cybrid metadata, etc.)
```

### 2. Cybrid Fiat Accounts (replaces CYBRID_FIAT_ACCOUNTS table)
```
PK: USER#<userId>
SK: CYBRID#FIAT#<accountGuid>
Attributes: accountId, customerId, asset, balance, state, createdAt, updatedAt
GSI: ExternalIdKey = CYBRID#CUSTOMER#<customerId>, ProviderIdKey = FIAT#<accountGuid>
```

### 3. Cybrid Identity Verifications (replaces CYBRID_IDENTITY_VERIFICATIONS table)
```
PK: USER#<userId>
SK: CYBRID#KYC#<timestamp>
Attributes: customerId, identityGuid, status, createdAt, outcome, personaInquiryId
GSI: ExternalIdKey = CYBRID#CUSTOMER#<customerId>, TimeSortKey = <timestamp>
```

### 4. Plaid Access Tokens (replaces PLAID_ACCESS_TOKENS table)
```
PK: USER#<userId>
SK: PLAID#TOKEN
Attributes: plaidAccessToken, processorToken, plaidItemId, metadata
```

### 5. External Bank Accounts (stored in ENTITIES cybrid metadata)
```
PK: USER#<userId>
SK: CYBRID#BANK#<externalAccountGuid>
Attributes: accountGuid, status, institutionName, accountNumber, routingNumber
```

### 6. CLKK Transactions (for new transaction storage)
```
PK: USER#<userId>
SK: TXN#<timestamp>#<transactionId>
Attributes: All transaction details
GSI: TransactionLookupKey = TXN#<transactionId>
```

## Query Patterns Mapping

### 1. Get User by ID
**Old**: `get({ entityId })`
**New**: `get({ PK: 'USER#<userId>', SK: 'USER#<userId>' })`

### 2. Get Cybrid Fiat Accounts by Customer ID
**Old**: `query({ IndexName: 'UserIdIndex', KeyConditionExpression: 'userId = :userId' })`
**New**: `query({ KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk)', ExpressionAttributeValues: { ':pk': 'USER#<userId>', ':sk': 'CYBRID#FIAT#' } })`

### 3. Get Identity Verification by Customer ID
**Old**: `query({ IndexName: 'customer_id_index', KeyConditionExpression: 'customerId = :customerId' })`
**New**: `query({ IndexName: 'ExternalIdIndex', KeyConditionExpression: 'ExternalIdKey = :key', ExpressionAttributeValues: { ':key': 'CYBRID#CUSTOMER#<customerId>' } })`

### 4. Get Plaid Token by User ID
**Old**: `get({ userId })`
**New**: `get({ PK: 'USER#<userId>', SK: 'PLAID#TOKEN' })`

## Response Transformation

When reading from the single table, Lambda functions must transform the data back to the original format expected by clients:

```javascript
// Example for Cybrid Fiat Account
// Single table item
{
  PK: "USER#123",
  SK: "CYBRID#FIAT#abc-def",
  accountId: "abc-def",
  customerId: "cust-123",
  balance: 1000,
  asset: "USD"
}

// Transform to client expected format
{
  userId: "123",
  accountId: "abc-def", 
  customerId: "cust-123",
  balance: 1000,
  asset: "USD"
}
```

## Implementation Notes

1. All Lambda functions will use the same table name from environment variable
2. Key structures must be built dynamically based on input parameters
3. Response transformations must maintain backward compatibility
4. GSIs are used for alternative access patterns (by customerId, by timestamp, etc.)
</file>

<file path="graphQl/cybrid/resolvers/getBalance.js">
import { util } from '@aws-appsync/utils';

/**
 * Sends a request to get balance for a specific user and account
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {import('@aws-appsync/utils').DynamoDBGetItemRequest} the request
 */
export function request(ctx) {
    return dynamoDBGetItemRequest({
        userId: ctx.args.userId,
        accountId: ctx.args.accountId,
    });
}

/**
 * Returns the fetched DynamoDB item
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the transformed balance data
 */
export function response(ctx) {
    if (ctx.error) {
        util.error(ctx.error.message, ctx.error.type);
    }
    return ctx.result;
}

/**
 * A helper function to get a DynamoDB item
 * @returns {import('@aws-appsync/utils').DynamoDBGetItemRequest} the request
 */
function dynamoDBGetItemRequest(key) {
    return {
        operation: 'GetItem',
        key: util.dynamodb.toMapValues(key),
    };
}
</file>

<file path="graphQl/cybrid/resolvers/updateBalance.js">
import { util } from '@aws-appsync/utils';

/**
 * Sends a request to update balance for a specific user and account
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {import('@aws-appsync/utils').DynamoDBUpdateItemRequest} the request
 */
export function request(ctx) {
    return dynamoDBUpdateItemRequest({
        key: {
            userId: ctx.args.userId,
            accountId: ctx.args.accountId,
        },
        values: {
            amount: ctx.args.amount,
            asset: ctx.args.asset,
        },
    });
}

/**
 * Returns the updated DynamoDB item
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the transformed balance data
 */
export function response(ctx) {
    if (ctx.error) {
        util.error(ctx.error.message, ctx.error.type);
    }
    return ctx.result;
}

/**
 * A helper function to update a DynamoDB item
 * @returns {import('@aws-appsync/utils').DynamoDBUpdateItemRequest} the request
 */
function dynamoDBUpdateItemRequest({ key, values }) {
    return {
        operation: 'UpdateItem',
        key: util.dynamodb.toMapValues(key),
        update: {
            expression: 'SET #amount = :amount, #asset = :asset',
            expressionNames: {
                '#amount': 'amount',
                '#asset': 'asset',
            },
            expressionValues: util.dynamodb.toMapValues({
                ':amount': values.amount,
                ':asset': values.asset,
            }),
        },
    };
}
</file>

<file path="graphQl/lambdas/clkk-business/currencyService.ts">
/**
 * Currency Service - Handles all currency conversions and calculations
 *
 * This service ensures consistent handling of monetary values throughout the application.
 * All amounts are stored and processed in the smallest currency unit (cents for USD)
 * to avoid floating point precision issues.
 */
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'currency-service' });

// Currency configuration
export interface CurrencyConfig {
    code: string; // Currency code (e.g., 'USD')
    decimals: number; // Number of decimal places (e.g., 2 for USD)
    symbol: string; // Currency symbol (e.g., '$')
}

// Supported currencies and their configurations
export const CURRENCIES: Record<string, CurrencyConfig> = {
    USD: { code: 'USD', decimals: 2, symbol: '$' },
    EUR: { code: 'EUR', decimals: 2, symbol: 'â‚¬' },
    // Add other currencies as needed
};

export class CurrencyService {
    /**
     * Convert a decimal amount (dollars) to the smallest unit (cents)
     * @param amount - Amount in decimal form (e.g., 10.99)
     * @param currencyCode - Currency code (defaults to USD)
     * @returns Amount in smallest units (e.g., 1099)
     */
    public static toSmallestUnit(amount: number, currencyCode = 'USD'): number {
        const currency = CURRENCIES[currencyCode] || CURRENCIES.USD;
        const factor = Math.pow(10, currency.decimals);

        // Use Math.round to handle potential floating point issues
        const result = Math.round(amount * factor);

        logger.debug('Converted to smallest unit', {
            from: amount,
            to: result,
            currency: currencyCode,
            operation: 'toSmallestUnit',
        });

        return result;
    }

    /**
     * Convert from smallest unit (cents) to decimal amount (dollars)
     * @param amount - Amount in smallest units (e.g., 1099)
     * @param currencyCode - Currency code (defaults to USD)
     * @returns Amount in decimal form (e.g., 10.99)
     */
    public static fromSmallestUnit(amount: number, currencyCode = 'USD'): number {
        const currency = CURRENCIES[currencyCode] || CURRENCIES.USD;
        const factor = Math.pow(10, currency.decimals);

        const result = amount / factor;

        logger.debug('Converted from smallest unit', {
            from: amount,
            to: result,
            currency: currencyCode,
            operation: 'fromSmallestUnit',
        });

        return result;
    }

    /**
     * Add two monetary amounts safely
     * @param a - First amount (in smallest units)
     * @param b - Second amount (in smallest units)
     * @returns Sum (in smallest units)
     */
    public static add(a: number, b: number): number {
        return a + b;
    }

    /**
     * Subtract one monetary amount from another safely
     * @param a - First amount (in smallest units)
     * @param b - Amount to subtract (in smallest units)
     * @returns Difference (in smallest units)
     */
    public static subtract(a: number, b: number): number {
        return a - b;
    }

    /**
     * Multiply a monetary amount by a factor
     * @param amount - Amount (in smallest units)
     * @param factor - Multiplication factor
     * @returns Product (in smallest units)
     */
    public static multiply(amount: number, factor: number): number {
        return Math.round(amount * factor);
    }

    /**
     * Calculate percentage of an amount
     * @param amount - Base amount (in smallest units)
     * @param percentage - Percentage as decimal (e.g., 0.01 for 1%)
     * @returns Percentage amount (in smallest units)
     */
    public static calculatePercentage(amount: number, percentage: number): number {
        const result = Math.round(amount * percentage);

        logger.debug('Calculated percentage', {
            amount,
            percentage: percentage * 100 + '%',
            result,
            operation: 'calculatePercentage',
        });

        return result;
    }

    /**
     * Format amount for display
     * @param amount - Amount (in smallest units)
     * @param currencyCode - Currency code
     * @returns Formatted string (e.g., "$10.99")
     */
    public static format(amount: number, currencyCode = 'USD'): string {
        const currency = CURRENCIES[currencyCode] || CURRENCIES.USD;
        const decimalAmount = this.fromSmallestUnit(amount, currencyCode);

        return `${currency.symbol}${decimalAmount.toFixed(currency.decimals)}`;
    }

    /**
     * Converts dollars to cents (integer)
     * @param dollars Amount in dollars (can be decimal)
     * @returns Amount in cents as integer
     */
    static dollarsToCents(dollars: number): number {
        return Math.round(dollars * 100);
    }

    /**
     * Converts cents to dollars
     * @param cents Amount in cents (integer)
     * @returns Amount in dollars (decimal)
     */
    static centsToDollars(cents: number): number {
        return cents / 100;
    }

    /**
     * Calculates fee amount based on percentage
     * @param amount Amount in cents
     * @param feePercentage Fee percentage (e.g., 0.01 for 1%)
     * @returns Fee amount in cents
     */
    static calculateFee(amount: number, feePercentage: number): number {
        return Math.round(amount * feePercentage);
    }

    /**
     * Formats amount for display with currency symbol
     * @param amount Amount in cents
     * @param currency Currency code
     * @returns Formatted currency string
     */
    static formatCurrency(amount: number, currency: string = 'USD'): string {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency,
        }).format(this.centsToDollars(amount));
    }
}
</file>

<file path="graphQl/lambdas/clkk-business/getBusinessTransaction.ts">
import { DynamoDBClient, GetItemCommand } from '@aws-sdk/client-dynamodb';
import { unmarshall } from '@aws-sdk/util-dynamodb';
import { DYNAMO_TABLES } from 'commons';

const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });

/**
 * Transaction interface matching GraphQL schema
 */
interface Transaction {
    userId: string;
    transactionId: string;
    type: string;
    status: string;
    amount: number;
    asset: string;
    createdAt: string;
    updatedAt: string;
    fee_processed_at?: string;
    sourceAccountId?: string;
    destinationAccountId?: string;
    quoteGuid?: string;
    paymentProviderId?: string;
    recipientId?: string;
    memo?: string;
    senderName?: string;
    senderClkktag?: string;
    recipientName?: string;
    recipientClkktag?: string;
    transferState?: string;
    recipientEntityId?: string;
    senderEntityId?: string;
    sender_entity_type?: string;
    recipient_current_email?: string;
    sender_current_email?: string;
    source_account_guid?: string;
    destination_account_guid?: string;
    recipient_cy_guid?: string;
    sender_cy_guid?: string;
    sender_name?: string;
    recipient_name?: string;
    sender_clkktag?: string;
    recipient_clkktag?: string;
    fees?: Fee;
    fee_amount?: number;
    fee_pending?: boolean;
    fee_percentage?: number;
    net_amount?: number;
}

interface Fee {
    type: string;
    rate: number;
    spread_fee: number;
    fixed_fee: number;
}

/**
 * Handler for getting a business transaction by ID
 * @param event Lambda event from AppSync
 * @returns The business transaction or null if not found
 */
export const handler = async (event: any): Promise<Transaction | null> => {
    console.log('â­ï¸ GetBusinessTransaction event:', JSON.stringify(event));

    const transactionId = event.arguments.transactionId;
    const businessId = event.arguments.businessId; // Optional: used for verification

    try {
        // Get the transaction by ID
        const params = {
            TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
            Key: {
                transactionId: { S: transactionId },
            },
        };

        console.log('ðŸ” Query params:', JSON.stringify(params));

        const result = await dynamoClient.send(new GetItemCommand(params));

        if (!result.Item) {
            console.log('Transaction not found');
            return null;
        }

        // Transform the DynamoDB item to our schema format
        const transaction = transformTransaction(result.Item);

        // Optionally verify that this transaction belongs to the business
        if (businessId && transaction.recipientEntityId !== businessId) {
            console.log('Transaction does not belong to the specified business');
            return null;
        }

        return transaction;
    } catch (error) {
        console.error('Error fetching business transaction:', error);
        throw new Error(
            `Failed to fetch business transaction: ${error instanceof Error ? error.message : 'Unknown error'}`,
        );
    }
};

/**
 * Transform DynamoDB item to Transaction object
 */
const transformTransaction = (item: any): Transaction => {
    const unmarshalled = unmarshall(item);

    return {
        // Required fields
        userId: unmarshalled.userId || '',
        transactionId: unmarshalled.transactionId || '',
        type: unmarshalled.type || 'p2p_transfer',
        status: unmarshalled.status || 'pending',
        amount: parseFloat(unmarshalled.amount?.toString() || '0'),
        asset: unmarshalled.asset || 'USD',
        createdAt: unmarshalled.createdAt || new Date().toISOString(),
        updatedAt: unmarshalled.updatedAt || new Date().toISOString(),
        recipientEntityId: unmarshalled.recipientEntityId || '',
        senderEntityId: unmarshalled.senderEntityId || '',

        // Optional fields
        sourceAccountId: unmarshalled.sourceAccountId,
        destinationAccountId: unmarshalled.destinationAccountId,
        quoteGuid: unmarshalled.quoteGuid,
        paymentProviderId: unmarshalled.paymentProviderId,
        recipientId: unmarshalled.recipientId,
        memo: unmarshalled.memo,
        senderName: unmarshalled.senderName,
        senderClkktag: unmarshalled.senderClkktag,
        recipientName: unmarshalled.recipientName,
        recipientClkktag: unmarshalled.recipientClkktag,
        transferState: unmarshalled.transferState,
        sender_entity_type: unmarshalled.sender_entity_type,
        recipient_current_email: unmarshalled.recipient_current_email,
        sender_current_email: unmarshalled.sender_current_email,
        source_account_guid: unmarshalled.source_account_guid,
        destination_account_guid: unmarshalled.destination_account_guid,
        recipient_cy_guid: unmarshalled.recipient_cy_guid,
        sender_cy_guid: unmarshalled.sender_cy_guid,
        sender_name: unmarshalled.sender_name,
        recipient_name: unmarshalled.recipient_name,
        sender_clkktag: unmarshalled.sender_clkktag,
        recipient_clkktag: unmarshalled.recipient_clkktag,
        fees: unmarshalled.fees
            ? {
                  type: unmarshalled.fees.type || '',
                  rate: parseFloat(unmarshalled.fees.rate?.toString() || '0'),
                  spread_fee: parseFloat(unmarshalled.fees.spread_fee?.toString() || '0'),
                  fixed_fee: parseFloat(unmarshalled.fees.fixed_fee?.toString() || '0'),
              }
            : undefined,
        fee_amount: parseFloat(unmarshalled.fee_amount?.toString() || '0'),
        fee_pending: unmarshalled.fee_pending || false,
        fee_percentage: parseFloat(unmarshalled.fee_percentage?.toString() || '0'),
        net_amount: parseFloat(unmarshalled.net_amount?.toString() || '0'),
        fee_processed_at: unmarshalled.fee_processed_at,
    };
};
</file>

<file path="graphQl/lambdas/clkk-business/getBusinessTransactions.ts">
import { DynamoDBClient, QueryCommand } from '@aws-sdk/client-dynamodb';
import { unmarshall } from '@aws-sdk/util-dynamodb';
import { DYNAMO_TABLES } from 'commons';
import { CurrencyService } from './currencyService';

const client = new DynamoDBClient({ region: process.env.AWS_REGION });

/**
 * Response interface for the GetBusinessTransactions API
 */
interface GetBusinessTransactionsResponse {
    transactions: Transaction[];
    nextToken?: string;
    totalCount?: number;
}

/**
 * Transaction interface matching GraphQL schema
 */
interface Transaction {
    userId: string;
    transactionId: string;
    type: string;
    status: string;
    amount: number;
    asset: string;
    createdAt: string;
    updatedAt: string;
    sourceAccountId?: string;
    destinationAccountId?: string;
    quoteGuid?: string;
    paymentProviderId?: string;
    recipientId?: string;
    memo?: string;
    senderName?: string;
    senderClkktag?: string;
    recipientName?: string;
    recipientClkktag?: string;
    transferState?: string;
    failureCode?: string;
    returnCode?: string;
    recipientEntityId: string;
    senderEntityId: string;
    recipient_entity_type?: string;
    sender_entity_type?: string;
    recipient_current_email?: string;
    sender_current_email?: string;
    source_account_guid?: string;
    destination_account_guid?: string;
    recipient_cy_guid?: string;
    sender_cy_guid?: string;
    sender_name?: string;
    recipient_name?: string;
    sender_clkktag?: string;
    recipient_clkktag?: string;
    fees?: Fee;
    fee_amount?: number;
    fee_pending?: boolean;
    fee_percentage?: number;
    net_amount?: number;
}

interface Fee {
    type: string;
    rate: number;
    spread_fee: number;
    fixed_fee: number;
}

interface BusinessTransactionFilter {
    senderClkktag?: string;
    senderEmail?: string;
    amountGreaterThan?: number;
    amountLessThan?: number;
    transactionId?: string;
    status?: string;
    dateFrom?: string;
    dateTo?: string;
}

/**
 * Fetches business transactions with optional filtering
 * @param {string} businessId - The business entity ID
 * @param {BusinessTransactionFilter} filter - Optional filter parameters
 * @param {number} limit - Maximum number of transactions to return
 * @param {string} nextToken - Token for pagination
 * @returns {Promise<Object>} - Business transactions and next token
 */
export const handler = async (event: any) => {
    try {
        console.log('â­ï¸ GetBusinessTransactions event:', JSON.stringify(event));

        const businessId = event.arguments.businessId;
        const filter = event.arguments.filter || {};
        const limit = event.arguments.limit || 20;
        const nextToken = event.arguments.nextToken ? JSON.parse(event.arguments.nextToken) : undefined;

        // Base query parameters
        const queryParams: any = {
            TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
            IndexName: 'RecipientIdIndex',
            KeyConditionExpression: 'recipientEntityId = :businessId',
            ExpressionAttributeValues: {
                ':businessId': { S: businessId },
            },
            Limit: limit,
            ScanIndexForward: false, // Most recent first
        };

        // Date range filters (need to be added to key condition since createdAt is a sort key)
        if (filter.dateFrom && filter.dateTo) {
            // Use BETWEEN operator for date range
            queryParams.KeyConditionExpression += ' AND createdAt BETWEEN :dateFrom AND :dateTo';
            queryParams.ExpressionAttributeValues[':dateFrom'] = { S: filter.dateFrom };
            queryParams.ExpressionAttributeValues[':dateTo'] = { S: filter.dateTo };
        } else if (filter.dateFrom) {
            // Only from date specified
            queryParams.KeyConditionExpression += ' AND createdAt >= :dateFrom';
            queryParams.ExpressionAttributeValues[':dateFrom'] = { S: filter.dateFrom };
        } else if (filter.dateTo) {
            // Only to date specified
            queryParams.KeyConditionExpression += ' AND createdAt <= :dateTo';
            queryParams.ExpressionAttributeValues[':dateTo'] = { S: filter.dateTo };
        }

        // Build filter expression for additional filters (non-key attributes)
        let filterExpressions: string[] = [];

        // TransactionId filter
        if (filter.transactionId) {
            filterExpressions.push('transactionId = :transactionId');
            queryParams.ExpressionAttributeValues[':transactionId'] = { S: filter.transactionId };
        }

        // Sender clkktag filter
        if (filter.senderClkktag) {
            filterExpressions.push('contains(sender_clkktag, :senderClkktag)');
            queryParams.ExpressionAttributeValues[':senderClkktag'] = { S: filter.senderClkktag };
        }

        // Sender email filter
        if (filter.senderEmail) {
            filterExpressions.push('contains(sender_current_email, :senderEmail)');
            queryParams.ExpressionAttributeValues[':senderEmail'] = { S: filter.senderEmail };
        }

        // Amount range filters
        if (filter.amountGreaterThan !== undefined) {
            // Convert dollars to cents using the existing CurrencyService utility
            const minAmountCents = CurrencyService.toSmallestUnit(filter.amountGreaterThan, 'USD');
            filterExpressions.push('amount >= :minAmount');
            queryParams.ExpressionAttributeValues[':minAmount'] = { N: minAmountCents.toString() };
        }

        if (filter.amountLessThan !== undefined) {
            // Convert dollars to cents using the existing CurrencyService utility
            const maxAmountCents = CurrencyService.toSmallestUnit(filter.amountLessThan, 'USD');
            filterExpressions.push('amount <= :maxAmount');
            queryParams.ExpressionAttributeValues[':maxAmount'] = { N: maxAmountCents.toString() };
        }

        // Status filter
        if (filter.status) {
            filterExpressions.push('status = :status');
            queryParams.ExpressionAttributeValues[':status'] = { S: filter.status };
        }

        // Combine filter expressions if any exist
        if (filterExpressions.length > 0) {
            queryParams.FilterExpression = filterExpressions.join(' AND ');
        }

        console.log('ðŸ” Query params:', JSON.stringify(queryParams));

        // Execute query
        const result = await client.send(new QueryCommand(queryParams));

        // Transform results - simply unmarshall without converting amounts
        const transactions = (result.Items || []).map((item) => unmarshall(item));

        // Prepare pagination token if more results exist
        const responseNextToken = result.LastEvaluatedKey ? JSON.stringify(result.LastEvaluatedKey) : null;

        console.log('ðŸ” Transactions:', JSON.stringify(transactions));

        return {
            items: transactions,
            nextToken: responseNextToken,
        };
    } catch (error) {
        console.error('Error fetching business transactions:', error);
        throw new Error(
            `Failed to fetch business transactions: ${error instanceof Error ? error.message : 'Unknown error'}`,
        );
    }
};

/**
 * Transform DynamoDB item to Transaction object
 */
const transformTransaction = (item: any): Transaction => {
    const unmarshalled = unmarshall(item);

    return {
        // Required fields
        userId: unmarshalled.userId || '',
        transactionId: unmarshalled.transactionId || '',
        type: unmarshalled.type || 'p2p_transfer',
        status: unmarshalled.status || 'pending',
        amount: parseFloat(unmarshalled.amount?.toString() || '0'),
        asset: unmarshalled.asset || 'USD',
        createdAt: unmarshalled.createdAt || new Date().toISOString(),
        updatedAt: unmarshalled.updatedAt || new Date().toISOString(),
        recipientEntityId: unmarshalled.recipientEntityId || '',
        senderEntityId: unmarshalled.senderEntityId || '',

        // Optional fields
        sourceAccountId: unmarshalled.sourceAccountId,
        destinationAccountId: unmarshalled.destinationAccountId,
        quoteGuid: unmarshalled.quoteGuid,
        paymentProviderId: unmarshalled.paymentProviderId,
        recipientId: unmarshalled.recipientId,
        memo: unmarshalled.memo,
        senderName: unmarshalled.senderName,
        senderClkktag: unmarshalled.senderClkktag,
        recipientName: unmarshalled.recipientName,
        recipientClkktag: unmarshalled.recipientClkktag,
        transferState: unmarshalled.transferState,
        failureCode: unmarshalled.failureCode,
        returnCode: unmarshalled.returnCode,
        recipient_entity_type: unmarshalled.recipient_entity_type,
        sender_entity_type: unmarshalled.sender_entity_type,
        recipient_current_email: unmarshalled.recipient_current_email,
        sender_current_email: unmarshalled.sender_current_email,
        source_account_guid: unmarshalled.source_account_guid,
        destination_account_guid: unmarshalled.destination_account_guid,
        recipient_cy_guid: unmarshalled.recipient_cy_guid,
        sender_cy_guid: unmarshalled.sender_cy_guid,
        sender_name: unmarshalled.sender_name,
        recipient_name: unmarshalled.recipient_name,
        sender_clkktag: unmarshalled.sender_clkktag,
        recipient_clkktag: unmarshalled.recipient_clkktag,
        fees: unmarshalled.fees
            ? {
                  type: unmarshalled.fees.type || '',
                  rate: parseFloat(unmarshalled.fees.rate?.toString() || '0'),
                  spread_fee: parseFloat(unmarshalled.fees.spread_fee?.toString() || '0'),
                  fixed_fee: parseFloat(unmarshalled.fees.fixed_fee?.toString() || '0'),
              }
            : undefined,
        fee_amount: parseFloat(unmarshalled.fee_amount?.toString() || '0'),
        fee_pending: unmarshalled.fee_pending || false,
        fee_percentage: parseFloat(unmarshalled.fee_percentage?.toString() || '0'),
        net_amount: parseFloat(unmarshalled.net_amount?.toString() || '0'),
    };
};
</file>

<file path="graphQl/lambdas/clkk-business/index.ts">
import { handler as getBusinessTransactionsHandler } from './getBusinessTransactions';
import { handler as getBusinessTransactionHandler } from './getBusinessTransaction';

/**
 * Main handler that routes requests based on field name
 */
export const handler = async (event: any) => {
    console.log('ðŸš€ Business API Event:', JSON.stringify(event));

    // Route based on the field name
    switch (event.field) {
        case 'getBusinessTransactions':
            return getBusinessTransactionsHandler(event);
        case 'getBusinessTransaction':
            return getBusinessTransactionHandler(event);
        default:
            throw new Error(`Unknown field: ${event.field}`);
    }
};
</file>

<file path="graphQl/lambdas/clkk-business/package.json">
{
    "name": "user-notifications",
    "version": "1.0.0",
    "description": "User Notifications Lambda",
    "main": "user-notifications.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-sdk/client-dynamodb": "^3.755.0",
        "@aws-sdk/util-dynamodb": "^3.755.0",
        "@aws-lambda-powertools/logger": "^2.11.0"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "axios": "^1.7.9",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="graphQl/lambdas/clkk-business/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="graphQl/lambdas/getFinancialData.ts">
import { DynamoDBClient, BatchGetItemCommand, QueryCommand, GetItemCommand } from '@aws-sdk/client-dynamodb';
import { DYNAMO_TABLES } from 'commons';
const client = new DynamoDBClient({ region: process.env.AWS_REGION });

interface FinancialDataResult {
    userProfile: UserProfile;
    cybridBalances: CybridBalance[];
    plaidAccounts: PlaidAccount[];
    recentTransactions: Transaction[];
    preferences: UserPreferences;
}

interface UserProfile {
    userId: string;
    name: string;
    email: string;
    kycStatus: string;
    accountState: string;
    createdAt: string;
    firstName: string;
    lastName: string;
    phoneNumber: string;
    profileImageUrl: string;
    clkkTag: string;
    updatedAt: string;
}

interface CybridBalance {
    accountId: string;
    balance: number;
    asset: string;
    name: string;
    customerId: string;
    state: string;
    createdAt: string;
    updatedAt: string;
}

interface PlaidAccount {
    id: string;
    mask: string;
    name: string;
    type: string;
    subtype: string;
    verificationStatus: string;
    institutionName: string;
}

interface Transaction {
    transactionId: string;
    senderId: string;
    requestType: string;
    senderName: string;
    senderClkktag: string;
    recipientId: string;
    recipientName: string;
    recipientClkktag: string;
    amount: number;
    asset: string;
    status: string;
    memo: string;
    createdAt: string;
    updatedAt: string;
}

interface UserPreferences {
    notificationSettings: NotificationSettings;
    displaySettings: DisplaySettings;
    deviceTokens: DeviceToken[];
}

interface NotificationSettings {
    emailEnabled: boolean;
    pushEnabled: boolean;
    smsEnabled: boolean;
}

interface DisplaySettings {
    theme: string;
    language: string;
    currency: string;
}

interface DeviceToken {
    token: string;
    platform: string;
    updatedAt: string;
}

const queryCybridAccounts = async (userId: string) => {
    const params = {
        TableName: DYNAMO_TABLES.CYBRID_FIAT_ACCOUNTS,
        IndexName: 'UserIdIndex',
        KeyConditionExpression: 'userId = :userId',
        ExpressionAttributeValues: {
            ':userId': { S: userId },
        },
    };

    const result = await client.send(new QueryCommand(params));
    console.log('cybridAccounts', result.Items);
    return result.Items || [];
};

const getEntity = async (userId: string) => {
    const params = {
        TableName: DYNAMO_TABLES.ENTITIES,
        Key: {
            entityId: { S: userId },
        },
    };

    const result = await client.send(new GetItemCommand(params));
    console.log('entity', result.Item);
    return result.Item;
};

const queryRecentTransactions = async (userId: string, limit: number = 10) => {
    console.log('Querying transactions for userId:', userId);

    // Get transactions where user is sender
    const senderParams = {
        TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
        IndexName: 'SenderIdIndex',
        KeyConditionExpression: 'senderEntityId = :userId',
        ExpressionAttributeValues: {
            ':userId': { S: userId },
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    };

    // Get transactions where user is recipient
    const recipientParams = {
        TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
        IndexName: 'RecipientIdIndex',
        KeyConditionExpression: 'recipientEntityId = :userId',
        ExpressionAttributeValues: {
            ':userId': { S: userId },
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    };

    // Get deposit/withdrawal transactions for this user
    const userTransactionParams = {
        TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
        IndexName: 'UserTransactionsIndex',
        KeyConditionExpression: 'userId = :userId',
        ExpressionAttributeValues: {
            ':userId': { S: userId },
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    };

    try {
        // Execute all queries in parallel
        const [senderResults, recipientResults, userTransactionResults] = await Promise.all([
            client.send(new QueryCommand(senderParams)),
            client.send(new QueryCommand(recipientParams)),
            client.send(new QueryCommand(userTransactionParams)),
        ]);

        // Create a Map to deduplicate transactions by transactionId
        const transactionMap = new Map();

        // Process all transaction results and add to map (deduplicating by transactionId)
        [
            ...(senderResults.Items || []),
            ...(recipientResults.Items || []),
            ...(userTransactionResults.Items || []),
        ].forEach((item) => {
            const transactionId = item.transactionId?.S;
            if (transactionId && !transactionMap.has(transactionId)) {
                transactionMap.set(transactionId, item);
            }
        });

        // Convert map values back to array and sort
        const uniqueTransactions = Array.from(transactionMap.values())
            .sort((a, b) => {
                const dateA = new Date(a.createdAt?.S || '').getTime();
                const dateB = new Date(b.createdAt?.S || '').getTime();
                return dateB - dateA; // Sort descending (newest first)
            })
            .slice(0, limit); // Limit to requested number

        console.log('Combined transactions count (after deduplication/sort/limit):', uniqueTransactions.length);
        return uniqueTransactions;
    } catch (error) {
        console.error('Error querying transactions:', error);
        return [];
    }
};

export const handler = async (event: any): Promise<FinancialDataResult> => {
    try {
        const userId = event.arguments.userId;
        const limit = event.arguments.limit || 10;

        console.log('â­ï¸ GraphQL request:', JSON.stringify(event));

        const [userEntity, cybridAccounts, recentTransactions] = await Promise.all([
            getEntity(userId),
            queryCybridAccounts(userId),
            queryRecentTransactions(userId, limit),
        ]);

        console.log('â­ï¸ Raw user entity:', JSON.stringify(userEntity));

        const result = {
            userProfile: transformUserProfile(userEntity),
            cybridBalances: transformCybridBalances(cybridAccounts),
            plaidAccounts: transformPlaidAccounts(userEntity?.plaid),
            recentTransactions: transformTransactions(recentTransactions, userId),
            preferences: transformPreferences(userEntity),
        };

        console.log('â­ï¸ Final result:', JSON.stringify(result));
        return result;
    } catch (error) {
        console.error('Error fetching financial data:', error);
        throw new Error('Failed to retrieve financial data');
    }
};

const transformUserProfile = (item: any): UserProfile => ({
    userId: item.entityId?.S || '',
    email: item.email?.S || '',
    firstName: item.firstName?.S || '',
    lastName: item.lastName?.S || '',
    phoneNumber: item.phoneNumber?.S || '',
    kycStatus: item.kyc?.M?.status?.S || 'pending',
    accountState: item.cybrid?.M?.customerData?.M?.state?.S || 'unknown',
    profileImageUrl: item.profileImageUrl?.S || '',
    clkkTag: item.clkktag?.S || '',
    createdAt: item.createdAt?.S || '',
    updatedAt: item.updatedAt?.S || '',
    name: `${item.firstName?.S || ''} ${item.lastName?.S || ''}`.trim(),
});

const transformCybridBalances = (items: any[]): CybridBalance[] =>
    items.map((item) => ({
        accountId: item.accountId?.S || '',
        name: item.nm?.S || '',
        balance: parseFloat(item.balance?.N || '0'),
        asset: item.asset?.S || 'USD',
        state: item.st?.S || 'unknown',
        customerId: item.customerId?.S || '',
        createdAt: item.createdAt?.S || '',
        updatedAt: item.updatedAt?.S || '',
    }));

const transformPlaidAccounts = (plaidData: any): PlaidAccount[] => {
    if (!plaidData?.M?.metadata?.M?.accounts?.L) return [];

    return plaidData.M.metadata.M.accounts.L.map((account: any) => ({
        id: account.M.id?.S || '',
        mask: account.M.mask?.S || '',
        name: account.M.name?.S || '',
        type: account.M.type?.S || '',
        subtype: account.M.subtype?.S || '',
        verificationStatus: account.M.verificationStatus?.S || '',
        institutionName: plaidData.M.metadata.M.institution?.M?.name?.S || '',
    }));
};

const transformTransactions = (items: any[], userId: string): Transaction[] =>
    items.map((item) => {
        // Determine if current user is sender or recipient
        const isSender = item.sender_entity_guid?.S === userId || item.senderEntityId?.S === userId;
        const isDeposit = item.type?.S === 'deposit';
        const isWithdrawal = item.type?.S === 'withdrawal';

        // Handle memo with proper precedence
        let memo = item.memo?.S || '';
        if (memo === '' && isDeposit) {
            memo = 'Deposit from bank account';
        } else if (memo === '' && isWithdrawal) {
            memo = 'Withdrawal to bank account';
        }

        return {
            transactionId: item.transactionId?.S || '',
            senderId: item.sender_entity_guid?.S || item.senderEntityId?.S || '',
            recipientId: item.recipient_entity_guid?.S || '',
            // Set request type based on transaction type and user's role
            requestType: isDeposit ? 'deposit' : isWithdrawal ? 'withdrawal' : isSender ? 'sent' : 'received',
            amount: parseFloat(item.amount?.N || '0'),
            asset: item.asset?.S || 'USD',
            status: item.status?.S || '',
            recipientName: item.recipient_name?.S || '',
            recipientClkktag: item.recipient_clkktag?.S || '',
            senderName: item.sender_name?.S || '',
            senderClkktag: item.sender_clkktag?.S || '',
            memo: memo,
            createdAt: item.createdAt?.S || '',
            updatedAt: item.updatedAt?.S || '',
        };
    });

const transformPreferences = (item: any): UserPreferences => {
    console.log('â­ï¸ Begin transforming preferences');
    console.log('â­ï¸ Raw item:', JSON.stringify(item));
    console.log('â­ï¸ Raw preferences:', JSON.stringify(item?.preferences));

    // Set default preferences
    const defaultPreferences = {
        notificationSettings: {
            emailEnabled: true,
            pushEnabled: true,
            smsEnabled: false,
        },
        displaySettings: {
            theme: 'dark',
            language: 'en',
            currency: 'USD',
        },
        deviceTokens: [],
    };

    // If no preferences exist, return defaults
    if (!item?.preferences?.M) {
        console.log('â­ï¸ No preferences found, returning defaults');
        return defaultPreferences;
    }

    try {
        // Extract and transform device tokens
        const deviceTokensArray = [];
        if (item.preferences.M.deviceTokens?.L && Array.isArray(item.preferences.M.deviceTokens.L)) {
            console.log('â­ï¸ Found device tokens array with length:', item.preferences.M.deviceTokens.L.length);

            for (const tokenItem of item.preferences.M.deviceTokens.L) {
                console.log('â­ï¸ Processing token item:', JSON.stringify(tokenItem));

                if (tokenItem.M && tokenItem.M.token?.S) {
                    const token = {
                        token: tokenItem.M.token.S,
                        platform: tokenItem.M.platform?.S || 'unknown',
                        updatedAt: tokenItem.M.updatedAt?.S || new Date().toISOString(),
                    };
                    console.log('â­ï¸ Adding token:', JSON.stringify(token));
                    deviceTokensArray.push(token);
                }
            }
        } else {
            console.log('â­ï¸ No device tokens found in preferences');
        }

        console.log('â­ï¸ Transformed device tokens:', JSON.stringify(deviceTokensArray));

        // Extract notification settings with defaults
        const notificationSettings = {
            emailEnabled:
                item.preferences.M.notificationSettings?.M?.emailEnabled?.BOOL ??
                defaultPreferences.notificationSettings.emailEnabled,
            pushEnabled:
                item.preferences.M.notificationSettings?.M?.pushEnabled?.BOOL ??
                defaultPreferences.notificationSettings.pushEnabled,
            smsEnabled:
                item.preferences.M.notificationSettings?.M?.smsEnabled?.BOOL ??
                defaultPreferences.notificationSettings.smsEnabled,
        };
        console.log('â­ï¸ Transformed notification settings:', JSON.stringify(notificationSettings));

        // Extract display settings with defaults
        const displaySettings = {
            theme: item.preferences.M.displaySettings?.M?.theme?.S || defaultPreferences.displaySettings.theme,
            language: item.preferences.M.displaySettings?.M?.language?.S || defaultPreferences.displaySettings.language,
            currency: item.preferences.M.displaySettings?.M?.currency?.S || defaultPreferences.displaySettings.currency,
        };
        console.log('â­ï¸ Transformed display settings:', JSON.stringify(displaySettings));

        // Construct final preferences object
        const result = {
            notificationSettings: notificationSettings,
            displaySettings: displaySettings,
            deviceTokens: deviceTokensArray,
        };

        console.log('â­ï¸ Final preferences object:', JSON.stringify(result));
        return result;
    } catch (error) {
        console.error('â­ï¸ Error transforming preferences:', error);
        return defaultPreferences;
    }
};
</file>

<file path="graphQl/lambdas/package.json">
{
    "name": "user-notifications",
    "version": "1.0.0",
    "description": "User Notifications Lambda",
    "main": "user-notifications.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-sdk/client-dynamodb": "^3.755.0",
        "@aws-lambda-powertools/logger": "^2.11.0"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "axios": "^1.7.9",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="graphQl/lambdas/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="graphQl/resolvers/clkk-business/getBusinessTransaction.js">
export function request(ctx) {
    const { source, args } = ctx;
    console.log('ðŸ” Request for Single Business Transaction:', JSON.stringify(ctx));
    return {
        operation: 'Invoke',
        payload: { field: 'getBusinessTransaction', arguments: args, source },
    };
}

export function response(ctx) {
    console.log('ðŸ” Response from Business Transaction Lambda:', JSON.stringify(ctx.result));
    return ctx.result;
}
</file>

<file path="graphQl/resolvers/clkk-business/getBusinessTransactions.js">
export function request(ctx) {
    const { source, args } = ctx;
    console.log('ðŸ” Request for Business Transactions:', JSON.stringify(ctx));
    return {
        operation: 'Invoke',
        payload: { field: 'getBusinessTransactions', arguments: args, source },
    };
}

export function response(ctx) {
    console.log('ðŸ” Response from Business Transactions Lambda:', JSON.stringify(ctx.result));
    return ctx.result;
}
</file>

<file path="graphQl/resolvers/getFinancialData.js">
export function request(ctx) {
    console.log('ðŸ” Request for Financial Data:', JSON.stringify(ctx));
    const { source, args } = ctx;
    return {
        operation: 'Invoke',
        payload: { field: ctx.info.fieldName, arguments: args, source },
    };
}

export function response(ctx) {
    console.log('ðŸ” Response from Financial Data Lambda:', JSON.stringify(ctx.result));
    return ctx.result;
}
</file>

<file path="graphQl/schema.graphql">
type Query {
    # Financial queries
    getFinancialData(userId: String!): FinancialData

    # Transaction queries
    getTransaction(transactionId: ID!): Transaction
    getUserTransactions(userId: ID!, filter: TransactionFilterInput): [Transaction]

    # Business queries
    getBusinessTransactions(
        businessId: ID!
        filter: BusinessTransactionFilter
        nextToken: String
        limit: Int
    ): BusinessTransactionConnection
    getBusinessTransaction(transactionId: ID!): Transaction
    getBusinessDashboardData(businessId: ID!): BusinessDashboardData
}

# Transaction related types
type Transaction {
    userId: String!
    transactionId: ID!
    type: String!
    status: String!
    amount: Float!
    asset: String!
    createdAt: String!
    updatedAt: String!
    sourceAccountId: String
    destinationAccountId: String
    quoteGuid: String
    paymentProviderId: String
    recipientId: String
    memo: String
    senderName: String
    senderClkktag: String
    recipientName: String
    recipientClkktag: String
    transferState: String
    failureCode: String
    returnCode: String
    recipientEntityId: String!
    senderEntityId: String!
    recipient_entity_type: String
    sender_entity_type: String
    recipient_current_email: String
    sender_current_email: String
    source_account_guid: String
    destination_account_guid: String
    recipient_cy_guid: String
    sender_cy_guid: String
    sender_name: String
    recipient_name: String
    sender_clkktag: String
    recipient_clkktag: String
    fees: Fee
    fee_amount: Float
    fee_pending: Boolean
    fee_percentage: Float
    net_amount: Float
    fee_processed_at: String
}

enum TransactionType {
    deposit
    withdrawal
    p2p_transfer
    p2b_transfer
    trade
}

enum TransactionStatus {
    pending
    completed
    failed
    cancelled
}

type Fee {
    type: String!
    rate: Float!
    spread_fee: Float!
    fixed_fee: Float!
}

type BusinessDashboardData {
    totalTransactions: Int!
    totalRevenue: Float!
    recentTransactions: [Transaction]
    revenueTrends: [RevenueTrend]
    transactionsByType: [TransactionByType]
    transactionsByStatus: [TransactionByStatus]
}

type RevenueTrend {
    date: String!
    amount: Float!
}

type TransactionByType {
    type: String!
    count: Int!
    amount: Float!
}

type TransactionByStatus {
    status: String!
    count: Int!
    amount: Float!
}

input TransactionFilterInput {
    startDate: String
    endDate: String
    status: TransactionStatus
    type: TransactionType
    minAmount: Float
    maxAmount: Float
    searchText: String
    businessId: ID
    userId: ID
}

# Need to define AWSJSON scalar
scalar AWSJSON

type UserRecentTransaction {
    transactionId: ID!
    requestType: String!
    amount: Float!
    asset: String!
    status: String!
    recipientName: String
    recipientClkktag: String
    senderName: String
    senderClkktag: String
    memo: String
    createdAt: String!
    updatedAt: String
}

type FinancialData {
    userProfile: UserProfile
    cybridBalances: [CybridBalance]
    plaidAccounts: [PlaidAccount]
    recentTransactions: [UserRecentTransaction]
    preferences: UserPreferences
}

type UserProfile {
    userId: ID!
    email: String!
    firstName: String!
    lastName: String!
    phoneNumber: String!
    kycStatus: String!
    accountState: String!
    profileImageUrl: String!
    clkkTag: String!
    createdAt: String!
    updatedAt: String!
}

type CybridBalance {
    accountId: ID!
    name: String!
    balance: Float!
    asset: String!
    state: String!
    customerId: String!
    createdAt: String!
    updatedAt: String!
}

type PlaidAccount {
    id: String!
    mask: String!
    name: String!
    type: String!
    subtype: String!
    institutionName: String!
    verificationStatus: String!
}

enum KYCStatus {
    NOT_STARTED
    IN_PROGRESS
    VERIFIED
    REJECTED
}

type UserPreferences {
    notificationSettings: NotificationSettings
    displaySettings: DisplaySettings
    deviceTokens: [DeviceToken]
}

type DeviceToken {
    token: String!
    platform: String!
    updatedAt: String!
}

type NotificationSettings {
    emailEnabled: Boolean
    pushEnabled: Boolean
    smsEnabled: Boolean
}

type DisplaySettings {
    theme: String
    language: String
    currency: String
}

input BusinessTransactionFilter {
    senderClkktag: String
    senderEmail: String
    amountGreaterThan: Float
    amountLessThan: Float
    transactionId: String
    status: String
    dateFrom: String
    dateTo: String
}

type BusinessTransactionConnection {
    items: [Transaction!]!
    nextToken: String
}
</file>

<file path="iac/appSync/app-sync.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Real-time DynamoDB Streams to AppSync Integration for User and Wallet Updates

Parameters:
    Environment:
        Type: String
        Default: dev
        AllowedValues:
            - dev
            - staging
            - prod
        Description: Environment name for deployment
    TableName:
        Type: String
        Description: DynamoDB table name to listen for changes
    ApplicationTableStreamArn:
        Type: String
        Description: ARN of the DynamoDB Stream to monitor
    LayerCommons:
        Type: String
        Description: The Layer Commons
    # Parameters for GraphQL API integration
    EntitiesTable:
        Type: String
        Description: Entities table name
    EntitiesTableArn:
        Type: String
        Description: Entities table ARN
    PlaidAccessTokensTable:
        Type: String
        Description: Plaid Access Tokens table name
    PlaidAccessTokensTableArn:
        Type: String
        Description: Plaid Access Tokens table ARN
    CybridFiatAccountsTable:
        Type: String
        Description: Cybrid Fiat Accounts table name
    CybridFiatAccountsTableArn:
        Type: String
        Description: Cybrid Fiat Accounts table ARN
    CybridIdentityVerificationsTable:
        Type: String
        Description: Cybrid Identity Verifications table name
    CybridIdentityVerificationsTableArn:
        Type: String
        Description: Cybrid Identity Verifications table ARN
    CLKKTransactionsTable:
        Type: String
        Description: CLKK Transactions table name
    CLKKTransactionsTableArn:
        Type: String
        Description: CLKK Transactions table ARN

Resources:
    # AppSync API and Schema
    AppSyncEventApi:
        Type: AWS::AppSync::GraphQLApi
        Properties:
            Name: !Sub event-api-${Environment}
            AuthenticationType: API_KEY
            XrayEnabled: true
            LogConfig:
                CloudWatchLogsRoleArn: !GetAtt AppSyncCloudWatchLogsRole.Arn
                FieldLogLevel: ALL

    # AppSync Schema - Define schema in a separate resource
    AppSyncSchema:
        Type: AWS::AppSync::GraphQLSchema
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            Definition: |
                type Subscription {
                  onMessage(channel: String!): Message
                    @aws_subscribe(mutations: ["publishMessage"])
                  
                  # Subscriptions for wallet and user data
                  onWalletBalanceChanged(userId: ID!): WalletBalanceUpdate
                    @aws_subscribe(mutations: ["publishWalletUpdate"])
                  
                  onUserDataChanged(userId: ID!): UserDataUpdate
                    @aws_subscribe(mutations: ["publishUserUpdate"])
                  
                  onCheckbookDataChanged(userId: ID!): CheckbookDataUpdate
                    @aws_subscribe(mutations: ["publishCheckbookUpdate"])
                }

                type Mutation {
                  publishMessage(channel: String!, message: String!): Message
                  
                  # New mutations for publishing updates (used by Lambda)
                  publishWalletUpdate(userId: ID!, walletData: WalletBalanceUpdateInput!): WalletBalanceUpdate
                  
                  publishUserUpdate(userId: ID!, userData: UserDataUpdateInput!): UserDataUpdate
                  
                  publishCheckbookUpdate(userId: ID!, checkbookData: CheckbookDataUpdateInput!): CheckbookDataUpdate
                }

                type Message {
                  channel: String!
                  message: String!
                  timestamp: AWSDateTime!
                }

                type Query {
                  getMessage(channel: String!): Message
                  
                  # Add placeholder queries for wallet and user data
                  getWalletBalance(userId: ID!): WalletBalanceUpdate @aws_lambda
                  getUserData(userId: ID!): UserDataUpdate @aws_lambda
                  getCheckbookData(userId: ID!): CheckbookDataUpdate @aws_lambda
                  
                  # Financial queries from GraphQL API
                  getFinancialData(userId: String!): FinancialData @aws_lambda
                  
                  # Transaction queries
                  getTransaction(transactionId: ID!): Transaction @aws_lambda
                  getUserTransactions(userId: ID!, filter: TransactionFilterInput): [Transaction] @aws_lambda
                  
                  # Business queries
                  getBusinessTransactions(
                    businessId: ID!
                    filter: BusinessTransactionFilter
                    nextToken: String
                    limit: Int
                  ): BusinessTransactionConnection @aws_lambda
                  getBusinessTransaction(transactionId: ID!): Transaction @aws_lambda
                  getBusinessDashboardData(businessId: ID!): BusinessDashboardData @aws_lambda
                }

                # Input and Type definitions for wallet updates
                input WalletBalanceUpdateInput {
                  balance: Float!
                  currency: String!
                  previousBalance: Float
                  transactionId: ID
                  updatedAt: AWSDateTime!
                }

                type WalletBalanceUpdate {
                  userId: ID!
                  balance: Float!
                  currency: String!
                  previousBalance: Float
                  transactionId: ID
                  updatedAt: AWSDateTime!
                }

                # Input and Type definitions for user data updates
                input UserDataUpdateInput {
                  userInfo: UserInfoInput
                  status: String
                  updatedAt: AWSDateTime!
                }

                input UserInfoInput {
                  firstName: String
                  lastName: String
                  phoneNumber: String
                  profilePictureUrl: String
                  preferredLanguage: String
                }

                type UserDataUpdate {
                  userId: ID!
                  userInfo: UserInfo
                  status: String
                  updatedAt: AWSDateTime!
                }

                type UserInfo {
                  firstName: String
                  lastName: String
                  phoneNumber: String
                  profilePictureUrl: String
                  preferredLanguage: String
                }

                # Input and Type definitions for checkbook data updates
                input CheckbookDataUpdateInput {
                  checkbookId: String
                  cardInfo: [CardInfoInput]
                  updatedAt: AWSDateTime!
                }

                input CardInfoInput {
                  cardId: String!
                  lastFourDigits: String
                  expirationDate: String
                  isDefault: Boolean
                }

                type CheckbookDataUpdate {
                  userId: ID!
                  checkbookId: String
                  cardInfo: [CardInfo]
                  updatedAt: AWSDateTime!
                }

                type CardInfo {
                  cardId: String!
                  lastFourDigits: String
                  expirationDate: String
                  isDefault: Boolean
                }
                
                # Transaction related types from GraphQL API
                type Transaction {
                  userId: String!
                  transactionId: ID!
                  type: String!
                  status: String!
                  amount: Float!
                  asset: String!
                  createdAt: String!
                  updatedAt: String!
                  sourceAccountId: String
                  destinationAccountId: String
                  quoteGuid: String
                  paymentProviderId: String
                  recipientId: String
                  memo: String
                  senderName: String
                  senderClkktag: String
                  recipientName: String
                  recipientClkktag: String
                  transferState: String
                  failureCode: String
                  returnCode: String
                  recipientEntityId: String!
                  senderEntityId: String!
                  recipient_entity_type: String
                  sender_entity_type: String
                  recipient_current_email: String
                  sender_current_email: String
                  source_account_guid: String
                  destination_account_guid: String
                  recipient_cy_guid: String
                  sender_cy_guid: String
                  sender_name: String
                  recipient_name: String
                  sender_clkktag: String
                  recipient_clkktag: String
                  fees: Fee
                  fee_amount: Float
                  fee_pending: Boolean
                  fee_percentage: Float
                  net_amount: Float
                  fee_processed_at: String
                }
                
                enum TransactionType {
                  deposit
                  withdrawal
                  p2p_transfer
                  p2b_transfer
                  trade
                }
                
                enum TransactionStatus {
                  pending
                  completed
                  failed
                  cancelled
                }
                
                type Fee {
                  type: String!
                  rate: Float!
                  spread_fee: Float!
                  fixed_fee: Float!
                }
                
                type BusinessDashboardData {
                  totalTransactions: Int!
                  totalRevenue: Float!
                  recentTransactions: [Transaction]
                  revenueTrends: [RevenueTrend]
                  transactionsByType: [TransactionByType]
                  transactionsByStatus: [TransactionByStatus]
                }
                
                type RevenueTrend {
                  date: String!
                  amount: Float!
                }
                
                type TransactionByType {
                  type: String!
                  count: Int!
                  amount: Float!
                }
                
                type TransactionByStatus {
                  status: String!
                  count: Int!
                  amount: Float!
                }
                
                input TransactionFilterInput {
                  startDate: String
                  endDate: String
                  status: TransactionStatus
                  type: TransactionType
                  minAmount: Float
                  maxAmount: Float
                  searchText: String
                  businessId: ID
                  userId: ID
                }
                
                # Need to define AWSJSON scalar
                scalar AWSJSON
                
                type UserRecentTransaction {
                  transactionId: ID!
                  requestType: String!
                  amount: Float!
                  asset: String!
                  status: String!
                  recipientName: String
                  recipientClkktag: String
                  senderName: String
                  senderClkktag: String
                  memo: String
                  createdAt: String!
                  updatedAt: String
                }
                
                type FinancialData {
                  userProfile: UserProfile
                  cybridBalances: [CybridBalance]
                  plaidAccounts: [PlaidAccount]
                  recentTransactions: [UserRecentTransaction]
                  preferences: UserPreferences
                }
                
                type UserProfile {
                  userId: ID!
                  email: String!
                  firstName: String!
                  lastName: String!
                  phoneNumber: String!
                  kycStatus: String!
                  accountState: String!
                  profileImageUrl: String!
                  clkkTag: String!
                  createdAt: String!
                  updatedAt: String!
                }
                
                type CybridBalance {
                  accountId: ID!
                  name: String!
                  balance: Float!
                  asset: String!
                  state: String!
                  customerId: String!
                  createdAt: String!
                  updatedAt: String!
                }
                
                type PlaidAccount {
                  id: String!
                  mask: String!
                  name: String!
                  type: String!
                  subtype: String!
                  institutionName: String!
                  verificationStatus: String!
                }
                
                enum KYCStatus {
                  NOT_STARTED
                  IN_PROGRESS
                  VERIFIED
                  REJECTED
                }
                
                type UserPreferences {
                  notificationSettings: NotificationSettings
                  displaySettings: DisplaySettings
                  deviceTokens: [DeviceToken]
                }
                
                type DeviceToken {
                  token: String!
                  platform: String!
                  updatedAt: String!
                }
                
                type NotificationSettings {
                  emailEnabled: Boolean
                  pushEnabled: Boolean
                  smsEnabled: Boolean
                }
                
                type DisplaySettings {
                  theme: String
                  language: String
                  currency: String
                }
                
                input BusinessTransactionFilter {
                  senderClkktag: String
                  senderEmail: String
                  amountGreaterThan: Float
                  amountLessThan: Float
                  transactionId: String
                  status: String
                  dateFrom: String
                  dateTo: String
                }
                
                type BusinessTransactionConnection {
                  items: [Transaction!]!
                  nextToken: String
                }

    # AppSync API Key
    AppSyncApiKey:
        Type: AWS::AppSync::ApiKey
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            Description: Default API Key for Event API

    # AppSync None Data Source
    AppSyncNoneDataSource:
        Type: AWS::AppSync::DataSource
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            Name: NoneDataSource
            Type: NONE

    # AppSync Lambda Data Source for Stream Processing
    AppSyncLambdaDataSource:
        Type: AWS::AppSync::DataSource
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            Name: LambdaDataSource
            Type: AWS_LAMBDA
            ServiceRoleArn: !GetAtt AppSyncLambdaServiceRole.Arn
            LambdaConfig:
                LambdaFunctionArn: !GetAtt DynamoStreamProcessor.Arn

    # AppSync Lambda Data Source for Financial Data
    FinancialDataLambdaDataSource:
        Type: AWS::AppSync::DataSource
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            Name: FinancialDataLambdaDataSource
            Type: AWS_LAMBDA
            ServiceRoleArn: !GetAtt AppSyncFinancialDataLambdaServiceRole.Arn
            LambdaConfig:
                LambdaFunctionArn: !GetAtt FinancialDataLambda.Arn

    # AppSync Lambda Data Source for Business Transactions
    BusinessTransactionsLambdaDataSource:
        Type: AWS::AppSync::DataSource
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            Name: BusinessTransactionsLambdaDataSource
            Type: AWS_LAMBDA
            ServiceRoleArn: !GetAtt AppSyncBusinessTransactionsLambdaServiceRole.Arn
            LambdaConfig:
                LambdaFunctionArn: !GetAtt BusinessTransactionsLambda.Arn

    # IAM Role for AppSync to invoke Lambda
    AppSyncLambdaServiceRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: appsync.amazonaws.com
                      Action: sts:AssumeRole
            ManagedPolicyArns:
                - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs
            Policies:
                - PolicyName: AppSyncLambdaInvocationPolicy
                  PolicyDocument:
                      Version: '2012-10-17'
                      Statement:
                          - Effect: Allow
                            Action:
                                - lambda:InvokeFunction
                            Resource: !GetAtt DynamoStreamProcessor.Arn

    # IAM Role for AppSync to invoke Financial Data Lambda
    AppSyncFinancialDataLambdaServiceRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: appsync.amazonaws.com
                      Action: sts:AssumeRole
            ManagedPolicyArns:
                - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs
            Policies:
                - PolicyName: AppSyncFinancialDataLambdaInvocationPolicy
                  PolicyDocument:
                      Version: '2012-10-17'
                      Statement:
                          - Effect: Allow
                            Action:
                                - lambda:InvokeFunction
                            Resource: !GetAtt FinancialDataLambda.Arn

    # IAM Role for AppSync to invoke Business Transactions Lambda
    AppSyncBusinessTransactionsLambdaServiceRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: appsync.amazonaws.com
                      Action: sts:AssumeRole
            ManagedPolicyArns:
                - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs
            Policies:
                - PolicyName: AppSyncBusinessTransactionsLambdaInvocationPolicy
                  PolicyDocument:
                      Version: '2012-10-17'
                      Statement:
                          - Effect: Allow
                            Action:
                                - lambda:InvokeFunction
                            Resource: !GetAtt BusinessTransactionsLambda.Arn

    # AppSync Resolvers
    PublishMessageResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Mutation
            FieldName: publishMessage
            DataSourceName: !GetAtt AppSyncNoneDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "payload": {
                    "channel": $util.toJson($context.arguments.channel),
                    "message": $util.toJson($context.arguments.message),
                    "timestamp": $util.time.nowISO8601()
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    # New Resolvers for wallet balance and user data
    PublishWalletUpdateResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Mutation
            FieldName: publishWalletUpdate
            DataSourceName: !GetAtt AppSyncNoneDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "payload": {
                    "userId": $util.toJson($context.arguments.userId),
                    "balance": $util.toJson($context.arguments.walletData.balance),
                    "currency": $util.toJson($context.arguments.walletData.currency),
                    "previousBalance": $util.toJson($context.arguments.walletData.previousBalance),
                    "transactionId": $util.toJson($context.arguments.walletData.transactionId),
                    "updatedAt": $util.toJson($context.arguments.walletData.updatedAt)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    PublishUserUpdateResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Mutation
            FieldName: publishUserUpdate
            DataSourceName: !GetAtt AppSyncNoneDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "payload": {
                    "userId": $util.toJson($context.arguments.userId),
                    "userInfo": $util.toJson($context.arguments.userData.userInfo),
                    "status": $util.toJson($context.arguments.userData.status),
                    "updatedAt": $util.toJson($context.arguments.userData.updatedAt)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    PublishCheckbookUpdateResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Mutation
            FieldName: publishCheckbookUpdate
            DataSourceName: !GetAtt AppSyncNoneDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "payload": {
                    "userId": $util.toJson($context.arguments.userId),
                    "checkbookId": $util.toJson($context.arguments.checkbookData.checkbookId),
                    "cardInfo": $util.toJson($context.arguments.checkbookData.cardInfo),
                    "updatedAt": $util.toJson($context.arguments.checkbookData.updatedAt)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    # Query Resolvers
    GetWalletBalanceResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Query
            FieldName: getWalletBalance
            DataSourceName: !GetAtt AppSyncLambdaDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "getWalletBalance",
                    "userId": $util.toJson($context.arguments.userId)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    GetUserDataResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Query
            FieldName: getUserData
            DataSourceName: !GetAtt AppSyncLambdaDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "getUserData",
                    "userId": $util.toJson($context.arguments.userId)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    GetCheckbookDataResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Query
            FieldName: getCheckbookData
            DataSourceName: !GetAtt AppSyncLambdaDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "getCheckbookData",
                    "userId": $util.toJson($context.arguments.userId)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    # Financial Data Query Resolver
    GetFinancialDataResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Query
            FieldName: getFinancialData
            DataSourceName: !GetAtt FinancialDataLambdaDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "field": "getFinancialData",
                    "arguments": $util.toJson($context.arguments),
                    "source": $util.toJson($context.source)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    # Transaction Query Resolvers
    GetTransactionResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Query
            FieldName: getTransaction
            DataSourceName: !GetAtt BusinessTransactionsLambdaDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "field": "getTransaction",
                    "arguments": $util.toJson($context.arguments),
                    "source": $util.toJson($context.source)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    GetUserTransactionsResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Query
            FieldName: getUserTransactions
            DataSourceName: !GetAtt BusinessTransactionsLambdaDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "field": "getUserTransactions",
                    "arguments": $util.toJson($context.arguments),
                    "source": $util.toJson($context.source)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    # Business Query Resolvers
    GetBusinessTransactionsResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Query
            FieldName: getBusinessTransactions
            DataSourceName: !GetAtt BusinessTransactionsLambdaDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "field": "getBusinessTransactions",
                    "arguments": $util.toJson($context.arguments),
                    "source": $util.toJson($context.source)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    GetBusinessTransactionResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Query
            FieldName: getBusinessTransaction
            DataSourceName: !GetAtt BusinessTransactionsLambdaDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "field": "getBusinessTransaction",
                    "arguments": $util.toJson($context.arguments),
                    "source": $util.toJson($context.source)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    GetBusinessDashboardDataResolver:
        Type: AWS::AppSync::Resolver
        Properties:
            ApiId: !GetAtt AppSyncEventApi.ApiId
            TypeName: Query
            FieldName: getBusinessDashboardData
            DataSourceName: !GetAtt BusinessTransactionsLambdaDataSource.Name
            RequestMappingTemplate: |
                {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "field": "getBusinessDashboardData",
                    "arguments": $util.toJson($context.arguments),
                    "source": $util.toJson($context.source)
                  }
                }
            ResponseMappingTemplate: |
                $util.toJson($context.result)

    # Lambda Function to Process DynamoDB Streams and Publish to AppSync
    DynamoStreamProcessor:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub dynamo-stream-processor-${Environment}
            Handler: index.handler
            Runtime: nodejs18.x
            Timeout: 30
            MemorySize: 256
            CodeUri: ../../lambdas/dynamo-stream-processor/
            Environment:
                Variables:
                    APPSYNC_ENDPOINT: !GetAtt AppSyncEventApi.GraphQLUrl
                    APPSYNC_API_KEY: !GetAtt AppSyncApiKey.ApiKey
                    ENVIRONMENT: !Ref Environment
                    TABLE_NAME: !Ref TableName
            Policies:
                - DynamoDBStreamReadPolicy:
                      TableName: !Ref TableName
                      StreamName: '*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - appsync:GraphQL
                        Resource:
                            - !Sub arn:aws:appsync:${AWS::Region}:${AWS::AccountId}:apis/${AppSyncEventApi.ApiId}/*
            Events:
                Stream:
                    Condition: !Not [!Equals [!Ref ApplicationTableStreamArn, '']]
                    Type: DynamoDB
                    Properties:
                        Stream: !Ref ApplicationTableStreamArn
                        StartingPosition: LATEST
                        BatchSize: 100
                        MaximumRetryAttempts: 3
                        Enabled: true
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - index.ts

    # Lambda Function for Financial Data Queries
    FinancialDataLambda:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub graphql-financial-data-${Environment}
            Handler: index.handler
            Runtime: nodejs18.x
            Timeout: 30
            MemorySize: 1024
            Architectures:
                - arm64
            CodeUri: ../../lambdas/graphql-financial-data/
            Environment:
                Variables:
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
                    # All data is now in single table
            Layers:
                - !Ref LayerCommons
            Policies:
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:BatchGetItem
                            - dynamodb:GetItem
                            - dynamodb:Query
                        Resource:
                            - !Ref EntitiesTableArn
                            - !Sub '${EntitiesTableArn}/index/*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                    - '@aws-sdk/client-dynamodb'
                    - '@aws-sdk/util-dynamodb'
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - index.ts

    # Lambda Function for Business Transaction Queries
    BusinessTransactionsLambda:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub graphql-business-transactions-${Environment}
            Handler: index.handler
            Runtime: nodejs18.x
            Timeout: 30
            MemorySize: 1024
            Architectures:
                - arm64
            CodeUri: ../../lambdas/graphql-business-transactions/
            Environment:
                Variables:
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Layers:
                - !Ref LayerCommons
            Policies:
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:Query
                            - dynamodb:GetItem
                            - dynamodb:Scan
                        Resource:
                            - !Ref EntitiesTableArn
                            - !Sub '${EntitiesTableArn}/index/*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                    - '@aws-sdk/client-dynamodb'
                    - '@aws-sdk/util-dynamodb'
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - index.ts

    # IAM Role for AppSync CloudWatch Logs
    AppSyncCloudWatchLogsRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: appsync.amazonaws.com
                      Action: sts:AssumeRole
            ManagedPolicyArns:
                - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs

Outputs:
    AppSyncApiEndpoint:
        Description: AppSync API URL
        Value: !GetAtt AppSyncEventApi.GraphQLUrl
        Export:
            Name: !Sub ${AWS::StackName}-AppSyncApiEndpoint

    AppSyncApiKey:
        Description: AppSync API Key (for testing only - rotate in production)
        Value: !GetAtt AppSyncApiKey.ApiKey
        Export:
            Name: !Sub ${AWS::StackName}-AppSyncApiKey

    WebSocketUrl:
        Description: WebSocket URL for real-time subscriptions
        Value: !Sub wss://${AppSyncEventApi.GraphQLUrl}/graphql
        Export:
            Name: !Sub ${AWS::StackName}-WebSocketUrl
</file>

<file path="iac/checkbook/checkbook-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'CLKK Checkbook Payment API Integration Stack'

Parameters:
    Environment:
        Type: String
        Default: dev
        AllowedValues:
            - 'dev'
            - 'staging'
            - 'prod'
        Description: 'Stage/environment for deployment'

    NetworkingStackName:
        Type: String
        Default: clkk-backend-networking
        Description: Name of the networking stack with VPC, subnets, etc.

    ApplicationTableName:
        Type: String
        Description: Name of the DynamoDB table containing CLKK application data

    CheckbookEnvironment:
        Type: String
        Default: 'SANDBOX'
        AllowedValues:
            - 'DEMO'
            - 'SANDBOX'
            - 'PRODUCTION'
        Description: 'Checkbook API environment'

    CheckbookPublishableApiKeyArn:
        Type: String
        NoEcho: true
        Description: 'Checkbook Publishable API Key'

    CheckbookSecretApiKeyArn:
        Type: String
        NoEcho: true
        Description: 'Checkbook Secret API Key'

    ClerkAuthorizerArn:
        Type: String
        Description: ARN of the Clerk Authorizer

    LayerCommons:
        Type: String
        Description: ARN of the Commons Lambda Layer

    RateLimitMaxRequests:
        Type: Number
        Default: 10
        Description: Maximum number of requests per minute per IP

    CheckbookApiUrl:
        Type: String
        Description: 'Checkbook API URL based on environment'
        Default: 'https://api.sandbox.checkbook.io/v3'
        AllowedValues:
            - 'https://demo.checkbook.io/v3'
            - 'https://api.sandbox.checkbook.io/v3'
            - 'https://api.checkbook.io/v3'

    KmsKeyId:
        Type: String
        Description: 'KMS Key ID for encryption'

Resources:
    # Create User Lambda Function
    CreateUserFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-create-user-${Environment}
            Handler: checkbook.createUserHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_PUBLISHABLE_API_KEY_ARN: !Ref CheckbookPublishableApiKeyArn
                    CHECKBOOK_SECRET_API_KEY_ARN: !Ref CheckbookSecretApiKeyArn
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - DynamoDBWritePolicy:
                      TableName: !Ref ApplicationTableName
                - KMSEncryptPolicy:
                      KeyId: !Ref KmsKeyId
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
                - Statement:
                      Effect: Allow
                      Action:
                          - kms:Encrypt
                          - kms:Decrypt
                          - kms:GenerateDataKey
                      Resource: !Sub 'arn:aws:kms:${AWS::Region}:${AWS::AccountId}:key/${KmsKeyId}'
            Events:
                CreateUser:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/user
                        Method: POST
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - checkbook
    # Get User Data Lambda Function
    GetUserDataFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-get-user-data-${Environment}
            Handler: checkbook.getUserDataHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_PUBLISHABLE_API_KEY_ARN: !Ref CheckbookPublishableApiKeyArn
                    CHECKBOOK_SECRET_API_KEY_ARN: !Ref CheckbookSecretApiKeyArn
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
            Events:
                GetUserData:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/user
                        Method: GET
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - checkbook
    # Create Digital Check Lambda Function
    CreateDigitalCheckFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-create-digital-check-${Environment}
            Handler: payment.createDigitalCheckHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    CHECKBOOK_API_TIMEOUT: '30000'
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - DynamoDBWritePolicy:
                      TableName: !Ref ApplicationTableName
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
            Events:
                CreateDigitalCheck:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/payment/digital
                        Method: POST
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - payment

    # Deposit Payment Lambda Function
    DepositPaymentFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-deposit-payment-${Environment}
            Handler: payment.depositPaymentHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    CHECKBOOK_API_TIMEOUT: '30000'
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
            Events:
                DepositPayment:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/payment/deposit/{check_id}
                        Method: POST
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - payment
    # Get Payment Lambda Function
    GetPaymentFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-get-payment-${Environment}
            Handler: payment.getPaymentHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    CHECKBOOK_API_TIMEOUT: '30000'
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
            Events:
                GetPayment:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/payment/{check_id}
                        Method: GET
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - payment

    # Add Card Lambda Function
    AddCardFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-add-card-${Environment}
            Handler: card.addCardHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    CHECKBOOK_API_TIMEOUT: '30000'
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTableName
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - KMSEncryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
                - Statement:
                      Effect: Allow
                      Action:
                          - dynamodb:DeleteItem
                      Resource:
                          - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ApplicationTableName}'
                          - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ApplicationTableName}/*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - kms:GenerateDataKey
                            - kms:Decrypt
                            - kms:Encrypt
                        Resource: !Sub 'arn:aws:kms:${AWS::Region}:${AWS::AccountId}:key/${KmsKeyId}'
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:DeleteItem
                        Resource:
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ApplicationTableName}'
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ApplicationTableName}/*'
                        Condition:
                            ForAllValues:StringLike:
                                'dynamodb:LeadingKeys':
                                    - 'USER#*'
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - DynamoDBWritePolicy:
                      TableName: !Ref ApplicationTableName
            Events:
                AddCard:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/card
                        Method: POST
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - card

    # Get Cards Lambda Function
    GetCardsFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-get-cards-${Environment}
            Handler: card.getCardsHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    CHECKBOOK_API_TIMEOUT: '30000'
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - KMSEncryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
            Events:
                GetCards:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/card
                        Method: GET
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - card

    # Update Card Lambda Function
    UpdateCardFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-update-card-${Environment}
            Handler: card.updateCardHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    CHECKBOOK_API_TIMEOUT: '30000'
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - DynamoDBWritePolicy:
                      TableName: !Ref ApplicationTableName
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - KMSEncryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
            Events:
                UpdateCard:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/card/{card_id}
                        Method: PUT
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - card

    # Remove Card Lambda Function
    RemoveCardFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-remove-card-${Environment}
            Handler: card.removeCardHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    CHECKBOOK_API_TIMEOUT: '30000'
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - DynamoDBWritePolicy:
                      TableName: !Ref ApplicationTableName
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - KMSEncryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
                - Statement:
                      Effect: Allow
                      Action:
                          - dynamodb:DeleteItem
                      Resource:
                          - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ApplicationTableName}'
                          - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ApplicationTableName}/*'
                      Condition:
                          ForAllValues:StringLike:
                              'dynamodb:LeadingKeys':
                                  - 'USER#*'
            Events:
                RemoveCard:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/card/{card_id}
                        Method: DELETE
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - card

    # Webhook Handler Lambda Function
    WebhookFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-webhook-${Environment}
            Handler: checkbook.webhookHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    TABLE_NAME: !Ref ApplicationTableName
                    CHECKBOOK_ENVIRONMENT: !Ref CheckbookEnvironment
                    CHECKBOOK_API_URL: !Ref CheckbookApiUrl
                    CHECKBOOK_API_TIMEOUT: '30000'
                    KMS_KEY_ID: !Ref KmsKeyId
                    CHECKBOOK_CREDENTIALS_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
            Policies:
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTableName
                - DynamoDBWritePolicy:
                      TableName: !Ref ApplicationTableName
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials*'
            Events:
                WebhookEndpoint:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/webhook
                        Method: POST
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - checkbook

    # Create a separate resource for the WebhookFunction URL
    WebhookFunctionUrl:
        Type: AWS::Lambda::Url
        Properties:
            AuthType: NONE
            InvokeMode: RESPONSE_STREAM
            TargetFunctionArn: !GetAtt WebhookFunction.Arn

    # Generate Data Key Lambda Function for client-side encryption
    GenerateDataKeyFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-checkbook-generate-data-key-${Environment}
            Handler: card-encryption.generateDataKeyHandler
            Runtime: nodejs18.x
            Architectures: [arm64]
            CodeUri: ../../lambdas/checkbook/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Environment
                    KMS_KEY_ID: !Ref KmsKeyId
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - Statement:
                      Effect: Allow
                      Action:
                          - kms:GenerateDataKey
                      Resource: !Sub 'arn:aws:kms:${AWS::Region}:${AWS::AccountId}:key/${KmsKeyId}'
            Events:
                GenerateDataKey:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CheckbookApi
                        Path: /checkbook/generate-data-key
                        Method: POST
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - card-encryption

    # API Gateway Definition
    CheckbookApi:
        Type: AWS::Serverless::Api
        Properties:
            StageName: !Ref Environment
            Auth:
                Authorizers:
                    ClerkAuthorizer:
                        FunctionArn: !Ref ClerkAuthorizerArn
                        FunctionPayloadType: TOKEN
                        Identity:
                            Header: Authorization
                            ValidationExpression: '^Bearer [-0-9a-zA-Z\._]*$'
                            ReauthorizeEvery: 0
                DefaultAuthorizer: ClerkAuthorizer
            MethodSettings:
                - ResourcePath: '/*'
                  HttpMethod: '*'
                  ThrottlingRateLimit: !Ref RateLimitMaxRequests
                  ThrottlingBurstLimit: !Ref RateLimitMaxRequests
                  MetricsEnabled: true

    # Allow client-side encryption with the existing KMS key
    ClientEncryptionPolicy:
        Type: AWS::IAM::ManagedPolicy
        Properties:
            Description: 'Policy for client app to use KMS for encryption'
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Action:
                          - kms:GenerateDataKey
                          - kms:Decrypt
                      Resource: !Sub 'arn:aws:kms:${AWS::Region}:${AWS::AccountId}:key/${KmsKeyId}'
                      Condition:
                          StringEquals:
                              'kms:ViaService': !Sub 'lambda.${AWS::Region}.amazonaws.com'

Outputs:
    ApiEndpoint:
        Description: Checkbook Payment API Gateway endpoint URL
        Value: !Sub https://${CheckbookApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/
        Export:
            Name: !Sub clkk-checkbook-api-endpoint-${Environment}

    CreateUserFunctionArn:
        Description: 'ARN of the Create User Lambda Function'
        Value: !GetAtt CreateUserFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-create-user-function-arn-${Environment}

    GetUserDataFunctionArn:
        Description: 'ARN of the Get User Data Lambda Function'
        Value: !GetAtt GetUserDataFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-get-user-data-function-arn-${Environment}

    CreateDigitalCheckFunctionArn:
        Description: 'ARN of the Create Digital Check Lambda Function'
        Value: !GetAtt CreateDigitalCheckFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-create-digital-check-function-arn-${Environment}

    GetPaymentFunctionArn:
        Description: 'ARN of the Get Payment Lambda Function'
        Value: !GetAtt GetPaymentFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-get-payment-function-arn-${Environment}

    AddCardFunctionArn:
        Description: 'ARN of the Add Card Lambda Function'
        Value: !GetAtt AddCardFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-add-card-function-arn-${Environment}

    GetCardsFunctionArn:
        Description: 'ARN of the Get Cards Lambda Function'
        Value: !GetAtt GetCardsFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-get-cards-function-arn-${Environment}

    UpdateCardFunctionArn:
        Description: 'ARN of the Update Card Lambda Function'
        Value: !GetAtt UpdateCardFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-update-card-function-arn-${Environment}

    RemoveCardFunctionArn:
        Description: 'ARN of the Remove Card Lambda Function'
        Value: !GetAtt RemoveCardFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-remove-card-function-arn-${Environment}

    CheckbookApiId:
        Description: 'API Gateway ID for Checkbook API'
        Value: !Ref CheckbookApi
        Export:
            Name: !Sub clkk-checkbook-api-id-${Environment}

    WebhookFunctionArn:
        Description: 'ARN of the Webhook Lambda Function'
        Value: !GetAtt WebhookFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-webhook-function-arn-${Environment}

    WebhookEndpoint:
        Description: 'Webhook endpoint URL for Checkbook'
        Value: !Sub https://${CheckbookApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/checkbook/webhook
        Export:
            Name: !Sub clkk-checkbook-webhook-endpoint-${Environment}

    GenerateDataKeyFunctionArn:
        Description: 'ARN of the Generate Data Key Lambda Function'
        Value: !GetAtt GenerateDataKeyFunction.Arn
        Export:
            Name: !Sub clkk-checkbook-generate-data-key-function-arn-${Environment}

    CheckbookWebhookUrlEndpoint:
        Description: 'Checkbook Webhook URL Endpoint'
        Value: !GetAtt WebhookFunctionUrl.FunctionUrl
</file>

<file path="iac/cybrid/cybrid-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
    Cybrid Stack
    This stack contains the resources for the Cybrid

Parameters:
    Environment:
        Type: String
        Default: dev
        Description: The environment to deploy to

    CybridBaseUrl:
        Type: String
        Default: sandbox.cybrid.app
    CybridSecretName:
        Type: String
        Default: '/cybrid/api-keys/dev'
        Description: 'Name of the Secrets Manager secret containing Cybrid client credentials'
    EntitiesTable:
        Type: String
        Description: Name of the Entities DynamoDB table
    EntitiesTableArn:
        Type: String
        Description: ARN of the Entities DynamoDB table
    LayerCommons:
        Type: String
        Description: Name of the Commons Lambda Layer
    PlaidAccessTokensTable:
        Type: String
        Description: Name of the Plaid Access Tokens Table
    ClerkAuthorizerArn:
        Type: String
    CybridUrlScheme:
        Type: String
        Default: https
        Description: URL scheme for Cybrid connections
    EntitiesTableArn:
        Type: String
        Description: The ARN of the Entities table
    EntitiesTableStreamArn:
        Type: String
        Description: The Stream ARN of the Entities table

Resources:
    #################################################################################################################
    # DynamoDB Tables
    #################################################################################################################

    CybridExternalBankAccountsTable:
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Type: AWS::DynamoDB::Table
        Properties:
            TableName: CybridExternalBankAccounts
            AttributeDefinitions:
                - AttributeName: cybridAccountId
                  AttributeType: S
                - AttributeName: cybridCustomerId
                  AttributeType: S
            KeySchema:
                - AttributeName: cybridAccountId
                  KeyType: HASH
            GlobalSecondaryIndexes:
                - IndexName: CustomerIndex
                  KeySchema:
                      - AttributeName: cybridCustomerId
                        KeyType: HASH
                  Projection:
                      ProjectionType: ALL
            BillingMode: PAY_PER_REQUEST
            SSESpecification:
                SSEEnabled: true

    CybridIdentityVerificationsTable:
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Type: AWS::DynamoDB::Table
        Properties:
            TableName: CybridIdentityVerifications
            AttributeDefinitions:
                - AttributeName: identityVerificationId
                  AttributeType: S
                - AttributeName: customerId
                  AttributeType: S
                - AttributeName: userId
                  AttributeType: S
                - AttributeName: verificationType
                  AttributeType: S
            KeySchema:
                - AttributeName: identityVerificationId
                  KeyType: HASH
            GlobalSecondaryIndexes:
                - IndexName: customerId-index
                  KeySchema:
                      - AttributeName: customerId
                        KeyType: HASH
                  Projection:
                      ProjectionType: ALL
                - IndexName: userId-verificationType-index
                  KeySchema:
                      - AttributeName: userId
                        KeyType: HASH
                      - AttributeName: verificationType
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
            BillingMode: PAY_PER_REQUEST
            SSESpecification:
                SSEEnabled: true

    #TODO: Create LSI for userId, remove unused attributes and GSI
    #Change to entityId
    CybridFiatAccountsTable:
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Type: AWS::DynamoDB::Table
        Properties:
            TableName: CybridFiatAccounts
            BillingMode: PAY_PER_REQUEST
            KeySchema:
                - AttributeName: userId
                  KeyType: HASH
                - AttributeName: accountId
                  KeyType: RANGE
            AttributeDefinitions:
                - AttributeName: userId
                  AttributeType: S
                - AttributeName: accountId
                  AttributeType: S
                - AttributeName: customerId
                  AttributeType: S
                - AttributeName: asset
                  AttributeType: S
            GlobalSecondaryIndexes:
                - IndexName: UserIdIndex
                  KeySchema:
                      - AttributeName: userId
                        KeyType: HASH
                  Projection:
                      ProjectionType: ALL
                - IndexName: customerId-asset-index
                  KeySchema:
                      - AttributeName: customerId
                        KeyType: HASH
                      - AttributeName: asset
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                - IndexName: AccountIdIndex
                  KeySchema:
                      - AttributeName: accountId
                        KeyType: HASH
                  Projection:
                      ProjectionType: ALL
            StreamSpecification:
                StreamViewType: NEW_AND_OLD_IMAGES
            SSESpecification:
                SSEEnabled: true

    # Transaction table for tracking all financial transactions
    # TODO: Add LSI for recipientEntityId
    CLKKTransactionsTable:
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Type: AWS::DynamoDB::Table
        Properties:
            TableName: CLKKTransactions
            BillingMode: PAY_PER_REQUEST
            KeySchema:
                - AttributeName: transactionId
                  KeyType: HASH
            AttributeDefinitions:
                - AttributeName: transactionId
                  AttributeType: S
                - AttributeName: userId
                  AttributeType: S
                - AttributeName: createdAt
                  AttributeType: S
                - AttributeName: status
                  AttributeType: S
                - AttributeName: type
                  AttributeType: S
                - AttributeName: paymentProviderId
                  AttributeType: S
                - AttributeName: senderEntityId
                  AttributeType: S
                - AttributeName: recipientEntityId
                  AttributeType: S
            GlobalSecondaryIndexes:
                - IndexName: UserTransactionsIndex
                  KeySchema:
                      - AttributeName: userId
                        KeyType: HASH
                      - AttributeName: createdAt
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                - IndexName: TransactionTypeIndex
                  KeySchema:
                      - AttributeName: type
                        KeyType: HASH
                      - AttributeName: createdAt
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                - IndexName: TransactionStatusIndex
                  KeySchema:
                      - AttributeName: status
                        KeyType: HASH
                      - AttributeName: createdAt
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                - IndexName: PaymentProviderIdIndex
                  KeySchema:
                      - AttributeName: paymentProviderId
                        KeyType: HASH
                  Projection:
                      ProjectionType: ALL
                # Index for sender's transactions
                - IndexName: SenderIdIndex
                  KeySchema:
                      - AttributeName: senderEntityId
                        KeyType: HASH
                      - AttributeName: createdAt
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # Index for recipient's transactions
                - IndexName: RecipientIdIndex
                  KeySchema:
                      - AttributeName: recipientEntityId
                        KeyType: HASH
                      - AttributeName: createdAt
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
            StreamSpecification:
                StreamViewType: NEW_AND_OLD_IMAGES
            SSESpecification:
                SSEEnabled: true

    PlatformRevenueTable:
        Type: AWS::DynamoDB::Table
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Properties:
            TableName: PlatformRevenue
            BillingMode: PAY_PER_REQUEST
            KeySchema:
                - AttributeName: revenueId
                  KeyType: HASH
            AttributeDefinitions:
                - AttributeName: revenueId
                  AttributeType: S
                - AttributeName: transactionId
                  AttributeType: S
                - AttributeName: createdAt
                  AttributeType: S
            GlobalSecondaryIndexes:
                - IndexName: TransactionIdIndex
                  KeySchema:
                      - AttributeName: transactionId
                        KeyType: HASH
                  Projection:
                      ProjectionType: ALL
                - IndexName: DateIndex
                  KeySchema:
                      - AttributeName: createdAt
                        KeyType: HASH
                  Projection:
                      ProjectionType: ALL
            SSESpecification:
                SSEEnabled: true

    ##################################################################################################################
    # Lambda Functions
    ##################################################################################################################

    GetVerificationStatusFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.getVerificationStatus
            CodeUri: ../../lambdas/plaid/verificationStatus
            Events:
                GetVerificationStatus:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /plaid/verification-status
                        Method: get
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 128
            Timeout: 30
            Environment:
                Variables:
                    DYNAMO_TABLES: !Ref EntitiesTable
            Policies:
                - DynamoDBReadPolicy:
                      TableName: !Ref CybridIdentityVerificationsTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:Query
                        Resource:
                            - !GetAtt CybridIdentityVerificationsTable.Arn
                            - !Sub '${CybridIdentityVerificationsTable.Arn}/index/*'
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    CreateIdentityFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.lambdaHandler
            CodeUri: ../../lambdas/cybrid/identities/
            Layers:
                - !Ref LayerCommons
            Events:
                ApiEndpoint:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /identities
                        Method: post
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
                    DYNAMO_TABLES: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    CreateAccountFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: cybrid-accounts.lambdaHandler
            CodeUri: ../../lambdas/cybrid/accounts/
            Layers:
                - !Ref LayerCommons
            Events:
                CreateAccount:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /accounts
                        Method: post
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - DynamoDBCrudPolicy:
                      TableName: !Ref CybridIdentityVerificationsTable
                - DynamoDBCrudPolicy:
                      TableName: !Ref CybridFiatAccountsTable
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - cybrid-accounts.ts

    # Get Identity Lambda
    GetIdentityFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: get-identity.lambdaHandler
            CodeUri: ../../lambdas/cybrid/identities/
            Layers:
                - !Ref LayerCommons
            Events:
                GetIdentity:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /identities
                        Method: get
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - DynamoDBCrudPolicy:
                      TableName: !Ref CybridIdentityVerificationsTable
                - DynamoDBCrudPolicy:
                      TableName: !Ref CybridFiatAccountsTable
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - get-identity.ts

    CybridWebhookProcessorFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/cybrid/webhooks/
            Handler: webhook-processor.cybridWebhookProcessor
            Layers:
                - !Ref LayerCommons
            Architectures:
                - arm64
            Runtime: nodejs18.x
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_WEBHOOK_QUEUE_URL: !Ref CybridWebhookQueue
                    CREATE_ACCOUNT_FUNCTION_NAME: !Ref CreateAccountFunction
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SQSPollerPolicy:
                      QueueName: !GetAtt CybridWebhookQueue.QueueName
                - SecretsManagerReadWrite
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource:
                            - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:cybrid-secrets*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:UpdateItem
                        Resource: !GetAtt CybridIdentityVerificationsTable.Arn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                        Resource: !GetAtt CybridIdentityVerificationsTable.Arn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:Scan
                            - dynamodb:Query
                            - dynamodb:PutItem
                        Resource:
                            - !Ref EntitiesTableArn
                            - !Sub '${EntitiesTableArn}/index/*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - lambda:InvokeFunction
                        Resource: !GetAtt CreateAccountFunction.Arn
            Events:
                SQSEvent:
                    Type: SQS
                    Properties:
                        Queue: !GetAtt CybridWebhookQueue.Arn
                        BatchSize: 10
        Metadata: # Manage esbuild properties
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - webhook-processor.ts
            LoggingConfig:
                LogFormat: JSON

    CreateCustomerFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: cybrid-customers.lambdaHandler
            CodeUri: ../../lambdas/cybrid/customers/
            Events:
                CreateCustomer:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /customers
                        Method: post
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Layers:
                - !Ref LayerCommons
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - DynamoDBCrudPolicy:
                      TableName: !Ref CybridFiatAccountsTable
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                        Resource: !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${EntitiesTable}'

        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - cybrid-customers.ts

    CybridPlaidAccountVerificationFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/cybrid/externalAccounts/verifyAccounts/
            Layers:
                - !Ref LayerCommons
            Handler: app.lambdaHandler
            Runtime: nodejs18.x
            Architectures:
                - arm64
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    VERIFICATION_QUEUE_URL: !Ref CybridPlaidAccountVerificationQueue
                    PLAID_SECRET: plaid-secrets
                    PLAID_SECRET_NAME: plaid-secrets
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - Statement:
                      - Effect: Allow
                        Action:
                            - sqs:SendMessage
                        Resource: !GetAtt CybridPlaidAccountVerificationQueue.Arn
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:plaid-secrets*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:cybrid-secrets*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - sqs:SendMessage
                        Resource: !GetAtt CybridPlaidAccountVerificationQueue.Arn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:UpdateItem
                        Resource: !GetAtt CybridIdentityVerificationsTable.Arn
                - Statement:
                      - Effect: Allow
                        Action:
                            - sqs:GetQueueUrl
                        Resource: !GetAtt CybridPlaidAccountVerificationQueue.Arn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                        Resource: !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${PlaidAccessTokensTable}'
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                            - dynamodb:Query
                            - dynamodb:PutItem
                            - dynamodb:UpdateItem
                        Resource: 
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${EntitiesTable}'
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${EntitiesTable}/index/*'

            Events:
                SQSEvent:
                    Type: SQS
                    Properties:
                        Queue: !GetAtt CybridPlaidAccountVerificationQueue.Arn
                        BatchSize: 10
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    # Cybrid Webhook SNS Topic
    CybridWebhookTopic:
        Type: AWS::SNS::Topic
        Properties:
            TopicName: !Sub '${Environment}-cybrid-webhook-events'
            DisplayName: Cybrid Webhook Events Fanout
            Subscription:
                - Protocol: sqs
                  Endpoint: !GetAtt CybridWebhookQueue.Arn

    # CYBRID WEBHOOK HANDLER
    CybridWebhookHandlerFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/cybrid/webhooks/
            Handler: webhook-handler.cybridWebhookHandler
            Runtime: nodejs18.x
            Timeout: 29
            MemorySize: 1024
            Architectures:
                - arm64
            Environment:
                Variables:
                    CYBRID_WEBHOOK_QUEUE_URL: !Ref CybridWebhookQueue
                    CYBRID_WEBHOOK_TOPIC_ARN: !Ref CybridWebhookTopic
                    CYBRID_TRANSFER_TOPIC_ARN: !GetAtt CybridTransferStack.Outputs.CybridTransferTopicArn
            Policies:
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - sqs:SendMessage
                            - sqs:GetQueueUrl
                        Resource: !GetAtt CybridWebhookQueue.Arn
                - SecretsManagerReadWrite
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource:
                            - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:cybrid-secrets*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - sns:Publish
                        Resource: !Ref CybridWebhookTopic
                - Statement:
                      - Effect: Allow
                        Action:
                            - sns:Publish
                        Resource: !GetAtt CybridTransferStack.Outputs.CybridTransferTopicArn
            Layers:
                - !Ref LayerCommons
            Events:
                Api:
                    Type: Api
                    Properties:
                        Path: /webhook/cybrid
                        Method: post

        Metadata: # Manage esbuild properties
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - webhook-handler.ts
            LoggingConfig:
                LogFormat: JSON

    CreateExternalBankAccountFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.createExternalBankAccountHandler
            CodeUri: ../../lambdas/cybrid/externalAccounts/
            Layers:
                - !Ref LayerCommons
            Runtime: nodejs18.x
            Timeout: 30
            MemorySize: 1024
            Architectures:
                - arm64
            Environment:
                Variables:
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    VERIFICATION_QUEUE_URL: !Ref CybridPlaidAccountVerificationQueue
            Policies:
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:UpdateItem
                        Resource: !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${EntitiesTable}'
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                        Resource: !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${EntitiesTable}'
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - sqs:SendMessage
                        Resource: !GetAtt CybridPlaidAccountVerificationQueue.Arn
            Events:
                Api:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /external-bank-account
                        Method: post
                        Auth:
                            Authorizer: CybridAuthorizer
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    # Business Customer Functions
    CreateBusinessCustomerFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: create-business-customer.lambdaHandler
            CodeUri: ../../lambdas/cybrid/customers/
            Events:
                CreateBusinessCustomer:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /business-customers
                        Method: post
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - create-business-customer.ts

    BusinessIdentityVerificationFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: business-identity-verification.lambdaHandler
            CodeUri: ../../lambdas/cybrid/identities/
            Events:
                BusinessIdentityVerification:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /business-identities
                        Method: post
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - business-identity-verification.ts

    CompleteBusinessVerificationFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: complete-business-verification.lambdaHandler
            CodeUri: ../../lambdas/cybrid/identities/
            Events:
                CompleteBusinessVerification:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /business-verification/complete
                        Method: post
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
                    DYNAMO_TABLES: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - complete-business-verification.ts

    CheckBusinessVerificationStatusFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: check-business-verification-status.lambdaHandler
            CodeUri: ../../lambdas/cybrid/identities/
            Events:
                CheckBusinessVerificationStatus:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /business-verification/status
                        Method: get
                        Auth:
                            Authorizer: CybridAuthorizer
                CheckSpecificBusinessVerificationStatus:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /business-verification/status/{id}
                        Method: get
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
                    DYNAMO_TABLES: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - check-business-verification-status.ts

    GetBusinessIdentityFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: get-business-identity.lambdaHandler
            CodeUri: ../../lambdas/cybrid/identities/
            Events:
                GetBusinessIdentity:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /business-identities
                        Method: get
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - get-business-identity.ts

    ListBusinessFilesFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: list-business-files.lambdaHandler
            CodeUri: ../../lambdas/cybrid/identities/
            Events:
                ListBusinessFiles:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /business-files
                        Method: get
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - list-business-files.ts

    UploadBusinessFileFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: upload-business-file.lambdaHandler
            CodeUri: ../../lambdas/cybrid/identities/
            Events:
                UploadBusinessFile:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /business-files
                        Method: post
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - upload-business-file.ts

    UploadFileFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: upload-file.lambdaHandler
            CodeUri: ../../lambdas/cybrid/identities/
            Events:
                UploadFile:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridApi
                        Path: /files
                        Method: post
                        Auth:
                            Authorizer: CybridAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CLERK_JWT_SECRET_ARN: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${Environment}-clerk-jwt-public-key'
                    ENVIRONMENT: !Ref Environment
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - SecretsManagerReadWrite
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - upload-file.ts

    ##################################################################################################################
    # Queues
    ##################################################################################################################

    CybridWebhookQueue:
        Type: AWS::SQS::Queue
        DeletionPolicy: Retain
        UpdateReplacePolicy: Retain
        Properties:
            VisibilityTimeout: 300
            RedrivePolicy:
                deadLetterTargetArn: !GetAtt CybridWebhookDLQ.Arn
                maxReceiveCount: 3
            MessageRetentionPeriod: 1209600 # 14 days - Explicitly set to avoid default 4 days deletion

    CybridWebhookDLQ:
        Type: AWS::SQS::Queue
        DeletionPolicy: Retain
        UpdateReplacePolicy: Retain
        Properties:
            MessageRetentionPeriod: 1209600 # 14 days

    CybridPlaidAccountVerificationQueue:
        Type: AWS::SQS::Queue
        DeletionPolicy: Retain
        UpdateReplacePolicy: Retain
        Properties:
            MessageRetentionPeriod: 1209600 # 14 days

    CybridPlaidAccountVerificationDLQ:
        Type: AWS::SQS::Queue
        DeletionPolicy: Retain
        UpdateReplacePolicy: Retain
        Properties:
            MessageRetentionPeriod: 1209600 # 14 days

    ##################################################################################################################
    # Policies
    ##################################################################################################################

    CybridWebhookQueuePolicy:
        Type: AWS::SQS::QueuePolicy
        Properties:
            Queues:
                - !Ref CybridWebhookQueue
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: 'sns.amazonaws.com'
                      Action: 'sqs:SendMessage'
                      Resource: !GetAtt CybridWebhookQueue.Arn
                      Condition:
                          ArnEquals:
                              'aws:SourceArn': !Ref CybridWebhookTopic

    ##################################################################################################################
    # Api Gateway
    ##################################################################################################################

    CybridApi:
        Type: AWS::Serverless::Api
        Properties:
            StageName: Prod
            Auth:
                DefaultAuthorizer: CybridAuthorizer
                Authorizers:
                    CybridAuthorizer:
                        FunctionPayloadType: TOKEN
                        FunctionArn: !Ref ClerkAuthorizerArn
                        Identity:
                            Header: Authorization
                            ValidationExpression: '^Bearer [-0-9a-zA-Z\._]*$'
                            ReauthorizeEvery: 0

    ##################################################################################################################
    # Transfers stack
    ##################################################################################################################

    CybridTransferStack:
        Type: AWS::CloudFormation::Stack
        Properties:
            TemplateURL: ./transfer-stack.yaml
            Parameters:
                Environment: !Ref Environment
                CybridSecretName: !Ref CybridSecretName
                CybridBaseUrl: !Ref CybridBaseUrl
                CybridUrlScheme: !Ref CybridUrlScheme
                CybridFiatAccountsTableArn: !Ref EntitiesTableArn
                CybridEntitiesTableArn: !Ref EntitiesTableArn
                CybridEntitiesTable: !Ref EntitiesTable
                ClerkAuthorizerArn: !Ref ClerkAuthorizerArn
                CLKKTransactionsTable: !Ref EntitiesTable
                CLKKTransactionsTableArn: !Ref EntitiesTableArn
                CLKKTransactionsTableStream: !Ref EntitiesTableStreamArn
                PlatformRevenueTable: !Ref EntitiesTable
                PlatformRevenueTableArn: !Ref EntitiesTableArn
                LayerCommons: !Ref LayerCommons

Outputs:
    CybridIdentityVerificationsTable:
        Value: !Ref EntitiesTable
        Export:
            Name: !Sub '${Environment}-CybridIdentityVerificationsTable'

    CybridIdentityVerificationsTableArn:
        Value: !Ref EntitiesTableArn
        Export:
            Name: !Sub '${Environment}-CybridIdentityVerificationsTableArn'

    CreateExternalBankAccountFunction:
        Value: !Ref CreateExternalBankAccountFunction
        Export:
            Name: !Sub '${Environment}-CreateExternalBankAccountFunction'

    CreateExternalBankAccountFunctionArn:
        Value: !GetAtt CreateExternalBankAccountFunction.Arn
        Export:
            Name: !Sub '${Environment}-CreateExternalBankAccountFunctionArn'

    CybridFiatAccountsTable:
        Value: !Ref EntitiesTable
        Export:
            Name: !Sub '${Environment}-CybridFiatAccountsTable'

    CybridFiatAccountsTableArn:
        Value: !Ref EntitiesTableArn
        Export:
            Name: !Sub '${Environment}-CybridFiatAccountsTableArn'

    CybridSecretName:
        Value: !Ref CybridSecretName
        Export:
            Name: !Sub '${Environment}-CybridSecretName'

    CybridBaseUrl:
        Value: !Ref CybridBaseUrl
        Export:
            Name: !Sub '${Environment}-CybridBaseUrl'

    CybridApi:
        Value: !Ref CybridApi
        Export:
            Name: !Sub '${Environment}-CybridApi'

    CLKKTransactionsTableArn:
        Value: !Ref EntitiesTableArn
        Export:
            Name: !Sub '${Environment}-CLKKTransactionsTableArn'

    CLKKTransactionsTable:
        Value: !Ref EntitiesTable
        Export:
            Name: !Sub '${Environment}-CLKKTransactionsTable'
</file>

<file path="iac/cybrid/transfer-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
    Transfer Stack
    This stack contains the resources for the Transfer

Parameters:
    Environment:
        Type: String
        Description: The environment to deploy to
    CybridSecretName:
        Type: String
        Description: The name of the Cybrid secret
    CybridBaseUrl:
        Type: String
        Description: The base URL of the Cybrid bank
    CybridUrlScheme:
        Type: String
        Description: The URL scheme of the Cybrid bank
    CybridFiatAccountsTableArn:
        Type: String
        Description: The name of the Cybrid fiat accounts table
    CybridEntitiesTableArn:
        Type: String
        Description: The ARN of the Cybrid entities table
    CybridEntitiesTable:
        Type: String
        Description: The name of the Cybrid entities table
    ClerkAuthorizerArn:
        Type: String
        Description: The ARN of the Clerk authorizer
    CLKKTransactionsTable:
        Type: String
        Description: The name of the CLKKTransactions table
    CLKKTransactionsTableArn:
        Type: String
        Description: ARN of the CLKKTransactions Table
    CLKKTransactionsTableStream:
        Type: String
        Description: 'Stream ARN for the CLKKTransactions table'
    PlatformRevenueTable:
        Type: String
        Description: The name of the PlatformRevenue table
    PlatformRevenueTableArn:
        Type: String
        Description: ARN of the PlatformRevenue Table
    LayerCommons:
        Type: String
        Description: ARN of the Commons Lambda Layer

Resources:
    ##################################################################################################################
    # Api Gateway
    ##################################################################################################################

    CybridTransferApi:
        Type: AWS::Serverless::Api
        Properties:
            StageName: Prod
            Auth:
                DefaultAuthorizer: CybridTransferAuthorizer
                Authorizers:
                    CybridTransferAuthorizer:
                        FunctionPayloadType: TOKEN
                        FunctionArn: !Ref ClerkAuthorizerArn
                        Identity:
                            Header: Authorization
                            ValidationExpression: '^Bearer [-0-9a-zA-Z\._]*$'
                            ReauthorizeEvery: 0

    # Cybrid Transfer SNS Topic
    CybridTransferTopic:
        Type: AWS::SNS::Topic
        Properties:
            TopicName: !Sub '${Environment}-cybrid-transfer-events'
            DisplayName: Cybrid Transfer Events Fanout

    CybridTransferProcessorSubscription:
        Type: AWS::SNS::Subscription
        Properties:
            TopicArn: !Ref CybridTransferTopic
            Protocol: sqs
            Endpoint: !GetAtt CybridTransferQueue.Arn

    CybridPushNotificationSubscription:
        Type: AWS::SNS::Subscription
        Properties:
            TopicArn: !Ref CybridTransferTopic
            Protocol: sqs
            Endpoint: !GetAtt CybridPushNotificationQueue.Arn

    CybridTransferQueue:
        Type: AWS::SQS::Queue
        DeletionPolicy: Retain
        UpdateReplacePolicy: Retain
        Properties:
            VisibilityTimeout: 300
            RedrivePolicy:
                deadLetterTargetArn: !GetAtt CybridTransferDLQ.Arn
                maxReceiveCount: 3
            MessageRetentionPeriod: 1209600 # 14 days - Explicitly set to avoid default 4 days deletion

    CybridTransferDLQ:
        Type: AWS::SQS::Queue
        DeletionPolicy: Retain
        UpdateReplacePolicy: Retain
        Properties:
            MessageRetentionPeriod: 1209600 # 14 days

    CybridPushNotificationQueue:
        Type: AWS::SQS::Queue
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Properties:
            VisibilityTimeout: 300
            MessageRetentionPeriod: 1209600 # 14 days
            RedrivePolicy:
                deadLetterTargetArn: !GetAtt CybridPushNotificationDLQ.Arn
                maxReceiveCount: 3

    CybridPushNotificationDLQ:
        Type: AWS::SQS::Queue
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Properties:
            MessageRetentionPeriod: 1209600 # 14 days

    CybridTransferProcessorFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/cybrid/transfers/webhooks
            Handler: transfer-processor.cybridTransferProcessor
            Runtime: nodejs18.x
            Timeout: 300
            MemorySize: 1024
            Architectures:
                - arm64
            Environment:
                Variables:
                    CYBRID_TRANSFER_QUEUE_URL: !Ref CybridTransferQueue
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CYBRID_URL_SCHEME: !Ref CybridUrlScheme
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
            Policies:
                - SQSPollerPolicy:
                      QueueName: !GetAtt CybridTransferQueue.QueueName
                - SecretsManagerReadWrite
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource:
                            - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:cybrid-secrets*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:UpdateItem
                        Resource: !Ref CybridEntitiesTableArn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:UpdateItem
                        Resource: !Ref CybridEntitiesTableArn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                        Resource: !Ref CybridEntitiesTableArn
                - Statement: #TODO:use better query anc change funcyion
                      - Effect: Allow
                        Action:
                            - dynamodb:Query
                        Resource:
                            - !Sub '${CybridEntitiesTableArn}/index/*'
                            - !Ref CybridEntitiesTableArn
                - Statement: #TODO:use better query anc change funcyion
                      - Effect: Allow
                        Action:
                            - dynamodb:Query
                        Resource:
                            - !Sub '${CybridEntitiesTableArn}/index/*'
                            - !Ref CybridEntitiesTableArn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                        Resource: !Ref CybridEntitiesTableArn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                        Resource: !Ref CybridEntitiesTableArn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:Query
                        Resource: !Sub '${CybridEntitiesTableArn}/index/*'
            Events:
                SQSEvent:
                    Type: SQS
                    Properties:
                        Queue: !GetAtt CybridTransferQueue.Arn
                        BatchSize: 10
            Layers:
                - !Ref LayerCommons
        Metadata: # Manage esbuild properties
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                External:
                    - commons
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - transfer-processor.ts
            LoggingConfig:
                LogFormat: JSON

    # Add Lambda permissions for SNS to invoke the processor
    CybridTransferProcessorPermission:
        Type: AWS::Lambda::Permission
        Properties:
            Action: lambda:InvokeFunction
            FunctionName: !Ref CybridTransferProcessorFunction
            Principal: sns.amazonaws.com
            SourceArn: !Ref CybridTransferTopic

    CybridTransferQueuePolicy:
        Type: AWS::SQS::QueuePolicy
        Properties:
            Queues:
                - !Ref CybridTransferQueue
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: 'sns.amazonaws.com'
                      Action: 'sqs:SendMessage'
                      Resource: !GetAtt CybridTransferQueue.Arn
                      Condition:
                          ArnEquals:
                              'aws:SourceArn': !Ref CybridTransferTopic

    # SQS Queue Policy for Push Notifications
    CybridPushNotificationQueuePolicy:
        Type: AWS::SQS::QueuePolicy
        Properties:
            Queues:
                - !Ref CybridPushNotificationQueue
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: 'sns.amazonaws.com'
                      Action: 'sqs:SendMessage'
                      Resource: !GetAtt CybridPushNotificationQueue.Arn
                      Condition:
                          ArnEquals:
                              'aws:SourceArn': !Ref CybridTransferTopic

    CybridTransferFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/cybrid/quotes
            Handler: app.createQuote
            Runtime: nodejs18.x
            Timeout: 300
            MemorySize: 1024
            Architectures:
                - arm64
            Environment:
                Variables:
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    SINGLE_TABLE_NAME: !Ref CybridEntitiesTable
                    CYBRID_URL_SCHEME: !Ref CybridUrlScheme
                    CYBRID_TRANSFER_QUEUE_URL: !Ref CybridTransferQueue
            Events:
                ApiEndpoint:
                    Type: Api
                    Properties:
                        RestApiId: !Ref CybridTransferApi
                        Path: /transfers
                        Method: post
                        Auth:
                            Authorizer: CybridTransferAuthorizer
            Policies:
                - SecretsManagerReadWrite #TODO: remove too many permissions
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                        Resource: !Ref CybridEntitiesTableArn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:PutItem
                            - dynamodb:UpdateItem
                            - dynamodb:GetItem
                            - dynamodb:Query
                        Resource:
                            - !Ref CybridEntitiesTableArn
                            - !Sub '${CybridEntitiesTableArn}/index/*'
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    ##################################################
    # Central Event Bus for Cross-Service Communication
    ##################################################
    FinancialEventBus:
        Type: AWS::Events::EventBus
        Properties:
            Name: !Sub ${Environment}-financial-events

    ##################################################
    # Stream Processors
    ##################################################

    TransactionStreamProcessor:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/streams/transaction-processor
            Handler: app.handler
            Runtime: nodejs18.x
            Layers:
                - !Ref LayerCommons
            Architectures:
                - arm64
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    EVENT_BUS_NAME: !Ref FinancialEventBus
            Policies:
                - DynamoDBStreamReadPolicy:
                      TableName: !Ref CLKKTransactionsTable
                      StreamName: !Ref CLKKTransactionsTableStream
                - EventBridgePutEventsPolicy:
                      EventBusName: !Ref FinancialEventBus

            Events:
                Stream:
                    Type: DynamoDB
                    Properties:
                        Stream: !Ref CLKKTransactionsTableStream
                        StartingPosition: LATEST
                        BatchSize: 100
                        MaximumBatchingWindowInSeconds: 10
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                External:
                    - commons
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    # Process platform fees when a p2b_transfer transaction is completed
    ProcessPlatformFeeFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/transactions/
            Handler: processPlatformFee.handler
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 256
            Timeout: 10
            Environment:
                Variables:
                    PLATFORM_REVENUE_TABLE: !Ref PlatformRevenueTable
                    PLATFORM_ENTITY_ID: 'platform-entity-id'
                    PLATFORM_NAME: 'CLKK Platform'
                    DEFAULT_FEE_PERCENTAGE: '2.5'
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    CYBRID_URL_SCHEME: !Ref CybridUrlScheme
                    CYBRID_TRANSFER_QUEUE_URL: !Ref CybridTransferQueue
                    SINGLE_TABLE_NAME: !Ref CybridEntitiesTable
            Policies:
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                - DynamoDBCrudPolicy:
                      TableName: !Ref PlatformRevenueTable
                - DynamoDBCrudPolicy:
                      TableName: !Ref CybridEntitiesTable
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - processPlatformFee.ts
    # EventBridge Rule for TransactionUpdates
    TransactionFeeProcessingRule:
        Type: AWS::Events::Rule
        Properties:
            EventBusName: !Ref FinancialEventBus
            EventPattern:
                source:
                    - 'clkk.transactions'
                detail-type:
                    - 'TransactionMODIFY'
                detail:
                    transactionType:
                        - 'p2b_transfer'
                    status:
                        - 'completed'
                    fee_amount:
                        - exists: true
                    fee_transfer_id:
                        - exists: false
            Targets:
                - Id: ProcessPlatformFeeTarget
                  Arn: !GetAtt ProcessPlatformFeeFunction.Arn

    # Permission for EventBridge to invoke Lambda
    ProcessPlatformFeeFunctionPermission:
        Type: AWS::Lambda::Permission
        Properties:
            Action: lambda:InvokeFunction
            FunctionName: !Ref ProcessPlatformFeeFunction
            Principal: events.amazonaws.com
            SourceArn: !GetAtt TransactionFeeProcessingRule.Arn

    CybridPushNotificationFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/
            Handler: notifications/push-notification.processNotification
            Runtime: nodejs18.x
            Timeout: 300
            MemorySize: 1024
            Architectures:
                - arm64
            Environment:
                Variables:
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
                    SINGLE_TABLE_NAME: !Ref CybridEntitiesTable
                    CYBRID_URL_SCHEME: !Ref CybridUrlScheme
            Policies:
                - SQSPollerPolicy:
                      QueueName: !GetAtt CybridPushNotificationQueue.QueueName
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource:
                            - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                            - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:firebase-secrets*'
                            - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:apple-push-notification-key*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:GetItem
                            - dynamodb:Query
                        Resource:
                            - !Ref CybridEntitiesTableArn
                            - !Sub '${CybridEntitiesTableArn}/index/*'
                            - !Ref CLKKTransactionsTableArn
                            - !Sub '${CLKKTransactionsTableArn}/index/*'
            Events:
                SQSEvent:
                    Type: SQS
                    Properties:
                        Queue: !GetAtt CybridPushNotificationQueue.Arn
                        BatchSize: 10
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                External:
                    - commons
                    - '@aws-sdk/client-dynamodb'
                    - '@aws-sdk/util-dynamodb'
                    - axios
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - notifications/push-notification.ts
            LoggingConfig:
                LogFormat: JSON

    # # Add Lambda permission for SNS to invoke the notification function
    CybridPushNotificationPermission:
        Type: AWS::Lambda::Permission
        Properties:
            Action: lambda:InvokeFunction
            FunctionName: !Ref CybridPushNotificationFunction
            Principal: sns.amazonaws.com
            SourceArn: !Ref CybridTransferTopic

Outputs:
    CybridTransferTopicArn:
        Value: !Ref CybridTransferTopic
</file>

<file path="iac/graphql/graphql-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: GraphQL API stack aggregating all data sources

Parameters:
    Environment:
        Type: String
        Default: dev
        AllowedValues: [dev, staging, prod]

    # Existing resource ARNs
    EntitiesTableArn:
        Type: String
    PlaidAccessTokensTableArn:
        Type: String
    CybridFiatAccountsTableArn:
        Type: String
    CybridIdentityVerificationsTableArn:
        Type: String
    EntitiesTable:
        Type: String
    PlaidAccessTokensTable:
        Type: String
    CybridFiatAccountsTable:
        Type: String
    CybridIdentityVerificationsTable:
        Type: String
    CLKKTransactionsTable:
        Type: String
    CLKKTransactionsTableArn:
        Type: String
    LayerCommons:
        Type: String

Resources:
    MyLambdaFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../graphQl/lambdas/
            Handler: getFinancialData.handler
            Runtime: nodejs18.x
            Timeout: 30
            MemorySize: 1024
            Architectures:
                - arm64
            Policies:
                - DynamoDBReadPolicy:
                      TableName: !Ref CLKKTransactionsTableArn
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:BatchGetItem
                            - dynamodb:GetItem
                            - dynamodb:Query
                        Resource:
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${EntitiesTable}'
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${CybridFiatAccountsTable}'
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${CybridIdentityVerificationsTable}'
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${CybridFiatAccountsTable}/index/UserIdIndex'
                            - !Sub '${CLKKTransactionsTableArn}/index/*'
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${CLKKTransactionsTable}'
                            - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${CLKKTransactionsTable}/index/UserTransactionsIndex'
            Layers:
                - !Ref LayerCommons
        Metadata: # Manage esbuild properties
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - getFinancialData.ts
            LoggingConfig:
                LogFormat: JSON

    FinancialGraphQLApi:
        Type: AWS::Serverless::GraphQLApi
        Properties:
            Auth:
                Type: API_KEY
            ApiKeys:
                MyApiKey: {}
            XrayEnabled: true
            SchemaUri: ../../graphQl/schema.graphql #Schema updates not working
            DataSources:
                Lambda:
                    LambdaDataSource:
                        FunctionArn: !GetAtt MyLambdaFunction.Arn
            Functions:
                lambaInvoker:
                    Runtime:
                        Name: APPSYNC_JS
                        Version: '1.0.0'
                    DataSource: LambdaDataSource
                    CodeUri: ../../graphQl/resolvers/getFinancialData.js
            Resolvers:
                Query:
                    getFinancialData:
                        Runtime:
                            Name: APPSYNC_JS
                            Version: '1.0.0'
                        Pipeline:
                            - lambaInvoker
</file>

<file path="iac/nmi/nmi-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: CLKK Backend - NMI Payment Gateway Integration

Parameters:
    Stage:
        Type: String
        Default: dev
        AllowedValues:
            - dev
            - staging
            - prod
        Description: Stage/environment for deployment

    NetworkingStackName:
        Type: String
        Default: clkk-backend-networking
        Description: Name of the networking stack with VPC, subnets, etc.

    KmsKeyId:
        Type: String
        Description: KMS Key ID for encrypting sensitive data

    NmiApiUrl:
        Type: String
        Default: 'https://rytepay.transactiongateway.com/api'
        Description: NMI API URL

    NmiPrivateKey:
        Type: String
        Default: '/clkk/nmi/security-key'
        Description: SSM Parameter name for NMI security key

    NmiMainApiUrl:
        Type: String
        Default: 'https://secure.nmi.com/api/v4'
        Description: NMI Main API URL

    AllowedOrigins:
        Type: String
        Default: http://localhost:3000,https://app.clkk.com
        Description: Comma-separated list of allowed origins for CORS

    RateLimitMaxRequests:
        Type: Number
        Default: 10
        Description: Maximum number of requests per minute per IP

    ClerkAuthorizerArn:
        Type: String
        Description: ARN of the Clerk Authorizer

    LayerCommons:
        Type: String
        Description: ARN of the Commons Lambda Layer

    NmiSecretName:
        Type: String
        Default: 'nmi/credentials'
        Description: Name of the Secrets Manager secret containing NMI credentials

    ApplicationTableName:
        Type: String
        Description: Name of the DynamoDB table containing CLKK transactions

    ApplicationTableArn:
        Type: String
        Description: ARN of the DynamoDB table containing CLKK transactions

    CybridSecretName:
        Type: String
        Default: '/cybrid/api-keys/dev'
        Description: Name of the Secrets Manager secret containing Cybrid credentials

    CybridBaseUrl:
        Type: String
        Default: 'sandbox.cybrid.app'
        Description: Cybrid API base URL

Resources:
    # Lambda Functions
    NmiEchoFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-nmi-echo-${Stage}
            Handler: nmi.echoHandler
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/nmi/handlers/
            Layers:
                - !Ref LayerCommons
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    KMS_KEY_ID: !Ref KmsKeyId
                    NMI_API_URL: !Ref NmiApiUrl
                    NMI_PRIVATE_KEY: !Ref NmiPrivateKey
                    ALLOWED_ORIGINS: !Ref AllowedOrigins
                    RATE_LIMIT_MAX_REQUESTS: !Ref RateLimitMaxRequests
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - SSMParameterReadPolicy:
                      ParameterName: !Ref NmiPrivateKey
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /nmi/echo
                        Method: get
                        RestApiId: !Ref NmiPaymentApi
                        Auth:
                            Authorizer: ClerkAuthorizer
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - nmi.ts

    NmiAuthorizeFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-nmi-authorize-${Stage}
            Handler: nmi.authorizeHandler
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/nmi/handlers/
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    KMS_KEY_ID: !Ref KmsKeyId
                    NMI_API_URL: !Ref NmiApiUrl
                    NMI_PRIVATE_KEY: !Ref NmiPrivateKey
                    ALLOWED_ORIGINS: !Ref AllowedOrigins
                    RATE_LIMIT_MAX_REQUESTS: !Ref RateLimitMaxRequests
                    TABLE_NAME: !Ref ApplicationTableName
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - SSMParameterReadPolicy:
                      ParameterName: !Ref NmiPrivateKey
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTableName
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /nmi/authorize
                        Method: post
                        RestApiId: !Ref NmiPaymentApi
                        Auth:
                            Authorizer: ClerkAuthorizer
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - nmi.ts

    NmiCaptureFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-nmi-capture-${Stage}
            Handler: nmi.captureHandler
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/nmi/handlers/
            Layers:
                - !Ref LayerCommons
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    KMS_KEY_ID: !Ref KmsKeyId
                    NMI_API_URL: !Ref NmiApiUrl
                    NMI_PRIVATE_KEY: !Ref NmiPrivateKey
                    ALLOWED_ORIGINS: !Ref AllowedOrigins
                    RATE_LIMIT_MAX_REQUESTS: !Ref RateLimitMaxRequests
                    TABLE_NAME: !Ref ApplicationTableName
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - SSMParameterReadPolicy:
                      ParameterName: !Ref NmiPrivateKey
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTableName
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /nmi/capture
                        Method: post
                        RestApiId: !Ref NmiPaymentApi
                        Auth:
                            Authorizer: ClerkAuthorizer
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - nmi.ts

    # Card Type Check Function
    CheckCardTypeFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-nmi-card-type-${Stage}
            Handler: nmi.cardTypeCheckHandler
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/nmi/handlers/
            Layers:
                - !Ref LayerCommons
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    KMS_KEY_ID: !Ref KmsKeyId
                    NMI_API_URL: !Ref NmiApiUrl
                    NMI_PRIVATE_KEY: !Ref NmiPrivateKey
                    NMI_MAIN_API_URL: !Ref NmiMainApiUrl
                    ALLOWED_ORIGINS: !Ref AllowedOrigins
                    RATE_LIMIT_MAX_REQUESTS: !Ref RateLimitMaxRequests
                    TABLE_NAME: !Ref ApplicationTableName
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - SSMParameterReadPolicy:
                      ParameterName: !Ref NmiPrivateKey
                - KMSDecryptPolicy:
                      KeyId: !Ref KmsKeyId
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTableName
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /nmi/card-type
                        Method: post
                        RestApiId: !Ref NmiPaymentApi
                        Auth:
                            Authorizer: ClerkAuthorizer
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - nmi.ts

    # API Gateway
    NmiPaymentApi:
        Type: AWS::Serverless::Api
        Properties:
            StageName: !Ref Stage
            Auth:
                Authorizers:
                    ClerkAuthorizer:
                        FunctionArn: !Ref ClerkAuthorizerArn
                        FunctionPayloadType: TOKEN
                        Identity:
                            Header: Authorization
                            ValidationExpression: '^Bearer [-0-9a-zA-Z\._]*$'
                            ReauthorizeEvery: 0
                DefaultAuthorizer: ClerkAuthorizer
            MethodSettings:
                - ResourcePath: '/*'
                  HttpMethod: '*'
                  ThrottlingRateLimit: !Ref RateLimitMaxRequests
                  ThrottlingBurstLimit: !Ref RateLimitMaxRequests
                  MetricsEnabled: true

    ###WEBHOOK INFRASTRUCTURE####

    # Webhook SNS Topic
    NmiWebhookTopic:
        Type: AWS::SNS::Topic
        Properties:
            TopicName: !Sub 'clkk-nmi-webhook-events-${Stage}'
            DisplayName: NMI Webhook Events Fanout

    # Webhook SQS Queue
    NmiWebhookQueue:
        Type: AWS::SQS::Queue
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Properties:
            QueueName: !Sub 'clkk-nmi-webhook-queue-${Stage}'
            VisibilityTimeout: 300
            RedrivePolicy:
                deadLetterTargetArn: !GetAtt NmiWebhookDLQ.Arn
                maxReceiveCount: 3
            MessageRetentionPeriod: 1209600 # 14 days

    # Dead Letter Queue for failed webhook processing
    NmiWebhookDLQ:
        Type: AWS::SQS::Queue
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Properties:
            QueueName: !Sub 'clkk-nmi-webhook-dlq-${Stage}'
            MessageRetentionPeriod: 1209600 # 14 days

    # SNS to SQS Subscription
    NmiWebhookSubscription:
        Type: AWS::SNS::Subscription
        Properties:
            TopicArn: !Ref NmiWebhookTopic
            Protocol: sqs
            Endpoint: !GetAtt NmiWebhookQueue.Arn

    # SQS Queue Policy to allow SNS to send messages
    NmiWebhookQueuePolicy:
        Type: AWS::SQS::QueuePolicy
        Properties:
            Queues:
                - !Ref NmiWebhookQueue
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: 'sns.amazonaws.com'
                      Action: 'sqs:SendMessage'
                      Resource: !GetAtt NmiWebhookQueue.Arn
                      Condition:
                          ArnEquals:
                              'aws:SourceArn': !Ref NmiWebhookTopic

    # Webhook Receiver Lambda (API Gateway -> SNS)
    NmiWebhookReceiverFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-nmi-webhook-receiver-${Stage}
            Handler: webhook-receiver.nmiWebhookReceiver
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/nmi/webhooks/
            Layers:
                - !Ref LayerCommons
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    NMI_WEBHOOK_TOPIC_ARN: !Ref NmiWebhookTopic
                    NMI_SECRET_NAME: !Ref NmiSecretName
            Policies:
                - SNSPublishMessagePolicy:
                      TopicName: !GetAtt NmiWebhookTopic.TopicName
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${NmiSecretName}*'
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /nmi/webhooks
                        Method: post
                        RestApiId: !Ref NmiPaymentApi
                        Auth:
                            Authorizer: NONE # No auth for NMI webhooks
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - webhook-receiver.ts
                External:
                    - commons
                    - '@aws-sdk/client-sns'
                    - '@aws-sdk/client-secrets-manager'
                    - '@aws-sdk/client-dynamodb'
                    - '@aws-sdk/lib-dynamodb'
                    - 'axios'
                    - 'uuid'

    # Webhook Processor Lambda (SQS -> Update Transactions)
    NmiWebhookProcessorFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-nmi-webhook-processor-${Stage}
            Handler: webhook-processor.nmiWebhookProcessor
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/nmi/webhooks/
            Layers:
                - !Ref LayerCommons
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    NMI_SECRET_NAME: !Ref NmiSecretName
                    TABLE_NAME: !Ref ApplicationTableName
                    SINGLE_TABLE_NAME: !Ref ApplicationTableName
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Policies:
                - VPCAccessPolicy: {}
                - SQSPollerPolicy:
                      QueueName: !GetAtt NmiWebhookQueue.QueueName
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTableName
                - Statement:
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${NmiSecretName}*'
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:cybrid-secrets*'
            Events:
                SQSEvent:
                    Type: SQS
                    Properties:
                        Queue: !GetAtt NmiWebhookQueue.Arn
                        BatchSize: 10
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - webhook-processor.ts
                External:
                    - commons
                    - '@aws-sdk/client-secrets-manager'
                    - '@aws-sdk/client-dynamodb'
                    - '@aws-sdk/lib-dynamodb'
                    - 'axios'
                    - 'uuid'

Outputs:
    ApiEndpoint:
        Description: NMI Payment API Gateway endpoint URL
        Value: !Sub https://${NmiPaymentApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}/
        Export:
            Name: !Sub ${AWS::StackName}-ApiEndpoint

    EchoFunctionArn:
        Description: NMI Echo Function ARN
        Value: !GetAtt NmiEchoFunction.Arn
        Export:
            Name: !Sub ${AWS::StackName}-EchoFunctionArn

    AuthorizeFunctionArn:
        Description: NMI Authorize Function ARN
        Value: !GetAtt NmiAuthorizeFunction.Arn
        Export:
            Name: !Sub ${AWS::StackName}-AuthorizeFunctionArn

    CaptureFunctionArn:
        Description: NMI Capture Function ARN
        Value: !GetAtt NmiCaptureFunction.Arn
        Export:
            Name: !Sub ${AWS::StackName}-CaptureFunctionArn

    CheckCardTypeFunctionArn:
        Description: NMI Card Type Check Function ARN
        Value: !GetAtt CheckCardTypeFunction.Arn
        Export:
            Name: !Sub ${AWS::StackName}-CheckCardTypeFunctionArn

    WebhookEndpoint:
        Description: NMI Webhook endpoint URL
        Value: !Sub https://${NmiPaymentApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}/nmi/webhooks
        Export:
            Name: !Sub ${AWS::StackName}-WebhookEndpoint

    WebhookTopicArn:
        Description: NMI Webhook SNS Topic ARN
        Value: !Ref NmiWebhookTopic
        Export:
            Name: !Sub ${AWS::StackName}-WebhookTopicArn
</file>

<file path="iac/plaid/plaid-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
    Plaid Stack
    This stack contains the resources for the Plaid

Parameters:
    EntitiesTableArn:
        Type: String
        Description: ARN of the Entities Table
    EntitiesTable:
        Type: String
        Description: Name of the Entities Table
    Environment:
        Type: String
        Description: Environment
    CybridIdentityVerificationsTableArn:
        Type: String
        Description: ARN of the Cybrid Identity Verifications Table
    CreateExternalBankAccountFunctionArn:
        Type: String
        Description: ARN of the Create External Bank Account Function
    CreateExternalBankAccountFunction:
        Type: String
        Description: Name of the Create External Bank Account Function
    PlaidAccessTokensTableArn:
        Type: String
        Description: ARN of the Plaid Access Tokens Table
    LayerCommons:
        Type: String
        Description: ARN of the Commons Layer
    ClerkAuthorizerArn:
        Type: String
    CybridSecretName:
        Type: String
        Description: The Cybrid Secret Name
    CybridBaseUrl:
        Type: String
        Description: The Cybrid Base URL
    PlaidSecret:
        Type: String
        Description: The Plaid Secret
        Default: plaid-secrets
    PlaidClientId:
        Type: String
        Description: The Plaid Client ID
        Default: plaid-client-id
    PlaidEnv:
        Type: String
        Description: The Plaid Environment
        Default: sandbox

Resources:
    PlaidApi:
        Type: AWS::Serverless::Api
        Properties:
            StageName: Prod
            Auth:
                DefaultAuthorizer: PlaidAuthorizer
                Authorizers:
                    PlaidAuthorizer:
                        FunctionPayloadType: TOKEN
                        FunctionArn: !Ref ClerkAuthorizerArn
                        Identity:
                            Header: Authorization
                            ValidationExpression: '^Bearer [-0-9a-zA-Z\._]*$'
                            ReauthorizeEvery: 0

    GetBalanceFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.getBalance
            CodeUri: ../../lambdas/plaid/
            Events:
                BalanceEndpoint:
                    Type: Api
                    Properties:
                        RestApiId: !Ref PlaidApi
                        Path: /balance
                        Method: get
                        Auth:
                            Authorizer: PlaidAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Policies:
                - DynamoDBReadPolicy: # Only needs read access for getBalance
                      TableName: !Ref EntitiesTable
            Environment:
                Variables:
                    PLAID_CLIENT_ID: !Ref PlaidClientId
                    PLAID_SECRET: !Ref PlaidSecret
                    PLAID_ENV: !Ref PlaidEnv
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    CreateLinkTokenFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.createLinkToken
            CodeUri: ../../lambdas/plaid/
            Events:
                CreateLinkToken:
                    Type: Api
                    Properties:
                        RestApiId: !Ref PlaidApi
                        Path: /create-link-token
                        Method: post
                        Auth:
                            Authorizer: PlaidAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    PLAID_CLIENT_ID: !Ref PlaidClientId
                    PLAID_SECRET: !Ref PlaidSecret
                    PLAID_ENV: !Ref PlaidEnv
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Policies:
                - DynamoDBCrudPolicy:
                      TableName: !Ref EntitiesTable
                - Statement:
                      Sid: SecretsAccess
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:plaid-secrets*'
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    GetPlaidDataFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.getBankData
            CodeUri: ../../lambdas/plaid/data
            Events:
                GetPlaidData:
                    Type: Api
                    Properties:
                        RestApiId: !Ref PlaidApi
                        Path: /bank-data
                        Method: get
                        Auth:
                            Authorizer: PlaidAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Policies:
                - DynamoDBReadPolicy:
                      TableName: !Ref EntitiesTable
            Layers:
                - !Ref LayerCommons
            Environment:
                Variables:
                    PLAID_CLIENT_ID: !Ref PlaidClientId
                    PLAID_SECRET: !Ref PlaidSecret
                    PLAID_ENV: !Ref PlaidEnv
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    DeletePlaidDataFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.deleteAccount
            CodeUri: ../../lambdas/plaid/
            Events:
                DeletePlaidData:
                    Type: Api
                    Properties:
                        RestApiId: !Ref PlaidApi
                        Path: /delete-account
                        Method: delete
                        Auth:
                            Authorizer: PlaidAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Policies:
                - Statement:
                      Sid: DynamoDBAccess
                      Effect: Allow
                      Action:
                          - dynamodb:GetItem
                          - dynamodb:PutItem
                          - dynamodb:UpdateItem
                          - dynamodb:DeleteItem
                          - dynamodb:Query
                          - dynamodb:TransactWriteItems
                      Resource:
                          - !Ref EntitiesTableArn
                - Statement:
                      Sid: SecretsAccess
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:plaid-secrets*'
                - Statement:
                      Sid: IndexAccess
                      Effect: Allow
                      Action:
                          - dynamodb:Query
                      Resource:
                          - !Sub '${EntitiesTableArn}/index/*'
            Environment:
                Variables:
                    PLAID_CLIENT_ID: !Ref PlaidClientId
                    PLAID_SECRET: !Ref PlaidSecret
                    PLAID_ENV: !Ref PlaidEnv
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    ExchangePublicTokenFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.exchangePublicToken
            CodeUri: ../../lambdas/plaid/
            Events:
                ExchangePublicToken:
                    Type: Api
                    Properties:
                        RestApiId: !Ref PlaidApi
                        Path: /exchange_public_token
                        Method: post
                        Auth:
                            Authorizer: PlaidAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    PLAID_CLIENT_ID: !Ref PlaidClientId
                    PLAID_SECRET: !Ref PlaidSecret
                    PLAID_ENV: !Ref PlaidEnv
                    SINGLE_TABLE_NAME: !Ref EntitiesTable
                    CREATE_EXTERNAL_BANK_ACCOUNT_FUNCTION_NAME: !Ref CreateExternalBankAccountFunction
                    CYBRID_SECRET_NAME: !Ref CybridSecretName
                    CYBRID_URL_SCHEME: https
                    CYBRID_BASE_URL: !Ref CybridBaseUrl
            Policies:
                - Statement:
                      Sid: DynamoDBAccess
                      Effect: Allow
                      Action:
                          - dynamodb:GetItem
                          - dynamodb:PutItem
                          - dynamodb:UpdateItem
                      Resource:
                          - !Ref EntitiesTableArn
                - Statement:
                      Sid: SecretsAccess
                      Effect: Allow
                      Action:
                          - secretsmanager:GetSecretValue
                      Resource:
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${CybridSecretName}*'
                          - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:plaid-secrets*'
                - Statement:
                      Sid: LambdaInvoke
                      Effect: Allow
                      Action:
                          - lambda:InvokeFunction
                      Resource: !Ref CreateExternalBankAccountFunctionArn
            Layers:
                - !Ref LayerCommons

        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    ##################################################################################################################
    # DynamoDB Tables
    ##################################################################################################################

    ##################################################################################################################
    # Outputs
    ##################################################################################################################
</file>

<file path="iac/prove/identity-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: CLKK Backend - Prove Identity Verification API

Parameters:
    Stage:
        Type: String
        Default: dev
        AllowedValues:
            - dev
            - staging
            - prod
        Description: Stage/environment for deployment

    NetworkingStackName:
        Type: String
        Default: clkk-backend-networking
        Description: Name of the networking stack with VPC, subnets, etc.

    KmsKeyId:
        Type: String
        Description: KMS Key ID for encrypting sensitive data

    ProveClientId:
        Type: String
        Description: Prove API Client ID
        NoEcho: true

    ProveClientSecret:
        Type: String
        Description: Prove API Client Secret
        NoEcho: true

    ProveEnvironment:
        Type: String
        Default: sandbox
        AllowedValues:
            - sandbox
            - production
        Description: Prove API Environment

    AllowedOrigins:
        Type: String
        Default: http://localhost:3000,https://app.clkk.com
        Description: Comma-separated list of allowed origins for CORS

    RateLimitMaxRequests:
        Type: Number
        Default: 10
        Description: Maximum number of requests per minute per IP

    ClerkAuthorizerArn:
        Type: String
        Description: ARN of the Clerk Authorizer

Resources:
    # Lambda Layer for dependencies
    ProveIdentityLayer:
        Type: AWS::Serverless::LayerVersion
        Properties:
            ContentUri: ../../layers/prove-identity
            CompatibleRuntimes:
                - nodejs18.x
            LayerName: !Sub clkk-prove-identity-layer-${Stage}
            Description: Prove Identity API dependencies

    # Lambda Functions
    EchoFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-prove-echo-${Stage}
            Handler: handlers/identity.echoHandler
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/prove
            Layers:
                - !Ref ProveIdentityLayer
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    KMS_KEY_ID: !Ref KmsKeyId
                    PROVE_CLIENT_ID: !Ref ProveClientId
                    PROVE_CLIENT_SECRET: !Ref ProveClientSecret
                    PROVE_ENVIRONMENT: !Ref ProveEnvironment
                    ALLOWED_ORIGINS: !Ref AllowedOrigins
                    RATE_LIMIT_MAX_REQUESTS: !Ref RateLimitMaxRequests
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /prove/echo
                        Method: get
                        RestApiId: !Ref ProveIdentityApi

    StartVerificationFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-prove-start-${Stage}
            Handler: handlers/identity.startHandler
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/prove
            Layers:
                - !Ref ProveIdentityLayer
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    KMS_KEY_ID: !Ref KmsKeyId
                    PROVE_CLIENT_ID: !Ref ProveClientId
                    PROVE_CLIENT_SECRET: !Ref ProveClientSecret
                    PROVE_ENVIRONMENT: !Ref ProveEnvironment
                    ALLOWED_ORIGINS: !Ref AllowedOrigins
                    RATE_LIMIT_MAX_REQUESTS: !Ref RateLimitMaxRequests
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /prove/start
                        Method: post
                        RestApiId: !Ref ProveIdentityApi

    ValidateVerificationFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-prove-validate-${Stage}
            Handler: handlers/identity.validateHandler
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/prove
            Layers:
                - !Ref ProveIdentityLayer
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    KMS_KEY_ID: !Ref KmsKeyId
                    PROVE_CLIENT_ID: !Ref ProveClientId
                    PROVE_CLIENT_SECRET: !Ref ProveClientSecret
                    PROVE_ENVIRONMENT: !Ref ProveEnvironment
                    ALLOWED_ORIGINS: !Ref AllowedOrigins
                    RATE_LIMIT_MAX_REQUESTS: !Ref RateLimitMaxRequests
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /prove/validate
                        Method: post
                        RestApiId: !Ref ProveIdentityApi

    ChallengeVerificationFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-prove-challenge-${Stage}
            Handler: handlers/identity.challengeHandler
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/prove
            Layers:
                - !Ref ProveIdentityLayer
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    KMS_KEY_ID: !Ref KmsKeyId
                    PROVE_CLIENT_ID: !Ref ProveClientId
                    PROVE_CLIENT_SECRET: !Ref ProveClientSecret
                    PROVE_ENVIRONMENT: !Ref ProveEnvironment
                    ALLOWED_ORIGINS: !Ref AllowedOrigins
                    RATE_LIMIT_MAX_REQUESTS: !Ref RateLimitMaxRequests
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /prove/challenge
                        Method: post
                        RestApiId: !Ref ProveIdentityApi

    CompleteVerificationFunction:
        Type: AWS::Serverless::Function
        Properties:
            FunctionName: !Sub clkk-prove-complete-${Stage}
            Handler: handlers/identity.completeHandler
            Runtime: nodejs18.x
            CodeUri: ../../lambdas/prove
            Layers:
                - !Ref ProveIdentityLayer
            MemorySize: 256
            Timeout: 30
            Environment:
                Variables:
                    STAGE: !Ref Stage
                    KMS_KEY_ID: !Ref KmsKeyId
                    PROVE_CLIENT_ID: !Ref ProveClientId
                    PROVE_CLIENT_SECRET: !Ref ProveClientSecret
                    PROVE_ENVIRONMENT: !Ref ProveEnvironment
                    ALLOWED_ORIGINS: !Ref AllowedOrigins
                    RATE_LIMIT_MAX_REQUESTS: !Ref RateLimitMaxRequests
            VpcConfig:
                SubnetIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-PrivateSubnetId
                SecurityGroupIds:
                    - Fn::ImportValue:
                          Fn::Sub: ${NetworkingStackName}-LambdaSecurityGroupId
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        Path: /prove/complete
                        Method: post
                        RestApiId: !Ref ProveIdentityApi

    # API Gateway
    ProveIdentityApi:
        Type: AWS::Serverless::Api
        Properties:
            StageName: !Ref Stage
            EndpointConfiguration: REGIONAL
            Cors:
                AllowMethods: "'GET,POST,OPTIONS'"
                AllowHeaders: "'Content-Type,Authorization'"
                AllowOrigin: !Sub "'${AllowedOrigins}'"
            Auth:
                DefaultAuthorizer: ClerkAuthorizer
                Authorizers:
                    ClerkAuthorizer:
                        FunctionPayloadType: TOKEN
                        FunctionArn:
                            Fn::ImportValue: !Sub '${Stage}-ClerkAuthorizerArn'
                        Identity:
                            Header: Authorization
                            ValidationExpression: '^Bearer [-0-9a-zA-Z\._]*$'
                            ReauthorizeEvery: 0

Outputs:
    ApiEndpoint:
        Description: API Gateway endpoint URL
        Value: !Sub https://${ProveIdentityApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}/

    NatGatewayIp:
        Description: Static outbound IP address for API calls
        Value:
            Fn::ImportValue:
                Fn::Sub: ${NetworkingStackName}-NatGatewayEIP
</file>

<file path="iac/shared/deploy-test-bucket.sh">
#!/bin/bash
set -e

# Default to dev environment if not specified
ENVIRONMENT=${1:-dev}

# Validate environment
if [[ "$ENVIRONMENT" != "dev" && "$ENVIRONMENT" != "test" ]]; then
  echo "Error: Environment must be either 'dev' or 'test'"
  echo "Usage: $0 [dev|test]"
  exit 1
fi

# Get the AWS account ID
# AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
AWS_ACCOUNT_ID=741448914938

# Stack name
STACK_NAME="clkk-test-data-bucket-$ENVIRONMENT"

echo "Deploying test data bucket for $ENVIRONMENT environment..."

# Deploy the CloudFormation stack
AWS_PROFILE=clkk-mobile-dev AWS_SDK_LOAD_CONFIG=1 aws cloudformation deploy \
  --template-file test-data-bucket.yaml \
  --stack-name $STACK_NAME \
  --parameter-overrides \
    Environment=$ENVIRONMENT \
    ApplicationName=clkk \
  --capabilities CAPABILITY_IAM \
  --tags Environment=$ENVIRONMENT Application=clkk Purpose=TestData

# Get the bucket name from the stack outputs
BUCKET_NAME=$(aws cloudformation describe-stacks \
  --stack-name $STACK_NAME \
  --query "Stacks[0].Outputs[?OutputKey=='TestDataBucketName'].OutputValue" \
  --output text)

echo "âœ… Deployment complete!"
echo "Test data bucket deployed: $BUCKET_NAME"
echo ""
echo "You can upload test data using:"
echo "aws s3 cp <local-file> s3://$BUCKET_NAME/<key>"
</file>

<file path="iac/shared/domain-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Description: CLKK API Custom Domain & Route53 Setup (All Envs)

Parameters:
    Environment:
        Type: String
        AllowedValues: [dev, test, prod]
        Description: Which environment is being deployed

    HostedZoneId:
        Type: String
        Description: Route 53 Hosted Zone ID from the shared account (for clkk-api.io)

Mappings:
    CertificateMap:
        dev:
            CertArn: arn:aws:acm:us-east-1:SHARED_ACCOUNT_ID:certificate/dev-cert-id
        test:
            CertArn: arn:aws:acm:us-east-1:SHARED_ACCOUNT_ID:certificate/test-cert-id
        prod:
            CertArn: arn:aws:acm:us-east-1:SHARED_ACCOUNT_ID:certificate/prod-cert-id

Conditions:
    IsProd: !Equals [!Ref Environment, prod]

Resources:
    ApiCustomDomain:
        Type: AWS::ApiGateway::DomainName
        DeletionPolicy: Retain
        UpdateReplacePolicy: Retain
        Properties:
            DomainName: !If
                - IsProd
                - api.clkk-api.io
                - !Sub api.${Environment}.clkk-api.io
            CertificateArn: !FindInMap [CertificateMap, !Ref Environment, CertArn]
            EndpointConfiguration:
                Types: [REGIONAL]

    ApiDomainRecord:
        Type: AWS::Route53::RecordSet
        Properties:
            HostedZoneId: !Ref HostedZoneId
            Name: !If
                - IsProd
                - api.clkk-api.io.
                - !Sub api.${Environment}.clkk-api.io.
            Type: A
            AliasTarget:
                DNSName: !GetAtt ApiCustomDomain.RegionalDomainName
                HostedZoneId: !GetAtt ApiCustomDomain.RegionalHostedZoneId

Outputs:
    DomainName:
        Description: API Gateway Custom Domain
        Value: !Ref ApiCustomDomain
        Export:
            Name: !Sub clkk-domain-${Environment}-name

    RegionalDomainName:
        Description: API Gateway regional domain endpoint
        Value: !GetAtt ApiCustomDomain.RegionalDomainName
        Export:
            Name: !Sub clkk-domain-${Environment}-target
</file>

<file path="iac/shared/iam-policies.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Description: 'CLKK Backend - IAM Policies for Prove Identity Verification'

Parameters:
    Environment:
        Type: String
        Default: dev
        AllowedValues:
            - dev
            - staging
            - prod
    KmsKeyId:
        Type: String
        Description: KMS Key ID for encrypting sensitive data
Resources:
    # IAM Role for Lambda functions
    ProveIdentityLambdaRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: lambda.amazonaws.com
                      Action: sts:AssumeRole
            ManagedPolicyArns:
                - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
                - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
            Policies:
                - PolicyName: ProveIdentityKMSPolicy
                  PolicyDocument:
                      Version: '2012-10-17'
                      Statement:
                          - Effect: Allow
                            Action:
                                - kms:Encrypt
                                - kms:Decrypt
                                - kms:ReEncrypt*
                                - kms:GenerateDataKey*
                                - kms:DescribeKey
                            Resource: !Sub 'arn:aws:kms:${AWS::Region}:${AWS::AccountId}:key/${KmsKeyId}'
                - PolicyName: ProveIdentitySecretAccess
                  PolicyDocument:
                      Version: '2012-10-17'
                      Statement:
                          - Effect: Allow
                            Action:
                                - secretsmanager:GetSecretValue
                                - secretsmanager:DescribeSecret
                            Resource:
                                - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:prove/credentials*'

    # CfnExecutionRole:
    #     Type: AWS::IAM::Role
    #     Properties:
    #         RoleName: !Sub clkk-cfn-execution-role-${Environment}
    #         AssumeRolePolicyDocument:
    #             Version: '2012-10-17'
    #             Statement:
    #                 - Effect: Allow
    #                   Principal:
    #                       Service:
    #                           - cloudformation.amazonaws.com
    #                   Action:
    #                       - sts:AssumeRole
    #         Policies:
    #             - PolicyName: CrossAccountRoute53AcmInline
    #               PolicyDocument:
    #                   Version: '2012-10-17'
    #                   Statement:
    #                       - Sid: AllowReadSharedCert
    #                         Effect: Allow
    #                         Action:
    #                             - acm:DescribeCertificate
    #                             - acm:ListCertificates
    #                         Resource: arn:aws:acm:us-east-1:599317821359:certificate/*
    #                       - Sid: AllowModifySharedZone
    #                         Effect: Allow
    #                         Action:
    #                             - route53:ChangeResourceRecordSets
    #                             - route53:ListResourceRecordSets
    #                         Resource: arn:aws:route53:::hostedzone/Z098588615LHSE8YCMDOU

Outputs:
    ProveIdentityLambdaRoleArn:
        Description: ARN of the IAM Role for Prove Identity Lambda functions
        Value: !GetAtt ProveIdentityLambdaRole.Arn
        Export:
            Name: !Sub ${AWS::StackName}-ProveIdentityLambdaRoleArn
</file>

<file path="iac/shared/networking.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Description: CLKK Backend - Networking Infrastructure

Parameters:
    Environment:
        Type: String
        Default: dev
        AllowedValues:
            - dev
            - staging
            - prod
Resources:
    # VPC for Lambda functions
    LambdaVPC:
        Type: AWS::EC2::VPC
        Properties:
            CidrBlock: 10.0.0.0/16
            EnableDnsSupport: true
            EnableDnsHostnames: true
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-vpc
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    # Public subnet for NAT Gateway
    PublicSubnet1:
        Type: AWS::EC2::Subnet
        Properties:
            VpcId: !Ref LambdaVPC
            AvailabilityZone: !Select
                - 0
                - !GetAZs ''
            CidrBlock: 10.0.0.0/24
            MapPublicIpOnLaunch: true
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-public-subnet-1
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    # Private subnet for Lambda functions
    PrivateSubnet1:
        Type: AWS::EC2::Subnet
        Properties:
            VpcId: !Ref LambdaVPC
            AvailabilityZone: !Select
                - 0
                - !GetAZs ''
            CidrBlock: 10.0.1.0/24
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-private-subnet-1
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    # Internet Gateway for public subnet
    InternetGateway:
        Type: AWS::EC2::InternetGateway
        Properties:
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-igw

    InternetGatewayAttachment:
        Type: AWS::EC2::VPCGatewayAttachment
        Properties:
            VpcId: !Ref LambdaVPC
            InternetGatewayId: !Ref InternetGateway

    # Elastic IP for NAT Gateway (this gives us our static IP)
    NatGatewayEIP:
        Type: AWS::EC2::EIP
        Properties:
            Domain: vpc
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-nat-eip

    # NAT Gateway with the Elastic IP
    NatGateway:
        Type: AWS::EC2::NatGateway
        DependsOn: InternetGatewayAttachment
        Properties:
            SubnetId: !Ref PublicSubnet1
            AllocationId: !GetAtt NatGatewayEIP.AllocationId
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-nat-gateway
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    # Route table for public subnet
    PublicRouteTable:
        Type: AWS::EC2::RouteTable
        Properties:
            VpcId: !Ref LambdaVPC
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-public-route-table
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    PublicRoute:
        Type: AWS::EC2::Route
        DependsOn: InternetGatewayAttachment
        Properties:
            RouteTableId: !Ref PublicRouteTable
            DestinationCidrBlock: 0.0.0.0/0
            GatewayId: !Ref InternetGateway

    PublicSubnet1RouteTableAssociation:
        Type: AWS::EC2::SubnetRouteTableAssociation
        Properties:
            SubnetId: !Ref PublicSubnet1
            RouteTableId: !Ref PublicRouteTable

    # Route table for private subnet
    PrivateRouteTable:
        Type: AWS::EC2::RouteTable
        Properties:
            VpcId: !Ref LambdaVPC
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-private-route-table
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    PrivateRoute:
        Type: AWS::EC2::Route
        Properties:
            RouteTableId: !Ref PrivateRouteTable
            DestinationCidrBlock: 0.0.0.0/0
            NatGatewayId: !Ref NatGateway

    PrivateSubnet1RouteTableAssociation:
        Type: AWS::EC2::SubnetRouteTableAssociation
        Properties:
            SubnetId: !Ref PrivateSubnet1
            RouteTableId: !Ref PrivateRouteTable

    # Security group for Lambda functions
    LambdaSecurityGroup:
        Type: AWS::EC2::SecurityGroup
        Properties:
            GroupDescription: Security group for Lambda functions
            VpcId: !Ref LambdaVPC
            SecurityGroupEgress:
                - IpProtocol: -1
                  CidrIp: 0.0.0.0/0
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-lambda-sg
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    # VPC Flow Logs Configuration
    VPCFlowLogsLogGroup:
        Type: AWS::Logs::LogGroup
        Properties:
            LogGroupName: !Sub /aws/vpc/flowlogs/${AWS::StackName}
            RetentionInDays: 90
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-flowlogs
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    VPCFlowLogsRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: vpc-flow-logs.amazonaws.com
                      Action: sts:AssumeRole
            Policies:
                - PolicyName: !Sub ${AWS::StackName}-vpc-flow-logs-policy
                  PolicyDocument:
                      Version: '2012-10-17'
                      Statement:
                          - Effect: Allow
                            Action:
                                - logs:CreateLogGroup
                                - logs:CreateLogStream
                                - logs:PutLogEvents
                                - logs:DescribeLogGroups
                                - logs:DescribeLogStreams
                            Resource: !GetAtt VPCFlowLogsLogGroup.Arn
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-flowlogs-role
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    VPCFlowLogs:
        Type: AWS::EC2::FlowLog
        Properties:
            DeliverLogsPermissionArn: !GetAtt VPCFlowLogsRole.Arn
            LogGroupName: !Ref VPCFlowLogsLogGroup
            ResourceId: !Ref LambdaVPC
            ResourceType: VPC
            TrafficType: ALL
            Tags:
                - Key: Name
                  Value: !Sub ${AWS::StackName}-vpc-flowlogs
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

Outputs:
    VpcId:
        Description: VPC ID
        Value: !Ref LambdaVPC
        Export:
            Name: !Sub ${AWS::StackName}-VpcId

    PrivateSubnetId:
        Description: Private Subnet ID for Lambda functions
        Value: !Ref PrivateSubnet1
        Export:
            Name: !Sub ${AWS::StackName}-PrivateSubnetId

    LambdaSecurityGroupId:
        Description: Security Group ID for Lambda functions
        Value: !Ref LambdaSecurityGroup
        Export:
            Name: !Sub ${AWS::StackName}-LambdaSecurityGroupId

    NatGatewayEIP:
        Description: Elastic IP address for NAT Gateway (Static IP for outbound requests)
        Value: !Ref NatGatewayEIP
        Export:
            Name: !Sub ${AWS::StackName}-NatGatewayEIP

    VPCFlowLogsLogGroupName:
        Description: CloudWatch Log Group for VPC Flow Logs
        Value: !Ref VPCFlowLogsLogGroup
        Export:
            Name: !Sub ${AWS::StackName}-VPCFlowLogsLogGroupName

    StackName:
        Description: Stack Name
        Value: !Ref AWS::StackName
        Export:
            Name: !Sub ${AWS::StackName}
</file>

<file path="iac/shared/shared-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Shared resources stack

Parameters:
    Environment:
        Type: String
        AllowedValues: [dev, staging, prod]
        Default: dev

    KmsKeyId:
        Type: String
        Description: KMS Key ID for encrypting sensitive data

Resources:
    LayerCommons:
        Type: AWS::Serverless::LayerVersion
        Properties:
            LayerName: 'commons'
            ContentUri: ../../layers/commons/
            Description: Shared dependencies for all Lambda functions
            CompatibleRuntimes: [nodejs18.x]
            CompatibleArchitectures: [arm64]
            RetentionPolicy: delete

        Metadata:
            BuildMethod: makefile

    # DynamoDB Tables
    EntitiesTable:
        Type: AWS::DynamoDB::Table
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Properties:
            TableName: !Sub 'Entities-${Environment}'
            AttributeDefinitions:
                - AttributeName: entityId
                  AttributeType: S
                - AttributeName: clkktag
                  AttributeType: S
                - AttributeName: name
                  AttributeType: S
                - AttributeName: entityType
                  AttributeType: S
            KeySchema:
                - AttributeName: entityId
                  KeyType: HASH
            GlobalSecondaryIndexes:
                - IndexName: ClkktagIndex
                  KeySchema:
                      - AttributeName: clkktag
                        KeyType: HASH
                  Projection:
                      ProjectionType: INCLUDE
                      NonKeyAttributes: [name, entityType]
                - IndexName: NameIndex
                  KeySchema:
                      - AttributeName: entityType
                        KeyType: HASH
                      - AttributeName: name
                        KeyType: RANGE
                  Projection:
                      ProjectionType: INCLUDE
                      NonKeyAttributes: [clkktag, entityType]
                - IndexName: EntityTypeAllAttributesIndex
                  KeySchema:
                      - AttributeName: entityType
                        KeyType: HASH
                      - AttributeName: entityId
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                - IndexName: EntityTypeClkkTagIndexV2
                  KeySchema:
                      - AttributeName: entityType
                        KeyType: HASH
                      - AttributeName: clkktag
                        KeyType: RANGE
                  Projection:
                      ProjectionType: INCLUDE
                      NonKeyAttributes: [firstName, lastName, metadata, profileImageUrl, kyc, email]
            BillingMode: PAY_PER_REQUEST
            SSESpecification:
                SSEEnabled: true

    PlaidAccessTokensTable:
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Type: AWS::DynamoDB::Table
        Properties:
            TableName: !Sub 'PlaidAccessToken-${Environment}'
            BillingMode: PAY_PER_REQUEST
            SSESpecification:
                SSEEnabled: true
            KeySchema:
                - AttributeName: userId
                  KeyType: HASH
            AttributeDefinitions:
                - AttributeName: userId
                  AttributeType: S

    ##################################################################################################################
    # Lambda Functions
    ##################################################################################################################

    ClerkAuthorizerFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: clerk-authorizer.handler
            CodeUri: ../../lambdas/clerk-users/auth/
            Events:
                ApiAuth:
                    Type: Api
                    Properties:
                        RestApiId: !Ref ClerkUsersApi
                        Path: /auth
                        Method: post
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    # Get the secret name from our referenced secret
                    CLERK_JWT_PUBLIC_KEY: '{{resolve:secretsmanager:dev-clerk-jwt-public-key:SecretString}}'
                    ENVIRONMENT: !Ref Environment
            Policies:
                - SecretsManagerReadWrite
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - clerk-authorizer.ts

    ClerkUsersApi:
        Type: AWS::Serverless::Api
        Properties:
            StageName: !Ref Environment
            Auth:
                DefaultAuthorizer: ClerkAuthorizer
                Authorizers:
                    ClerkAuthorizer:
                        FunctionPayloadType: TOKEN
                        FunctionArn: !GetAtt ClerkAuthorizerFunction.Arn
                        Identity:
                            Header: Authorization
                            ValidationExpression: '^Bearer [-0-9a-zA-Z\._]*$'
                            ReauthorizeEvery: 0

#Outputs
Outputs:
    LayerCommons:
        Value: !Ref LayerCommons
        Export:
            Name: !Sub '${Environment}-LayerCommons'

    ClerkAuthorizerArn:
        Value: !GetAtt ClerkAuthorizerFunction.Arn
        Export:
            Name: !Sub '${Environment}-ClerkAuthorizerArn'

    EntitiesTable:
        Value: !Ref EntitiesTable
        Export:
            Name: !Sub '${Environment}-EntitiesTable'

    EntitiesTableArn:
        Value: !GetAtt EntitiesTable.Arn
        Export:
            Name: !Sub '${Environment}-EntitiesTableArn'

    PlaidAccessTokensTable:
        Value: !Ref PlaidAccessTokensTable
        Export:
            Name: !Sub '${Environment}-PlaidAccessTokensTable'

    PlaidAccessTokensTableArn:
        Value: !GetAtt PlaidAccessTokensTable.Arn
        Export:
            Name: !Sub '${Environment}-PlaidAccessTokensTableArn'
</file>

<file path="iac/shared/test-data-bucket.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for Test Data S3 Bucket'

Parameters:
    Environment:
        Type: String
        Default: dev
        AllowedValues:
            - dev
            - test
            - prod
        Description: Environment (dev, test, prod)

    ApplicationName:
        Type: String
        Default: clkk
        Description: Application name used for resource naming

Conditions:
    IsDevOrTest: !Or [!Equals [!Ref Environment, 'dev'], !Equals [!Ref Environment, 'test']]

Resources:
    TestDataBucket:
        Type: AWS::S3::Bucket
        Condition: IsDevOrTest
        Properties:
            BucketName: !Sub ${ApplicationName}-test-data-${Environment}-${AWS::AccountId}
            AccessControl: Private
            PublicAccessBlockConfiguration:
                BlockPublicAcls: true
                BlockPublicPolicy: true
                IgnorePublicAcls: true
                RestrictPublicBuckets: true
            BucketEncryption:
                ServerSideEncryptionConfiguration:
                    - ServerSideEncryptionByDefault:
                          SSEAlgorithm: AES256
            LifecycleConfiguration:
                Rules:
                    - Id: ExpireOldTestData
                      Status: Enabled
                      ExpirationInDays: 30
            Tags:
                - Key: Environment
                  Value: !Ref Environment
                - Key: Application
                  Value: !Ref ApplicationName
                - Key: Purpose
                  Value: TestData

    TestDataBucketPolicy:
        Type: AWS::S3::BucketPolicy
        Condition: IsDevOrTest
        Properties:
            Bucket: !Ref TestDataBucket
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Deny
                      Principal: '*'
                      Action: 's3:*'
                      Resource:
                          - !Sub arn:aws:s3:::${TestDataBucket}
                          - !Sub arn:aws:s3:::${TestDataBucket}/*
                      Condition:
                          Bool:
                              aws:SecureTransport: false

Outputs:
    TestDataBucketName:
        Description: Name of the test data S3 bucket
        Value: !Ref TestDataBucket
        Condition: IsDevOrTest

    TestDataBucketArn:
        Description: ARN of the test data S3 bucket
        Value: !GetAtt TestDataBucket.Arn
        Condition: IsDevOrTest
</file>

<file path="iac/users/users-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
    Users Stack

    This stack contains the resources for the entities application

Parameters:
    Environment:
        Type: String
        Default: dev
        Description: The environment to deploy to

    LayerCommons:
        Type: String
        Description: The Layer Commons
    ApplicationTable:
        Type: String
        Description: The Application Table
    ApplicationTableArn:
        Type: String
        Description: The Application Table ARN
    ClerkAuthorizerArn:
        Type: String
        Description: The Clerk Authorizer ARN

Globals:
    Function:
        Tracing: Active
        # AutoPublishAlias: live # TODO: Uncomment this for production
        # DeploymentPreference:
        #     Type: AllAtOnce # Consider Canary or Linear for production

Resources:
    ##################################################################################################################
    # API Gateway
    ##################################################################################################################

    ClerkApi:
        Type: AWS::Serverless::Api
        Properties:
            StageName: Prod
            TracingEnabled: true
            Auth:
                DefaultAuthorizer: ClerkAuthorizer
                Authorizers:
                    ClerkAuthorizer:
                        FunctionPayloadType: TOKEN
                        FunctionArn: !Ref ClerkAuthorizerArn
                        Identity:
                            Header: Authorization
                            ValidationExpression: '^Bearer [-0-9a-zA-Z\._]*$'
                            ReauthorizeEvery: 0

    ##################################################################################################################
    # SNS Topics and SQS Queues (Messaging Resources)
    ##################################################################################################################

    # Add SNS Topic for CloudWatch Alarms
    # External email service will subscribe to this topic
    AlarmNotificationTopic:
        Type: AWS::SNS::Topic
        Properties:
            TopicName: !Sub '${Environment}-cloudwatch-alarms'
            DisplayName: !Sub '${Environment} CloudWatch Alarms'
            # No subscriptions here - external service will subscribe to this topic

    # Add SNS Topic
    UserWebhookTopic:
        Type: AWS::SNS::Topic
        Properties:
            TopicName: !Sub '${Environment}-user-webhook-events'
            DisplayName: User Webhook Events Fanout
            Subscription:
                - Protocol: sqs
                  Endpoint: !GetAtt UserNotificationsQueue.Arn
                - Protocol: sqs
                  Endpoint: !GetAtt UserDynamoUpdatesQueue.Arn

    # Add SQS Queues
    UserNotificationsQueue:
        Type: AWS::SQS::Queue
        Properties:
            VisibilityTimeout: 300
            RedrivePolicy:
                maxReceiveCount: 3
                deadLetterTargetArn: !GetAtt UserNotificationsDLQ.Arn
            MessageRetentionPeriod: 1209600 # 14 days

    UserNotificationsDLQ:
        Type: AWS::SQS::Queue
        Properties:
            MessageRetentionPeriod: 1209600 # 14 days

    UserDynamoUpdatesQueue:
        Type: AWS::SQS::Queue
        Properties:
            VisibilityTimeout: 300
            RedrivePolicy:
                maxReceiveCount: 3
                deadLetterTargetArn: !GetAtt UserDynamoUpdatesDLQ.Arn
            MessageRetentionPeriod: 1209600 # 14 days

    UserDynamoUpdatesDLQ:
        Type: AWS::SQS::Queue
        Properties:
            MessageRetentionPeriod: 1209600 # 14 days

    # Add SQS Queue Policies
    UserNotificationsQueuePolicy:
        Type: AWS::SQS::QueuePolicy
        Properties:
            Queues:
                - !Ref UserNotificationsQueue
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: 'sns.amazonaws.com'
                      Action: 'sqs:SendMessage'
                      Resource: !GetAtt UserNotificationsQueue.Arn
                      Condition:
                          ArnEquals:
                              'aws:SourceArn': !Ref UserWebhookTopic

    UserDynamoUpdatesQueuePolicy:
        Type: AWS::SQS::QueuePolicy
        Properties:
            Queues:
                - !Ref UserDynamoUpdatesQueue
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Principal:
                          Service: 'sns.amazonaws.com'
                      Action: 'sqs:SendMessage'
                      Resource: !GetAtt UserDynamoUpdatesQueue.Arn
                      Condition:
                          ArnEquals:
                              'aws:SourceArn': !Ref UserWebhookTopic

    ##################################################################################################################
    # Lambda Functions
    ##################################################################################################################

    # Webhook Functions
    ClerkWebhookFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/clerk-users/
            Handler: clerk-webhook.handler
            Runtime: nodejs18.x
            Timeout: 29
            Architectures:
                - arm64
            MemorySize: 1024
            Environment:
                Variables:
                    WEBHOOK_TOPIC_ARN: !Ref UserWebhookTopic

            Policies:
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - secretsmanager:GetSecretValue
                        Resource:
                            - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:clerk-secrets*'
                - Statement:
                      - Effect: Allow
                        Action:
                            - sns:Publish
                        Resource: !Ref UserWebhookTopic
            Layers:
                - !Ref LayerCommons
            Events:
                Api:
                    Type: Api
                    Properties:
                        Path: /webhook/clerk
                        Method: post

        Metadata: # Manage esbuild properties
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - clerk-webhook.ts

    # Notification Processors
    UserNotificationsProcessor:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/notifications/
            Handler: user-notifications.handler
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            # Environment:
            #     Variables:
            #         EMAIL_FROM_ADDRESS: !Ref EmailFromAddress
            #         SES_CONFIGURATION_SET: !Ref SESConfigurationSet
            Events:
                SQS:
                    Type: SQS
                    Properties:
                        Queue: !GetAtt UserNotificationsQueue.Arn
                        BatchSize: 10
            Policies:
                - SQSPollerPolicy:
                      QueueName: !GetAtt UserNotificationsQueue.QueueName
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTable

    # DynamoDB Data Processors
    UserDynamoUpdater:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: ../../lambdas/
            Handler: dynamo-updater/dynamo-updater.handler
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    DYNAMO_TABLES: !Ref ApplicationTable
                    TABLE_NAME: !Ref ApplicationTable
            Events:
                SQSEvent:
                    Type: SQS
                    Properties:
                        Queue: !GetAtt UserDynamoUpdatesQueue.Arn
                        BatchSize: 10
            Policies:
                - SQSPollerPolicy:
                      QueueName: !GetAtt UserDynamoUpdatesQueue.QueueName
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTable
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - dynamo-updater/dynamo-updater.ts

    # User API Endpoints
    UserProfileFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.getProfile
            CodeUri: ../../lambdas/user/profile
            Events:
                UserProfile:
                    Type: Api
                    Properties:
                        RestApiId: !Ref ClerkApi
                        Path: /user/profile
                        Method: get
                        Auth:
                            Authorizer: ClerkAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 128
            Timeout: 30
            Policies:
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTable
            Environment:
                Variables:
                    DYNAMO_TABLES: !Ref ApplicationTable
            Layers:
                - !Ref LayerCommons

    # User Details Function - provides comprehensive user data including wallet balance and transactions
    UserDetailsFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.handler
            CodeUri: ../../lambdas/user/details
            AutoPublishAlias: live # Ensures we can apply provisioned concurrency
            ProvisionedConcurrencyConfig:
                ProvisionedConcurrentExecutions: 1 # Number of instances to keep warm
            Events:
                UserDetails:
                    Type: Api
                    Properties:
                        RestApiId: !Ref ClerkApi
                        Path: /user/details
                        Method: get
                        Auth:
                            Authorizer: ClerkAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 256
            Timeout: 30
            Policies:
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTable
            Environment:
                Variables:
                    DYNAMO_TABLES: !Ref ApplicationTable
                    TABLE_NAME: !Ref ApplicationTable
            Layers:
                - !Ref LayerCommons

        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    UserSearchFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.getEntityProfile
            CodeUri: ../../lambdas/search/
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 1024
            Timeout: 30
            Environment:
                Variables:
                    DYNAMO_TABLES: !Ref ApplicationTable
            Events:
                Api:
                    Type: Api
                    Properties:
                        RestApiId: !Ref ClerkApi
                        Path: /user/search
                        Method: get
                        Auth:
                            Authorizer: ClerkAuthorizer
            Policies:
                - DynamoDBReadPolicy:
                      TableName: !Ref ApplicationTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:Query
                        Resource:
                            - !Sub '${ApplicationTableArn}/index/GSI1'
                            - !Sub '${ApplicationTableArn}/index/GSI2'
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    # Transaction Filtering Functions
    UserTransactionsFilteredFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.getTransactionsHandler
            CodeUri: ../../lambdas/user/transactions
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        RestApiId: !Ref ClerkApi
                        Path: /user/transactions
                        Method: get
                        Auth:
                            Authorizer: ClerkAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 256
            Timeout: 30
            Policies:
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:Query
                        Resource:
                            - !Sub '${ApplicationTableArn}/index/*'
            Environment:
                Variables:
                    DYNAMO_TABLES: !Ref ApplicationTable
                    TABLE_NAME: !Ref ApplicationTable
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    UserTransactionsFiltersFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.getTransactionFiltersHandler
            CodeUri: ../../lambdas/user/transactions
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        RestApiId: !Ref ClerkApi
                        Path: /user/transactions/filters
                        Method: get
                        Auth:
                            Authorizer: ClerkAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 128
            Timeout: 30
            Policies:
                - AWSLambdaBasicExecutionRole
            Environment:
                Variables:
                    DYNAMO_TABLES: !Ref ApplicationTable
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    UserTransactionDetailsFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.getTransactionDetailsHandler
            CodeUri: ../../lambdas/user/transactions
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        RestApiId: !Ref ClerkApi
                        Path: /user/transactions/{transactionId}
                        Method: get
                        Auth:
                            Authorizer: ClerkAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 128
            Timeout: 30
            Policies:
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTable
            Environment:
                Variables:
                    DYNAMO_TABLES: !Ref ApplicationTable
                    TABLE_NAME: !Ref ApplicationTable
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    # Enhanced User Profile Search Function
    UserProfileSearchFunction:
        Type: AWS::Serverless::Function
        Properties:
            Handler: app.handler
            CodeUri: ../../lambdas/user/search
            Events:
                ApiEvent:
                    Type: Api
                    Properties:
                        RestApiId: !Ref ClerkApi
                        Path: /users/search
                        Method: get
                        Auth:
                            Authorizer: ClerkAuthorizer
            Runtime: nodejs18.x
            Architectures:
                - arm64
            MemorySize: 256
            Timeout: 30
            Policies:
                - DynamoDBCrudPolicy:
                      TableName: !Ref ApplicationTable
                - Statement:
                      - Effect: Allow
                        Action:
                            - dynamodb:Query
                        Resource:
                            - !Sub '${ApplicationTableArn}/index/*'
            Environment:
                Variables:
                    DYNAMO_TABLES: !Ref ApplicationTable
                    TABLE_NAME: !Ref ApplicationTable
            Layers:
                - !Ref LayerCommons
        Metadata:
            BuildMethod: esbuild
            BuildProperties:
                External:
                    - commons
                Minify: true
                Target: es2020
                Sourcemap: true
                EntryPoints:
                    - app.ts

    ##################################################################################################################
    # CloudWatch Alarms
    ##################################################################################################################

    # Critical function error alarms
    ClerkWebhookErrorAlarm:
        Type: AWS::CloudWatch::Alarm
        Properties:
            AlarmDescription: !Sub 'Errors detected in ${Environment} ClerkWebhookFunction'
            Namespace: 'AWS/Lambda'
            MetricName: 'Errors'
            Dimensions:
                - Name: FunctionName
                  Value: !Ref ClerkWebhookFunction
            Statistic: Sum
            Period: 60
            EvaluationPeriods: 1
            Threshold: 1
            ComparisonOperator: GreaterThanOrEqualToThreshold
            TreatMissingData: notBreaching
            AlarmActions:
                - !Ref AlarmNotificationTopic
            OKActions:
                - !Ref AlarmNotificationTopic

    UserDynamoUpdaterErrorAlarm:
        Type: AWS::CloudWatch::Alarm
        Properties:
            AlarmDescription: !Sub 'Errors detected in ${Environment} UserDynamoUpdater'
            Namespace: 'AWS/Lambda'
            MetricName: 'Errors'
            Dimensions:
                - Name: FunctionName
                  Value: !Ref UserDynamoUpdater
            Statistic: Sum
            Period: 60
            EvaluationPeriods: 1
            Threshold: 1
            ComparisonOperator: GreaterThanOrEqualToThreshold
            TreatMissingData: notBreaching
            AlarmActions:
                - !Ref AlarmNotificationTopic
            OKActions:
                - !Ref AlarmNotificationTopic

    # DLQ monitoring alarms
    UserNotificationsDLQAlarm:
        Type: AWS::CloudWatch::Alarm
        Properties:
            AlarmDescription: !Sub 'Messages in ${Environment} UserNotificationsDLQ'
            Namespace: 'AWS/SQS'
            MetricName: 'ApproximateNumberOfMessagesVisible'
            Dimensions:
                - Name: QueueName
                  Value: !GetAtt UserNotificationsDLQ.QueueName
            Statistic: Sum
            Period: 300
            EvaluationPeriods: 1
            Threshold: 1
            ComparisonOperator: GreaterThanOrEqualToThreshold
            TreatMissingData: notBreaching
            AlarmActions:
                - !Ref AlarmNotificationTopic
            OKActions:
                - !Ref AlarmNotificationTopic

    UserDynamoUpdatesDLQAlarm:
        Type: AWS::CloudWatch::Alarm
        Properties:
            AlarmDescription: !Sub 'Messages in ${Environment} UserDynamoUpdatesDLQ'
            Namespace: 'AWS/SQS'
            MetricName: 'ApproximateNumberOfMessagesVisible'
            Dimensions:
                - Name: QueueName
                  Value: !GetAtt UserDynamoUpdatesDLQ.QueueName
            Statistic: Sum
            Period: 300
            EvaluationPeriods: 1
            Threshold: 1
            ComparisonOperator: GreaterThanOrEqualToThreshold
            TreatMissingData: notBreaching
            AlarmActions:
                - !Ref AlarmNotificationTopic
            OKActions:
                - !Ref AlarmNotificationTopic

Outputs:
    ClerkApiEndpoint:
        Description: 'API Gateway endpoint URL for Prod stage'
        Value: !Sub 'https://${ClerkApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/'

    ClerkWebhookEndpoint:
        Description: 'Clerk Webhook Endpoint'
        Value: !Ref ClerkWebhookFunction

    UserWebhookTopic:
        Description: 'User Webhook SNS Topic ARN'
        Value: !Ref UserWebhookTopic

    AlarmNotificationTopic:
        Description: 'CloudWatch Alarm SNS Topic ARN'
        Value: !Ref AlarmNotificationTopic
</file>

<file path="iac/database-stack.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: |
    Database stack for the CLKK application

    This template defines two DynamoDB tables:
    1. ApplicationTable - Primary single-table design for all application data
       - Uses a single-table approach with GSIs for efficient access patterns
       - Stores entities (users, businesses), transactions, wallets, etc.
       - See below for GSI descriptions and purposes

Parameters:
    Environment:
        Type: String
        Default: dev
        Description: Deployment Environment

Resources:
    # DynamoDB Single Table Design
    # This table implements a single-table approach where all entities are stored
    # in a single table with appropriate key design for efficient access patterns.
    #
    # Key Structure:
    # - PK: Entity type and ID (e.g., USER#123, BUSINESS#456, TRANSACTION#789)
    # - SK: Context-specific identifier to enable various access patterns
    #
    # GSI Structure with Meaningful Naming:
    # - EntityTypeIndex: For querying by entity type, status, and role
    # - EmailIndex: For email-based lookups
    # - PhoneIndex: For phone number lookups
    # - KYCStatusIndex: For querying entities by KYC status
    # - UsernameIndex: For username-based searches and lookups
    # - TransactionIndex: For transaction lookups
    # - EntityTimeIndex: For entity time-based queries (transactions, history)
    # - ProviderTimeIndex: For provider time-based queries
    # - ExternalIdIndex: For external provider transaction ID lookups
    # - ProviderTransactionIndex: For direct lookup by provider transaction ID
    ApplicationTable:
        Type: AWS::DynamoDB::Table
        DeletionPolicy: Delete
        UpdateReplacePolicy: Delete
        Properties:
            TableName: !Sub clkk-app-table-${Environment}
            BillingMode: PAY_PER_REQUEST
            PointInTimeRecoverySpecification:
                PointInTimeRecoveryEnabled: true
            SSESpecification:
                SSEEnabled: true
            AttributeDefinitions:
                - AttributeName: PK
                  AttributeType: S
                - AttributeName: SK
                  AttributeType: S
                # Meaningful attribute names for entity type and status queries
                - AttributeName: EntityTypeKey
                  AttributeType: S
                - AttributeName: EntityStatusSortKey
                  AttributeType: S
                # Meaningful attribute names for email lookups
                - AttributeName: EmailLookupKey
                  AttributeType: S
                - AttributeName: EmailValue
                  AttributeType: S
                # Meaningful attribute names for KYC status queries
                - AttributeName: KYCStatusKey
                  AttributeType: S
                - AttributeName: EntityTypeIdKey
                  AttributeType: S
                # Meaningful attribute names for phone lookups
                - AttributeName: PhoneLookupKey
                  AttributeType: S
                - AttributeName: PhoneValue
                  AttributeType: S
                # Meaningful attribute names for username lookups
                - AttributeName: UsernameIndexKey
                  AttributeType: S
                - AttributeName: UsernameIndexValue
                  AttributeType: S
                # Meaningful attribute names for transaction lookups
                - AttributeName: TransactionLookupKey
                  AttributeType: S
                - AttributeName: TransactionDetailsKey
                  AttributeType: S
                # Meaningful attribute names for entity time-based queries
                - AttributeName: EntityTimeKey
                  AttributeType: S
                - AttributeName: TimeSortKey
                  AttributeType: S
                # Meaningful attribute names for provider time-based queries
                - AttributeName: ProviderTimeKey
                  AttributeType: S
                - AttributeName: ProviderTimeSortKey
                  AttributeType: S
                # Meaningful attribute names for external ID lookups
                - AttributeName: ExternalIdKey
                  AttributeType: S
                - AttributeName: ProviderIdKey
                  AttributeType: S
                # Meaningful attribute name for provider transaction ID lookup
                - AttributeName: ProviderTransactionIdKey
                  AttributeType: S
                - AttributeName: EntityRoleKey
                  AttributeType: S
                - AttributeName: ReceiverRoleKey
                  AttributeType: S
                - AttributeName: ReceiverTimeSortKey
                  AttributeType: S

            KeySchema:
                - AttributeName: PK
                  KeyType: HASH
                - AttributeName: SK
                  KeyType: RANGE
            GlobalSecondaryIndexes:
                # EntityTypeIndex - Used for querying entities by type, status, and role
                - IndexName: EntityTypeIndex
                  KeySchema:
                      - AttributeName: EntityTypeKey
                        KeyType: HASH
                      - AttributeName: EntityStatusSortKey
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # EmailIndex - Used for email-based lookups
                - IndexName: EmailIndex
                  KeySchema:
                      - AttributeName: EmailLookupKey
                        KeyType: HASH
                      - AttributeName: EmailValue
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # KYCStatusIndex - Used for KYC status queries
                - IndexName: KYCStatusIndex
                  KeySchema:
                      - AttributeName: KYCStatusKey
                        KeyType: HASH
                      - AttributeName: EntityTypeIdKey
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # PhoneIndex - Used for phone number lookups
                - IndexName: PhoneIndex
                  KeySchema:
                      - AttributeName: PhoneLookupKey
                        KeyType: HASH
                      - AttributeName: PhoneValue
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # UsernameIndex - Used for username-based searches and lookups
                - IndexName: UsernameIndex
                  KeySchema:
                      - AttributeName: UsernameIndexKey
                        KeyType: HASH
                      - AttributeName: UsernameIndexValue
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # TransactionIndex - Used for transaction lookups
                - IndexName: TransactionIndex
                  KeySchema:
                      - AttributeName: TransactionLookupKey
                        KeyType: HASH
                      - AttributeName: TransactionDetailsKey
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # EntityTimeIndex - Used for entity time-based queries (transactions, activity history)
                - IndexName: EntityTimeIndex
                  KeySchema:
                      - AttributeName: EntityTimeKey
                        KeyType: HASH
                      - AttributeName: TimeSortKey
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # ProviderTimeIndex - Used for provider time-based queries
                - IndexName: ProviderTimeIndex
                  KeySchema:
                      - AttributeName: ProviderTimeKey
                        KeyType: HASH
                      - AttributeName: ProviderTimeSortKey
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # ExternalIdIndex - Used for external provider transaction ID lookups
                - IndexName: ExternalIdIndex
                  KeySchema:
                      - AttributeName: ExternalIdKey
                        KeyType: HASH
                      - AttributeName: ProviderIdKey
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # ProviderTransactionIndex - Used for direct lookups by provider transaction ID
                - IndexName: ProviderTransactionIndex
                  KeySchema:
                      - AttributeName: ProviderTransactionIdKey
                        KeyType: HASH
                  Projection:
                      ProjectionType: ALL

                # EntityRoleTransactionIndex - Used for unified entity transaction queries (both sender and receiver)
                - IndexName: EntityRoleTransactionIndex
                  KeySchema:
                      - AttributeName: EntityRoleKey
                        KeyType: HASH
                      - AttributeName: TimeSortKey
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                # ReceiverRoleTransactionIndex - Used for receiver-only transaction queries
                - IndexName: ReceiverRoleTransactionIndex
                  KeySchema:
                      - AttributeName: ReceiverRoleKey
                        KeyType: HASH
                      - AttributeName: ReceiverTimeSortKey
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
            StreamSpecification:
                StreamViewType: NEW_AND_OLD_IMAGES

Outputs:
    TableName:
        Description: 'DynamoDB Table Name'
        Value: !Ref ApplicationTable
    TableArn:
        Description: 'DynamoDB Table ARN'
        Value: !GetAtt ApplicationTable.Arn

    TableStreamArn:
        Description: 'DynamoDB Table Stream ARN'
        Value: !GetAtt ApplicationTable.StreamArn
</file>

<file path="lambdas/appsync-authorizer/index.ts">
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'appsync-authorizer' });

/**
 * AppSync Lambda Authorizer
 * This function authorizes requests to the AppSync GraphQL API
 *
 * @param event The authorization event from AppSync
 * @returns Authorization response with isAuthorized and resolverContext
 */
export const handler = async (event: any) => {
    logger.info('Authorizer event received', { event });

    try {
        const { authorizationToken, requestContext } = event;

        // For testing: Log the request details
        logger.info('Auth request details', {
            token: authorizationToken ? `${authorizationToken.substring(0, 10)}...` : 'none',
            apiId: requestContext.apiId,
            operationName: requestContext.operationName || 'none',
        });

        // Extract token
        // Format: "Bearer eyJhbGc..."
        let token = authorizationToken;

        if (token && token.startsWith('Bearer ')) {
            token = token.substring(7);
        }

        // TODO: Implement JWT validation using Clerk
        // For now, we'll authorize all requests for testing

        // Extract userId from path parameters if available
        // This is a naive implementation that assumes the userID is in the variables
        // We'll want to extract this from the JWT in production
        let userId = 'default-user-id';

        if (requestContext.variables && requestContext.variables.userId) {
            userId = requestContext.variables.userId;
        }

        // Return authorization response
        // Eventually we'll verify the token and extract claims
        return {
            isAuthorized: true, // Always authorize for now (testing only)
            resolverContext: {
                userId,
                // Include additional context that will be available in resolvers
                authTime: new Date().toISOString(),
                source: 'appsync-authorizer',
            },
            // Optional: Deny specific fields based on authorization rules
            // deniedFields: [],
            // Optional: Override TTL
            ttlOverride: 300, // 5 minutes
        };
    } catch (error) {
        logger.error('Authorization error', { error });

        // For security, don't expose error details in production
        return {
            isAuthorized: false,
        };
    }
};
</file>

<file path="lambdas/appsync-authorizer/package.json">
{
  "name": "appsync-authorizer",
  "version": "1.0.0",
  "description": "Lambda authorizer for AppSync GraphQL API",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^1.5.1"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.114",
    "@types/node": "^18.15.11",
    "typescript": "^5.0.3"
  }
}
</file>

<file path="lambdas/appsync-authorizer/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "lib": ["es2018", "esnext.asynciterable"],
        "declaration": true,
        "strict": true,
        "noImplicitAny": true,
        "strictNullChecks": true,
        "noImplicitThis": true,
        "alwaysStrict": true,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noImplicitReturns": true,
        "noFallthroughCasesInSwitch": false,
        "inlineSourceMap": true,
        "inlineSources": true,
        "experimentalDecorators": true,
        "strictPropertyInitialization": false,
        "esModuleInterop": true,
        "typeRoots": ["./node_modules/@types"],
        "outDir": "dist"
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/checkbook/config/index.ts">
// Checkbook API Configuration
export const CHECKBOOK_BASE_URLS = {
    PRODUCTION: 'https://api.checkbook.io',
    SANDBOX: 'https://sandbox.checkbook.io',
};

export const CHECKBOOK_ENDPOINTS = {
    USER: '/v3/user',
    CHECK: '/v3/check',
    CARD: '/v3/account/card',
    WEBHOOK: '/v3/webhook',
    // Add other endpoints as needed
};

export const CHECKBOOK_API_URLS = {
    DEMO: {
        BASE: 'https://demo.checkbook.io/v3',
        ENDPOINTS: {
            USER: '/user',
            CHECK: '/check',
            CARD: '/account/card',
            WEBHOOK: '/webhook',
        },
    },
    SANDBOX: {
        BASE: 'https://api.sandbox.checkbook.io/v3',
        ENDPOINTS: {
            USER: '/user',
            CHECK: '/check',
            CARD: '/account/card',
            WEBHOOK: '/webhook',
        },
    },
    PRODUCTION: {
        BASE: 'https://api.checkbook.io/v3',
        ENDPOINTS: {
            USER: '/user',
            CHECK: '/check',
            CARD: '/account/card',
            WEBHOOK: '/webhook',
        },
    },
};
</file>

<file path="lambdas/checkbook/constants/checkbook-keys.ts">
/**
 * Checkbook DynamoDB field names and keys
 * Used to ensure consistency in field names across the codebase
 */
export const CheckbookKeys = {
    // Credentials
    API_KEY: 'checkbookKey',
    API_SECRET: 'checkbookSecret',

    // Entity fields
    ENTITY_ID: 'entityId',
    ENTITY_TYPE: 'entityType',

    // Payment fields
    PAYMENT_ID: 'paymentId',
    PAYMENT_TYPE: 'paymentType',
    PAYMENT_STATUS: 'paymentStatus',
    PAYMENT_AMOUNT: 'paymentAmount',
    RECIPIENT_NAME: 'recipientName',
    RECIPIENT_EMAIL: 'recipientEmail',
    DESCRIPTION: 'description',

    // Card fields
    CARD_ID: 'cardId',
    CARD_LAST_FOUR: 'lastFour',
    CARD_TYPE: 'cardType',
    CARD_EXPIRATION: 'expiration',
    CARD_STATUS: 'cardStatus',

    // Common fields
    CREATED_AT: 'createdAt',
    UPDATED_AT: 'updatedAt',

    // Table names
    PAYMENTS_TABLE: 'checkbook-payments',
    CARDS_TABLE: 'checkbook-cards',
};
</file>

<file path="lambdas/checkbook/services/checkbook-base-service.ts">
import { createLogger } from 'commons';
import { CHECKBOOK_FIELDS } from 'commons';
import axios, { AxiosError } from 'axios';
import { SecretManagerService } from 'commons';
import { KmsService } from 'commons';
import { GetCommand, GetCommandOutput } from '@aws-sdk/lib-dynamodb';
import { docClient } from 'commons';
import { EntityKeys } from 'commons';
import { CHECKBOOK_API_URLS } from '../config';

/**
 * Common base service for all Checkbook API operations.
 */
export abstract class CheckbookBaseService {
    protected logger = createLogger(this.constructor.name);
    protected readonly apiUrl: string;
    protected readonly timeout: number;
    protected secretManager: SecretManagerService;
    protected readonly secretsArn: string;
    protected readonly environment: 'DEMO' | 'SANDBOX' | 'PRODUCTION';
    protected readonly TABLE_NAME = process.env.TABLE_NAME;
    protected kmsService: KmsService;

    /**
     * Initialize the Checkbook Base Service
     * @param environment - Environment (sandbox/production)
     * @param timeout - Timeout for API requests in milliseconds
     */
    constructor(environment: 'DEMO' | 'SANDBOX' | 'PRODUCTION', timeout: number = 30000) {
        this.environment = environment;
        this.apiUrl = CHECKBOOK_API_URLS[environment].BASE;
        this.timeout = timeout;
        this.secretManager = SecretManagerService.getInstance();
        this.secretsArn = process.env.CHECKBOOK_CREDENTIALS_ARN || 'checkbook/credentials';

        // Initialize KMS service for decryption
        const kmsKeyId = process.env.KMS_KEY_ID || '';
        if (!kmsKeyId) {
            this.logger.error('KMS Key ID not provided in environment variables');
            throw new Error('KMS Key ID is required for encryption/decryption operations');
        }

        this.kmsService = new KmsService(kmsKeyId);
    }

    /**
     * Get the Checkbook Funding Source ID
     * @returns Checkbook Funding Source ID
     */
    protected async getCheckbookFundingSourceId(): Promise<string> {
        const secret = await this.secretManager.getSecret<{
            apiKey: string;
            apiSecret: string;
            fundingSourceId: string;
        }>(this.secretsArn);

        return secret.fundingSourceId;
    }

    /**
     * Get API credentials from Secrets Manager
     * @returns API credentials for Checkbook
     */
    protected async getApiCredentials(): Promise<{ apiKey: string; apiSecret: string }> {
        return await this.secretManager.getSecret<{
            apiKey: string;
            apiSecret: string;
        }>(this.secretsArn);
    }

    /**
     * Get user-specific API keys for Checkbook operations
     * @param entityId - User's ID in our system
     * @returns API credentials for user-specific operations
     */
    protected async getUserApiKeys(entityId: string): Promise<{ apiKey: string; apiSecret: string }> {
        this.logger.info('Getting user-specific Checkbook API keys', { entityId });

        try {
            // Get the user's Checkbook data
            const userData = await this.getUserCheckbookData(entityId);
            if (!userData) {
                throw new Error('User does not have a Checkbook account');
            }

            // Ensure the user has API keys
            if (!userData[CHECKBOOK_FIELDS.API_KEY] || !userData[CHECKBOOK_FIELDS.API_SECRET]) {
                throw new Error('User does not have Checkbook API keys configured');
            }

            // Decrypt the API secret
            const apiSecret = await this.kmsService.decryptData(userData[CHECKBOOK_FIELDS.API_SECRET]);
            if (!apiSecret) {
                throw new Error('Failed to decrypt user API secret');
            }

            //log the api key and secret
            this.logger.info('User API keys', {
                apiKey: userData[CHECKBOOK_FIELDS.API_KEY],
                apiSecret: apiSecret,
            });

            return {
                apiKey: userData[CHECKBOOK_FIELDS.API_KEY],
                apiSecret: apiSecret,
            };
        } catch (error) {
            this.logger.error('Error getting user API keys', {
                entityId,
                error: error instanceof Error ? error.message : String(error),
            });
            throw error;
        }
    }

    /**
     * Get user's Checkbook data from DynamoDB
     * @param entityId - User's ID in our system
     * @returns User's Checkbook data or null if not found
     */
    protected async getUserCheckbookData(entityId: string): Promise<any | null> {
        this.logger.info('Getting Checkbook user data', { entityId });

        const params = {
            TableName: this.TABLE_NAME,
            Key: {
                [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                [EntityKeys.ATTR_SK]: CHECKBOOK_FIELDS.USER_DATA_SK,
            },
        };

        try {
            const response = (await docClient.send(new GetCommand(params))) as GetCommandOutput;

            if (!response.Item) {
                this.logger.info('No Checkbook data found for user', { entityId });
                return null;
            }

            this.logger.info('Found Checkbook data for user', { entityId });
            return response.Item;
        } catch (error: unknown) {
            this.logger.error('Error getting Checkbook user data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to retrieve Checkbook user data');
        }
    }

    /**
     * Make a call to the Checkbook API
     * @param method - HTTP method (GET, POST, PUT, DELETE)
     * @param endpoint - API endpoint (without base URL)
     * @param data - Request body data (for POST/PUT)
     * @param entityId - User ID for logging
     * @returns API response data
     */
    protected async callCheckbookApi<T>(
        method: 'get' | 'post' | 'put' | 'delete',
        endpoint: string,
        data?: any,
        entityId?: string,
    ): Promise<T> {
        try {
            // Get API credentials
            const credentials = await this.getApiCredentials();

            // Build full URL
            const url = `${this.apiUrl}${endpoint}`;

            this.logger.info(`Calling Checkbook API ${method.toUpperCase()}`, {
                url,
                entityId,
                requestType: method,
            });

            //lig keys but only first 4 characters
            this.logger.info('API keys', {
                apiKey: credentials.apiKey.slice(0, 4),
                apiSecret: credentials.apiSecret.slice(0, 4),
            });

            // Make API call
            const response = await axios({
                method,
                url,
                data,
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                    Authorization: `${credentials.apiKey}:${credentials.apiSecret}`,
                },
                timeout: this.timeout,
            });

            return response.data;
        } catch (error) {
            this.handleApiError(error, `${method} ${endpoint}`, entityId || 'unknown');
            throw error; // This line will only execute if handleApiError doesn't throw
        }
    }

    /**
     * Make a call to the Checkbook API using user-specific credentials
     * @param method - HTTP method (GET, POST, PUT, DELETE)
     * @param endpoint - API endpoint (without base URL)
     * @param entityId - User ID for API access
     * @param data - Request body data (for POST/PUT)
     * @returns API response data
     */
    protected async callUserCheckbookApi<T>(
        method: 'get' | 'post' | 'put' | 'delete',
        endpoint: string,
        entityId: string,
        data?: any,
    ): Promise<T> {
        try {
            // Get user-specific API credentials
            const credentials = await this.getUserApiKeys(entityId);

            // Build full URL
            const url = `${this.apiUrl}${endpoint}`;

            this.logger.info(`Calling Checkbook API with user credentials: ${method.toUpperCase()}`, {
                url,
                entityId,
                requestType: method,
            });

            //LOG FULL REQUEST
            this.logger.info('Full request to Checkbook API', {
                data,
            });

            //lig keys but only first 4 characters
            this.logger.info('User API keys', {
                apiKey: credentials.apiKey.slice(0, 4),
                apiSecret: credentials.apiSecret.slice(0, 4),
            });

            // Make API call with user credentials
            const response = await axios({
                method,
                url,
                data: data,
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                    Authorization: `${credentials.apiKey}:${credentials.apiSecret}`,
                },
                timeout: this.timeout,
            });

            return response.data;
        } catch (error) {
            this.logger.info('Full response error from Checkbook API', {
                error: error,
            });
            this.handleApiError(error, `${method} ${endpoint}`, entityId);
            throw error; // This line will only execute if handleApiError doesn't throw
        }
    }

    /**
     * Handle API errors for better error messages and logging
     */
    protected handleApiError(error: unknown, operation: string, entityId: string): never {
        if (axios.isAxiosError(error)) {
            const axiosError = error as AxiosError;
            const status = axiosError.response?.status;
            const errorData = axiosError.response?.data;

            // Safe stringify for logging
            const safeErrorData =
                typeof errorData === 'object'
                    ? JSON.stringify(errorData, Object.getOwnPropertyNames(errorData))
                    : String(errorData);

            this.logger.error(`Checkbook API error during ${operation}`, {
                status,
                entityId,
                errorData: safeErrorData,
                errorMessage: axiosError.message,
            });

            throw new Error(`Checkbook API error (${status}): ${axiosError.message}`);
        }

        this.logger.error(`Unknown error during ${operation}`, {
            entityId,
            error: String(error),
        });

        throw new Error(`Unknown error during ${operation}: ${String(error)}`);
    }

    /**
     * Fires a webhook to simulate status updates in sandbox environment
     * This method should ONLY be called in sandbox environments for testing
     *
     * @param checkId - The ID of the check to update
     * @param status - The new status to set ('PAID', 'FAILED', 'VOID', etc.)
     * @param entityId - Optional entity ID for logging purposes
     * @returns The response from the webhook API call
     * @throws Error if not in sandbox environment or if the API call fails
     */
    protected async fireWebhookForSandbox<T>(checkId: string, status: string, entityId?: string): Promise<T> {
        if (this.environment !== 'SANDBOX' && process.env.ENVIRONMENT !== 'dev') {
            const errorMessage = 'Attempted to fire webhook simulation outside of sandbox environment';
            this.logger.error(errorMessage, {
                environment: this.environment,
                appEnvironment: process.env.ENVIRONMENT,
                checkId,
                status,
            });
            throw new Error(errorMessage);
        }

        this.logger.info('Firing webhook for sandbox testing', {
            checkId,
            status,
            entityId: entityId || 'not provided',
        });

        try {
            // Build endpoint for webhook simulation
            // Note: The actual endpoint for webhook simulation may need to be adjusted
            // based on Checkbook's API documentation
            const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.CHECK}/webhook/${checkId}`;

            // Prepare webhook payload
            const webhookPayload = {
                status: status,
                simulation: true,
            };

            // Call API using MASTER credentials
            const response = await this.callCheckbookApi<T>('put', endpoint, webhookPayload, entityId);

            this.logger.info('Successfully simulated webhook', {
                checkId,
                status,
                entityId: entityId || 'not provided',
            });

            return response;
        } catch (error) {
            this.logger.error('Failed to simulate webhook', {
                checkId,
                status,
                entityId: entityId || 'not provided',
                error: error instanceof Error ? error.message : String(error),
            });
            throw error;
        }
    }
}
</file>

<file path="lambdas/checkbook/services/checkbook-card-service.ts">
import { DeleteCommand, GetCommand, GetCommandOutput, PutCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';
import { docClient } from 'commons';
import { EntityKeys } from 'commons';
import { CheckbookBaseService } from './checkbook-base-service';
import { CardResponse, CheckbookCardData, CreateCardRequest, UpdateCardRequest } from '../types/card';
import { CHECKBOOK_API_URLS } from '../config';
import { CHECKBOOK_CARD_SK_PREFIX, CHECKBOOK_FIELDS } from 'commons';
import { CheckbookService } from './checkbook-service';

/**
 * Service class for handling Checkbook Card API operations
 */
export class CheckbookCardService extends CheckbookBaseService {
    private checkbookService: CheckbookService;

    /**
     * Initialize the Checkbook Card Service
     * @param environment - Environment (sandbox/production)
     * @param timeout - Timeout for API requests in milliseconds
     */
    constructor(environment: 'DEMO' | 'SANDBOX' | 'PRODUCTION', timeout: number = 30000) {
        super(environment, timeout);

        // Initialize the Checkbook service for account creation if needed
        this.checkbookService = new CheckbookService({
            apiUrl: CHECKBOOK_API_URLS[environment].BASE,
            timeout: timeout,
            environment: environment,
        });
    }

    /**
     * Ensures a user has a Checkbook account, creating one if needed
     * @param entityId - User's ID in our system
     * @returns User's Checkbook data
     */
    private async ensureCheckbookAccount(entityId: string): Promise<any> {
        // Get the user's Checkbook data to check if they have an account
        let userData = await this.getUserCheckbookData(entityId);

        // If user doesn't have a Checkbook account, create one
        if (!userData) {
            this.logger.info('User does not have a Checkbook account, creating one', { entityId });
            try {
                // Create a Checkbook account for the user
                const createResponse = await this.checkbookService.createUser(entityId);
                this.logger.info('Successfully created Checkbook account for user', {
                    entityId,
                    checkbookId: createResponse.id,
                });

                // Get the updated user data
                userData = await this.getUserCheckbookData(entityId);
                if (!userData) {
                    throw new Error('Failed to retrieve user data after account creation');
                }
            } catch (createError) {
                this.logger.error('Error creating Checkbook account for user', {
                    entityId,
                    error: String(createError),
                });
                throw new Error(`Failed to create Checkbook account: ${String(createError)}`);
            }
        }

        return userData;
    }
    /**
     * Add a new card in Checkbook API
     * @param entityId - User's ID in our system
     * @param cardData - Card data for creation
     * @returns API response with the created card
     */
    async addCard(entityId: string, cardData: CreateCardRequest): Promise<CardResponse> {
        this.logger.info('Adding card in Checkbook', { entityId });

        try {
            // Ensure user has a Checkbook account, creating one if needed
            await this.ensureCheckbookAccount(entityId);

            // Check if user already has cards - MUST delete them all first
            const existingCards = await this.getAllCardData(entityId);

            // Log existing cards for debugging
            this.logger.info('Existing cards check', {
                entityId,
                existingCardCount: existingCards.length,
                cardIds: existingCards.map((card) => card.cardId),
            });

            // Delete ALL existing cards before adding a new one
            if (existingCards.length > 0) {
                this.logger.info('User already has cards, removing all existing cards first', {
                    entityId,
                    existingCardCount: existingCards.length,
                });

                // First remove cards from DynamoDB
                const deletePromises = existingCards.map((card) => {
                    return this.deleteCardData(entityId, card.cardId).catch((err) => {
                        this.logger.error('Failed to delete card from DynamoDB', {
                            entityId,
                            cardId: card.cardId,
                            error: String(err),
                        });
                    });
                });

                // Wait for all deletions to complete
                await Promise.all(deletePromises);

                // Now try to delete from API (but continue even if this fails)
                for (const card of existingCards) {
                    try {
                        const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.CARD}/${card.cardId}`;
                        await this.callUserCheckbookApi<any>('delete', endpoint, entityId, undefined);
                        this.logger.info('Successfully removed card from API', { entityId, cardId: card.cardId });
                    } catch (apiError) {
                        // Just log the error but continue with new card creation
                        this.logger.warn('Error removing card from API (continuing anyway)', {
                            entityId,
                            cardId: card.cardId,
                            error: String(apiError),
                        });
                    }
                }

                // Verify cards were removed
                const remainingCards = await this.getAllCardData(entityId);
                if (remainingCards.length > 0) {
                    this.logger.warn('Some cards could not be deleted, forcing deletion again', {
                        entityId,
                        remainingCount: remainingCards.length,
                        cardIds: remainingCards.map((card) => card.cardId),
                    });

                    // Force delete any remaining cards in DB with stronger error handling
                    for (const card of remainingCards) {
                        try {
                            const params = {
                                TableName: this.TABLE_NAME,
                                Key: {
                                    [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                                    [EntityKeys.ATTR_SK]: `${CHECKBOOK_CARD_SK_PREFIX}${card.cardId}`,
                                },
                            };
                            await docClient.send(new DeleteCommand(params));
                        } catch (finalDeleteError) {
                            this.logger.error('Critical error - failed final deletion attempt', {
                                entityId,
                                cardId: card.cardId,
                                error: String(finalDeleteError),
                            });
                        }
                    }
                }
            }

            // Call API to create the card using user-specific credentials
            const endpoint = CHECKBOOK_API_URLS[this.environment].ENDPOINTS.CARD;
            const response = await this.callUserCheckbookApi<CardResponse>('post', endpoint, entityId, cardData);

            this.logger.info('Successfully added card in Checkbook', {
                entityId,
                cardId: response.id,
                cardNumber: response.card_number,
                expirationDate: response.expiration_date,
                isDefault: response.default,
                name: response.name,
            });

            // Store the card data in DynamoDB
            await this.storeCardData(entityId, response);

            return response;
        } catch (error: unknown) {
            // Log and re-throw the error
            this.logger.error('Error adding card in Checkbook', {
                entityId,
                error: String(error),
            });
            throw error;
        }
    }

    /**
     * Get all cards for a user from Checkbook API
     * @param entityId - User's ID in our system
     * @returns List of user's cards
     */
    async getCards(entityId: string): Promise<CardResponse[]> {
        this.logger.info('Getting cards from Checkbook', { entityId });

        try {
            // Ensure user has a Checkbook account, creating one if needed
            await this.ensureCheckbookAccount(entityId);

            // Call API to get all cards using user-specific credentials
            const endpoint = CHECKBOOK_API_URLS[this.environment].ENDPOINTS.CARD;
            const response = await this.callUserCheckbookApi<{ cards: CardResponse[] }>(
                'get',
                endpoint,
                entityId,
                undefined,
            );

            this.logger.info('Successfully retrieved cards from Checkbook', {
                entityId,
                cardCount: response.cards.length,
            });

            return response.cards;
        } catch (error: unknown) {
            // Log and re-throw the error
            this.logger.error('Error getting cards from Checkbook', {
                entityId,
                error: String(error),
            });
            throw error;
        }
    }

    /**
     * Update a card in Checkbook API
     * @param entityId - User's ID in our system
     * @param cardId - Card ID to update
     * @param updateData - Card data to update
     * @returns Success message
     */
    async updateCard(entityId: string, cardId: string, updateData: UpdateCardRequest): Promise<any> {
        this.logger.info('Updating card in Checkbook', { entityId, cardId });

        try {
            // Ensure user has a Checkbook account, creating one if needed
            await this.ensureCheckbookAccount(entityId);

            // Check if the card exists and belongs to the user
            const cardData = await this.getCardData(entityId, cardId);
            if (!cardData) {
                throw new Error('Card not found or does not belong to the user');
            }

            // Call API to update the card using user-specific credentials
            const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.CARD}/${cardId}`;
            const response = await this.callUserCheckbookApi<any>('put', endpoint, entityId, updateData);

            this.logger.info('Successfully updated card in Checkbook', {
                entityId,
                cardId,
            });

            // Update the card data in DynamoDB
            await this.updateCardData(entityId, cardId, updateData);

            return response;
        } catch (error: unknown) {
            // Log and re-throw the error
            this.logger.error('Error updating card in Checkbook', {
                entityId,
                cardId,
                error: String(error),
            });
            throw error;
        }
    }

    /**
     * Remove a card from Checkbook API
     * @param entityId - User's ID in our system
     * @param cardId - Card ID to remove
     * @returns Success message
     */
    async removeCard(entityId: string, cardId: string): Promise<any> {
        this.logger.info('Removing card from Checkbook', { entityId, cardId });

        try {
            // Ensure user has a Checkbook account, creating one if needed
            await this.ensureCheckbookAccount(entityId);

            // Check if the card exists and belongs to the user
            const cardData = await this.getCardData(entityId, cardId);
            if (!cardData) {
                throw new Error('Card not found or does not belong to the user');
            }

            // Call API to delete the card using user-specific credentials
            const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.CARD}/${cardId}`;
            const response = await this.callUserCheckbookApi<any>('delete', endpoint, entityId, undefined);

            this.logger.info('Successfully removed card from Checkbook', {
                entityId,
                cardId,
            });

            // Delete the card data from DynamoDB
            await this.deleteCardData(entityId, cardId);

            return response;
        } catch (error: unknown) {
            // Log and re-throw the error
            this.logger.error('Error removing card from Checkbook', {
                entityId,
                cardId,
                error: String(error),
            });
            throw error;
        }
    }

    /**
     * Store card data in DynamoDB
     * @param entityId - User's ID in our system
     * @param cardData - Card data from Checkbook API
     */
    private async storeCardData(entityId: string, cardData: CardResponse): Promise<void> {
        this.logger.info('Storing card data', {
            entityId,
            cardId: cardData.id,
            rawCardData: JSON.stringify(cardData),
        });

        const now = new Date().toISOString();

        // Use the date from the API response for consistency
        // If expiration_date is missing, use an appropriate date value
        const expirationDate = cardData.expiration_date || cardData.date || now;

        const params = {
            TableName: this.TABLE_NAME,
            Item: {
                [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                [EntityKeys.ATTR_SK]: `${CHECKBOOK_CARD_SK_PREFIX}${cardData.id}`,
                [EntityKeys.FIELD_ID]: entityId,
                [CHECKBOOK_FIELDS.CARD_ID]: cardData.id,
                [CHECKBOOK_FIELDS.CARD_NUMBER]: cardData.card_number,
                [CHECKBOOK_FIELDS.EXPIRATION_DATE]: expirationDate,
                [CHECKBOOK_FIELDS.IS_DEFAULT]: cardData.default,
                [CHECKBOOK_FIELDS.LAST_FOUR_DIGITS]: cardData.card_number.slice(-4),
                name: cardData.name || undefined,
                [EntityKeys.FIELD_CREATED_AT]: cardData.date || now,
                [EntityKeys.FIELD_UPDATED_AT]: now,
            },
        };

        try {
            await docClient.send(new PutCommand(params));
            this.logger.info('Successfully stored card data', { entityId, cardId: cardData.id });
        } catch (error: unknown) {
            this.logger.error('Error storing card data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to store card data');
        }
    }

    /**
     * Get card data from DynamoDB
     * @param entityId - User's ID in our system
     * @param cardId - Card ID to retrieve
     * @returns Card data or null if not found
     */
    private async getCardData(entityId: string, cardId: string): Promise<CheckbookCardData | null> {
        this.logger.info('Getting card data', { entityId, cardId });

        const params = {
            TableName: this.TABLE_NAME,
            Key: {
                [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                [EntityKeys.ATTR_SK]: `${CHECKBOOK_CARD_SK_PREFIX}${cardId}`,
            },
        };

        try {
            const response = (await docClient.send(new GetCommand(params))) as GetCommandOutput;

            if (!response.Item) {
                this.logger.info('No card data found', { entityId, cardId });
                return null;
            }

            this.logger.info('Found card data', { entityId, cardId });
            return response.Item as unknown as CheckbookCardData;
        } catch (error: unknown) {
            this.logger.error('Error getting card data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to retrieve card data');
        }
    }

    /**
     * Update card data in DynamoDB
     * @param entityId - User's ID in our system
     * @param cardId - Card ID to update
     * @param updateData - Card data to update
     */
    private async updateCardData(entityId: string, cardId: string, updateData: UpdateCardRequest): Promise<void> {
        this.logger.info('Updating card data', { entityId, cardId });

        try {
            // Get existing card data
            const existingCardData = await this.getCardData(entityId, cardId);
            if (!existingCardData) {
                throw new Error('Card data not found');
            }

            // Prepare update data
            const now = new Date().toISOString();
            const params = {
                TableName: this.TABLE_NAME,
                Item: {
                    [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                    [EntityKeys.ATTR_SK]: `${CHECKBOOK_CARD_SK_PREFIX}${cardId}`,
                    [EntityKeys.FIELD_ID]: entityId,
                    [CHECKBOOK_FIELDS.CARD_ID]: cardId,
                    [CHECKBOOK_FIELDS.CARD_NUMBER]: existingCardData.cardNumber,
                    [CHECKBOOK_FIELDS.EXPIRATION_DATE]: existingCardData.expirationDate,
                    [CHECKBOOK_FIELDS.IS_DEFAULT]:
                        updateData.default !== undefined ? updateData.default : existingCardData.isDefault,
                    name: updateData.name !== undefined ? updateData.name : existingCardData.name,
                    [EntityKeys.FIELD_CREATED_AT]: existingCardData.createdAt,
                    [EntityKeys.FIELD_UPDATED_AT]: now,
                },
            };

            await docClient.send(new PutCommand(params));
            this.logger.info('Successfully updated card data', { entityId, cardId });
        } catch (error: unknown) {
            this.logger.error('Error updating card data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to update card data');
        }
    }

    /**
     * Delete card data from DynamoDB
     * @param entityId - User's ID in our system
     * @param cardId - Card ID to delete
     */
    private async deleteCardData(entityId: string, cardId: string): Promise<void> {
        this.logger.info('Deleting card data', { entityId, cardId });

        const params = {
            TableName: this.TABLE_NAME,
            Key: {
                [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                [EntityKeys.ATTR_SK]: `${CHECKBOOK_CARD_SK_PREFIX}${cardId}`,
            },
        };

        try {
            await docClient.send(new DeleteCommand(params));
            this.logger.info('Successfully deleted card data', { entityId, cardId });
        } catch (error: unknown) {
            this.logger.error('Error deleting card data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to delete card data');
        }
    }

    /**
     * Get all cards for a user from DynamoDB
     * @param entityId - User's ID in our system
     * @returns List of user's cards
     */
    async getAllCardData(entityId: string): Promise<CheckbookCardData[]> {
        this.logger.info('Getting all card data from database', { entityId });

        const params = {
            TableName: this.TABLE_NAME,
            KeyConditionExpression: '#pk = :pk AND begins_with(#sk, :sk_prefix)',
            ExpressionAttributeNames: {
                '#pk': EntityKeys.ATTR_PK,
                '#sk': EntityKeys.ATTR_SK,
            },
            ExpressionAttributeValues: {
                ':pk': `${EntityKeys.USER_PREFIX}${entityId}`,
                ':sk_prefix': CHECKBOOK_CARD_SK_PREFIX,
            },
        };

        try {
            const response = await docClient.send(new QueryCommand(params));
            const items = response.Items || [];

            this.logger.info('Found card data', { entityId, count: items.length });
            return items as unknown as CheckbookCardData[];
        } catch (error: unknown) {
            this.logger.error('Error getting all card data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to retrieve all card data');
        }
    }
}
</file>

<file path="lambdas/checkbook/services/checkbook-payment-service.ts">
import { CHECKBOOK_API_URLS } from '../config';
import {
    CheckbookPaymentData,
    CreateDigitalCheckRequest,
    DigitalCheckResponse,
    GetPaymentResponse,
    PaymentResponse,
    DepositOptionValue,
    WithdrawalCheckResponse,
} from '../types/payment';
import { CheckbookBaseService } from './checkbook-base-service';
import { Transaction, TransactionStatus, TransactionType } from 'commons';
import { Entity, getEntity } from 'commons';
import { DeleteCommand, GetCommand, GetCommandOutput, PutCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';
import { docClient } from 'commons';
import { EntityKeys } from 'commons';
import { CHECKBOOK_PAYMENT_SK_PREFIX, CHECKBOOK_FIELDS, CHECKBOOK_CARD_SK_PREFIX } from 'commons';
import { v4 as uuidv4 } from 'uuid';
import { WalletService, getWallet } from 'commons';
import { Money } from 'commons';
import { ProviderName, ProviderType, PROVIDER_CONSTANTS } from 'commons';
import { Revenue, RevenueType, calculateAndRecordFee } from 'commons';
import { EntityTypeString } from 'commons';

/**
 * Service class for handling Checkbook payment operations
 */
export class CheckbookPaymentService extends CheckbookBaseService {
    /**
     * Create a digital check payment
     * @param entityId - User's ID in our system
     * @param request - Digital check request data
     * @returns Digital check response from Checkbook API
     */
    async createDigitalCheck(entityId: string, request: CreateDigitalCheckRequest): Promise<WithdrawalCheckResponse> {
        this.logger.info('Creating digital check payment', {
            entityId,
            amount: request.amount,
            recipientId: request.recipientId,
            transactionType: request.transactionType || 'withdrawal',
        });

        try {
            // 1. Verify the sender has a Checkbook account
            const senderData = await this.getUserCheckbookData(entityId);
            if (!senderData) {
                throw new Error('Sender does not have a Checkbook account');
            }

            // 2. Get sender entity from database
            const senderEntity = await getEntity(entityId, 'USER');
            if (!senderEntity) {
                throw new Error('Sender entity not found');
            }

            // 3. Get recipient entity from database
            const recipientEntity = await getEntity(request.recipientId, 'USER');
            if (!recipientEntity) {
                throw new Error('Recipient not found');
            }

            // 4. Verify recipient has a Checkbook account with cards
            const recipientCheckbookData = await this.getUserCheckbookData(request.recipientId);
            if (!recipientCheckbookData) {
                throw new Error('Recipient does not have a Checkbook account');
            }

            // 5. Get the sender's wallet to verify sufficient funds
            const senderWallet = await getWallet(entityId, 'USER');
            if (!senderWallet) {
                throw new Error('Sender does not have a wallet');
            }

            // Map request transaction type to our internal TransactionType enum
            const transactionType = this.mapRequestTransactionType(request.transactionType);

            this.logger.info('Transaction type', {
                requestType: request.transactionType,
                mappedType: transactionType,
            });

            // 6. Calculate withdrawal fee (1.5%)
            const withdrawalAmount = new Money(request.amount, 'USD');
            const feePercentage = PROVIDER_CONSTANTS.WITHDRAWAL_FEE_PERCENTAGE;
            const feeAmount = withdrawalAmount.percentage(feePercentage);

            //LOG FEE AMOUNT
            this.logger.info('Fee amount', { feeAmount: feeAmount.toString() });

            // 7. Calculate check amount (withdrawal - fee)
            const checkAmount = withdrawalAmount.subtract(feeAmount);

            //LOG CHECK AMOUNT
            this.logger.info('Check amount (after fee deduction)', { checkAmount: checkAmount.toString() });

            // 8. Check if sender has sufficient funds
            if (!senderWallet.hasSufficientFunds(withdrawalAmount)) {
                throw new Error(
                    `Insufficient funds. Required: ${withdrawalAmount.toString()}, Available: ${senderWallet
                        .getAvailableBalance()
                        .toString()}`,
                );
            }

            // 9. Get recipient's cards to find the default one for auto-deposit
            const recipientCards = await this.getUserCheckbookCards(request.recipientId);
            const defaultCard = recipientCards.find((card) => card.isDefault) || recipientCards[0];

            // 10. Build full request object for Checkbook API
            const fullRequest = {
                account: await this.getCheckbookFundingSourceId(),
                amount: checkAmount.getNumericAmount(),
                name: recipientEntity.fullName || request.recipientId,
                recipient: request.recipientId,
                description: request.description || 'withdrawal',
            };

            //LOG FULL REQUEST
            this.logger.info('Full request to Checkbook API', { fullRequest });

            // 11. Build endpoint for digital check
            const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.CHECK}/digital`;

            // 12. Call API using MASTER credentials (not user-specific) to create the payment
            const response = await this.callCheckbookApi<DigitalCheckResponse>('post', endpoint, fullRequest, entityId);

            //LOG FULL RESPONSE
            this.logger.info('Full response from Checkbook API AFTER creating digital check', { response });

            this.logger.info('Successfully created digital check', {
                entityId,
                checkId: response.id,
                status: response.status,
            });

            // 13. Generate a unique transaction ID for our system
            const transactionId = uuidv4();

            // 14. Deduct the withdrawal amount from the sender's wallet
            await WalletService.withdraw(entityId, 'USER', withdrawalAmount, transactionId, 'USD');

            // 15. Record the fee as revenue
            const { fee, revenue } = await calculateAndRecordFee(transactionId, withdrawalAmount, entityId, 'USER', {
                type: RevenueType.WITHDRAWAL_FEE,
                feePercentage,
                providerName: ProviderName.CHECKBOOK,
                providerType: ProviderType.WITHDRAWAL_PROVIDER,
                providerTransactionId: response.id,
                description: `${feePercentage}% withdrawal fee for Checkbook payment`,
            });

            this.logger.info('Recorded withdrawal fee', {
                transactionId,
                amount: withdrawalAmount.toString(),
                feeAmount: fee.toString(),
                revenueId: revenue.revenueId,
            });

            // 16. Create a withdrawal transaction in our system
            await this.createWithdrawalTransaction(
                entityId,
                response,
                fullRequest,
                transactionId,
                feeAmount.toString(),
                transactionType,
            );

            // 17. In sandbox environment, simulate a webhook to update check status
            if (this.environment === 'SANDBOX' || process.env.ENVIRONMENT === 'dev') {
                try {
                    // Wait a short time before simulating webhook to mimic real-world timing
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    await this.simulateCheckStatusWebhook(
                        response.id,
                        'PAID', // Simulate successful payment
                        entityId,
                    );

                    this.logger.info('Successfully simulated webhook for check status update', {
                        entityId,
                        checkId: response.id,
                        status: 'PAID',
                    });
                } catch (webhookError) {
                    // Log but don't fail the original operation
                    this.logger.error('Error simulating webhook', {
                        entityId,
                        checkId: response.id,
                        error: webhookError instanceof Error ? webhookError.message : String(webhookError),
                    });
                }
            }

            //Build custom response

            const checkResponse: WithdrawalCheckResponse = {
                checkId: response.id,
                status: response.status,
                amount: response.amount,
                transactionId: transactionId,
                feeAmount: feeAmount.toString(),
                totalWithdrawalAmount: withdrawalAmount.toString(), // Total amount withdrawn from wallet
                amountAfterFees: checkAmount.toString(), // Amount sent as check (after fee deduction)
            };

            return checkResponse;
        } catch (error) {
            // Base class handleApiError already handles API errors
            if (error instanceof Error) {
                throw error;
            }

            throw new Error(`Unknown error creating digital check: ${String(error)}`);
        }
    }

    /**
     * Checks if we should auto-deposit checks based on environment
     * @returns True if auto-deposit should be performed
     * @deprecated This functionality has been removed
     */
    private shouldAutoDeposit(): boolean {
        return false; // Functionality removed
    }

    /**
     * Get recipient information and verify they have a Checkbook account with cards
     * @param recipient - The recipient from the request (could be string email/ID or object)
     * @returns Recipient Checkbook info including their entity ID and default card ID (if found)
     */
    private async getRecipientCheckbookInfo(
        recipient: string | any,
    ): Promise<{ entityId: string; defaultCardId?: string } | null> {
        try {
            let recipientId: string | null = null;

            // Extract recipient ID based on recipient type
            if (typeof recipient === 'string') {
                // If recipient is an email or phone number, try to find the entity
                if (recipient.includes('@')) {
                    const entity = await Entity.getByEmail(recipient);
                    recipientId = entity?.id || null;
                } else {
                    const entity = await Entity.getByPhoneNumber(recipient);
                    recipientId = entity?.id || null;
                }
            } else if (recipient.email) {
                // If recipient has email property, try to find the entity
                const entity = await Entity.getByEmail(recipient.email);
                recipientId = entity?.id || null;
            }

            // If we couldn't identify the recipient, return null
            if (!recipientId) {
                this.logger.warn('Could not identify recipient entity', { recipient });
                return null;
            }

            // Verify recipient has a Checkbook account
            const recipientData = await this.getUserCheckbookData(recipientId);
            if (!recipientData) {
                this.logger.warn('Recipient does not have a Checkbook account', { recipientId });
                return null;
            }

            // Get recipient's cards to find the default one
            const recipientCards = await this.getUserCheckbookCards(recipientId);
            if (!recipientCards || recipientCards.length === 0) {
                this.logger.warn('Recipient does not have any Checkbook cards', { recipientId });
                return { entityId: recipientId }; // Return recipient info without card ID
            }

            // Find default card or use the first one
            const defaultCard = recipientCards.find((card) => card.isDefault) || recipientCards[0];

            return {
                entityId: recipientId,
                defaultCardId: defaultCard.cardId,
            };
        } catch (error) {
            this.logger.error('Error getting recipient Checkbook info', {
                error: error instanceof Error ? error.message : String(error),
                stack: error instanceof Error ? error.stack : undefined,
            });
            return null;
        }
    }

    /**
     * Get all cards for a user from DynamoDB
     * @param entityId - User's ID in our system
     * @returns List of user's cards or empty array if none found
     */
    private async getUserCheckbookCards(entityId: string): Promise<{ cardId: string; isDefault: boolean }[]> {
        this.logger.info('Getting user Checkbook cards', { entityId });

        const params = {
            TableName: this.TABLE_NAME,
            KeyConditionExpression: '#pk = :pk AND begins_with(#sk, :sk_prefix)',
            ExpressionAttributeNames: {
                '#pk': EntityKeys.ATTR_PK,
                '#sk': EntityKeys.ATTR_SK,
            },
            ExpressionAttributeValues: {
                ':pk': `${EntityKeys.USER_PREFIX}${entityId}`,
                ':sk_prefix': CHECKBOOK_CARD_SK_PREFIX,
            },
        };

        try {
            const response = await docClient.send(new QueryCommand(params));
            const items = response.Items || [];

            this.logger.info('Found card data', { entityId, count: items.length });

            // Map to a simpler structure with just the card ID and default status
            return items.map((item: Record<string, any>) => ({
                cardId: item[CHECKBOOK_FIELDS.CARD_ID],
                isDefault: item[CHECKBOOK_FIELDS.IS_DEFAULT] || false,
            }));
        } catch (error) {
            this.logger.error('Error getting user Checkbook cards', {
                entityId,
                error: error instanceof Error ? error.message : String(error),
            });
            return [];
        }
    }

    /**
     * Deposit a payment to a specified account
     * @param entityId - User's ID in our system (RECIPIENT's ID, not sender)
     * @param checkId - ID of the check to deposit
     * @param accountId - ID of the account to deposit the payment to
     * @returns Digital check response from Checkbook API
     */
    async depositPayment(entityId: string, checkId: string, accountId: string): Promise<DigitalCheckResponse> {
        this.logger.info('Depositing payment', {
            entityId,
            checkId,
            accountId,
        });

        try {
            // Verify the recipient has a Checkbook account
            const userData = await this.getUserCheckbookData(entityId);
            if (!userData) {
                throw new Error('Recipient does not have a Checkbook account');
            }

            // Build endpoint for deposit check
            const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.CHECK}/deposit/${checkId}`;

            // Call API using RECIPIENT'S credentials (not sender)
            const response = await this.callUserCheckbookApi<DigitalCheckResponse>('post', endpoint, entityId, {
                account: accountId,
            });

            //LOG FULL RESPONSE
            this.logger.info('Full response from Checkbook API AFTER auto-depositing check', { response });

            this.logger.info('Successfully deposited payment', {
                entityId,
                checkId: response.id,
                status: response.status,
            });

            // Update the transaction with deposit status
            await this.updateTransactionAfterDeposit(entityId, response);

            return response;
        } catch (error) {
            // Base class handleApiError already handles API errors
            if (error instanceof Error) {
                throw error;
            }

            throw new Error(`Unknown error depositing payment: ${String(error)}`);
        }
    }

    /**
     * Get payment details by ID
     * @param entityId - User's ID in our system
     * @param checkId - ID of the check to retrieve
     * @returns Payment details from Checkbook API
     */
    async getPayment(entityId: string, checkId: string): Promise<GetPaymentResponse> {
        this.logger.info('Retrieving payment details', {
            entityId,
            checkId,
        });

        try {
            // Verify the user has a Checkbook account
            const userData = await this.getUserCheckbookData(entityId);
            if (!userData) {
                throw new Error('User does not have a Checkbook account');
            }

            // Build endpoint for get payment
            const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.CHECK}/${checkId}`;

            // Call API using user-specific credentials
            const response = await this.callUserCheckbookApi<GetPaymentResponse>('get', endpoint, entityId, undefined);

            this.logger.info('Successfully retrieved payment details', {
                entityId,
                checkId: response.id,
                status: response.status,
            });

            return response;
        } catch (error) {
            // Base class handleApiError already handles API errors
            if (error instanceof Error) {
                throw error;
            }

            throw new Error(`Unknown error retrieving payment: ${String(error)}`);
        }
    }

    /**
     * Creates a withdrawal transaction in our system after creating a digital check
     * @param entityId - User's ID in our system
     * @param response - Response from Checkbook API
     * @param request - Original request sent to Checkbook API
     * @param transactionId - Optional transaction ID (will generate if not provided)
     * @param feeAmount - Fee amount charged for the withdrawal
     * @param transactionType - Transaction type for the withdrawal
     * @returns The created transaction
     */
    private async createWithdrawalTransaction(
        entityId: string,
        response: DigitalCheckResponse,
        request: any,
        transactionId?: string,
        feeAmount?: string,
        transactionType: TransactionType = TransactionType.WITHDRAWAL,
    ): Promise<Transaction> {
        this.logger.info('Creating withdrawal transaction for digital check', {
            entityId,
            checkbookId: response.id,
            amount: response.amount,
            feeAmount: feeAmount || '0.00',
        });

        try {
            // Get sender entity details from our database
            const senderEntity = await getEntity(entityId, 'USER');
            if (!senderEntity) {
                this.logger.warn('Sender entity not found, proceeding with limited information', { entityId });
            }

            // Extract recipient information
            let recipientId = '';
            let recipientType: 'USER' | 'BUSINESS' = 'USER';
            let recipientName = '';
            let recipientEntity = null;

            // If recipient is an entity ID in our system
            recipientId = typeof request.recipient === 'string' ? request.recipient : request.recipientId;

            // Use entityType from request if provided, otherwise default to USER
            recipientType = request.entityType || 'USER';

            try {
                recipientEntity = await getEntity(recipientId, 'USER');
                if (recipientEntity) {
                    recipientName = recipientEntity.fullName;
                    // Only override the recipient type if we found an entity and don't have an explicit type in the request
                    if (!request.entityType) {
                        recipientType = recipientEntity.type;
                    }
                }
            } catch (error) {
                this.logger.warn('Error finding recipient entity', {
                    error,
                    recipientId,
                });
            }

            // Determine transaction status based on Checkbook payment status
            let transactionStatus: TransactionStatus;
            switch (response.status) {
                case 'PAID':
                    transactionStatus = TransactionStatus.COMPLETED;
                    break;
                case 'FAILED':
                    transactionStatus = TransactionStatus.FAILED;
                    break;
                case 'VOID':
                    transactionStatus = TransactionStatus.CANCELLED;
                    break;
                default:
                    transactionStatus = TransactionStatus.PENDING;
            }

            // Calculate the total withdrawal amount (check amount + fee)
            const checkAmount = new Money(response.amount, 'USD');
            const fee = new Money(feeAmount || '0.00', 'USD');
            const totalWithdrawalAmount = checkAmount.add(fee);

            // Build rich metadata
            const metadata = {
                description: request.description || 'Digital check payment',
                checkbookPaymentId: response.id,
                checkbookStatus: response.status,
                checkNumber: response.number,
                feeAmount: fee.toString(),
                feePercentage: PROVIDER_CONSTANTS.WITHDRAWAL_FEE_PERCENTAGE.toString(),
                amountAfterFees: checkAmount.toString(), // Amount after fees (what the recipient gets)
                totalAmount: totalWithdrawalAmount.toString(), // Total withdrawal amount (what user paid)
                senderName: senderEntity ? senderEntity.fullName : undefined,
                senderEmail: senderEntity ? senderEntity.email : undefined,
                recipientName,
                recipientId,
                image_uri: response.image_uri,
            };

            // Create the transaction with the total withdrawal amount
            // (This shows the user what they actually withdrew from their account)
            const transaction = new Transaction(
                transactionType,
                totalWithdrawalAmount.toString(),
                'USD',
                transactionStatus,
                {
                    transactionId: transactionId,
                    receiver: {
                        id: recipientId,
                        type: recipientType,
                        name: recipientName,
                    },
                    providerType: 'WITHDRAWAL_PROVIDER',
                    providerId: 'CHECKBOOK',
                    providerTransactionId: response.id,
                    metadata,
                },
            );

            // Save the transaction
            await transaction.create();

            this.logger.info('Successfully created withdrawal transaction', {
                entityId,
                checkbookId: response.id,
                transactionId: transaction.transactionId,
                status: transaction.status,
                totalAmount: totalWithdrawalAmount.toString(),
                amountAfterFees: checkAmount.toString(),
                feeAmount: fee.toString(),
            });

            return transaction;
        } catch (error) {
            this.logger.error('Error creating withdrawal transaction', {
                entityId,
                checkbookId: response.id,
                error: error instanceof Error ? error.message : String(error),
                stack: error instanceof Error ? error.stack : undefined,
            });

            // We don't want to fail the main operation if transaction creation fails
            // Just log the error and continue
            return null as unknown as Transaction;
        }
    }

    /**
     * Updates an existing transaction after a payment has been deposited
     * @param entityId - User's ID in our system
     * @param response - Response from Checkbook API after deposit
     */
    private async updateTransactionAfterDeposit(entityId: string, response: DigitalCheckResponse): Promise<void> {
        this.logger.info('Updating transaction after deposit', {
            entityId,
            checkbookId: response.id,
        });

        try {
            // Find transactions with this provider transaction ID
            const transactions = await Transaction.getByProviderTransactionId(response.id);

            if (!transactions || transactions.length === 0) {
                this.logger.warn('No transaction found for Checkbook payment ID', {
                    entityId,
                    checkbookId: response.id,
                });
                return;
            }

            // Update each transaction (typically should be just one)
            for (const transaction of transactions) {
                // Update status based on the response
                let newStatus: TransactionStatus;
                switch (response.status) {
                    case 'PAID':
                        newStatus = TransactionStatus.COMPLETED;
                        break;
                    case 'FAILED':
                        newStatus = TransactionStatus.FAILED;
                        break;
                    case 'VOID':
                        newStatus = TransactionStatus.CANCELLED;
                        break;
                    default:
                        newStatus = TransactionStatus.PENDING;
                }

                // Only update if status has changed
                if (transaction.status !== newStatus) {
                    transaction.status = newStatus;

                    // Add deposit information to metadata
                    if (!transaction.metadata) {
                        transaction.metadata = {};
                    }

                    transaction.metadata.depositedAt = new Date().toISOString();
                    transaction.metadata.checkbookStatus = response.status;

                    // Complete the transaction if appropriate
                    if (newStatus === TransactionStatus.COMPLETED) {
                        await transaction.complete();
                    } else if (newStatus === TransactionStatus.FAILED) {
                        await transaction.fail('Payment deposit failed');
                    } else {
                        await transaction.update();
                    }

                    this.logger.info('Successfully updated transaction after deposit', {
                        entityId,
                        checkbookId: response.id,
                        transactionId: transaction.transactionId,
                        newStatus: newStatus,
                    });
                } else {
                    this.logger.info('Transaction status unchanged, no update needed', {
                        entityId,
                        checkbookId: response.id,
                        transactionId: transaction.transactionId,
                        status: transaction.status,
                    });
                }
            }
        } catch (error) {
            this.logger.error('Error updating transaction after deposit', {
                entityId,
                checkbookId: response.id,
                error: error instanceof Error ? error.message : String(error),
                stack: error instanceof Error ? error.stack : undefined,
            });

            // Don't throw the error, just log it
            // We don't want to fail the deposit operation if transaction update fails
        }
    }

    /**
     * Store payment data in DynamoDB
     * @param entityId - User's ID in our system
     * @param paymentData - Payment data from Checkbook API
     * @deprecated This method is currently not used. Payment data is stored via Transaction entities.
     */
    private async storePaymentData(entityId: string, paymentData: PaymentResponse): Promise<void> {
        this.logger.info('Storing payment data', { entityId, paymentId: paymentData.id });

        const now = new Date().toISOString();

        const params = {
            TableName: this.TABLE_NAME,
            Item: {
                [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                [EntityKeys.ATTR_SK]: `${CHECKBOOK_PAYMENT_SK_PREFIX}${paymentData.id}`,
                [EntityKeys.FIELD_ID]: entityId,
                [CHECKBOOK_FIELDS.PAYMENT_ID]: paymentData.id,
                [CHECKBOOK_FIELDS.PAYMENT_TYPE]: paymentData.type,
                [CHECKBOOK_FIELDS.PAYMENT_STATUS]: paymentData.status,
                [CHECKBOOK_FIELDS.PAYMENT_AMOUNT]: paymentData.amount,
                recipientName: paymentData.recipient?.name || '',
                recipientEmail: paymentData.recipient?.email || '',
                description: paymentData.description || '',
                [EntityKeys.FIELD_CREATED_AT]: paymentData.date || now,
                [EntityKeys.FIELD_UPDATED_AT]: now,
            },
        };

        try {
            await docClient.send(new PutCommand(params));
            this.logger.info('Successfully stored payment data', { entityId, paymentId: paymentData.id });
        } catch (error: unknown) {
            this.logger.error('Error storing payment data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to store payment data');
        }
    }

    /**
     * Get payment data from DynamoDB
     * @param entityId - User's ID in our system
     * @param paymentId - Payment ID to retrieve
     * @returns Payment data or null if not found
     * @deprecated This method is currently not used. Payment data is retrieved via Transaction entities.
     */
    private async getPaymentData(entityId: string, paymentId: string): Promise<CheckbookPaymentData | null> {
        this.logger.info('Getting payment data', { entityId, paymentId });

        const params = {
            TableName: this.TABLE_NAME,
            Key: {
                [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                [EntityKeys.ATTR_SK]: `${CHECKBOOK_PAYMENT_SK_PREFIX}${paymentId}`,
            },
        };

        try {
            const response = (await docClient.send(new GetCommand(params))) as GetCommandOutput;

            if (!response.Item) {
                this.logger.info('No payment data found', { entityId, paymentId });
                return null;
            }

            this.logger.info('Found payment data', { entityId, paymentId });
            return response.Item as unknown as CheckbookPaymentData;
        } catch (error: unknown) {
            this.logger.error('Error getting payment data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to retrieve payment data');
        }
    }

    /**
     * Get all payments for a user from DynamoDB
     * @param entityId - User's ID in our system
     * @returns List of user's payments
     * @deprecated This method is currently not used. Payment data is typically retrieved via Transaction queries.
     */
    async getAllPaymentData(entityId: string): Promise<CheckbookPaymentData[]> {
        this.logger.info('Getting all payment data from database', { entityId });

        const params = {
            TableName: this.TABLE_NAME,
            KeyConditionExpression: '#pk = :pk AND begins_with(#sk, :sk_prefix)',
            ExpressionAttributeNames: {
                '#pk': EntityKeys.ATTR_PK,
                '#sk': EntityKeys.ATTR_SK,
            },
            ExpressionAttributeValues: {
                ':pk': `${EntityKeys.USER_PREFIX}${entityId}`,
                ':sk_prefix': CHECKBOOK_PAYMENT_SK_PREFIX,
            },
        };

        try {
            const response = await docClient.send(new QueryCommand(params));
            const items = response.Items || [];

            this.logger.info('Found payment data', { entityId, count: items.length });
            return items as unknown as CheckbookPaymentData[];
        } catch (error: unknown) {
            this.logger.error('Error getting all payment data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to retrieve all payment data');
        }
    }

    /**
     * Maps the request transaction type string to our internal TransactionType enum
     * @param requestType Transaction type from the request
     * @returns The corresponding TransactionType enum value
     */
    private mapRequestTransactionType(type?: string): TransactionType {
        if (!type) {
            return TransactionType.WITHDRAWAL;
        }

        if (type === 'P2P') {
            return TransactionType.P2P;
        }

        if (type === 'P2B') {
            return TransactionType.P2B;
        }

        return TransactionType.WITHDRAWAL;
    }

    private mapRequestEntityType(type?: string): EntityTypeString {
        if (!type) {
            return 'USER';
        }

        if (type.toUpperCase() === 'BUSINESS') {
            return 'BUSINESS';
        }

        return 'USER';
    }

    /**
     * Simulates a webhook for a check status update in sandbox environment
     * This method is only for testing purposes in sandbox environments
     *
     * @param checkId - The ID of the check to update
     * @param status - The new status to set (e.g., 'PAID', 'FAILED', 'VOID')
     * @param entityId - Optional entity ID for logging
     * @returns Response from the webhook simulation API
     * @throws Error if not in sandbox environment
     */
    async simulateCheckStatusWebhook(checkId: string, status: string, entityId?: string): Promise<any> {
        // Only proceed if we're in a sandbox environment
        if (this.environment !== 'SANDBOX' && process.env.ENVIRONMENT !== 'dev') {
            const errorMessage = 'Check status webhooks can only be simulated in sandbox or dev environments';
            this.logger.error(errorMessage, { checkId, status, environment: this.environment });
            throw new Error(errorMessage);
        }

        this.logger.info('Simulating check status webhook', {
            checkId,
            status,
            entityId: entityId || 'not provided',
        });

        // Call the base class method to fire the webhook
        const response = await this.fireWebhookForSandbox<any>(checkId, status, entityId);

        // Update the transaction with the new status
        if (response) {
            try {
                await this.updateTransactionAfterWebhook(checkId, status);
            } catch (error) {
                // Log but don't fail the operation if transaction update fails
                this.logger.error('Failed to update transaction after webhook simulation', {
                    checkId,
                    status,
                    error: error instanceof Error ? error.message : String(error),
                });
            }
        }

        return response;
    }

    /**
     * Updates transaction status after receiving a webhook
     * @param checkId - The Checkbook payment ID
     * @param status - The new status from the webhook
     */
    private async updateTransactionAfterWebhook(checkId: string, status: string): Promise<void> {
        try {
            // Find transactions with this provider transaction ID
            const transactions = await Transaction.getByProviderTransactionId(checkId);

            if (!transactions || transactions.length === 0) {
                this.logger.warn('No transaction found for Checkbook payment ID', {
                    checkbookId: checkId,
                });
                return;
            }

            // Map Checkbook status to our transaction status
            let newStatus: TransactionStatus;
            switch (status) {
                case 'PAID':
                    newStatus = TransactionStatus.COMPLETED;
                    break;
                case 'FAILED':
                    newStatus = TransactionStatus.FAILED;
                    break;
                case 'VOID':
                    newStatus = TransactionStatus.CANCELLED;
                    break;
                default:
                    newStatus = TransactionStatus.PENDING;
            }

            // Update each transaction (typically should be just one)
            for (const transaction of transactions) {
                // Only update if status has changed
                if (transaction.status !== newStatus) {
                    transaction.status = newStatus;

                    // Add webhook information to metadata
                    if (!transaction.metadata) {
                        transaction.metadata = {};
                    }

                    transaction.metadata.webhookReceivedAt = new Date().toISOString();
                    transaction.metadata.checkbookStatus = status;

                    // Complete the transaction if appropriate
                    if (newStatus === TransactionStatus.COMPLETED) {
                        await transaction.complete();
                    } else if (newStatus === TransactionStatus.FAILED) {
                        await transaction.fail('Payment failed as reported by webhook');
                    } else {
                        await transaction.update();
                    }

                    this.logger.info('Successfully updated transaction after webhook', {
                        checkbookId: checkId,
                        transactionId: transaction.transactionId,
                        newStatus: newStatus,
                    });
                } else {
                    this.logger.info('Transaction status unchanged, no update needed after webhook', {
                        checkbookId: checkId,
                        transactionId: transaction.transactionId,
                        status: transaction.status,
                    });
                }
            }
        } catch (error) {
            this.logger.error('Error updating transaction after webhook', {
                checkbookId: checkId,
                error: error instanceof Error ? error.message : String(error),
                stack: error instanceof Error ? error.stack : undefined,
            });
            throw error;
        }
    }

    private async processVoidDigitalCheckWebhook() {
        // ... existing code ...
        // ... existing code ...
    }
}
</file>

<file path="lambdas/checkbook/services/checkbook-service.ts">
import axios, { AxiosError } from 'axios';
import { CHECKBOOK_API_URLS } from '../config';
import { CreateUserRequest, CreateUserResponse, CheckbookErrorResponse } from '../types/checkbook';
import { PutCommand, GetCommand, GetCommandOutput, PutCommandOutput, DeleteCommand } from '@aws-sdk/lib-dynamodb';
import { docClient } from 'commons';
import { EntityKeys } from 'commons';
import { KmsService } from 'commons';
import { CheckbookBaseService } from './checkbook-base-service';

// Add constant for Checkbook data
const CHECKBOOK_DATA_SK = 'CHECKBOOK#DATA';

/**
 * Checkbook API error codes with corresponding messages
 */
export const CheckbookErrorCodes = {
    BAD_REQUEST: {
        code: 400,
        message: 'Bad Request',
        details: 'Your request is invalid',
    },
    UNAUTHORIZED: {
        code: 401,
        message: 'Unauthorized',
        details: 'Your API key is wrong',
    },
    FORBIDDEN: {
        code: 403,
        message: 'Forbidden',
        details: 'You do not have permission to access the requested endpoint',
    },
    NOT_FOUND: {
        code: 404,
        message: 'Not Found',
        details: 'The specified endpoint could not be found',
    },
    METHOD_NOT_ALLOWED: {
        code: 405,
        message: 'Method Not Allowed',
        details: 'You tried to access an endpoint with an invalid method',
    },
    TOO_MANY_REQUESTS: {
        code: 429,
        message: 'Too Many Requests',
        details: 'You have sent too many requests. Retry after a few seconds',
    },
    INTERNAL_SERVER_ERROR: {
        code: 500,
        message: 'Internal Server Error',
        details: 'We had a problem with our server. Try again later',
    },
    SERVICE_UNAVAILABLE: {
        code: 503,
        message: 'Service Unavailable',
        details: 'We are temporarily offline for maintenance. Please try again later',
    },
};

/**
 * Custom error class for Checkbook API errors
 */
export class CheckbookError extends Error {
    code: number;
    details: string;

    constructor(errorCode: keyof typeof CheckbookErrorCodes, additionalInfo?: string) {
        const errorObj = CheckbookErrorCodes[errorCode];
        const message = `${errorObj.message}: ${errorObj.details}${additionalInfo ? ` - ${additionalInfo}` : ''}`;
        super(message);
        this.name = 'CheckbookError';
        this.code = errorObj.code;
        this.details = errorObj.details;
    }
}

/**
 * Configuration for Checkbook service
 */
interface CheckbookConfig {
    /** Base API URL for Checkbook */
    apiUrl: string;
    /** Timeout for API requests in milliseconds */
    timeout: number;
    /** Environment (sandbox/production) */
    environment: 'DEMO' | 'SANDBOX' | 'PRODUCTION';
}

/**
 * Service class for handling Checkbook API operations
 */
export class CheckbookService extends CheckbookBaseService {
    protected kmsService: KmsService;

    /**
     * Initialize the Checkbook Service
     * @param config - Configuration for Checkbook API
     */
    constructor(config: CheckbookConfig) {
        super(config.environment, config.timeout);
        this.kmsService = new KmsService(process.env.KMS_KEY_ID || '');
    }

    /**
     * Encrypt sensitive data using KMS
     */
    private async encryptValue(plaintext: string): Promise<string> {
        const encrypted = await this.kmsService.encryptData(plaintext);
        if (!encrypted) {
            throw new Error('Failed to encrypt data');
        }
        return encrypted;
    }

    /**
     * Decrypt encrypted data using KMS
     */
    private async decryptValue(encryptedText: string): Promise<string> {
        const decrypted = await this.kmsService.decryptData(encryptedText);
        if (!decrypted) {
            throw new Error('Failed to decrypt data');
        }
        return decrypted;
    }

    /**
     * Get entity information from our database
     * @param entityId - User's ID in our system
     * @returns Entity data or null if not found
     */
    private async getEntityData(entityId: string): Promise<any | null> {
        this.logger.info('Getting entity data', { entityId });

        try {
            const params = {
                TableName: this.TABLE_NAME,
                Key: {
                    [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                    [EntityKeys.ATTR_SK]: EntityKeys.PROFILE_SK,
                },
            };

            const response = (await docClient.send(new GetCommand(params))) as GetCommandOutput;

            if (!response.Item) {
                this.logger.warn('No entity found with ID', { entityId });
                return null;
            }

            this.logger.info('Found entity data', { entityId });
            return response.Item;
        } catch (error) {
            this.logger.error('Error getting entity data', error);
            throw new Error(error instanceof Error ? error.message : 'Failed to retrieve entity data');
        }
    }

    /**
     * Create a new user in Checkbook API
     * @param entityId - User's ID in our system
     * @returns API response with the created user
     */
    async createUser(entityId: string): Promise<CreateUserResponse> {
        this.logger.info('Creating user in Checkbook', { entityId });

        try {
            // Check if user already has Checkbook data
            const existingData = await this.getUserCheckbookData(entityId);
            if (existingData) {
                this.logger.info('User already has Checkbook account', { entityId });
                throw new Error('User already has a Checkbook account');
            }

            // Get user entity data
            const entityData = await this.getEntityData(entityId);
            if (!entityData) {
                throw new Error('User entity not found');
            }

            // Get user name from entity data
            let name = entityData.displayName || entityData.email;
            if (entityData.userInfo) {
                if (entityData.userInfo.firstName && entityData.userInfo.lastName) {
                    name = `${entityData.userInfo.firstName} ${entityData.userInfo.lastName}`;
                } else if (entityData.userInfo.firstName) {
                    name = entityData.userInfo.firstName;
                } else if (entityData.userInfo.lastName) {
                    name = entityData.userInfo.lastName;
                }
            }

            // Create the request object
            const request: CreateUserRequest = {
                name: name,
                user_id: entityId,
            };

            this.logger.info('Prepared Checkbook create user request', { request });

            // Call API using centralized method
            const endpoint = CHECKBOOK_API_URLS[this.environment].ENDPOINTS.USER;
            const response = await this.callCheckbookApi<CreateUserResponse>('post', endpoint, request, entityId);

            this.logger.info('Successfully created Checkbook user', {
                entityId,
                checkbookId: response.id,
            });

            // Store the user data in DynamoDB
            await this.storeUserCheckbookData(entityId, response);

            return response;
        } catch (error: unknown) {
            // Re-throw if it's already been processed by callCheckbookApi
            if (error instanceof Error) {
                throw error;
            }

            // Fallback error handling for non-API errors
            this.logger.error('Error creating Checkbook user', {
                entityId,
                error: String(error),
            });
            throw new Error(`Failed to create Checkbook user: ${String(error)}`);
        }
    }

    /**
     * Handle API errors for specific Checkbook user API cases
     * Extends the base class error handling
     */
    protected handleApiError(error: unknown, operation: string, entityId: string): never {
        if (axios.isAxiosError(error)) {
            const axiosError = error as AxiosError;
            const status = axiosError.response?.status;
            const errorData = axiosError.response?.data;

            // Handle specific errors for this service
            if (status === 400 && errorData && (errorData as any)?.error === 'User already exists') {
                throw new Error('User already has a Checkbook account');
            }
        }

        // Let the base class handle general API errors
        super.handleApiError(error, operation, entityId);

        // This will never be reached as the base method will throw
        throw new Error('Unreachable code');
    }

    /**
     * Store Checkbook user data in DynamoDB
     * @param entityId - User's ID in our system
     * @param data - User data from Checkbook API
     */
    private async storeUserCheckbookData(entityId: string, data: CreateUserResponse): Promise<void> {
        this.logger.info('Storing Checkbook user data', { entityId, checkbookId: data.id });

        const now = new Date().toISOString();

        // Store under the user's partition
        const params = {
            TableName: this.TABLE_NAME,
            Item: {
                [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                [EntityKeys.ATTR_SK]: CHECKBOOK_DATA_SK,
                [EntityKeys.FIELD_ID]: entityId,
                checkbookId: data.id,
                checkbookKey: data.key,
                checkbookSecret: await this.encryptValue(data.secret),
                [EntityKeys.FIELD_CREATED_AT]: now,
                [EntityKeys.FIELD_UPDATED_AT]: now,
            },
        };

        try {
            (await docClient.send(new PutCommand(params))) as PutCommandOutput;
            this.logger.info('Successfully stored Checkbook user data', { entityId });
        } catch (error: unknown) {
            this.logger.error('Error storing Checkbook user data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to store Checkbook user data');
        }
    }

    /**
     * Get user's Checkbook data from DynamoDB
     * @param entityId - User's ID in our system
     * @returns User's Checkbook data or null if not found
     */
    async getUserCheckbookData(entityId: string): Promise<any | null> {
        this.logger.info('Getting Checkbook user data', { entityId });

        const params = {
            TableName: this.TABLE_NAME,
            Key: {
                [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                [EntityKeys.ATTR_SK]: CHECKBOOK_DATA_SK,
            },
        };

        try {
            const response = (await docClient.send(new GetCommand(params))) as GetCommandOutput;

            if (!response.Item) {
                this.logger.info('No Checkbook data found for user', { entityId });
                return null;
            }

            this.logger.info('Found Checkbook data for user', { entityId });

            // If needed, decrypt secret data
            if (response.Item.checkbookSecret) {
                response.Item.checkbookSecret = await this.decryptValue(response.Item.checkbookSecret);
            }

            return response.Item;
        } catch (error: unknown) {
            this.logger.error('Error getting Checkbook user data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to retrieve Checkbook user data');
        }
    }

    /**
     * Update a user in Checkbook API
     * @param entityId - User's ID in our system
     * @param userData - Updated user data
     * @returns API response message
     */
    async updateUser(
        entityId: string,
        userData: {
            business_name?: string;
            check_number?: number;
            dob?: string;
            first_name?: string;
            invoice_number?: number;
            last_name?: string;
            password?: string;
            phone?: string;
            ssn?: string;
        },
    ): Promise<{ errors: Record<string, any>; message: string }> {
        this.logger.info('Updating user in Checkbook', { entityId });

        try {
            // Get Checkbook data for user
            const existingData = await this.getUserCheckbookData(entityId);
            if (!existingData) {
                throw new Error('User does not have a Checkbook account');
            }

            // Call API using centralized method
            const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.USER}/${existingData.checkbookId}`;
            const response = await this.callCheckbookApi<{ errors: Record<string, any>; message: string }>(
                'put',
                endpoint,
                userData,
                entityId,
            );

            this.logger.info('Successfully updated Checkbook user', {
                entityId,
                checkbookId: existingData.checkbookId,
            });

            return response;
        } catch (error: unknown) {
            // Re-throw if it's already been processed by callCheckbookApi
            if (error instanceof Error) {
                throw error;
            }

            // Fallback error handling for non-API errors
            this.logger.error('Error updating Checkbook user', {
                entityId,
                error: String(error),
            });
            throw new Error(`Failed to update Checkbook user: ${String(error)}`);
        }
    }

    /**
     * Delete a user from Checkbook API and our database
     * @param entityId - User's ID in our system
     * @returns API response message
     */
    async deleteUser(entityId: string): Promise<{ errors: Record<string, any>; message: string }> {
        this.logger.info('Deleting user from Checkbook', { entityId });

        try {
            // Get Checkbook data for user
            const existingData = await this.getUserCheckbookData(entityId);
            if (!existingData) {
                this.logger.warn('Attempted to delete non-existent Checkbook user data', { entityId });
                return { errors: {}, message: 'User not found in Checkbook or already deleted.' };
            }

            // Call API using centralized method
            const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.USER}/${existingData.checkbookId}`;

            try {
                const response = await this.callCheckbookApi<{ errors: Record<string, any>; message: string }>(
                    'delete',
                    endpoint,
                    undefined,
                    entityId,
                );

                // Delete local data only after successful API deletion
                await this.deleteUserCheckbookData(entityId);

                this.logger.info('Successfully deleted Checkbook user', {
                    entityId,
                    checkbookId: existingData.checkbookId,
                });

                return response;
            } catch (apiError) {
                // Handle 404 case specially
                if (axios.isAxiosError(apiError) && apiError.response?.status === 404) {
                    this.logger.warn('Checkbook user not found on API during delete, attempting local delete', {
                        entityId,
                    });

                    // If 404, still delete local data
                    await this.deleteUserCheckbookData(entityId);
                    return { errors: {}, message: 'User not found on Checkbook API, local data deleted.' };
                }
                throw apiError;
            }
        } catch (error: unknown) {
            // Re-throw if it's already been processed by callCheckbookApi
            if (error instanceof Error) {
                throw error;
            }

            // Fallback error handling for non-API errors
            this.logger.error('Error deleting Checkbook user', {
                entityId,
                error: String(error),
            });
            throw new Error(`Failed to delete Checkbook user: ${String(error)}`);
        }
    }

    /**
     * Delete Checkbook user data from DynamoDB
     * @param entityId - User's ID in our system
     */
    private async deleteUserCheckbookData(entityId: string): Promise<void> {
        this.logger.info('Deleting Checkbook user data', { entityId });

        const params = {
            TableName: this.TABLE_NAME,
            Key: {
                [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                [EntityKeys.ATTR_SK]: CHECKBOOK_DATA_SK,
            },
        };

        try {
            await docClient.send(new DeleteCommand(params));
            this.logger.info('Successfully deleted Checkbook user data', { entityId });
        } catch (error: unknown) {
            this.logger.error('Error deleting Checkbook user data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to delete Checkbook user data');
        }
    }

    /**
     * Generate new API keys for a user
     * @param entityId - User's ID in our system
     * @param options - Optional parameters for key generation
     * @returns API response with new keys
     */
    async rotateApiKeys(
        entityId: string,
        options?: {
            name?: string;
            expiration_date?: string;
        },
    ): Promise<{
        id: string;
        secret: string;
        webhook_key: string;
        name: string | null;
        expiration_date: string | null;
    }> {
        this.logger.info('Rotating API keys for Checkbook user', { entityId });

        try {
            // Get Checkbook data for user
            const existingData = await this.getUserCheckbookData(entityId);
            if (!existingData) {
                throw new Error('User does not have a Checkbook account');
            }

            // Call API using centralized method
            const endpoint = `${CHECKBOOK_API_URLS[this.environment].ENDPOINTS.USER}/api_key`;
            const response = await this.callCheckbookApi<{
                id: string;
                secret: string;
                webhook_key: string;
                name: string | null;
                expiration_date: string | null;
            }>('post', endpoint, options || {}, entityId);

            this.logger.info('Successfully generated new API keys', {
                entityId,
                checkbookId: existingData.checkbookId,
            });

            // Update the stored user data with new keys
            await this.updateUserCheckbookKeys(entityId, {
                checkbookId: existingData.checkbookId,
                checkbookKey: response.id,
                checkbookSecret: response.secret,
                webhookKey: response.webhook_key,
            });

            return response;
        } catch (error: unknown) {
            // Re-throw if it's already been processed by callCheckbookApi
            if (error instanceof Error) {
                throw error;
            }

            // Fallback error handling for non-API errors
            this.logger.error('Error rotating API keys', {
                entityId,
                error: String(error),
            });
            throw new Error(`Failed to rotate API keys: ${String(error)}`);
        }
    }

    /**
     * Update Checkbook API keys in DynamoDB
     * @param entityId - User's ID in our system
     * @param keyData - New key data to store
     */
    private async updateUserCheckbookKeys(
        entityId: string,
        keyData: {
            checkbookId: string;
            checkbookKey: string;
            checkbookSecret: string;
            webhookKey: string;
        },
    ): Promise<void> {
        this.logger.info('Updating Checkbook keys in database', { entityId });

        try {
            // Get current item to preserve other fields
            const params = {
                TableName: this.TABLE_NAME,
                Key: {
                    [EntityKeys.ATTR_PK]: `${EntityKeys.USER_PREFIX}${entityId}`,
                    [EntityKeys.ATTR_SK]: CHECKBOOK_DATA_SK,
                },
            };

            const response = (await docClient.send(new GetCommand(params))) as GetCommandOutput;

            if (!response.Item) {
                throw new Error('User Checkbook data not found');
            }

            // Update with new key data
            const now = new Date().toISOString();
            const updateParams = {
                TableName: this.TABLE_NAME,
                Item: {
                    ...response.Item,
                    checkbookKey: keyData.checkbookKey,
                    checkbookSecret: await this.encryptValue(keyData.checkbookSecret),
                    webhookKey: keyData.webhookKey,
                    [EntityKeys.FIELD_UPDATED_AT]: now,
                },
            };

            await docClient.send(new PutCommand(updateParams));
            this.logger.info('Successfully updated Checkbook key data', { entityId });
        } catch (error: unknown) {
            this.logger.error('Error updating Checkbook key data', {
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error('Failed to update Checkbook key data');
        }
    }
}
</file>

<file path="lambdas/checkbook/services/payment-security-service.ts">
import { createLogger } from 'commons';
import { APIGatewayProxyEvent } from 'aws-lambda';
import { CreateDigitalCheckRequest } from '../types/payment';

// In-memory cache for rate limiting and fraud detection
// Note: In a production environment with multiple Lambda instances,
// this should be replaced with a distributed cache like DynamoDB or Redis
interface RequestTracker {
    [userId: string]: {
        lastRequestTimestamp: number;
        requestCounts: {
            [endpoint: string]: {
                count: number;
                firstRequestTimestamp: number;
            };
        };
    };
}

/**
 * Security service for payment operations
 * Centralizes security checks for payment-related operations
 */
export class PaymentSecurityService {
    private logger = createLogger('PaymentSecurityService');

    // Simple in-memory rate limiting and tracking
    // This will reset whenever the Lambda cold starts
    private requestTracker: RequestTracker = {};

    // Rate limiting configuration
    private readonly MAX_REQUESTS_PER_MINUTE = 10;
    private readonly SUSPICIOUS_AMOUNT_THRESHOLD = 5000; // $5000 threshold for extra scrutiny

    /**
     * Validates that a request is authorized properly
     *
     * @param event API Gateway event
     * @returns User ID from authorizer if authorized, null otherwise
     */
    validateAuthorization(event: APIGatewayProxyEvent): string | null {
        const authorizedUserId = event.requestContext.authorizer?.userId;

        if (!authorizedUserId) {
            this.logger.warn('Unauthorized request attempt', {
                path: event.path,
                httpMethod: event.httpMethod,
                ip: event.requestContext.identity?.sourceIp,
            });
            return null;
        }

        return authorizedUserId;
    }

    /**
     * Track request for rate limiting and fraud detection
     *
     * @param userId User making the request
     * @param endpoint Endpoint being accessed
     * @returns True if the request passes rate limiting checks
     */
    private trackRequest(userId: string, endpoint: string): boolean {
        const now = Date.now();

        // Initialize tracking for new users
        if (!this.requestTracker[userId]) {
            this.requestTracker[userId] = {
                lastRequestTimestamp: now,
                requestCounts: {},
            };
        }

        // Initialize tracking for new endpoints
        if (!this.requestTracker[userId].requestCounts[endpoint]) {
            this.requestTracker[userId].requestCounts[endpoint] = {
                count: 0,
                firstRequestTimestamp: now,
            };
        }

        const userTracking = this.requestTracker[userId];
        const endpointTracking = userTracking.requestCounts[endpoint];

        // Reset counter if it's been more than a minute since the first request
        if (now - endpointTracking.firstRequestTimestamp > 60000) {
            endpointTracking.count = 0;
            endpointTracking.firstRequestTimestamp = now;
        }

        // Increment request count
        endpointTracking.count++;
        userTracking.lastRequestTimestamp = now;

        // Check if rate limit is exceeded
        if (endpointTracking.count > this.MAX_REQUESTS_PER_MINUTE) {
            this.logger.warn('Rate limit exceeded', {
                userId,
                endpoint,
                requestCount: endpointTracking.count,
                timeWindow: '1 minute',
            });
            return false;
        }

        return true;
    }

    /**
     * Validates a digital check request
     * Ensures the request is properly formed and the user is authorized to make it
     *
     * @param event API Gateway event
     * @param authorizedUserId User ID from authorizer
     * @param requestBody The parsed request body
     * @returns Validation result with success flag and error message if applicable
     */
    validateDigitalCheckRequest(
        event: APIGatewayProxyEvent,
        authorizedUserId: string,
        requestBody: CreateDigitalCheckRequest,
    ): { isValid: boolean; errorMessage?: string } {
        try {
            // Rate limiting check
            const endpoint = 'createDigitalCheck';
            if (!this.trackRequest(authorizedUserId, endpoint)) {
                return {
                    isValid: false,
                    errorMessage: 'Too many requests. Please try again later.',
                };
            }

            // Basic data validation - should be handled by schema validator
            if (!requestBody.amount || requestBody.amount <= 0) {
                return {
                    isValid: false,
                    errorMessage: 'Amount must be greater than 0',
                };
            }

            if (!requestBody.recipientId) {
                return {
                    isValid: false,
                    errorMessage: 'Recipient ID is required',
                };
            }

            // Ensure the user isn't sending money to themself
            if (authorizedUserId === requestBody.recipientId) {
                this.logger.warn('Self-payment attempt', {
                    userId: authorizedUserId,
                    amount: requestBody.amount,
                });

                return {
                    isValid: false,
                    errorMessage: 'Cannot send payment to yourself',
                };
            }

            // Validate transaction type if specified
            if (requestBody.transactionType && !['withdrawal', 'P2P', 'P2B'].includes(requestBody.transactionType)) {
                return {
                    isValid: false,
                    errorMessage: 'Invalid transaction type',
                };
            }

            // Enhanced fraud detection for large amounts
            if (requestBody.amount > this.SUSPICIOUS_AMOUNT_THRESHOLD) {
                this.logger.warn('Large amount transaction detected', {
                    userId: authorizedUserId,
                    amount: requestBody.amount,
                    recipientId: requestBody.recipientId,
                    ip: event.requestContext.identity?.sourceIp,
                });

                // In a production system, you might:
                // 1. Flag this for review
                // 2. Require additional verification
                // 3. Apply stricter limits
                // For this demo, we'll still allow it but with detailed logging
            }

            // Log the successful validation
            this.logger.info('Digital check request validated', {
                userId: authorizedUserId,
                recipientId: requestBody.recipientId,
                amount: requestBody.amount,
            });

            return { isValid: true };
        } catch (error) {
            this.logger.error('Error validating digital check request', {
                error: error instanceof Error ? error.message : String(error),
                userId: authorizedUserId,
            });

            return {
                isValid: false,
                errorMessage: 'Invalid request format',
            };
        }
    }

    /**
     * Validates a payment deposit request
     *
     * @param event API Gateway event
     * @param authorizedUserId User ID from authorizer
     * @param checkId Check ID from path parameters
     * @param accountId Account ID from request body
     * @returns Validation result with success flag and error message if applicable
     */
    validateDepositRequest(
        event: APIGatewayProxyEvent,
        authorizedUserId: string,
        checkId: string,
        accountId: string,
    ): { isValid: boolean; errorMessage?: string } {
        try {
            // Rate limiting check
            const endpoint = 'depositPayment';
            if (!this.trackRequest(authorizedUserId, endpoint)) {
                return {
                    isValid: false,
                    errorMessage: 'Too many requests. Please try again later.',
                };
            }

            // Basic data validation
            if (!checkId) {
                return {
                    isValid: false,
                    errorMessage: 'Check ID is required',
                };
            }

            if (!accountId) {
                return {
                    isValid: false,
                    errorMessage: 'Account ID is required',
                };
            }

            // No need to check if recipient matches the authorizer
            // as users can only deposit to their own accounts,
            // which is enforced by the Checkbook API

            // Log the successful validation
            this.logger.info('Deposit request validated', {
                userId: authorizedUserId,
                checkId,
                accountId,
            });

            return { isValid: true };
        } catch (error) {
            this.logger.error('Error validating deposit request', {
                error: error instanceof Error ? error.message : String(error),
                userId: authorizedUserId,
                checkId,
            });

            return {
                isValid: false,
                errorMessage: 'Invalid deposit request',
            };
        }
    }

    /**
     * Validates a payment retrieval request
     *
     * @param event API Gateway event
     * @param authorizedUserId User ID from authorizer
     * @param checkId Check ID from path parameters
     * @returns Validation result with success flag and error message if applicable
     */
    validateGetPaymentRequest(
        event: APIGatewayProxyEvent,
        authorizedUserId: string,
        checkId: string,
    ): { isValid: boolean; errorMessage?: string } {
        try {
            // Rate limiting check
            const endpoint = 'getPayment';
            if (!this.trackRequest(authorizedUserId, endpoint)) {
                return {
                    isValid: false,
                    errorMessage: 'Too many requests. Please try again later.',
                };
            }

            // Basic data validation
            if (!checkId) {
                return {
                    isValid: false,
                    errorMessage: 'Check ID is required',
                };
            }

            // Log the successful validation
            this.logger.info('Get payment request validated', {
                userId: authorizedUserId,
                checkId,
            });

            return { isValid: true };
        } catch (error) {
            this.logger.error('Error validating get payment request', {
                error: error instanceof Error ? error.message : String(error),
                userId: authorizedUserId,
                checkId,
            });

            return {
                isValid: false,
                errorMessage: 'Invalid payment request',
            };
        }
    }
}

// Export singleton instance for easier usage
export const paymentSecurityService = new PaymentSecurityService();
</file>

<file path="lambdas/checkbook/types/card.ts">
/**
 * Checkbook Card API type definitions
 */

/**
 * Request payload for creating a card in Checkbook
 */
export interface CreateCardRequest {
    card_number: string; // Required: Card number (e.g. "4111111111111111")
    expiration_date: string; // Required: Expiration date in YYYY-MM format (e.g. "2030-01")
    cvv?: string; // Optional: Card verification value
    name?: string; // Optional: Name on card
    address?: {
        // Optional: Billing address
        line1?: string;
        line2?: string;
        city?: string;
        state?: string;
        zip?: string;
        country?: string;
    };
}

/**
 * Request payload for updating a card in Checkbook
 */
export interface UpdateCardRequest {
    name?: string; // Name on card
    default?: boolean; // Whether this is the default card
}

// Card address data
export interface CardAddress {
    line1?: string; // Address line 1
    line2?: string; // Address line 2
    city?: string; // City
    state?: string; // State
    zip?: string; // ZIP code
    country?: string; // Country
}

/**
 * Response from the Checkbook API when creating/getting a card
 */
export interface CardResponse {
    id: string; // Card ID
    card_number: string; // Masked card number (e.g. "************1111")
    expiration_date: string; // Expiration date
    name?: string; // Name on card
    default: boolean; // Whether this is the default card
    date: string; // Creation date
}

/**
 * Card data stored in DynamoDB
 */
export interface CheckbookCardData {
    id: string; // User ID
    cardId: string; // Card ID
    cardNumber: string; // Masked card number (e.g. "************1111")
    expirationDate: string; // Expiration date
    lastFourDigits: string; // Last four digits of card number
    isDefault: boolean; // Whether this is the default card
    name?: string; // Name on card
    createdAt: string; // Creation date
    updatedAt: string; // Last updated date
}

// Card error response from Checkbook API
export interface CardErrorResponse {
    errors: Record<string, any>;
    message: string;
}
</file>

<file path="lambdas/checkbook/types/checkbook.ts">
/**
 * Checkbook API type definitions
 */

// User creation request
export interface CreateUserRequest {
    name: string;       // length between 2 and 180
    user_id: string;    // length between 2 and 80
}

// User creation response
export interface CreateUserResponse {
    id: string;         // Unique identifier for user
    key: string;        // Publishable key of the user
    secret: string;     // Secret key of the user
    user_id: string | null; // Specific user_id provided by the marketplace owner
}

// Checkbook API error response
export interface CheckbookErrorResponse {
    error: {
        message: string;
        code?: string;
        type?: string;
    };
}

// Stored user data in DynamoDB
export interface CheckbookUserData {
    userId: string;          // Our user ID
    checkbookId: string;     // Checkbook's user ID
    checkbookKey: string;    // Publishable key
    checkbookSecret: string; // Secret key (should be encrypted)
    createdAt: string;       // ISO date string
    updatedAt: string;       // ISO date string
}
</file>

<file path="lambdas/checkbook/types/payment.ts">
// {
//     "amount": "<number>",
//     "name": "<string>",
//     "recipient": "<string>",
//     "account": "<uuid>",
//     "attachment": {
//       "content": "<string>",
//       "filename": "<string>"
//     },
//     "deposit_options": [
//       "<string>"
//     ],
//     "description": "<string,null>",
//     "number": "<string>",
//     "pin": {
//       "description": "<string>",
//       "value": "<string>"
//     },
//     "remittance_advice": [
//       {
//         "id": "<string>",
//         "date": "<string>",
//         "amount": "<number,null>",
//         "description": "<string,null>"
//       }
//     ]
//   }

/**
 * Checkbook Payment API type definitions
 */

// Digital check recipient types
export interface CheckAddress {
    name: string;
    line1: string;
    line2?: string;
    city: string;
    state: string;
    zip: string;
}

// Define deposit options
export const DEPOSIT_OPTIONS = {
    PRINT: 'PRINT',
    MAIL: 'MAIL',
    BANK: 'BANK',
    CARD: 'CARD',
    VCC: 'VCC',
    RTP: 'RTP',
    PAYPAL: 'PAYPAL',
    WALLET: 'WALLET',
    VENMO: 'VENMO',
    INTERAC: 'INTERAC',
    WIRE: 'WIRE',
} as const;

// Type for deposit options values
export type DepositOptionValue = (typeof DEPOSIT_OPTIONS)[keyof typeof DEPOSIT_OPTIONS];

export interface DigitalRecipient {
    email?: string;
    phone?: string;
    address?: CheckAddress;
}

// Pin for check authentication
export interface Pin {
    length?: number;
    type?: 'random' | 'ssn_last4' | 'phone_last4' | 'zip';
    value?: string;
}

// Attachment for check
export interface Attachment {
    filename: string;
    content: string; // base64 encoded
    content_type: string;
}

// Remittance advice for digital check
export interface RemittanceAdvice {
    id: string;
    date: string;
    amount?: number | null;
    description?: string | null;
}

// Digital check request payload
export interface CreateDigitalCheckRequest {
    amount: number;
    recipientId: string; // ID of the recipient in our system
    description?: string; // Optional description
    transactionType?: 'withdrawal' | 'deposit' | 'p2p_transfer' | 'p2b_transfer' | 'trade'; // Type of transaction (defaults to withdrawal if not specified)
    entityType?: 'USER' | 'BUSINESS'; // Type of entity receiving the payment (defaults to USER if not specified)
}

// Original structure kept for reference
export interface LegacyDigitalCheckRequest {
    amount: number;
    name: string;
    deposit_options: DepositOptionValue[];
    recipient: string | DigitalRecipient;
    remittance_advice: RemittanceAdvice[];
    description?: string;
    account?: string; // UUID
    attachment?: string | Attachment;
    number?: string | number;
    pin?: Pin;
}

// Digital check response
export interface DigitalCheckResponse {
    amount: number;
    date: string;
    id: string;
    remittance_advice: [string, string][];
    status: string;
    description: string | null;
    image_uri: string | null;
    name: string | null;
    number: number;
    recipient: string;
}

export interface WithdrawalCheckResponse {
    checkId: string;
    status: string;
    amount: number;
    transactionId: string;
    feeAmount: string;
    totalWithdrawalAmount: string; // Total amount withdrawn from wallet
    amountAfterFees: string; // Amount sent as check (after fee deduction)
}

// Error response
export interface CheckbookPaymentErrorResponse {
    message: string;
    errors: Record<string, any>;
}

// Get payment response
export interface GetPaymentResponse {
    amount: number;
    date: string;
    id: string;
    remittance_advice: [string, string][];
    status: string;
    description: string | null;
    image_uri: string | null;
    name: string | null;
    number: number | string;
    recipient: string | string[] | CheckAddress;
}

// Generic payment response for internal operations
export interface PaymentResponse {
    id: string;
    type: string;
    status: string;
    amount: number;
    date?: string;
    description?: string;
    recipient?: {
        name?: string;
        email?: string;
    };
}

// Database storage structure for payment data
export interface CheckbookPaymentData {
    id: string;
    paymentId: string;
    paymentType: string;
    paymentStatus: string;
    paymentAmount: number;
    recipientName?: string;
    recipientEmail?: string;
    description?: string;
    createdAt: string;
    updatedAt: string;
}
</file>

<file path="lambdas/checkbook/types/request-types.ts">
/**
 * Request types for Checkbook handlers
 */

// No specific request parameters needed for create user
// as we get the data from the entity record

// Response type for the Lambda handlers
export interface CheckbookResponse {
    success: boolean;
    message?: string;
    data?: any;
    error?: {
        code: string;
        message: string;
    };
}
</file>

<file path="lambdas/checkbook/validators/card-validator.ts">
import * as Joi from 'joi';
import { CreateCardRequest, UpdateCardRequest } from '../types/card';

/**
 * Validate a CreateCardRequest
 * @param data - Data to validate
 * @returns Validated data or validation error
 */
export const validateCreateCardRequest = (
    data: unknown,
): { value: CreateCardRequest; error?: undefined } | { value?: undefined; error: Error } => {
    const schema = Joi.object<CreateCardRequest>({
        card_number: Joi.string()
            .required()
            .pattern(/^\d{13,19}$/)
            .messages({
                'string.empty': 'Card number is required',
                'string.pattern.base': 'Card number must be between 13 and 19 digits',
            }),
        expiration_date: Joi.string()
            .required()
            .pattern(/^\d{4}-\d{2}$/)
            .messages({
                'string.empty': 'Expiration date is required',
                'string.pattern.base': 'Expiration date must be in YYYY-MM format',
            }),
        cvv: Joi.string()
            .pattern(/^\d{3,4}$/)
            .optional()
            .messages({
                'string.pattern.base': 'CVV must be 3 or 4 digits',
            }),
        address: Joi.object({
            line1: Joi.string().optional(),
            line2: Joi.string().optional(),
            city: Joi.string().optional(),
            state: Joi.string().optional(),
            zip: Joi.string().optional(),
            country: Joi.string().optional(),
        }).optional(),
    });

    const result = schema.validate(data, { abortEarly: false, stripUnknown: true });

    if (result.error) {
        return {
            error: new Error(result.error.details.map((detail: Joi.ValidationErrorItem) => detail.message).join('; ')),
        };
    }

    return { value: result.value as CreateCardRequest };
};

/**
 * Validate an UpdateCardRequest
 * @param data - Data to validate
 * @returns Validated data or validation error
 */
export const validateUpdateCardRequest = (
    data: unknown,
): { value: UpdateCardRequest; error?: undefined } | { value?: undefined; error: Error } => {
    const schema = Joi.object<UpdateCardRequest>({
        name: Joi.string().max(128).optional().messages({
            'string.max': 'Name must not exceed 128 characters',
        }),
        default: Joi.boolean().optional(),
    })
        .min(1)
        .messages({
            'object.min': 'At least one field is required for update',
        });

    const result = schema.validate(data, { abortEarly: false, stripUnknown: true });

    if (result.error) {
        return {
            error: new Error(result.error.details.map((detail: Joi.ValidationErrorItem) => detail.message).join('; ')),
        };
    }

    return { value: result.value as UpdateCardRequest };
};

/**
 * Validate a card ID parameter
 * @param cardId - Card ID to validate
 * @returns True if valid, otherwise false
 */
export const validateCardId = (cardId: string): boolean => {
    if (!cardId || typeof cardId !== 'string') {
        return false;
    }

    // Validate card ID format (basic check for non-empty string)
    return cardId.trim().length > 0;
};
</file>

<file path="lambdas/checkbook/validators/digital-check-validator.ts">
import { CreateDigitalCheckRequest } from '../types/payment';

/**
 * Validates a digital check creation request
 * @param request - The request to validate
 * @returns Error message string if invalid, null if valid
 */
export const validateDigitalCheckRequest = (request: CreateDigitalCheckRequest): string | null => {
    // Check required fields
    if (!request) return 'Request body is required';

    // Amount validation
    if (!request.amount) return 'Amount is required';
    if (typeof request.amount !== 'number') return 'Amount must be a number';
    if (request.amount < 0.01) return 'Amount must be at least 0.01';

    // Recipient ID validation
    if (!request.recipientId) return 'Recipient ID is required';
    if (typeof request.recipientId !== 'string') return 'Recipient ID must be a string';
    if (request.recipientId.trim().length === 0) return 'Recipient ID cannot be empty';

    // Transaction type validation (if provided)
    if (request.transactionType !== undefined) {
        const validTypes = ['withdrawal', 'deposit', 'p2p_transfer', 'p2b_transfer', 'trade'];
        if (!validTypes.includes(request.transactionType)) {
            return `Invalid transaction type. Must be one of: ${validTypes.join(', ')}`;
        }
    }

    // Entity type validation (if provided)
    if (request.entityType !== undefined) {
        const validEntityTypes = ['USER', 'BUSINESS'];
        if (!validEntityTypes.includes(request.entityType)) {
            return `Invalid entity type. Must be one of: ${validEntityTypes.join(', ')}`;
        }
    }

    // Optional description validation
    if (request.description !== undefined && typeof request.description !== 'string') {
        return 'Description must be a string';
    }

    // If we get here, the request is valid
    return null;
};
</file>

<file path="lambdas/checkbook/validators/request-validator.ts">
import Ajv from 'ajv';
import { createLogger } from '../../../layers/commons/utils/logger_v2';

const logger = createLogger('CheckbookValidator');
const ajv = new Ajv({ allErrors: true });

/**
 * Validates a request against the provided schema
 * @param request - The request object to validate
 * @param schema - JSON schema to validate against
 * @returns Validation result with errors if any
 */
export const validateRequest = (request: any, schema: object) => {
    const validate = ajv.compile(schema);
    const isValid = validate(request);
    
    if (!isValid) {
        logger.warn('Request validation failed', {
            errors: validate.errors,
            request,
        });
        
        return {
            isValid: false,
            errors: formatErrors(validate.errors || []),
        };
    }
    
    return {
        isValid: true,
        errors: [],
    };
};

/**
 * Format AJV errors into a more user-friendly format
 * @param errors - Array of AJV error objects
 * @returns Formatted error messages
 */
const formatErrors = (errors: any[]) => {
    return errors.map((error) => {
        const path = error.instancePath || '';
        const field = path.startsWith('/') ? path.substring(1) : path;
        
        switch (error.keyword) {
            case 'required':
                return {
                    field: error.params.missingProperty,
                    message: `The ${error.params.missingProperty} field is required.`,
                };
            case 'type':
                return {
                    field,
                    message: `The ${field || 'value'} must be a ${error.params.type}.`,
                };
            case 'minLength':
                return {
                    field,
                    message: `The ${field} must be at least ${error.params.limit} characters.`,
                };
            case 'maxLength':
                return {
                    field,
                    message: `The ${field} must not exceed ${error.params.limit} characters.`,
                };
            default:
                return {
                    field: field || 'unknown',
                    message: error.message || 'Invalid input',
                };
        }
    });
};
</file>

<file path="lambdas/checkbook/validators/schemas.ts">
/**
 * JSON schema definitions for request validation
 */

// Schema for user creation
export const createUserSchema = {
    type: 'object',
    required: ['name', 'user_id'],
    properties: {
        name: {
            type: 'string',
            minLength: 2,
            maxLength: 180
        },
        user_id: {
            type: 'string',
            minLength: 2,
            maxLength: 80
        }
    },
    additionalProperties: false
};
</file>

<file path="lambdas/checkbook/webhooks/types.ts">
import * as Joi from 'joi';

/**
 * Enum for possible Checkbook payment statuses
 */
export enum CheckbookPaymentStatus {
    IN_PROCESS = 'IN_PROCESS',
    PAID = 'PAID',
    FAILED = 'FAILED',
    VOID = 'VOID',
    REFUNDED = 'REFUNDED',
}

/**
 * Enum for check deposit options
 */
export enum CheckbookDepositOption {
    STANDARD = 'STANDARD',
    INSTANT = 'INSTANT',
}

/**
 * Enum for Checkbook payment types
 */
export enum CheckbookPaymentType {
    CHECK = 'CHECK',
    DEPOSIT = 'DEPOSIT',
}

/**
 * Interface for Checkbook webhook headers based on observed logs
 */
export interface CheckbookWebhookHeaders {
    'content-length'?: string;
    'x-amzn-tls-version'?: string;
    'x-forwarded-proto'?: string;
    'signature'?: string;
    'x-webhook-id': string;
    'x-forwarded-port'?: string;
    'x-forwarded-for'?: string;
    'accept'?: string;
    'x-amzn-tls-cipher-suite'?: string;
    'x-amzn-trace-id'?: string;
    'x-webhook-source'?: string;
    'host'?: string;
    'content-type'?: string;
    'x-original-timestamp'?: string;
    'accept-encoding'?: string;
    'user-agent'?: string;
}

/**
 * Interface defining the request structure based on observed logs
 */
export interface CheckbookWebhookRequest {
    headers: CheckbookWebhookHeaders;
    body?: string;
    httpMethod?: string;
    requestContext?: {
        http?: {
            method?: string;
            path?: string;
        };
        httpMethod?: string;
    };
    path?: string;
}

/**
 * Interface for Checkbook webhook payload
 * Based on their API documentation and webhook observed structure
 */
export interface CheckbookWebhookPayload {
    // Core fields we require
    status: CheckbookPaymentStatus;
    id: string;
    type: CheckbookPaymentType;

    // Optional fields that might be present
    deposit_option?: CheckbookDepositOption;
    amount?: string | number;
    memo?: string;
    name?: string;
    created_date?: string;
    check_number?: string;

    // Fields that might be in the webhook notification
    event_type?: string;
    event_timestamp?: string;

    // Allow additional fields for forward compatibility
    [key: string]: any;
}

/**
 * Joi schema for validating the webhook headers
 */
export const checkbookWebhookHeadersSchema = Joi.object({
    'x-webhook-id': Joi.string().required().description('Webhook ID'),
    'x-webhook-source': Joi.string().optional().description('Webhook source'),
    'signature': Joi.string().optional().description('Webhook signature'),
    'x-original-timestamp': Joi.string().optional().description('Original timestamp'),
    // Additional headers are optional
}).unknown(true);

/**
 * Joi schema for validating Checkbook webhook payloads
 * The schema is intentionally permissive to handle variations in payload structure
 */
export const checkbookWebhookSchema = Joi.object({
    status: Joi.string()
        .valid(...Object.values(CheckbookPaymentStatus))
        .required()
        .description('Status of the payment'),

    id: Joi.string().required().description('Checkbook payment ID'),

    type: Joi.string()
        .valid(...Object.values(CheckbookPaymentType))
        .required()
        .description('Type of payment'),

    deposit_option: Joi.string()
        .valid(...Object.values(CheckbookDepositOption))
        .optional()
        .description('Deposit option if relevant'),

    // Additional fields that might be present in webhooks
    amount: Joi.alternatives().try(Joi.string(), Joi.number()).optional().description('Payment amount'),

    memo: Joi.string().optional().description('Payment memo'),

    name: Joi.string().optional().description('Recipient name'),

    created_date: Joi.string().optional().description('Creation date of the payment'),

    check_number: Joi.string().optional().description('Check number if available'),

    event_type: Joi.string().optional().description('Type of event that triggered the webhook'),

    event_timestamp: Joi.string().optional().description('Timestamp when event occurred'),
}).unknown(true); // Allow additional fields for forward compatibility
</file>

<file path="lambdas/checkbook/webhooks/webhook-handler.ts">
import { createLogger } from 'commons';
import { Transaction, TransactionStatus } from 'commons';
import { WalletService } from 'commons';
import { CheckbookWebhookPayload, checkbookWebhookSchema, CheckbookPaymentStatus } from './types';

/**
 * Class for handling Checkbook webhook notifications
 */
export class CheckbookWebhookHandler {
    private logger = createLogger('CheckbookWebhookHandler');

    /**
     * Process an incoming webhook notification from Checkbook
     *
     * @param payload The webhook payload from Checkbook
     * @returns A success flag and message
     */
    async processWebhook(webhookData: unknown): Promise<{ success: boolean; message: string }> {
        try {
            // Validate the webhook payload
            const validationResult = checkbookWebhookSchema.validate(webhookData);
            if (validationResult.error) {
                this.logger.error('Invalid webhook payload', {
                    error: validationResult.error.message,
                    receivedPayload: webhookData,
                });
                return {
                    success: false,
                    message: `Invalid webhook payload: ${validationResult.error.message}`,
                };
            }

            // Type-cast to our interface now that it's validated
            const payload = validationResult.value as CheckbookWebhookPayload;

            this.logger.info('Processing Checkbook webhook', {
                checkId: payload.id,
                status: payload.status,
                type: payload.type,
                depositOption: payload.deposit_option,
            });

            // Check for duplicate webhook processing using idempotency key
            const idempotencyKey = `${payload.id}:${payload.status}`;
            this.logger.info('Webhook idempotency key', { idempotencyKey });
            
            // Lookup transaction by Checkbook payment ID (provider transaction ID)
            const transactions = await Transaction.getByProviderTransactionId(payload.id);

            if (!transactions || transactions.length === 0) {
                // Gracefully handle missing transaction without throwing an error
                this.logger.warn('No transaction found for Checkbook payment. This might be expected for test webhooks or newly configured integrations.', { 
                    checkId: payload.id,
                    status: payload.status,
                    type: payload.type 
                });
                
                // Return success even when transaction is not found to prevent retries
                // This is important for handling test webhooks from Checkbook
                return {
                    success: true,
                    message: `No transaction found for Checkbook payment ID: ${payload.id}. Acknowledging webhook.`,
                };
            }

            this.logger.info('Found transactions for Checkbook payment', {
                checkId: payload.id,
                count: transactions.length,
                transactionIds: transactions.map((t: Transaction) => t.transactionId),
            });

            // Map Checkbook status to our transaction status
            const newStatus = this.mapCheckbookStatusToTransactionStatus(payload.status);

            // Process each transaction (typically should be just one)
            for (const transaction of transactions) {
                // Check for idempotency - skip if transaction already has the desired status
                if (transaction.status === newStatus) {
                    this.logger.info('Transaction already has the desired status, skipping update for idempotency', {
                        transactionId: transaction.transactionId,
                        status: transaction.status,
                        desiredStatus: newStatus,
                        idempotencyKey
                    });
                    
                    // Skip this transaction since it's already in the desired state
                    continue;
                }
                
                // Also check if this exact webhook was already processed
                if (transaction.metadata?.processedWebhooks?.includes(idempotencyKey)) {
                    this.logger.info('This exact webhook was already processed for this transaction, skipping for idempotency', {
                        transactionId: transaction.transactionId,
                        idempotencyKey,
                        processedWebhooks: transaction.metadata?.processedWebhooks
                    });
                    
                    // Skip this transaction since this webhook was already processed
                    continue;
                }
                
                // If transaction is already completed, log and skip
                if (transaction.status === TransactionStatus.COMPLETED && 
                    newStatus !== TransactionStatus.CANCELLED && 
                    newStatus !== TransactionStatus.FAILED) {
                    
                    this.logger.info('Transaction is already completed, cannot change to another status except cancelled or failed', {
                        transactionId: transaction.transactionId,
                        currentStatus: transaction.status,
                        requestedStatus: newStatus
                    });
                    
                    continue;
                }

                await this.updateTransactionStatus(transaction, newStatus, payload, idempotencyKey);
            }

            return {
                success: true,
                message: `Successfully processed webhook for payment ID: ${payload.id}`,
            };
        } catch (error) {
            this.logger.error('Error processing Checkbook webhook', {
                error: error instanceof Error ? error.message : String(error),
                stack: error instanceof Error ? error.stack : undefined,
                webhookData,
            });

            return {
                success: false,
                message: `Error processing webhook: ${error instanceof Error ? error.message : String(error)}`,
            };
        }
    }

    /**
     * Maps Checkbook payment status to our internal TransactionStatus
     *
     * @param checkbookStatus The status from Checkbook
     * @returns Our internal TransactionStatus
     */
    private mapCheckbookStatusToTransactionStatus(checkbookStatus: CheckbookPaymentStatus): TransactionStatus {
        switch (checkbookStatus) {
            case CheckbookPaymentStatus.PAID:
                return TransactionStatus.COMPLETED;
            case CheckbookPaymentStatus.FAILED:
                return TransactionStatus.FAILED;
            case CheckbookPaymentStatus.VOID:
            case CheckbookPaymentStatus.REFUNDED:
                return TransactionStatus.CANCELLED;
            case CheckbookPaymentStatus.IN_PROCESS:
            default:
                return TransactionStatus.PENDING;
        }
    }

    /**
     * Update transaction status based on webhook data and handle refunds if needed
     *
     * @param transaction The transaction to update
     * @param newStatus The new transaction status
     * @param webhookData The original webhook data
     * @param idempotencyKey Unique key for this webhook event
     */
    private async updateTransactionStatus(
        transaction: Transaction,
        newStatus: TransactionStatus,
        webhookData: CheckbookWebhookPayload,
        idempotencyKey: string,
    ): Promise<void> {
        const oldStatus = transaction.status;

        // Skip if status hasn't changed - idempotency check
        if (oldStatus === newStatus) {
            this.logger.info('Transaction status unchanged, no update needed', {
                transactionId: transaction.transactionId,
                status: oldStatus,
                checkbookId: webhookData.id,
            });
            return;
        }

        // Add webhook information to transaction metadata
        if (!transaction.metadata) {
            transaction.metadata = {};
        }

        // Track webhook processing for idempotency
        if (!transaction.metadata.processedWebhooks) {
            transaction.metadata.processedWebhooks = [];
        }
        
        // Add this webhook to the list of processed webhooks
        transaction.metadata.processedWebhooks.push(idempotencyKey);

        transaction.metadata.webhookReceivedAt = new Date().toISOString();
        transaction.metadata.checkbookStatus = webhookData.status;
        transaction.metadata.checkbookType = webhookData.type;

        if (webhookData.deposit_option) {
            transaction.metadata.depositOption = webhookData.deposit_option;
        }

        // Special handling based on the new status
        try {
            if (newStatus === TransactionStatus.COMPLETED) {
                // Skip if already completed - extra idempotency check
                if (transaction.status === TransactionStatus.COMPLETED) {
                    this.logger.info('Transaction is already completed, skipping redundant completion', {
                        transactionId: transaction.transactionId,
                        checkbookId: webhookData.id,
                    });
                    return;
                }
                
                // For completed transactions, mark as completed with no wallet update
                // (wallet was already debited when creating the payment)
                this.logger.info('Marking transaction as completed', {
                    transactionId: transaction.transactionId,
                    checkbookId: webhookData.id,
                });

                // Complete without updating the wallet
                await transaction.complete(undefined, false);
            } else if (
                (newStatus === TransactionStatus.FAILED || newStatus === TransactionStatus.CANCELLED) &&
                oldStatus !== TransactionStatus.COMPLETED
            ) {
                // Skip if already failed/cancelled with the same status - extra idempotency check
                if ((transaction.status === TransactionStatus.FAILED && newStatus === TransactionStatus.FAILED) ||
                    (transaction.status === TransactionStatus.CANCELLED && newStatus === TransactionStatus.CANCELLED)) {
                    this.logger.info('Transaction already has the same failed/cancelled status, skipping redundant update', {
                        transactionId: transaction.transactionId,
                        status: transaction.status,
                        checkbookId: webhookData.id,
                    });
                    return;
                }
                
                // For failed or cancelled transactions that were previously pending, handle refund
                // Only refund if transaction was not previously completed
                this.logger.info('Transaction failed or cancelled, handling refund', {
                    transactionId: transaction.transactionId,
                    checkbookId: webhookData.id,
                    oldStatus,
                    newStatus,
                });

                await this.handleRefund(transaction, webhookData);
            } else {
                // Skip if already in the target status - extra idempotency check
                if (transaction.status === newStatus) {
                    this.logger.info('Transaction already has the target status, skipping redundant update', {
                        transactionId: transaction.transactionId,
                        status: transaction.status,
                        targetStatus: newStatus,
                        checkbookId: webhookData.id,
                    });
                    return;
                }
                
                // For any other status change, just update the status
                transaction.status = newStatus;
                await transaction.update();

                this.logger.info('Updated transaction status', {
                    transactionId: transaction.transactionId,
                    checkbookId: webhookData.id,
                    oldStatus,
                    newStatus,
                });
            }
        } catch (error) {
            this.logger.error('Error updating transaction status', {
                transactionId: transaction.transactionId,
                checkbookId: webhookData.id,
                error: error instanceof Error ? error.message : String(error),
            });
            throw error;
        }
    }

    /**
     * Handle refunding a transaction that failed or was cancelled
     *
     * @param transaction The transaction to refund
     * @param webhookData The webhook data that triggered the refund
     */
    private async handleRefund(transaction: Transaction, webhookData: CheckbookWebhookPayload): Promise<void> {
        // Only process refunds for withdrawal transactions where money was taken from wallet
        if (!transaction.senderId || !transaction.senderType || transaction.status === TransactionStatus.COMPLETED) {
            this.logger.info('Transaction not eligible for refund', {
                transactionId: transaction.transactionId,
                checkbookId: webhookData.id,
                senderExists: !!transaction.senderId,
                status: transaction.status,
            });

            // Update the status but don't attempt to refund
            transaction.status = TransactionStatus.FAILED;
            transaction.metadata!.refundEligible = false;
            transaction.metadata!.refundSkipReason = 'Transaction not eligible for refund';

            return transaction.update();
        }

        try {
            // Check if already refunded to prevent double refunds
            if (transaction.metadata?.refunded) {
                this.logger.warn('Transaction already refunded, skipping', {
                    transactionId: transaction.transactionId,
                    checkbookId: webhookData.id,
                    refundedAt: transaction.metadata.refundedAt,
                });

                return;
            }

            this.logger.info('Processing refund for failed transaction', {
                transactionId: transaction.transactionId,
                checkbookId: webhookData.id,
                senderId: transaction.senderId,
                senderType: transaction.senderType,
                amount: transaction.amount.toString(),
            });

            // Refund the sender's wallet by depositing the amount back
            await WalletService.deposit(
                transaction.senderId,
                transaction.senderType,
                transaction.amount,
                transaction.transactionId,
                transaction.currency,
            );

            // Update transaction metadata with refund information
            transaction.metadata!.refunded = true;
            transaction.metadata!.refundedAt = new Date().toISOString();
            transaction.metadata!.refundReason = webhookData.status;

            // Mark transaction as failed
            await transaction.fail(`Payment ${webhookData.status.toLowerCase()}`, false);

            this.logger.info('Successfully refunded transaction', {
                transactionId: transaction.transactionId,
                checkbookId: webhookData.id,
                amount: transaction.amount.toString(),
            });
        } catch (error) {
            this.logger.error('Error refunding transaction', {
                transactionId: transaction.transactionId,
                checkbookId: webhookData.id,
                error: error instanceof Error ? error.message : String(error),
            });

            // Mark the refund as failed in the metadata
            transaction.metadata!.refundFailed = true;
            transaction.metadata!.refundFailureReason = error instanceof Error ? error.message : String(error);
            transaction.metadata!.refundFailureTimestamp = new Date().toISOString();

            // Still mark transaction as failed but without automatic refund
            await transaction.fail(
                `Payment failed but refund failed: ${error instanceof Error ? error.message : String(error)}`,
                false,
            );

            // Don't throw the error to prevent webhook processing from failing
            // The metadata will record the refund failure for investigation
        }
    }
}

// Export singleton instance
export const checkbookWebhookHandler = new CheckbookWebhookHandler();
</file>

<file path="lambdas/checkbook/webhooks/webhook-receiver.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { createLogger } from 'commons';
import { checkbookWebhookHandler } from './webhook-handler';
import { CheckbookWebhookRequest, checkbookWebhookHeadersSchema } from './types';

const logger = createLogger('CheckbookWebhookReceiver');

/**
 * Lambda handler for Checkbook webhook events
 *
 * @param event The API Gateway event
 * @returns API Gateway response
 */
export const handler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    try {
        // Cast event to our more specific webhook request type for better type checking
        const webhookRequest = event as unknown as CheckbookWebhookRequest;
        
        logger.info('Received Checkbook webhook', {
            path: webhookRequest.path,
            httpMethod: webhookRequest.httpMethod,
            headers: webhookRequest.headers,
            requestContext: webhookRequest.requestContext?.http ? {
                method: webhookRequest.requestContext.http.method,
                path: webhookRequest.requestContext.http.path,
            } : undefined,
        });

        // Validate the webhook headers
        const headerValidation = checkbookWebhookHeadersSchema.validate(webhookRequest.headers);
        if (headerValidation.error) {
            logger.warn('Invalid webhook headers', { 
                error: headerValidation.error.message,
                headers: webhookRequest.headers
            });
            // Continue processing as headers might be missing in some cases
        }

        // Some integrations might not properly set httpMethod when using Lambda Function URLs
        // So we check multiple possible sources for the HTTP method
        const method = webhookRequest.requestContext?.http?.method || 
                      webhookRequest.requestContext?.httpMethod || 
                      webhookRequest.httpMethod || 
                      'POST'; // Default to POST for Lambda Function URLs that don't set method
        
        // For Lambda Function URL invocations, assume POST when webhooks come from known sources
        const isWebhookRequest = 
            webhookRequest.headers?.['x-webhook-source'] === 'CLKK-Shared-Service' || 
            webhookRequest.headers?.['x-webhook-id'] !== undefined;

        // Only validate method if we're not getting a webhook from known sources
        if (method !== 'POST' && !isWebhookRequest) {
            logger.warn('Invalid HTTP method', { method, headers: webhookRequest.headers });
            return {
                statusCode: 405,
                body: JSON.stringify({ message: 'Method not allowed' }),
            };
        }

        // Check if body exists
        if (!webhookRequest.body) {
            logger.error('Missing request body');
            return {
                statusCode: 400,
                body: JSON.stringify({ message: 'Missing request body' }),
            };
        }

        // Parse the webhook body
        let webhookData;
        try {
            webhookData = JSON.parse(webhookRequest.body);
            logger.info('Webhook full data:', { webhookData });
        } catch (error) {
            logger.error('Error parsing webhook body', { error, body: webhookRequest.body });
            return {
                statusCode: 400,
                body: JSON.stringify({ message: 'Invalid JSON in request body' }),
            };
        }

        // Process the webhook data
        const result = await checkbookWebhookHandler.processWebhook(webhookData);

        // Return appropriate response
        if (result.success) {
            return {
                statusCode: 200,
                body: JSON.stringify({ message: result.message }),
            };
        } else {
            // For webhook processing, we still return 200 to acknowledge receipt
            // even if there was an error processing the webhook
            // This prevents Checkbook from retrying constantly
            logger.warn('Webhook processing error', { message: result.message });
            return {
                statusCode: 200,
                body: JSON.stringify({
                    message: 'Webhook received but processing had issues',
                    details: result.message,
                }),
            };
        }
    } catch (error) {
        logger.error('Unhandled error in webhook handler', {
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined,
        });

        // Return 200 even on errors to prevent retries
        return {
            statusCode: 200,
            body: JSON.stringify({
                message: 'Webhook received but encountered server error',
                error: error instanceof Error ? error.message : 'Unknown error',
            }),
        };
    }
};
</file>

<file path="lambdas/checkbook/card-encryption.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { KMSClient, GenerateDataKeyCommand } from '@aws-sdk/client-kms';
import { createLogger } from 'commons';

// Create logger for this service
const logger = createLogger('CardEncryption');

// Initialize KMS client
const kmsClient = new KMSClient({ region: process.env.AWS_REGION });

// HTTP Status Codes
enum StatusCodes {
    OK = 200,
    CREATED = 201,
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
}

/**
 * Build a standardized Lambda response
 * @param statusCode - HTTP status code
 * @param body - Response body object
 * @returns Formatted API Gateway response
 */
const buildResponse = (statusCode: number, body: any): APIGatewayProxyResult => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type,Authorization',
            'Access-Control-Allow-Methods': 'OPTIONS,POST,GET,PUT,DELETE',
        },
        body: JSON.stringify(body),
    };
};

/**
 * Generate a data key for client-side encryption
 * This uses the AWS KMS GenerateDataKey API to create a data key that can be used
 * for envelope encryption of sensitive card data on the client.
 *
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response with data key information
 */
export const generateDataKeyHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Generate data key called', { requestId: context.awsRequestId });

    // Get user ID from authorizer
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    try {
        // Use a simplified encryption context to avoid issues
        const encryptionContext = {
            userId: entityId,
        };

        logger.info('Generating data key with context', { encryptionContext });

        // Generate a data key from KMS
        const command = new GenerateDataKeyCommand({
            KeyId: process.env.KMS_KEY_ID,
            KeySpec: 'AES_256',
            // Simplified encryption context
            EncryptionContext: encryptionContext,
        });

        const response = await kmsClient.send(command);

        if (!response.CiphertextBlob || !response.Plaintext) {
            throw new Error('Failed to generate data key - missing required components');
        }

        logger.info('Successfully generated data key');

        // Return both encrypted key and plaintext key to client
        // The client will use plaintext key for encryption
        // The server will store the encrypted key for later decryption
        return buildResponse(StatusCodes.OK, {
            success: true,
            data: {
                // Base64 encode for easy transmission
                encryptedKey: Buffer.from(response.CiphertextBlob).toString('base64'),
                plaintextKey: Buffer.from(response.Plaintext).toString('base64'),
                keyId: process.env.KMS_KEY_ID,
                // Return the same encryption context so client can send it back
                encryptionContext: encryptionContext,
            },
        });
    } catch (error) {
        logger.error('Error generating data key', {
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined,
        });

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: 'Failed to generate data key for encryption',
            },
        });
    }
};
</file>

<file path="lambdas/checkbook/card-test.js">
/**
 * Test script for card encryption
 *
 * Run with:
 * node card-test.js
 */

// Sample card data with correct formats
const correctCardData = {
    card_number: '4111111111111111', // 16 digits
    cvv: '123', // 3 digits
    expiration_date: '2030-01', // YYYY-MM format
    cardholder_name: 'John Doe', // Optional
};

// Sample card data with INCORRECT formats
const incorrectCardData = {
    card_number: '411111111111', // Only 12 digits - TOO SHORT
    cvv: '12', // Only 2 digits - TOO SHORT
    expiration_date: '01/30', // MM/YY format - WRONG FORMAT
    cardholder_name: 'John Doe',
};

// Function to validate card data
function validateCardData(data) {
    const errors = [];

    // Check card_number format
    if (!/^\d{13,19}$/.test(data.card_number)) {
        errors.push('Card number must be 13-19 digits');
    }

    // Check cvv format
    if (!/^\d{3,4}$/.test(data.cvv)) {
        errors.push('CVV must be 3-4 digits');
    }

    // Check expiration_date format - MUST BE YYYY-MM
    if (!/^\d{4}-\d{2}$/.test(data.expiration_date)) {
        errors.push("Expiration date must be in YYYY-MM format (e.g., '2030-01')");
    }

    return {
        isValid: errors.length === 0,
        errors,
    };
}

// Function to format expiration date from MM/YY to YYYY-MM
function formatExpirationDate(mmyy) {
    // Handle MM/YY format
    if (/^\d{2}\/\d{2}$/.test(mmyy)) {
        const [month, year] = mmyy.split('/');
        return `20${year}-${month}`; // Convert to YYYY-MM
    }

    // Handle MMYY format
    if (/^\d{4}$/.test(mmyy)) {
        const month = mmyy.substring(0, 2);
        const year = mmyy.substring(2, 4);
        return `20${year}-${month}`; // Convert to YYYY-MM
    }

    return mmyy; // Return unchanged if not recognized
}

// Test the correct data
console.log('TESTING CORRECT DATA FORMAT:');
console.log(correctCardData);
const correctResult = validateCardData(correctCardData);
console.log(`Valid: ${correctResult.isValid}`);
if (!correctResult.isValid) {
    console.log('Errors:', correctResult.errors);
}

console.log('\n-----------------------------------\n');

// Test the incorrect data
console.log('TESTING INCORRECT DATA FORMAT:');
console.log(incorrectCardData);
const incorrectResult = validateCardData(incorrectCardData);
console.log(`Valid: ${incorrectResult.isValid}`);
if (!incorrectResult.isValid) {
    console.log('Errors:', incorrectResult.errors);
}

console.log('\n-----------------------------------\n');

// Fix common format issues
console.log('FIXING COMMON FORMAT ISSUES:');

// Example: User entered "12/30" (MM/YY) format instead of "2030-12" (YYYY-MM)
const userInput = {
    card_number: '4111111111111111',
    cvv: '123',
    expiration_date: '12/30', // Wrong format
};

console.log('Before:', userInput);

// Fix the expiration date format
const fixedInput = {
    ...userInput,
    expiration_date: formatExpirationDate(userInput.expiration_date),
};

console.log('After:', fixedInput);
const fixedResult = validateCardData(fixedInput);
console.log(`Valid: ${fixedResult.isValid}`);

console.log('\n-----------------------------------\n');

// Examples of how to convert various inputs to YYYY-MM format
console.log('CONVERSION EXAMPLES:');

const conversions = [
    { input: '12/30', output: formatExpirationDate('12/30') },
    { input: '1230', output: formatExpirationDate('1230') },
    { input: '01/2030', output: formatExpirationDate('01/2030') || '2030-01' },
    { input: '01-30', output: formatExpirationDate('01-30') || '2030-01' },
];

console.log('Converting various expiration date formats to YYYY-MM:');
conversions.forEach((item) => {
    console.log(`  ${item.input} â†’ ${item.output}`);
});

console.log('\n-----------------------------------\n');

console.log('INSTRUCTIONS FOR IMPLEMENTATION:');
console.log(`
1. Always use the exact field names:
   - card_number (not cardNumber)
   - cvv 
   - expiration_date (not expirationDate)

2. Format requirements:
   - card_number: 13-19 digits
   - cvv: 3-4 digits
   - expiration_date: YYYY-MM format (e.g., "2030-01")

3. Convert user input:
   - If user enters "MM/YY", convert to "20YY-MM"
   - If user enters "MMYY", convert to "20YY-MM"

4. Example implementation:
   
   function formatCardDataForAPI(userInput) {
     return {
       card_number: userInput.cardNumber.replace(/\\D/g, ''),
       cvv: userInput.cvv,
       expiration_date: formatExpirationDate(userInput.expirationDate),
       cardholder_name: userInput.name
     };
   }
`);
</file>

<file path="lambdas/checkbook/card.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { createLogger } from 'commons';
import { CheckbookCardService } from './services/checkbook-card-service';
import { validateCardId, validateCreateCardRequest, validateUpdateCardRequest } from './validators/card-validator';
import { KMSClient, DecryptCommand } from '@aws-sdk/client-kms';

// HTTP Status Codes
enum StatusCodes {
    OK = 200,
    CREATED = 201,
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
}

const logger = createLogger('CheckbookCardHandlers');

const environment = (process.env.CHECKBOOK_ENVIRONMENT || 'SANDBOX') as 'DEMO' | 'SANDBOX' | 'PRODUCTION';
const timeout = parseInt(process.env.CHECKBOOK_API_TIMEOUT || '10000', 10);

// Initialize service
const cardService = new CheckbookCardService(environment, timeout);

// Initialize KMS client for decryption
const kmsClient = new KMSClient({ region: process.env.AWS_REGION });

/**
 * Build a standardized Lambda response
 * @param statusCode - HTTP status code
 * @param body - Response body object
 * @returns Formatted API Gateway response
 */
const buildResponse = (statusCode: number, body: any): APIGatewayProxyResult => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type,Authorization',
            'Access-Control-Allow-Methods': 'OPTIONS,POST,GET,PUT,DELETE',
        },
        body: JSON.stringify(body),
    };
};

/**
 * Decrypt data encrypted with a data key
 * @param encryptedData - Base64 encoded encrypted data
 * @param encryptedDataKey - Base64 encoded encrypted data key from KMS
 * @param encryptionContext - The encryption context used during key generation
 * @returns Decrypted data as string
 */
async function decryptWithDataKey(
    encryptedData: string,
    encryptedDataKey: string,
    encryptionContext: Record<string, string>,
): Promise<string> {
    try {
        logger.info('Starting KMS data key decryption', {
            keyId: process.env.KMS_KEY_ID,
            encryptionContext,
        });

        // 1. First decrypt the data key with KMS
        const decryptCommand = new DecryptCommand({
            CiphertextBlob: Buffer.from(encryptedDataKey, 'base64'),
            // Using optional KeyId can help verify you're using the correct key
            KeyId: process.env.KMS_KEY_ID,
            // Must match the encryption context used during key generation
            EncryptionContext: encryptionContext,
        });

        logger.info('Sending KMS decrypt command');
        const decryptResponse = await kmsClient.send(decryptCommand);

        if (!decryptResponse.Plaintext) {
            logger.error('KMS decrypt response missing plaintext');
            throw new Error('Failed to decrypt data key - no plaintext returned');
        }

        logger.info('Successfully decrypted data key');
        const plaintextKey = decryptResponse.Plaintext;

        // 2. Use the plaintext key to decrypt the data
        const crypto = require('crypto');

        // Extract IV and ciphertext from the encrypted data
        // Format: [IV (16 bytes)][Ciphertext]
        const encryptedBuffer = Buffer.from(encryptedData, 'base64');

        // Ensure encrypted data is valid
        if (encryptedBuffer.length <= 16) {
            logger.error('Invalid encrypted data format - too short');
            throw new Error('Invalid encrypted data format');
        }

        const iv = encryptedBuffer.slice(0, 16);
        const ciphertext = encryptedBuffer.slice(16);

        // Create decipher with the plaintext key and IV
        const decipher = crypto.createDecipheriv('aes-256-cbc', plaintextKey, iv);

        // Decrypt the data
        try {
            const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()]);

            logger.info('Successfully decrypted card data field');
            return decrypted.toString('utf8');
        } catch (cryptoError) {
            logger.error('Crypto decryption error', {
                error: cryptoError instanceof Error ? cryptoError.message : String(cryptoError),
            });
            throw new Error(
                'Failed to decrypt data: ' +
                    (cryptoError instanceof Error ? cryptoError.message : 'unknown crypto error'),
            );
        }
    } catch (error) {
        logger.error('Error decrypting data', {
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined,
        });
        throw new Error('Failed to decrypt card data: ' + (error instanceof Error ? error.message : 'unknown error'));
    }
}

/**
 * Add a new card in Checkbook
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const addCardHandler = async (event: APIGatewayProxyEvent, context: Context): Promise<APIGatewayProxyResult> => {
    logger.info('Add card called', { requestId: context.awsRequestId });

    //log body
    logger.info('Add card body', { body: event.body });

    // Get user ID from authorizer
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    try {
        // Parse request body
        const parsedBody = event.body ? JSON.parse(event.body) : {};

        let cardData;

        // Check if data is encrypted
        if (parsedBody.encrypted === true && parsedBody.encryptedDataKey) {
            try {
                logger.info('Decrypting encrypted card data', { entityId });

                // Get encryption context from request or create a basic one
                const encryptionContext = parsedBody.encryptionContext || { userId: entityId };

                // Decrypt each sensitive field
                cardData = {
                    ...parsedBody,
                    card_number: await decryptWithDataKey(
                        parsedBody.card_number,
                        parsedBody.encryptedDataKey,
                        encryptionContext,
                    ),
                    cvv: await decryptWithDataKey(parsedBody.cvv, parsedBody.encryptedDataKey, encryptionContext),
                    expiration_date: await decryptWithDataKey(
                        parsedBody.expiration_date,
                        parsedBody.encryptedDataKey,
                        encryptionContext,
                    ),
                    encrypted: false, // Mark as decrypted
                };

                logger.info('Successfully decrypted card data');
            } catch (decryptError) {
                logger.error('Failed to decrypt card data', {
                    entityId,
                    error: decryptError instanceof Error ? decryptError.message : String(decryptError),
                });

                return buildResponse(StatusCodes.BAD_REQUEST, {
                    success: false,
                    error: {
                        code: 'DECRYPTION_ERROR',
                        message:
                            'Failed to decrypt card data: ' +
                            (decryptError instanceof Error ? decryptError.message : 'unknown error'),
                    },
                });
            }
        } else {
            // Use the original data if not encrypted
            cardData = parsedBody;
        }

        //Log the card data
        logger.info('Adding card', { entityId, cardData });

        // Validate the card data (whether decrypted or original)
        const validationResult = validateCreateCardRequest(cardData);

        if (validationResult.error) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: validationResult.error.message,
                },
            });
        }

        // Add card
        const response = await cardService.addCard(entityId, validationResult.value);

        return buildResponse(StatusCodes.CREATED, {
            success: true,
            data: response,
        });
    } catch (error) {
        logger.error('Error adding card', {
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined,
            entityId,
        });

        // Handle specific error cases
        if (error instanceof Error) {
            if (error.message.includes('User does not have a Checkbook account')) {
                return buildResponse(StatusCodes.BAD_REQUEST, {
                    success: false,
                    error: {
                        code: 'NO_CHECKBOOK_ACCOUNT',
                        message: 'User does not have a Checkbook account',
                    },
                });
            }
        }

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unknown error occurred',
            },
        });
    }
};

/**
 * Get all cards for a user
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const getCardsHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Get cards called', { requestId: context.awsRequestId });

    // Get user ID from authorizer
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    try {
        // Get cards
        const cards = await cardService.getCards(entityId);

        return buildResponse(StatusCodes.OK, {
            success: true,
            data: {
                cards,
            },
        });
    } catch (error) {
        logger.error('Error getting cards', { error, entityId });

        // Handle specific error cases
        if (error instanceof Error) {
            if (error.message.includes('User does not have a Checkbook account')) {
                return buildResponse(StatusCodes.BAD_REQUEST, {
                    success: false,
                    error: {
                        code: 'NO_CHECKBOOK_ACCOUNT',
                        message: 'User does not have a Checkbook account',
                    },
                });
            }
        }

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unknown error occurred',
            },
        });
    }
};

/**
 * Update a card in Checkbook
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const updateCardHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Update card called', { requestId: context.awsRequestId });

    // Get user ID from authorizer
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    // Get card ID from path parameters
    const cardId = event.pathParameters?.card_id;

    if (!cardId || !validateCardId(cardId)) {
        return buildResponse(StatusCodes.BAD_REQUEST, {
            success: false,
            error: {
                code: 'INVALID_CARD_ID',
                message: 'Invalid card ID',
            },
        });
    }

    try {
        // Parse and validate request body
        const parsedBody = event.body ? JSON.parse(event.body) : {};
        const validationResult = validateUpdateCardRequest(parsedBody);

        if (validationResult.error) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: validationResult.error.message,
                },
            });
        }

        // Update card
        const response = await cardService.updateCard(entityId, cardId, validationResult.value);

        return buildResponse(StatusCodes.OK, {
            success: true,
            data: response,
        });
    } catch (error) {
        logger.error('Error updating card', { error, entityId, cardId });

        // Handle specific error cases
        if (error instanceof Error) {
            if (error.message.includes('User does not have a Checkbook account')) {
                return buildResponse(StatusCodes.BAD_REQUEST, {
                    success: false,
                    error: {
                        code: 'NO_CHECKBOOK_ACCOUNT',
                        message: 'User does not have a Checkbook account',
                    },
                });
            }
            if (error.message.includes('Card not found')) {
                return buildResponse(StatusCodes.NOT_FOUND, {
                    success: false,
                    error: {
                        code: 'CARD_NOT_FOUND',
                        message: 'Card not found or does not belong to the user',
                    },
                });
            }
        }

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unknown error occurred',
            },
        });
    }
};

/**
 * Remove a card from Checkbook
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const removeCardHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Remove card called', { requestId: context.awsRequestId });

    // Get user ID from authorizer
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    // Get card ID from path parameters
    const cardId = event.pathParameters?.card_id;

    if (!cardId || !validateCardId(cardId)) {
        return buildResponse(StatusCodes.BAD_REQUEST, {
            success: false,
            error: {
                code: 'INVALID_CARD_ID',
                message: 'Invalid card ID',
            },
        });
    }

    try {
        // Remove card
        const response = await cardService.removeCard(entityId, cardId);

        return buildResponse(StatusCodes.OK, {
            success: true,
            data: response,
        });
    } catch (error) {
        logger.error('Error removing card', { error, entityId, cardId });

        // Handle specific error cases
        if (error instanceof Error) {
            if (error.message.includes('User does not have a Checkbook account')) {
                return buildResponse(StatusCodes.BAD_REQUEST, {
                    success: false,
                    error: {
                        code: 'NO_CHECKBOOK_ACCOUNT',
                        message: 'User does not have a Checkbook account',
                    },
                });
            }
            if (error.message.includes('Card not found')) {
                return buildResponse(StatusCodes.NOT_FOUND, {
                    success: false,
                    error: {
                        code: 'CARD_NOT_FOUND',
                        message: 'Card not found or does not belong to the user',
                    },
                });
            }
        }

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unknown error occurred',
            },
        });
    }
};
</file>

<file path="lambdas/checkbook/checkbook.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { CheckbookService } from './services/checkbook-service';
import { createLogger } from 'commons';
import { CHECKBOOK_API_URLS } from './config';
import { handler as webhookHandler } from './webhooks/webhook-receiver';

// HTTP Status Codes
enum StatusCodes {
    OK = 200,
    CREATED = 201,
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
}

const logger = createLogger('CheckbookHandlers');

const checkbookConfig = {
    apiUrl: process.env.CHECKBOOK_API_URL || CHECKBOOK_API_URLS.SANDBOX.BASE,
    apiKey: process.env.CHECKBOOK_PUBLISHABLE_API_KEY_ARN || '',
    apiSecret: process.env.CHECKBOOK_SECRET_API_KEY_ARN || '',
    timeout: parseInt(process.env.CHECKBOOK_API_TIMEOUT || '10000', 10),
    environment: (process.env.CHECKBOOK_ENVIRONMENT || 'SANDBOX') as 'SANDBOX' | 'PRODUCTION',
};

// Initialize service
const checkbookService = new CheckbookService(checkbookConfig);

/**
 * Build a standardized Lambda response
 * @param statusCode - HTTP status code
 * @param body - Response body object
 * @returns Formatted API Gateway response
 */
const buildResponse = (statusCode: number, body: any): APIGatewayProxyResult => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type,Authorization',
            'Access-Control-Allow-Methods': 'OPTIONS,POST,GET',
        },
        body: JSON.stringify(body),
    };
};

/**
 * Create a new user in Checkbook API
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const createUserHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Create Checkbook user called', { requestId: context.awsRequestId });

    // Get user ID from authorizer
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    try {
        logger.info('Processing Checkbook user creation for user', { entityId });

        const response = await checkbookService.createUser(entityId);

        return buildResponse(StatusCodes.CREATED, {
            success: true,
            data: {
                id: response.id,
                key: response.key,
                user_id: response.user_id,
            },
        });
    } catch (error) {
        logger.error('Error creating Checkbook user', error);

        // Handle specific errors
        if (error instanceof Error) {
            if (error.message.includes('already has a Checkbook account')) {
                return buildResponse(StatusCodes.BAD_REQUEST, {
                    success: false,
                    error: {
                        code: 'USER_EXISTS',
                        message: 'User already has a Checkbook account',
                    },
                });
            }
        }

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unknown error occurred',
            },
        });
    }
};

/**
 * Get user's Checkbook data
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const getUserDataHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Get Checkbook user data called', { requestId: context.awsRequestId });

    // Get user ID from authorizer
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    try {
        // Get user's Checkbook data
        const userData = await checkbookService.getUserCheckbookData(entityId);

        if (!userData) {
            return buildResponse(StatusCodes.NOT_FOUND, {
                success: false,
                error: {
                    code: 'NOT_FOUND',
                    message: 'No Checkbook account found for this user',
                },
            });
        }

        return buildResponse(StatusCodes.OK, {
            success: true,
            data: {
                checkbookId: userData.checkbookId,
                checkbookKey: userData.checkbookKey,
                createdAt: userData.createdAt,
                // Note: We don't return the secret
            },
        });
    } catch (error) {
        logger.error('Error getting Checkbook user data', error);

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unknown error occurred',
            },
        });
    }
};

// Export webhook handler
export { webhookHandler };
</file>

<file path="lambdas/checkbook/package.json">
{
    "name": "checkbook",
    "version": "1.0.0",
    "description": "Checkbook Payment API Integration",
    "main": "dist/app.js",
    "author": "CLKK",
    "license": "MIT",
    "scripts": {
        "unit": "jest",
        "lint": "eslint '*.ts' --quiet --fix",
        "compile": "tsc",
        "test": "npm run compile && npm run unit"
    },
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0",
        "@aws-sdk/client-dynamodb": "^3.716.0",
        "@aws-sdk/client-kms": "^3.797.0",
        "@aws-sdk/client-secrets-manager": "^3.716.0",
        "@aws-sdk/lib-dynamodb": "^3.789.0",
        "ajv": "^8.12.0",
        "axios": "^1.8.4",
        "joi": "^17.13.3",
        "uuid": "^9.0.0"
    },
    "devDependencies": {
        "@jest/globals": "^29.2.0",
        "@types/aws-lambda": "^8.10.146",
        "@types/jest": "^29.2.0",
        "@types/node": "^18.11.4",
        "@typescript-eslint/eslint-plugin": "^5.10.2",
        "@typescript-eslint/parser": "^5.10.2",
        "esbuild": "^0.14.14",
        "eslint": "^8.8.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^29.2.1",
        "prettier": "^2.5.1",
        "ts-jest": "^29.0.5",
        "ts-node": "^10.9.1",
        "typescript": "^4.8.4"
    },
    "esbuild": {
        "config": "./esbuild.config.js"
    }
}
</file>

<file path="lambdas/checkbook/payment.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { CheckbookPaymentService } from './services/checkbook-payment-service';
import { createLogger } from 'commons';
import { CreateDigitalCheckRequest } from './types/payment';
import { validateDigitalCheckRequest } from './validators/digital-check-validator';

// HTTP Status Codes
enum StatusCodes {
    OK = 200,
    CREATED = 201,
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
}

const logger = createLogger('CheckbookPaymentHandlers');

// Initialize service
const checkbookPaymentService = new CheckbookPaymentService(
    (process.env.CHECKBOOK_ENVIRONMENT || 'SANDBOX') as 'SANDBOX' | 'PRODUCTION',
    parseInt(process.env.CHECKBOOK_API_TIMEOUT || '30000', 10),
);

/**
 * Build a standardized Lambda response
 * @param statusCode - HTTP status code
 * @param body - Response body object
 * @returns Formatted API Gateway response
 */
const buildResponse = (statusCode: number, body: any): APIGatewayProxyResult => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type,Authorization',
            'Access-Control-Allow-Methods': 'OPTIONS,POST,GET',
        },
        body: JSON.stringify(body),
    };
};

/**
 * Create a digital check payment
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const createDigitalCheckHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Create digital check called', { requestId: context.awsRequestId });

    // Get user ID from authorizer of the user making the request for a digital check
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    try {
        // Parse and validate request body
        if (!event.body) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'INVALID_REQUEST',
                    message: 'Request body is required',
                },
            });
        }

        let requestBody: CreateDigitalCheckRequest;
        try {
            requestBody = JSON.parse(event.body) as CreateDigitalCheckRequest;
        } catch (error) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'INVALID_JSON',
                    message: 'Invalid JSON in request body',
                },
            });
        }

        // Validate request using our validator
        const validationError = validateDigitalCheckRequest(requestBody);
        if (validationError) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: validationError,
                },
            });
        }

        logger.info('Processing digital check creation', {
            entityId,
            amount: requestBody.amount,
            recipientId: requestBody.recipientId,
            transactionType: requestBody.transactionType || 'withdrawal',
        });

        // Create the digital check
        const response = await checkbookPaymentService.createDigitalCheck(entityId, requestBody);

        return buildResponse(StatusCodes.CREATED, {
            success: true,
            data: response,
        });
    } catch (error) {
        logger.error('Error creating digital check', {
            error: error instanceof Error ? error.message : 'Unknown error',
            stack: error instanceof Error ? error.stack : undefined,
        });

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unknown error occurred',
            },
        });
    }
};

/**
 * Deposit a payment to a specified account
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const depositPaymentHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Deposit payment called', { requestId: context.awsRequestId });

    // Get user ID from authorizer
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    try {
        // Get check ID from path parameter
        const checkId = event.pathParameters?.check_id;
        if (!checkId) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'MISSING_PARAMETER',
                    message: 'Check ID is required',
                },
            });
        }

        // Parse and validate request body
        if (!event.body) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'INVALID_REQUEST',
                    message: 'Request body is required',
                },
            });
        }

        // Parse the request body
        let requestBody: { account: string };
        try {
            requestBody = JSON.parse(event.body) as { account: string };
        } catch (error) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'INVALID_JSON',
                    message: 'Invalid JSON in request body',
                },
            });
        }

        // Validate account ID is provided
        if (!requestBody.account) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'MISSING_PARAMETER',
                    message: 'Account ID is required',
                },
            });
        }

        logger.info('Processing payment deposit', {
            entityId,
            checkId,
            accountId: requestBody.account,
        });

        // Deposit the payment
        const response = await checkbookPaymentService.depositPayment(entityId, checkId, requestBody.account);

        return buildResponse(StatusCodes.CREATED, {
            success: true,
            data: response,
        });
    } catch (error) {
        logger.error('Error depositing payment', {
            error: error instanceof Error ? error.message : 'Unknown error',
            stack: error instanceof Error ? error.stack : undefined,
        });

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unknown error occurred',
            },
        });
    }
};

/**
 * Get payment details by ID
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const getPaymentHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Get payment details called', { requestId: context.awsRequestId });

    // Get user ID from authorizer
    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, {
            success: false,
            error: {
                code: 'UNAUTHORIZED',
                message: 'User authentication required',
            },
        });
    }

    try {
        // Get check ID from path parameter
        const checkId = event.pathParameters?.check_id;
        if (!checkId) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: {
                    code: 'MISSING_PARAMETER',
                    message: 'Check ID is required',
                },
            });
        }

        logger.info('Processing payment details request', {
            entityId,
            checkId,
        });

        // Get payment details
        const response = await checkbookPaymentService.getPayment(entityId, checkId);

        return buildResponse(StatusCodes.OK, {
            success: true,
            data: response,
        });
    } catch (error) {
        logger.error('Error retrieving payment details', {
            error: error instanceof Error ? error.message : 'Unknown error',
            stack: error instanceof Error ? error.stack : undefined,
        });

        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unknown error occurred',
            },
        });
    }
};
</file>

<file path="lambdas/checkbook/README-client-encryption.md">
# Client-Side Card Data Encryption Guide

This guide shows exactly how to implement secure client-side encryption for card data with AWS KMS.

## Fields to Encrypt

Only encrypt these three fields (with exact field names):

-   `card_number` (NOT cardNumber)
-   `cvv`
-   `expiration_date` (NOT expirationDate)

## Step-by-Step Implementation

### Step 1: Install Required Library

```bash
npm install crypto-js
# or
yarn add crypto-js
```

### Step 2: Create Encryption Utility (CardEncryption.js)

```javascript
// CardEncryption.js
import CryptoJS from 'crypto-js';

// Get a data key from our API
async function getDataKey(apiUrl, authToken) {
    try {
        const response = await fetch(`${apiUrl}/checkbook/generate-data-key`, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${authToken}`,
                'Content-Type': 'application/json',
            },
        });

        const result = await response.json();

        if (!result.success) {
            throw new Error(result.error?.message || 'Failed to get encryption key');
        }

        console.log('Successfully obtained data key');
        return result.data;
    } catch (error) {
        console.error('Error getting data key:', error);
        throw error;
    }
}

// Encrypt a single field with the data key
function encryptField(value, plaintextKey) {
    // Convert base64 key to format CryptoJS can use
    const key = CryptoJS.enc.Base64.parse(plaintextKey);

    // Create random initialization vector (16 bytes)
    const iv = CryptoJS.lib.WordArray.random(16);

    // Encrypt the data
    const encrypted = CryptoJS.AES.encrypt(value, key, {
        iv: iv,
        padding: CryptoJS.pad.Pkcs7,
        mode: CryptoJS.mode.CBC,
    });

    // Combine IV and encrypted data - THIS FORMAT IS CRITICAL
    const combined = iv.concat(encrypted.ciphertext);

    // Return as base64 string
    return CryptoJS.enc.Base64.stringify(combined);
}

// Encrypt card data before sending to server
export async function encryptCardData(cardData, apiUrl, authToken) {
    try {
        // Validate formats before encrypting
        if (!/^\d{13,19}$/.test(cardData.card_number)) {
            throw new Error('Card number must be 13-19 digits');
        }

        if (!/^\d{3,4}$/.test(cardData.cvv)) {
            throw new Error('CVV must be 3-4 digits');
        }

        if (!/^\d{4}-\d{2}$/.test(cardData.expiration_date)) {
            throw new Error('Expiration date must be in YYYY-MM format (e.g., "2030-01")');
        }

        // 1. Get encryption key from server
        const dataKey = await getDataKey(apiUrl, authToken);

        // 2. Extract encryption context to send back
        const encryptionContext = dataKey.encryptionContext;

        // 3. Encrypt ONLY the sensitive fields - use exact field names!
        const encryptedCardData = {
            ...cardData, // Keep other fields as is

            // Encrypt the three sensitive fields
            card_number: encryptField(cardData.card_number, dataKey.plaintextKey),
            cvv: encryptField(cardData.cvv, dataKey.plaintextKey),
            expiration_date: encryptField(cardData.expiration_date, dataKey.plaintextKey),

            // Add these fields so server knows data is encrypted
            encrypted: true,
            encryptedDataKey: dataKey.encryptedKey,
            encryptionContext: encryptionContext,
        };

        console.log('Card data encrypted successfully');
        return encryptedCardData;
    } catch (error) {
        console.error('Error encrypting card data:', error);
        throw error;
    }
}

// Submit encrypted card data to API
export async function submitEncryptedCardData(cardData, apiUrl, authToken) {
    try {
        // 1. Encrypt the card data
        const encryptedData = await encryptCardData(cardData, apiUrl, authToken);

        // 2. Submit to API
        const response = await fetch(`${apiUrl}/checkbook/card`, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${authToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(encryptedData),
        });

        // 3. Parse and return response
        const result = await response.json();

        if (!result.success) {
            console.error('API error:', result.error);
            throw new Error(result.error?.message || 'Failed to add card');
        }

        console.log('Card added successfully');
        return result;
    } catch (error) {
        console.error('Error submitting card:', error);
        throw error;
    }
}
```

### Step 3: Usage in React Component

```jsx
import React, { useState } from 'react';
import { submitEncryptedCardData } from './CardEncryption';

function CardForm({ apiUrl, getAuthToken }) {
    const [formData, setFormData] = useState({
        card_number: '', // IMPORTANT: Use exact field names
        cvv: '', // IMPORTANT: Use exact field names
        expiration_date: '', // IMPORTANT: Use exact field names
        name: '',
        isDefault: true,
    });

    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');
    const [success, setSuccess] = useState(false);

    const handleChange = (e) => {
        const { name, value, type, checked } = e.target;
        setFormData({
            ...formData,
            [name]: type === 'checkbox' ? checked : value,
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setLoading(true);
        setError('');
        setSuccess(false);

        try {
            // Get auth token
            const authToken = await getAuthToken();

            // Submit card data with encryption
            const result = await submitEncryptedCardData(formData, apiUrl, authToken);

            // Handle success
            setSuccess(true);
            setFormData({
                card_number: '',
                cvv: '',
                expiration_date: '',
                name: '',
                isDefault: true,
            });
        } catch (err) {
            setError(err.message || 'An error occurred');
        } finally {
            setLoading(false);
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            {error && <div className="error">{error}</div>}
            {success && <div className="success">Card added successfully!</div>}

            <div>
                <label htmlFor="card_number">Card Number</label>
                <input
                    id="card_number"
                    name="card_number"
                    value={formData.card_number}
                    onChange={handleChange}
                    required
                />
            </div>

            <div>
                <label htmlFor="cvv">CVV</label>
                <input id="cvv" name="cvv" value={formData.cvv} onChange={handleChange} required />
            </div>

            <div>
                <label htmlFor="expiration_date">Expiration Date (YYYY-MM)</label>
                <input
                    id="expiration_date"
                    name="expiration_date"
                    value={formData.expiration_date}
                    onChange={handleChange}
                    placeholder="2030-01"
                    required
                />
            </div>

            <div>
                <label htmlFor="name">Name on Card</label>
                <input id="name" name="name" value={formData.name} onChange={handleChange} required />
            </div>

            <div>
                <label>
                    <input type="checkbox" name="isDefault" checked={formData.isDefault} onChange={handleChange} />
                    Set as default card
                </label>
            </div>

            <button type="submit" disabled={loading}>
                {loading ? 'Adding Card...' : 'Add Card'}
            </button>
        </form>
    );
}

export default CardForm;
```

## Example Request/Response Flow

### 1. Getting a Data Key

**Request:**

```
POST /checkbook/generate-data-key
Authorization: Bearer your-auth-token
```

**Response:**

```json
{
    "success": true,
    "data": {
        "encryptedKey": "AQICAHi...Base64EncodedEncryptedKey...",
        "plaintextKey": "xk8J...Base64EncodedPlaintextKey...",
        "keyId": "arn:aws:kms:region:account:key/key-id",
        "encryptionContext": {
            "userId": "user_123456"
        }
    }
}
```

### 2. Sending Encrypted Card Data

**Original Data:**

```json
{
    "card_number": "4111111111111188",
    "cvv": "411",
    "expiration_date": "2030-01",
    "name": "John Doe",
    "isDefault": true
}
```

**Encrypted Request:**

```json
{
    "card_number": "azB4...Base64EncodedEncryptedCardNumber...",
    "cvv": "dK9P...Base64EncodedEncryptedCVV...",
    "expiration_date": "Tx7R...Base64EncodedEncryptedExpirationDate...",
    "name": "John Doe",
    "isDefault": true,
    "encrypted": true,
    "encryptedDataKey": "AQICAHi...Base64EncodedEncryptedKey...",
    "encryptionContext": {
        "userId": "user_123456"
    }
}
```

**Response:**

```json
{
    "success": true,
    "data": {
        "cardId": "card_12345",
        "lastFourDigits": "1188",
        "expirationDate": "2030-01",
        "name": "John Doe",
        "isDefault": true
    }
}
```

## Troubleshooting

If you encounter `DECRYPTION_ERROR` from the server:

1. **Check field names** - Make sure you're using `card_number`, `cvv`, and `expiration_date` (not camelCase)
2. **Check encryption context** - Make sure you're sending back the exact same context received from the key generation API
3. **Check IV prepending** - The IV must be the first 16 bytes of the encrypted data
4. **Check Base64 encoding** - Make sure you're properly base64 encoding both the encrypted data and the encrypted key

For security, never log the encrypted data key, plaintext key, or raw card data in production.

## Exact Required Field Formats

The following formats are strictly required by the server validator:

1. **card_number**:

    - Must be 13-19 digits
    - Example: "4111111111111111"

2. **cvv**:

    - Must be 3-4 digits
    - Example: "123" or "1234"

3. **expiration_date**:
    - Must be in YYYY-MM format
    - Example: "2030-01" (for January 2030)
    - âš ï¸ NOT "01/30" or "1230" or any other format

**Original Data (Correct Format):**

```json
{
    "card_number": "4111111111111111",
    "cvv": "411",
    "expiration_date": "2030-01",
    "name": "John Doe",
    "isDefault": true
}
```
</file>

<file path="lambdas/checkbook/simple-card-encrypt.js">
/**
 * Simple card encryption example
 * This shows exactly how to prepare and encrypt card data for the API
 */

// ===== USER INPUT CONVERSION FUNCTIONS =====

// Convert user input format (MM/YY) to API format (YYYY-MM)
function formatExpirationDate(userInput) {
    // Handle MM/YY format (e.g., "12/30")
    if (/^\d{2}\/\d{2}$/.test(userInput)) {
        const [month, year] = userInput.split('/');
        return `20${year}-${month}`; // "12/30" â†’ "2030-12"
    }

    // Handle MMYY format (e.g., "1230")
    if (/^\d{4}$/.test(userInput)) {
        const month = userInput.substring(0, 2);
        const year = userInput.substring(2, 4);
        return `20${year}-${month}`; // "1230" â†’ "2030-12"
    }

    // Return as is if it's already in YYYY-MM format
    if (/^\d{4}-\d{2}$/.test(userInput)) {
        return userInput;
    }

    // Otherwise, let validation catch the error
    return userInput;
}

// Format card data from form input to API format
function formatCardDataForAPI(userInput) {
    return {
        // Remove any non-digits from card number
        card_number: userInput.cardNumber.replace(/\D/g, ''),

        // CVV as is (will be validated)
        cvv: userInput.cvv,

        // Convert expiration date to YYYY-MM format
        expiration_date: formatExpirationDate(userInput.expirationDate),

        // Optional fields
        cardholder_name: userInput.name,
        isDefault: userInput.isDefault || false,
    };
}

// ===== ENCRYPTION & API FUNCTIONS =====

// Get a data key from the API
async function getDataKey(apiBaseUrl, authToken) {
    const response = await fetch(`${apiBaseUrl}/checkbook/generate-data-key`, {
        method: 'POST',
        headers: {
            Authorization: `Bearer ${authToken}`,
            'Content-Type': 'application/json',
        },
    });

    const result = await response.json();

    if (!result.success) {
        throw new Error(`Failed to get encryption key: ${result.error?.message || 'Unknown error'}`);
    }

    return result.data;
}

// Encrypt a single field with the data key
function encryptField(value, plaintextKey) {
    // Using CryptoJS for demonstration
    const CryptoJS = window.CryptoJS; // Ensure CryptoJS is loaded

    // Convert base64 key to format CryptoJS can use
    const key = CryptoJS.enc.Base64.parse(plaintextKey);

    // Create random initialization vector (16 bytes)
    const iv = CryptoJS.lib.WordArray.random(16);

    // Encrypt the data
    const encrypted = CryptoJS.AES.encrypt(value, key, {
        iv: iv,
        padding: CryptoJS.pad.Pkcs7,
        mode: CryptoJS.mode.CBC,
    });

    // Combine IV and encrypted data (IV must be first 16 bytes)
    const combined = iv.concat(encrypted.ciphertext);

    // Return as base64 string
    return CryptoJS.enc.Base64.stringify(combined);
}

// Encrypt card data and prepare for API submission
async function encryptCardData(formattedCardData, apiBaseUrl, authToken) {
    // First validate the card data format
    if (!/^\d{13,19}$/.test(formattedCardData.card_number)) {
        throw new Error('Card number must be 13-19 digits');
    }

    if (!/^\d{3,4}$/.test(formattedCardData.cvv)) {
        throw new Error('CVV must be 3-4 digits');
    }

    if (!/^\d{4}-\d{2}$/.test(formattedCardData.expiration_date)) {
        throw new Error('Expiration date must be in YYYY-MM format (e.g., "2030-01")');
    }

    // Get encryption key from server
    const dataKey = await getDataKey(apiBaseUrl, authToken);

    // Extract encryption context to send back
    const encryptionContext = dataKey.encryptionContext;

    // Encrypt only the sensitive fields
    const encryptedCardData = {
        ...formattedCardData, // Include all original fields

        // Encrypt sensitive fields
        card_number: encryptField(formattedCardData.card_number, dataKey.plaintextKey),
        cvv: encryptField(formattedCardData.cvv, dataKey.plaintextKey),
        expiration_date: encryptField(formattedCardData.expiration_date, dataKey.plaintextKey),

        // Add metadata for decryption
        encrypted: true,
        encryptedDataKey: dataKey.encryptedKey,
        encryptionContext: encryptionContext,
    };

    return encryptedCardData;
}

// Submit encrypted card data to API
async function submitCardToAPI(userFormData, apiBaseUrl, authToken) {
    try {
        // Step 1: Format user input to match API requirements
        const formattedCardData = formatCardDataForAPI(userFormData);

        console.log('Formatted card data:', formattedCardData);

        // Step 2: Encrypt the formatted card data
        const encryptedCardData = await encryptCardData(formattedCardData, apiBaseUrl, authToken);

        console.log('Card data encrypted successfully');

        // Step 3: Submit to API
        const response = await fetch(`${apiBaseUrl}/checkbook/card`, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${authToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(encryptedCardData),
        });

        const result = await response.json();

        if (!result.success) {
            throw new Error(`API error: ${result.error?.message || 'Unknown error'}`);
        }

        return result.data;
    } catch (error) {
        console.error('Error submitting card:', error);
        throw error;
    }
}

// ===== EXAMPLE USAGE =====

/**
 * Example React component for adding a card
 *
 * import React, { useState } from 'react';
 * import { submitCardToAPI } from './simple-card-encrypt';
 *
 * function AddCardForm({ apiBaseUrl, getAuthToken }) {
 *   const [formData, setFormData] = useState({
 *     cardNumber: '',
 *     cvv: '',
 *     expirationDate: '',
 *     name: '',
 *     isDefault: true
 *   });
 *
 *   const handleSubmit = async (e) => {
 *     e.preventDefault();
 *     try {
 *       const authToken = await getAuthToken();
 *       const result = await submitCardToAPI(formData, apiBaseUrl, authToken);
 *       alert('Card added successfully!');
 *     } catch (error) {
 *       alert(`Error: ${error.message}`);
 *     }
 *   };
 *
 *   // ... render form ...
 * }
 */
</file>

<file path="lambdas/checkbook/tsconfig.json">
{
    "compilerOptions": {
        "target": "es2020",
        "strict": true,
        "preserveConstEnums": true,
        "noEmit": true,
        "sourceMap": false,
        "module": "es2015",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/clerk-users/auth/clerk-authorizer.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { APIGatewayTokenAuthorizerEvent, APIGatewayAuthorizerResult, Context } from 'aws-lambda';

import { decode, verify } from 'jsonwebtoken';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'clkk-aws',
});


interface JWTPayload {
    iss: string;
    sub: string;
    exp: number;
    iat: number;
    [key: string]: any;
}

export const handler = async (
    event: APIGatewayTokenAuthorizerEvent,
    context: Context,
): Promise<APIGatewayAuthorizerResult> => {
    try {
        logger.info('Authorizing Clerk JWT token', { event });

        // 1. Extract the token from the Authorization header
        const token = event.authorizationToken.startsWith('Bearer ')
            ? event.authorizationToken.substring(7)
            : event.authorizationToken;

        // 2. Get the public key from the environment variable
        const publicKey = process.env.CLERK_JWT_PUBLIC_KEY;
        if (!publicKey) {
            logger.error('CLERK_JWT_PUBLIC_KEY environment variable not set.');
            throw new Error('Unauthorized');
        }

        // 4. Verify the token
        const decodedToken = decode(token, { complete: true });
        logger.info('Decoded token', { token: decodedToken });

        if (!decodedToken) {
            logger.error('Invalid token format.');
            throw new Error('Unauthorized');
        }

        const issuer = (decodedToken.payload as JWTPayload).iss;
        const secret = publicKey.replace('{ISSUER}', issuer);

        const claims = verify(token, secret) as JWTPayload;
        logger.info('Token verified successfully', { claims });
        logger.info('Event method ARN', { arn: event.methodArn });

        // 5. Generate the IAM policy
        return {
            principalId: claims.sub,
            policyDocument: {
                Version: '2012-10-17',
                Statement: [
                    {
                        Action: 'execute-api:Invoke',
                        Effect: 'Allow',
                        Resource: event.methodArn,
                    },
                ],
            },
            context: {
                userId: claims.sub,
            },
        };
    } catch (error) {
        logger.error('Error authorizing Clerk JWT token', { error });
        throw new Error('Unauthorized');
    }
};
</file>

<file path="lambdas/clerk-users/auth/package.json">
{
    "name": "clerk-authorizer",
    "version": "1.0.0",
    "description": "Clerk Authorizer Function",
    "main": "clerk-authorizer.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0",
        "@clerk/backend": "^1.20.0",
        "jsonwebtoken": "^9.0.2"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="lambdas/clerk-users/services/auth/auth-service.ts">
import { logger } from 'commons';
import { Entity } from 'commons';

import { type AuthProvider, type AuthWebhookEvent } from '../../types/auth';

export interface ParsedClerkUser {
    entityId: string;
    username: string;
    email: string | undefined;
    firstName: string;
    lastName: string;
    phoneNumber: string | undefined;
    profileImageUrl: string | undefined;
    name: string;
}

export class AuthService {
    private provider: AuthProvider;

    constructor(provider: AuthProvider) {
        this.provider = provider;
    }

    async verifyWebhook(payload: string, headers: Record<string, string>): Promise<boolean> {
        try {
            const event = await this.provider.verifyWebhook(payload, headers);
            return !!event;
        } catch (error) {
            logger.error('Error in webhook verification', {
                error: error instanceof Error ? error.message : 'Unknown error',
                stack: error instanceof Error ? error.stack : undefined,
            });
            return false;
        }
    }

    async processWebhookEvent(event: AuthWebhookEvent): Promise<boolean> {
        try {
            logger.info('Processing webhook event', { eventType: event.type });

            // Validate event
            if (!event || !event.type || !event.data) {
                logger.error('Invalid webhook event structure', { event });
                return false;
            }

            // Parse user data
            const parsedUser = this.provider.parseUser(event.data);

            if (!parsedUser) {
                logger.error('Failed to parse user data from webhook', {
                    eventType: event.type,
                    dataExists: !!event.data,
                });
                return false;
            }

            let success = false;

            switch (event.type) {
                case 'user.created':
                    logger.info('Processing user creation event', {
                        userId: parsedUser.entityId,
                        email: parsedUser.email ? `${parsedUser.email.substring(0, 3)}...` : undefined,
                    });
                    success = await this.saveUser(parsedUser);
                    break;

                case 'user.updated':
                    logger.info('Processing user update event', { userId: parsedUser.entityId });
                    success = await this.updateUser(parsedUser);
                    break;

                case 'user.deleted':
                    logger.info('Processing user deletion event', { userId: parsedUser.entityId });
                    success = await this.deleteUser(parsedUser);
                    break;

                default:
                    logger.info('Unhandled event type', { type: event.type });
                    // Not considering unhandled events as failures
                    return true;
            }

            if (success) {
                logger.info('Successfully processed webhook event', {
                    eventType: event.type,
                    userId: parsedUser.entityId,
                });
            } else {
                logger.error('Failed to process webhook event', {
                    eventType: event.type,
                    userId: parsedUser.entityId,
                });
            }

            return success;
        } catch (error) {
            logger.error('Unexpected error in processWebhookEvent', {
                error: error instanceof Error ? error.message : 'Unknown error',
                stack: error instanceof Error ? error.stack : undefined,
                eventType: event?.type,
            });
            return false;
        }
    }

    private async saveUser(userData: ParsedClerkUser): Promise<boolean> {
        try {
            logger.info('Creating new user entity', { userId: userData.entityId });

            // Check if user already exists by entityId
            const existingUser = await Entity.getById(userData.entityId, 'USER');

            logger.info('Existing user', { existingUser });

            console.log('no existing null');

            logger.info('User does not exist, creating new user', { userId: userData.entityId });

            // Check if user exists by email

            logger.info('Creating new user entity no email check', { userId: userData.entityId });

            // Create a new Entity instance for the user
            logger.info('Creating user with data', {
                email: userData.email || '',
                username: userData.username || '',
                entityId: userData.entityId,
                firstName: userData.firstName,
                lastName: userData.lastName,
                phoneNumber: userData.phoneNumber,
                profileImageUrl: userData.profileImageUrl,
                displayName: userData.name || `${userData.firstName} ${userData.lastName}`.trim(),
            });

            const user = Entity.createUser(userData.email || '', userData.username || '', {
                id: userData.entityId,
                firstName: userData.firstName,
                lastName: userData.lastName,
                phoneNumber: userData.phoneNumber,
                profilePictureUrl: userData.profileImageUrl,
                displayName: userData.name || `${userData.firstName} ${userData.lastName}`.trim(),
            });

            // Log the user object structure
            logger.info('User object created', {
                id: user.id,
                type: user.type,
                email: user.email,
                username: user.username,
                userInfoExists: !!user.userInfo,
                userInfo: JSON.stringify(user.userInfo),
            });

            // Create the user in the database
            try {
                await user.create();
                logger.info('User created successfully', { entityId: userData.entityId });
                return true;
            } catch (createError) {
                logger.error('Specific error during user create operation', {
                    error: createError instanceof Error ? createError.message : 'Unknown error',
                    stack: createError instanceof Error ? createError.stack : undefined,
                    userId: userData.entityId,
                    userObject: JSON.stringify(user),
                });
                throw createError; // Re-throw to be caught by outer catch
            }
        } catch (error) {
            logger.error('Error creating user entity', {
                error: error instanceof Error ? error.message : 'Unknown error',
                stack: error instanceof Error ? error.stack : undefined,
                userId: userData.entityId,
            });
            return false;
        }
    }

    private async updateUser(userData: ParsedClerkUser): Promise<boolean> {
        try {
            logger.info('Updating user entity', { userId: userData.entityId });

            // Get the existing user entity
            const user = await Entity.getById(userData.entityId, 'USER');

            // If user doesn't exist, create instead
            if (!user) {
                logger.info('User not found for update, creating new user instead', {
                    userId: userData.entityId,
                });
                return await this.saveUser(userData);
            }

            // Track if any changes were made
            let hasChanges = false;

            // Update user properties
            if (userData.firstName && user.userInfo?.firstName !== userData.firstName) {
                user.userInfo = { ...user.userInfo, firstName: userData.firstName };
                hasChanges = true;
            }

            if (userData.lastName && user.userInfo?.lastName !== userData.lastName) {
                user.userInfo = { ...user.userInfo, lastName: userData.lastName };
                hasChanges = true;
            }

            if (userData.phoneNumber && user.userInfo?.phoneNumber !== userData.phoneNumber) {
                user.userInfo = { ...user.userInfo, phoneNumber: userData.phoneNumber };
                hasChanges = true;
            }

            if (userData.profileImageUrl && user.userInfo?.profilePictureUrl !== userData.profileImageUrl) {
                user.userInfo = { ...user.userInfo, profilePictureUrl: userData.profileImageUrl };
                hasChanges = true;
            }

            // Only update if changes were made
            if (hasChanges) {
                // Save the updated user
                await user.update();
                logger.info('User updated successfully', { entityId: userData.entityId });
            } else {
                logger.info('No changes detected, skipping update', { entityId: userData.entityId });
            }

            return true;
        } catch (error) {
            logger.error('Error updating user', {
                error: error instanceof Error ? error.message : 'Unknown error',
                stack: error instanceof Error ? error.stack : undefined,
                userId: userData.entityId,
            });
            return false;
        }
    }

    private async deleteUser(userData: ParsedClerkUser): Promise<boolean> {
        try {
            logger.info('Processing user deletion request', { userId: userData.entityId });

            // Get the existing user entity
            const user = await Entity.getById(userData.entityId, 'USER');

            // If user doesn't exist, consider deletion successful
            if (!user) {
                logger.info('User already deleted or does not exist', {
                    userId: userData.entityId,
                });
                return true;
            }

            // If user is already inactive, no need to update
            if (user.status === 'INACTIVE') {
                logger.info('User already marked as inactive', { userId: userData.entityId });
                return true;
            }

            // Mark user as inactive rather than deleting
            user.status = 'INACTIVE';
            await user.update();
            logger.info('User marked as inactive successfully', { entityId: userData.entityId });
            return true;
        } catch (error) {
            logger.error('Error marking user as inactive', {
                error: error instanceof Error ? error.message : 'Unknown error',
                stack: error instanceof Error ? error.stack : undefined,
                userId: userData.entityId,
            });
            return false;
        }
    }
}
</file>

<file path="lambdas/clerk-users/services/auth/clerk-provider.ts">
import { logger } from 'commons';
import { AWS_SECRETS, getSecret } from 'commons';
import { Webhook } from 'svix';
import { ParsedClerkUser } from './auth-service';

import { type AuthProvider, type AuthWebhookEvent } from '../../types/auth';

// Define a webhook event interface since it's not exported by @clerk/types
interface ClerkWebhookEvent {
    type: string;
    data: any;
}

export class ClerkAuthProvider implements AuthProvider {
    async verifyWebhook(payload: string, headers: Record<string, string>): Promise<AuthWebhookEvent | null> {
        try {
            // Validate inputs
            if (!payload) {
                logger.error('Empty webhook payload received');
                return null;
            }

            if (!headers['svix-id'] || !headers['svix-timestamp'] || !headers['svix-signature']) {
                logger.error('Missing required Svix headers', {
                    hasId: !!headers['svix-id'],
                    hasTimestamp: !!headers['svix-timestamp'],
                    hasSignature: !!headers['svix-signature'],
                });
                return null;
            }

            // Get webhook secret
            logger.info('Retrieving webhook secret', {
                secretName: AWS_SECRETS.CLERK.SECRET_NAME,
                secretKey: AWS_SECRETS.CLERK.KEYS.WEBHOOK_SECRET,
            });

            const secret = await getSecret(AWS_SECRETS.CLERK.SECRET_NAME, AWS_SECRETS.CLERK.KEYS.WEBHOOK_SECRET);

            if (!secret) {
                logger.error('Webhook secret not found or is empty', {
                    secretName: AWS_SECRETS.CLERK.SECRET_NAME,
                });
                return null;
            }

            logger.info('Secret retrieved successfully');

            // Verify webhook
            const wh = new Webhook(secret);

            try {
                const evt = wh.verify(payload, {
                    'svix-id': headers['svix-id'],
                    'svix-timestamp': headers['svix-timestamp'],
                    'svix-signature': headers['svix-signature'],
                }) as ClerkWebhookEvent;

                if (!evt || !evt.type || !evt.data) {
                    logger.error('Invalid webhook event structure', { event: evt });
                    return null;
                }

                logger.info('Webhook verified successfully', { eventType: evt.type });
                return {
                    type: evt.type,
                    data: evt.data,
                };
            } catch (verifyError) {
                logger.error('Webhook verification failed', {
                    error: verifyError instanceof Error ? verifyError.message : 'Unknown error',
                    stack: verifyError instanceof Error ? verifyError.stack : undefined,
                });
                return null;
            }
        } catch (error) {
            logger.error('Unexpected error in verifyWebhook', {
                error: error instanceof Error ? error.message : 'Unknown error',
                stack: error instanceof Error ? error.stack : undefined,
            });
            return null;
        }
    }

    parseUser(data: any): ParsedClerkUser | null {
        try {
            // Validate minimum required data
            if (!data || !data.id) {
                logger.error('Invalid user data: missing id', { data });
                return null;
            }

            logger.info('Parsing user data', {
                userId: data.id,
                hasEmailAddresses: Array.isArray(data.email_addresses),
                hasPhoneNumbers: Array.isArray(data.phone_numbers),
            });

            // Extract email and phone safely
            let primaryEmail: string | undefined;
            let primaryPhone: string | undefined;

            try {
                if (Array.isArray(data.email_addresses) && data.email_addresses.length > 0) {
                    const emailObj = data.email_addresses.find((e: any) => e.id === data.primary_email_address_id);
                    primaryEmail = emailObj?.email_address;
                }
            } catch (emailError) {
                logger.warn('Error extracting primary email', { error: emailError });
            }

            try {
                if (Array.isArray(data.phone_numbers) && data.phone_numbers.length > 0) {
                    const phoneObj = data.phone_numbers.find((p: any) => p.id === data.primary_phone_number_id);
                    primaryPhone = phoneObj?.phone_number;
                }
            } catch (phoneError) {
                logger.warn('Error extracting primary phone', { error: phoneError });
            }

            // Format data to match our Entity structure
            const parsedUser: ParsedClerkUser = {
                entityId: data.id,
                email: primaryEmail,
                firstName: data.first_name || '',
                lastName: data.last_name || '',
                phoneNumber: primaryPhone,
                profileImageUrl: data.image_url || data.profile_image_url,
                username: data.username,
                name: `${data.first_name || ''} ${data.last_name || ''}`.trim() || 'Unnamed User',
            };

            logger.info('User parsed successfully', {
                entityId: parsedUser.entityId,
                email: parsedUser.email ? `${parsedUser.email.substring(0, 3)}...` : undefined,
            });

            return parsedUser;
        } catch (error) {
            logger.error('Error parsing user data', {
                error: error instanceof Error ? error.message : 'Unknown error',
                stack: error instanceof Error ? error.stack : undefined,
                userId: data?.id,
            });
            return null;
        }
    }
}
</file>

<file path="lambdas/clerk-users/services/userService.ts">
interface WebhookEvent {
    type: string;
    data: any;
}

export async function processUserEvent(event: WebhookEvent): Promise<void> {
    switch (event.type) {
        case 'user.created':
            await handleUserCreated(event.data);
            break;
        case 'user.updated':
            await handleUserUpdated(event.data);
            break;
        case 'user.deleted':
            await handleUserDeleted(event.data);
            break;
        default:
            console.log(`Unhandled event type: ${event.type}`);
    }
}

async function handleUserCreated(userData: any): Promise<void> {
    console.log('Processing user.created event:', userData);
    // Implement user creation logic
}

async function handleUserUpdated(userData: any): Promise<void> {
    console.log('Processing user.updated event:', userData);
    // Implement user update logic
}

async function handleUserDeleted(userData: any): Promise<void> {
    console.log('Processing user.deleted event:', userData);
    // Implement user deletion logic
}
</file>

<file path="lambdas/clerk-users/types/auth.ts">
export interface AuthWebhookEvent {
    type: string;
    data: any; // Raw data from Clerk webhook
}

export interface AuthProvider {
    verifyWebhook(payload: string, headers: Record<string, string>): Promise<AuthWebhookEvent | null>;
    parseUser(data: any): any; // Parse the webhook data into a format compatible with our Entity model
}
</file>

<file path="lambdas/clerk-users/utils/verifySignature.ts">
import { Webhook } from 'svix';
import { WebhookEvent } from '@clerk/nextjs/server';
import { Logger } from 'commons';
import { getSecret } from 'commons';
import { AWS_SECRETS } from 'commons';

const logger = new Logger({ serviceName: 'webhook-verification' });

export async function verifyWebhookSignature(
    payload: string,
    svixId: string,
    svixTimestamp: string,
    svixSignature: string,
): Promise<WebhookEvent | null> {
    try {
        const secret = await getSecret(AWS_SECRETS.CLERK.SECRET_NAME, AWS_SECRETS.CLERK.KEYS.WEBHOOK_SECRET);
        const webhook = new Webhook(secret);

        const evt = webhook.verify(payload, {
            'svix-id': svixId,
            'svix-timestamp': svixTimestamp,
            'svix-signature': svixSignature,
        }) as WebhookEvent;

        return evt;
    } catch (error) {
        logger.error('Error verifying webhook signature', {
            error: error instanceof Error ? error.message : 'Unknown error',
            svixId,
            timestamp: svixTimestamp,
        });
        return null;
    }
}
</file>

<file path="lambdas/clerk-users/clerk-webhook.ts">
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { logger } from 'commons';
import { SNSService } from 'commons';

import { AuthService } from './services/auth/auth-service';
import { ClerkAuthProvider } from './services/auth/clerk-provider';

const authService = new AuthService(new ClerkAuthProvider());
const snsService = new SNSService();

export const handler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    try {
        logger.info('Received webhook event', { event: event.body });
        const verified = await authService.verifyWebhook(event.body || '{}', event.headers as Record<string, string>);
        if (!verified) {
            return { statusCode: 401, body: JSON.stringify({ error: 'Unauthorized' }) };
        }

        const webhookEvent = JSON.parse(event.body || '{}');
        await snsService.publishMessage(process.env.WEBHOOK_TOPIC_ARN || '', webhookEvent, webhookEvent.type);

        return { statusCode: 200, body: JSON.stringify({ success: true }) };
    } catch (error) {
        logger.error('Webhook processing error', { error });
        return {
            statusCode: 500,
            body: JSON.stringify({ error: 'Internal server error' }),
        };
    }
};
</file>

<file path="lambdas/clerk-users/package.json">
{
  "name": "clerk-users",
  "version": "1.0.0",
  "description": "Clerk webhook handler",
  "main": "dist/app.js",
  "author": "SAM CLI",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^2.11.0",
    "@aws-sdk/client-secrets-manager": "^3.716.0",
    "@clerk/backend": "^1.20.0",
    "@clerk/types": "^4.50.2",
    "jsonwebtoken": "^9.0.2",
    "svix": "^1.59.2"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "@types/aws-lambda": "^8.10.146",
    "@types/jest": "^29.2.0",
    "@types/node": "^18.11.4",
    "@typescript-eslint/eslint-plugin": "^5.10.2",
    "@typescript-eslint/parser": "^5.10.2",
    "esbuild": "^0.14.14",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.2.1",
    "prettier": "^2.5.1",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
</file>

<file path="lambdas/clerk-users/tsconfig.json">
{
    "compilerOptions": {
        "target": "es2020",
        "strict": true,
        "preserveConstEnums": true,
        "sourceMap": true,
        "module": "commonjs",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "outDir": "dist",
        "rootDir": "./"
    },
    "exclude": ["node_modules", "**/*.test.ts"],
    "include": ["**/*.ts", "../../layers/commons/utils/sqsService.ts"]
}
</file>

<file path="lambdas/cybrid/accounts/create-account.ts">

</file>

<file path="lambdas/cybrid/accounts/cybrid-accounts.ts">
import { type AccountBankModel } from '@cybrid/cybrid-api-bank-typescript';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import axios from 'axios';
import { type CreateFiatAccountRequest, DateUtil, dynamoDB, getCybridToken, responseBuilder } from 'commons';
import { type Entity, logger } from 'commons';
import { type CybridFiatAccount } from 'commons';
import { getCybridUrl } from 'commons';
import { KYCStatus } from 'commons/types';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';

// Request/Response types
export interface CreateAccountRequest {
    userId?: string;
    clerkUserId?: string;
}

export interface CreateAccountResponse {
    message: string;
    accountId?: string;
}

async function getUser(userId: string, requestId: string): Promise<Entity> {
    const functionName = 'getUser';
    
    logger.info(`[${functionName}] Retrieving user from database`, {
        requestId,
        userId,
    });
    
    const keys = SingleTableKeys.user(userId);
    const params = {
        TableName: SINGLE_TABLE_NAME,
        Key: keys,
    };
    
    logger.debug(`[${functionName}] DynamoDB GetItem parameters`, {
        requestId,
        params,
    });
    
    const startTime = Date.now();
    const response = (await dynamoDB.get(params)) as Entity | null;
    const latency = Date.now() - startTime;
    
    logger.info(`[${functionName}] User retrieval completed`, {
        requestId,
        userId,
        recordFound: !!response,
        latencyMs: latency,
    });
    
    return response as Entity;
}

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'CreateCybridFiatAccount';
    
    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });
    
    // Step 1: Parse and validate request body
    const eventBody = JSON.parse(event.body || '{}');
    const userId = eventBody.userId || eventBody.clerkUserId;
    
    logger.info(`[${functionName}] Step 1: Parsing request body`, {
        requestId,
        hasUserId: !!eventBody.userId,
        hasClerkUserId: !!eventBody.clerkUserId,
        extractedUserId: userId,
    });

    if (!userId) {
        logger.error(`[${functionName}] Missing required userId in request body`, {
            requestId,
            eventBody,
        });
        return responseBuilder('userId or clerkUserId not provided in the event body', 403);
    }

    try {
        // Step 2: Retrieve user record
        logger.info(`[${functionName}] Step 2: Retrieving user record`, {
            requestId,
            userId,
        });
        
        const userRecord = await getUser(userId, requestId);
        if (!userRecord) {
            logger.error(`[${functionName}] User record not found`, {
                requestId,
                userId,
            });
            return responseBuilder('User record not found', 404);
        }

        const typedUserRecord = userRecord as Entity;

        logger.info(`[${functionName}] User record retrieved successfully`, {
            requestId,
            userId,
            userEmail: typedUserRecord.email,
            hasMetadata: !!typedUserRecord.metadata,
            hasCybridMetadata: !!typedUserRecord.metadata?.cybrid,
        });
        
        // Step 3: Extract and validate Cybrid customer ID
        const cybridCustomerId = typedUserRecord.metadata?.cybrid?.customerId || 
                               typedUserRecord.metadata?.cybrid?.customer?.guid;
        
        logger.info(`[${functionName}] Step 3: Checking Cybrid customer ID`, {
            requestId,
            userId,
            hasCybridCustomerId: !!cybridCustomerId,
            cybridCustomerId,
        });

        if (!cybridCustomerId) {
            logger.error(`[${functionName}] Cybrid customer ID not found for user`, {
                requestId,
                userId,
                metadata: typedUserRecord.metadata,
            });
            return responseBuilder('Cybrid customer ID not found for this user', 404);
        }

        // Step 4: Check KYC completion status
        logger.info(`[${functionName}] Step 4: Verifying KYC status`, {
            requestId,
            userId,
            kycStatus: typedUserRecord.kyc?.status,
            kycRequired: KYCStatus.Success,
        });
        
        if (typedUserRecord.kyc?.status !== KYCStatus.Success) {
            logger.error(`[${functionName}] KYC verification not completed`, {
                requestId,
                userId,
                currentKycStatus: typedUserRecord.kyc?.status,
                requiredStatus: KYCStatus.Success,
            });
            return responseBuilder('KYC is not completed for this user', 400);
        }

        // Step 5: Check for existing fiat account
        const existingFiatAccount = typedUserRecord.metadata?.cybrid?.fiatAccountId;
        
        logger.info(`[${functionName}] Step 5: Checking for existing fiat account`, {
            requestId,
            userId,
            hasExistingAccount: !!existingFiatAccount,
            existingAccountId: existingFiatAccount,
        });
        
        if (existingFiatAccount) {
            logger.info(`[${functionName}] Fiat account already exists - returning existing account`, {
                requestId,
                userId,
                existingFiatAccountId: existingFiatAccount,
                totalExecutionTime: Date.now() - startTime,
            });
            
            const accountResponse: CreateAccountResponse = {
                message: 'Fiat account already exists for user',
                accountId: existingFiatAccount,
            };

            return responseBuilder(accountResponse, 200);
        }

        // Step 6: Create fiat account using Cybrid's API
        logger.info(`[${functionName}] Step 6: Creating fiat account in Cybrid`, {
            requestId,
            userId,
            cybridCustomerId,
        });
        
        const cybridStartTime = Date.now();
        const fiatAccount = await createFiatAccountWithRetry(cybridCustomerId, requestId);
        const cybridLatency = Date.now() - cybridStartTime;

        logger.info(`[${functionName}] Fiat account creation completed`, {
            requestId,
            userId,
            accountId: fiatAccount?.guid,
            accountAsset: fiatAccount?.asset,
            accountName: fiatAccount?.name,
            accountState: fiatAccount?.state,
            cybridLatencyMs: cybridLatency,
        });

        if (!fiatAccount.guid) {
            logger.error(`[${functionName}] Failed to create fiat account - missing GUID`, {
                requestId,
                userId,
                fiatAccountResponse: fiatAccount,
            });
            return responseBuilder('Failed to create fiat account', 500);
        }

        // Step 7: Prepare DynamoDB records for transaction
        logger.info(`[${functionName}] Step 7: Preparing DynamoDB transaction`, {
            requestId,
            userId,
            accountId: fiatAccount.guid,
        });
        
        const userKeys = SingleTableKeys.user(userId);
        const fiatAccountKeys = SingleTableKeys.cybridFiatAccount(userId, fiatAccount.guid);
        
        const fiatAccountRecord = {
            ...fiatAccountKeys,
            entityType: 'CYBRID_FIAT_ACCOUNT',
            userId,
            accountId: fiatAccount.guid,
            customerId: cybridCustomerId,
            asset: fiatAccount.asset || '',
            balance: fiatAccount.platform_balance || 0,
            name: fiatAccount.name || '',
            state: fiatAccount.state || '',
            createdAt: DateUtil.now(),
            // GSI attributes for querying
            EntityTypeKey: 'CYBRID_FIAT_ACCOUNT',
            EntityStatusSortKey: `CUSTOMER#${cybridCustomerId}`,
        };
        
        logger.debug(`[${functionName}] Fiat account record prepared`, {
            requestId,
            fiatAccountRecord,
        });

        const transactionItems = [
            {
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: userKeys,
                    UpdateExpression: 'SET #metadata.#cybrid.#fiatAccountId = :fiatAccountId, updatedAt = :updatedAt',
                    ExpressionAttributeNames: {
                        '#metadata': 'metadata',
                        '#cybrid': 'cybrid',
                        '#fiatAccountId': 'fiatAccountId',
                    },
                    ExpressionAttributeValues: {
                        ':fiatAccountId': fiatAccount.guid,
                        ':updatedAt': DateUtil.now(),
                    },
                },
            },
            {
                Put: {
                    TableName: SINGLE_TABLE_NAME,
                    Item: fiatAccountRecord,
                },
            },
        ];

        // Step 8: Execute the transaction
        logger.info(`[${functionName}] Step 8: Executing DynamoDB transaction`, {
            requestId,
            userId,
            transactionItemsCount: transactionItems.length,
        });
        
        const transactStartTime = Date.now();
        await dynamoDB.transactWrite({ TransactItems: transactionItems });
        const transactLatency = Date.now() - transactStartTime;

        logger.info(`[${functionName}] Transaction completed successfully`, {
            requestId,
            userId,
            accountId: fiatAccount.guid,
            transactionLatencyMs: transactLatency,
        });
        
        // Step 9: Prepare and return response
        const response: CreateAccountResponse = {
            message: 'Successfully created and stored fiat account',
            accountId: fiatAccount.guid,
        };

        logger.info(`[${functionName}] Fiat account creation completed successfully`, {
            requestId,
            userId,
            accountId: fiatAccount.guid,
            accountAsset: fiatAccount.asset,
            totalExecutionTime: Date.now() - startTime,
        });

        return responseBuilder(response, 200);
    } catch (error: any) {
        const errorDetails = {
            requestId,
            userId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            errorStatus: error.status,
            errorResponse: error.response?.data,
            totalExecutionTime: Date.now() - startTime,
        };
        
        logger.error(`[${functionName}] Error creating Cybrid fiat account`, errorDetails);

        // Provide more specific error handling based on the error type
        let statusCode = 500;
        let message = 'Internal server error';
        
        if (error.message?.includes('KYC')) {
            statusCode = 400;
            message = error.message;
        } else if (error.status) {
            statusCode = error.status;
            message = error.message || 'Cybrid API error';
        }
        
        logger.error(`[${functionName}] Returning error response`, {
            requestId,
            statusCode,
            message,
        });
        
        return responseBuilder(message, statusCode);
    }
};

// Helper function to create a fiat account with retry on 409
async function createFiatAccountWithRetry(customerId: string, requestId: string): Promise<AccountBankModel> {
    const functionName = 'createFiatAccountWithRetry';
    
    logger.info(`[${functionName}] Starting fiat account creation`, {
        requestId,
        customerId,
    });
    const cybridToken = await getCybridToken();
    const headers = {
        Authorization: `Bearer ${cybridToken}`,
        'Content-Type': 'application/json',
    };

    const fiatAccountData: CreateFiatAccountRequest = {
        type: 'fiat',
        asset: 'USD',
        customer_guid: customerId,
        name: 'USD Funding Account',
        labels: ['funding'],
    };

    const startTime = Date.now();
    
    try {
        logger.debug(`[${functionName}] Sending request to Cybrid API`, {
            requestId,
            url: getCybridUrl.accounts(),
            payload: fiatAccountData,
        });
        
        const fiatAccountResponse = await axios.post(getCybridUrl.accounts(), fiatAccountData, { headers });
        const latency = Date.now() - startTime;
        
        logger.info(`[${functionName}] Fiat account created successfully`, {
            requestId,
            customerId,
            accountId: fiatAccountResponse.data.guid,
            accountState: fiatAccountResponse.data.state,
            latencyMs: latency,
        });
        
        return fiatAccountResponse.data;
    } catch (error) {
        const latency = Date.now() - startTime;
        
        if (axios.isAxiosError(error) && error.response?.status === 409) {
            logger.warn(`[${functionName}] Fiat account conflict (409) - attempting to fetch existing`, {
                requestId,
                customerId,
                errorStatus: error.response?.status,
                errorData: error.response?.data,
                latencyMs: latency,
                asset: fiatAccountData.asset,
            });
            
            const fetchedFiatAccount = await getExistingFiatAccount(customerId, 'USD', requestId);
            if (!fetchedFiatAccount) {
                logger.error(`[${functionName}] Failed to fetch existing fiat account after 409`, {
                    requestId,
                    customerId,
                    asset: 'USD',
                });
                throw error;
            }
            
            logger.info(`[${functionName}] Retrieved existing fiat account`, {
                requestId,
                customerId,
                accountId: fetchedFiatAccount.guid,
                accountState: fetchedFiatAccount.state,
            });
            
            return fetchedFiatAccount;
        } else {
            logger.error(`[${functionName}] Error creating fiat account`, {
                requestId,
                customerId,
                errorMessage: error.message,
                errorResponse: axios.isAxiosError(error) ? error.response?.data : undefined,
                latencyMs: latency,
            });
            throw error;
        }
    }
}

// Helper function to fetch an existing fiat account from Cybrid
async function getExistingFiatAccount(customerId: string, asset: string, requestId: string): Promise<AccountBankModel | null> {
    const functionName = 'getExistingFiatAccount';
    
    logger.info(`[${functionName}] Attempting to fetch existing fiat account`, {
        requestId,
        customerId,
        asset,
    });
    try {
        const cybridToken = await getCybridToken();
        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        const params = {
            customer_guid: customerId,
            asset: asset,
        };
        
        logger.debug(`[${functionName}] Querying Cybrid accounts API`, {
            requestId,
            url: getCybridUrl.accounts(),
            params,
        });
        
        const startTime = Date.now();
        const response = await axios.get(getCybridUrl.accounts(), { headers, params });
        const latency = Date.now() - startTime;

        logger.info(`[${functionName}] Accounts query completed`, {
            requestId,
            accountsCount: response.data.objects?.length || 0,
            latencyMs: latency,
        });

        const fiatAccount = response.data.objects.find(
            (account: AccountBankModel) => account.type === 'fiat' && account.asset === asset,
        );

        if (fiatAccount) {
            logger.info(`[${functionName}] Found existing fiat account`, {
                requestId,
                customerId,
                asset,
                accountId: fiatAccount.guid,
                accountState: fiatAccount.state,
            });
            return fiatAccount;
        } else {
            logger.warn(`[${functionName}] No existing fiat account found`, {
                requestId,
                customerId,
                asset,
                accountsChecked: response.data.objects?.length || 0,
            });
            return null;
        }
    } catch (error: any) {
        logger.error(`[${functionName}] Error fetching existing fiat account`, {
            requestId,
            customerId,
            asset,
            errorMessage: error.message,
            errorResponse: axios.isAxiosError(error) ? error.response?.data : undefined,
        });
        return null;
    }
}
</file>

<file path="lambdas/cybrid/auth/clerk-authorizer.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { APIGatewayTokenAuthorizerEvent, APIGatewayAuthorizerResult, Context } from 'aws-lambda';
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';
import { decode, verify } from 'jsonwebtoken';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'clkk-aws',
});

// Create the Secrets Manager client outside the handler for better performance (it can be reused across invocations)
const secretsClient = new SecretsManagerClient({ region: process.env.AWS_REGION });

interface JWTPayload {
    iss: string;
    sub: string;
    exp: number;
    iat: number;
    [key: string]: any;
}

export const handler = async (
    event: APIGatewayTokenAuthorizerEvent,
    context: Context,
): Promise<APIGatewayAuthorizerResult> => {
    try {
        logger.info('Authorizing Clerk JWT token', { event });

        // 1. Extract the token from the Authorization header
        const token = event.authorizationToken.startsWith('Bearer ')
            ? event.authorizationToken.substring(7)
            : event.authorizationToken;

        // 2. Get the secret ARN from the environment variable
        const secretArn = process.env.CLERK_JWT_SECRET_ARN;

        if (!secretArn) {
            logger.error('CLERK_JWT_SECRET_ARN environment variable not set.');
            throw new Error('Unauthorized');
        }

        // 3. Fetch the secret value from Secrets Manager
        const command = new GetSecretValueCommand({ SecretId: secretArn });
        const data = await secretsClient.send(command);

        if (!data.SecretString) {
            logger.error('Secret value not found or not a string.');
            throw new Error('Unauthorized');
        }

        const publicKey = data.SecretString;

        // 4. Verify the token
        const decodedToken = decode(token, { complete: true });
        logger.info('Decoded token', decodedToken);

        if (!decodedToken) {
            logger.error('Invalid token format.');
            throw new Error('Unauthorized');
        }

        const issuer = (decodedToken.payload as JWTPayload).iss;
        const secret = publicKey.replace('{ISSUER}', issuer);

        const claims = verify(token, secret) as JWTPayload;
        logger.info('Token verified successfully', { claims });
        logger.info('Event method ARN', { arn: event.methodArn });

        // 5. Generate the IAM policy
        return {
            principalId: claims.sub,
            policyDocument: {
                Version: '2012-10-17',
                Statement: [
                    {
                        Action: 'execute-api:Invoke',
                        Effect: 'Allow',
                        Resource: event.methodArn,
                    },
                ],
            },
            context: {
                userId: claims.sub,
            },
        };
    } catch (error) {
        logger.error('Error authorizing Clerk JWT token', { error });
        throw new Error('Unauthorized');
    }
};
</file>

<file path="lambdas/cybrid/customers/create-business-customer.ts">
import {
    type CustomerBankModel,
    type PostCustomerBankModel,
    PostCustomerBankModelTypeEnum,
    type PostIdentificationNumberBankModel,
} from '@cybrid/cybrid-api-bank-typescript';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { DateUtil, DYNAMO_TABLES, dynamoDB, type Entity, logger, responseBuilder } from 'commons';
import { CybridService } from 'commons';

// Business customer request interface
interface BusinessCustomerRequest {
    name: {
        full: string;
    };
    address: {
        street: string;
        street2?: string;
        city: string;
        postal_code: string;
        country_code: string;
        subdivision: string;
    };
    phone_number: string;
    email_address: string;
    website?: string;
    identification_numbers: Array<{
        type: 'business_registration_number' | 'employer_identification_number' | 'tax_identification_number';
        issuing_country_code: string;
        identification_number: string;
    }>;
    nature_of_business?: string;
}

// Response interface
interface CreateBusinessCustomerResponse {
    success: boolean;
    message: string;
    guid?: string;
    state?: string;
}

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    logger.info('CreateBusinessCustomerFunction invoked', { event });

    try {
        const userId = event.requestContext.authorizer?.userId;

        logger.info('User ID', { userId });

        if (!userId) {
            logger.error('User ID not found in the context');
            return {
                statusCode: 403,
                body: JSON.stringify({ message: 'Forbidden' }),
            };
        }

        if (!event.body) {
            logger.error('Request body is missing');
            return responseBuilder('Request body is required', 400);
        }

        // Parse request body
        const businessRequest: BusinessCustomerRequest = JSON.parse(event.body);
        logger.info('Business customer request', { businessRequest });

        // Validate required fields
        if (!businessRequest.name || !businessRequest.name.full) {
            return responseBuilder('Business name is required', 400);
        }

        if (
            !businessRequest.address ||
            !businessRequest.address.street ||
            !businessRequest.address.city ||
            !businessRequest.address.postal_code ||
            !businessRequest.address.country_code
        ) {
            return responseBuilder('Complete business address is required', 400);
        }

        if (!businessRequest.identification_numbers || businessRequest.identification_numbers.length === 0) {
            return responseBuilder('At least one identification number is required', 400);
        }

        // Check for valid identification number types
        const validTypes = [
            'business_registration_number',
            'employer_identification_number',
            'tax_identification_number',
        ];
        const hasValidIdType = businessRequest.identification_numbers.every((id) => validTypes.includes(id.type));

        if (!hasValidIdType) {
            return responseBuilder('Invalid identification number type provided', 400);
        }

        // 1. Get User Record from DynamoDB to see if the business already exists
        const getParams = {
            TableName: DYNAMO_TABLES.ENTITIES,
            Key: {
                entityId: userId,
            },
        };
        logger.info('Get params', { getParams });

        const response = (await dynamoDB.get(getParams)) as Entity | null;

        // Check if user record exists and has necessary data
        if (!response) {
            logger.error('User record not found', { userId });
            return responseBuilder('User record not found', 404);
        }

        const userRecord: Entity = response;
        logger.info('User record', { userRecord });

        // Check for existing Cybrid customer
        const existingCybridCustomerId = userRecord.metadata?.cybrid?.businessCustomerId;
        if (existingCybridCustomerId) {
            logger.info('Cybrid business customer already exists for this user', { userId, existingCybridCustomerId });
            const existingCustomerResponse: CreateBusinessCustomerResponse = {
                success: true,
                message: 'Business customer already exists',
                guid: existingCybridCustomerId,
            };
            return responseBuilder(
                {
                    message: 'Business customer already stored in banking provider',
                    data: existingCustomerResponse,
                },
                200,
            );
        }

        // 3. Create Cybrid Customer
        const postCustomerBankModel: PostCustomerBankModel = {
            type: PostCustomerBankModelTypeEnum.Business,
            // Split the business name into first and last parts
            name: {
                full: businessRequest.name.full,
            },
            address: {
                street: businessRequest.address.street,
                street2: businessRequest.address.street2,
                city: businessRequest.address.city,
                subdivision: businessRequest.address.subdivision,
                postal_code: businessRequest.address.postal_code,
                country_code: businessRequest.address.country_code,
            },
            phone_number: businessRequest.phone_number,
            email_address: businessRequest.email_address,
            identification_numbers: businessRequest.identification_numbers.map(
                (id) =>
                    ({
                        type: id.type,
                        issuing_country_code: id.issuing_country_code,
                        identification_number: id.identification_number,
                    } as PostIdentificationNumberBankModel),
            ),
            labels: [userId, 'business'], // Adding userId and 'business' label for reference
        };

        // Add website if provided
        if (businessRequest.website) {
            (postCustomerBankModel as any).website = businessRequest.website;
        }

        logger.info('Creating business customer in Cybrid', { postCustomerBankModel });

        const cybridService = new CybridService();

        let customer: CustomerBankModel;
        try {
            customer = await cybridService.createCustomer(postCustomerBankModel);
            logger.info('Business customer created in Cybrid', { customer });
        } catch (error: any) {
            if (error.status === 409) {
                logger.warn('Cybrid business customer might already exist (409 Conflict)', { userId });
                return {
                    statusCode: 409,
                    body: JSON.stringify({
                        success: false,
                        message: 'Cybrid business customer might already exist.',
                    }),
                };
            } else {
                logger.error('Error creating business customer in Cybrid', { error });
                throw error;
            }
        }

        // Ensure the cybrid object exists in metadata
        const initParams = {
            TableName: DYNAMO_TABLES.ENTITIES,
            Key: {
                entityId: userId,
            },
            UpdateExpression: 'SET metadata.#cybrid = if_not_exists(metadata.#cybrid, :emptyCybrid)',
            ExpressionAttributeNames: {
                '#cybrid': 'cybrid',
            },
            ExpressionAttributeValues: {
                ':emptyCybrid': {},
            },
            ReturnValues: 'NONE' as const,
        };

        await dynamoDB.update(initParams);

        // Set the businessCustomerId and updatedAt
        const updateParams = {
            TableName: DYNAMO_TABLES.ENTITIES,
            Key: {
                entityId: userId,
            },
            UpdateExpression: 'SET metadata.#cybrid.#businessCustomerId = :customerId, updatedAt = :updatedAt',
            ExpressionAttributeNames: {
                '#cybrid': 'cybrid',
                '#businessCustomerId': 'businessCustomerId',
            },
            ExpressionAttributeValues: {
                ':customerId': customer.guid,
                ':updatedAt': DateUtil.now(),
            },
            ReturnValues: 'NONE' as const,
        };

        await dynamoDB.update(updateParams);
        logger.info('User record updated with Cybrid business data', {
            userId,
            cybridBusinessCustomerId: customer.guid,
        });

        const cybridCustomerResponse: CreateBusinessCustomerResponse = {
            success: true,
            message: 'Business customer created successfully',
            guid: customer.guid,
            state: customer.state,
        };

        return responseBuilder(
            {
                message: 'Business customer created and stored in banking provider',
                data: cybridCustomerResponse,
            },
            200,
        );
    } catch (error: any) {
        logger.error('Error during business customer creation process:', { error });

        let errorMessage = 'Internal server error';
        let statusCode = 500;

        if (error.status) {
            errorMessage = error.message || 'Cybrid API request failed';
            statusCode = error.status || 500;
        } else if (error instanceof Error) {
            errorMessage = error.message;
        }

        return responseBuilder(errorMessage, statusCode);
    }
};
</file>

<file path="lambdas/cybrid/customers/cybrid-customers.ts">
import {
    type CustomerBankModel,
    type PostCustomerBankModel,
    PostCustomerBankModelTypeEnum,
} from '@cybrid/cybrid-api-bank-typescript';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { type CreateCyCustomerResponse } from 'commons';
import { DateUtil, dynamoDB, logger, responseBuilder } from 'commons';
import { CybridService } from 'commons';
import { type Entity } from 'commons/types/users/entities.i';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';

// Request/Response types
export interface CreateCustomerRequest {
    // No body params needed, userId comes from auth context
}

export interface CreateCustomerResponse {
    message: string;
    data?: CreateCyCustomerResponse;
}

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'CreateCybridCustomer';
    
    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });

    try {
        // Step 1: Extract and validate user ID
        const userId = event.requestContext.authorizer?.userId;

        logger.info(`[${functionName}] Step 1: Extracting user ID from authorizer`, {
            requestId,
            userIdFound: !!userId,
            authorizerContext: event.requestContext.authorizer,
        });

        if (!userId) {
            logger.error(`[${functionName}] Authorization failed - User ID not found`, {
                requestId,
                authorizerContext: event.requestContext.authorizer,
            });
            return {
                statusCode: 403,
                body: JSON.stringify({ message: 'Forbidden' }),
            };
        }

        // Step 2: Retrieve user record from DynamoDB
        logger.info(`[${functionName}] Step 2: Retrieving user record from DynamoDB`, {
            requestId,
            userId,
            tableName: SINGLE_TABLE_NAME,
        });
        
        const keys = SingleTableKeys.user(userId);
        const getParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: keys,
        };
        
        logger.debug(`[${functionName}] DynamoDB GetItem parameters`, {
            requestId,
            params: getParams,
        });

        const dbStartTime = Date.now();
        const response = await dynamoDB.get(getParams);
        const dbLatency = Date.now() - dbStartTime;
        
        logger.info(`[${functionName}] DynamoDB GetItem completed`, {
            requestId,
            latencyMs: dbLatency,
            recordFound: !!response,
        });

        // Check if user record exists and has necessary data
        if (!response) {
            logger.error(`[${functionName}] User record not found in database`, {
                requestId,
                userId,
                keys,
            });
            return responseBuilder('User record not found', 404);
        }

        const userRecord = response as Entity;

        logger.info(`[${functionName}] User record retrieved successfully`, {
            requestId,
            userId,
            userEmail: userRecord.email,
            userName: userRecord.name || `${userRecord.firstName} ${userRecord.lastName}`,
            hasMetadata: !!userRecord.metadata,
            hasCybridMetadata: !!userRecord.metadata?.cybrid,
        });

        // Step 3: Check for existing Cybrid customer
        const existingCybridCustomerId = userRecord.metadata?.cybrid?.customerId;
        
        logger.info(`[${functionName}] Step 3: Checking for existing Cybrid customer`, {
            requestId,
            userId,
            hasExistingCustomer: !!existingCybridCustomerId,
            existingCustomerId: existingCybridCustomerId,
        });
        
        if (existingCybridCustomerId) {
            logger.info(`[${functionName}] Cybrid customer already exists - returning existing customer`, {
                requestId,
                userId,
                existingCybridCustomerId,
                totalExecutionTime: Date.now() - startTime,
            });
            
            const existingCustomerResponse: CreateCyCustomerResponse = {
                success: true,
                message: 'Customer already exists',
                guid: existingCybridCustomerId,
                state: null,
            };
            
            return responseBuilder(
                {
                    message: 'Customer already stored in banking provider',
                    data: existingCustomerResponse,
                },
                200,
            );
        }

        // Step 4: Extract and validate user data
        const { firstName, lastName, email, phoneNumber } = userRecord;
        
        logger.info(`[${functionName}] Step 4: Extracting user data for Cybrid customer creation`, {
            requestId,
            userId,
            hasFirstName: !!firstName,
            hasLastName: !!lastName,
            hasEmail: !!email,
            hasPhoneNumber: !!phoneNumber,
        });

        // Step 5: Prepare Cybrid customer data
        const postCustomerBankModel: PostCustomerBankModel = {
            type: PostCustomerBankModelTypeEnum.Individual,
            name: {
                first: firstName,
                last: lastName,
            },
            email_address: email,
            phone_number: phoneNumber,
            labels: [userId],
        };

        logger.info(`[${functionName}] Step 5: Prepared Cybrid customer payload`, {
            requestId,
            userId,
            customerType: postCustomerBankModel.type,
            labels: postCustomerBankModel.labels,
        });

        const cybridService = new CybridService();

        // Step 6: Create customer in Cybrid
        let customer: CustomerBankModel;
        try {
            logger.info(`[${functionName}] Step 6: Creating customer in Cybrid API`, {
                requestId,
                userId,
            });
            
            const cybridStartTime = Date.now();
            customer = await cybridService.createCustomer(postCustomerBankModel);
            const cybridLatency = Date.now() - cybridStartTime;
            
            logger.info(`[${functionName}] Customer successfully created in Cybrid`, {
                requestId,
                userId,
                cybridCustomerId: customer.guid,
                customerState: customer.state,
                cybridLatencyMs: cybridLatency,
                activityLimits: customer.activity_limits,
            });
        } catch (error: any) {
            const errorDetails = {
                requestId,
                userId,
                errorStatus: error.status,
                errorMessage: error.message,
                errorResponse: error.response?.data,
            };
            
            if (error.status === 409) {
                logger.warn(`[${functionName}] Cybrid customer creation conflict (409)`, errorDetails);
                return {
                    statusCode: 409,
                    body: JSON.stringify({
                        success: false,
                        message: 'Cybrid customer might already exist.',
                    }),
                };
            } else {
                logger.error(`[${functionName}] Failed to create customer in Cybrid`, errorDetails);
                throw error;
            }
        }

        // Step 7: Update user record with Cybrid customer ID
        logger.info(`[${functionName}] Step 7: Updating user record with Cybrid customer ID`, {
            requestId,
            userId,
            cybridCustomerId: customer.guid,
        });
        
        const userKeys = SingleTableKeys.user(userId);
        
        // Step 7a: First ensure metadata exists
        const initMetadataParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
            UpdateExpression: 'SET #metadata = if_not_exists(#metadata, :emptyMetadata)',
            ExpressionAttributeNames: {
                '#metadata': 'metadata',
            },
            ExpressionAttributeValues: {
                ':emptyMetadata': {},
            },
            ReturnValues: 'NONE' as const,
        };
        
        logger.debug(`[${functionName}] Step 7a: Initializing metadata field`, {
            requestId,
            updateParams: initMetadataParams,
        });
        
        const initStartTime = Date.now();
        await dynamoDB.update(initMetadataParams);
        const initLatency = Date.now() - initStartTime;
        
        logger.info(`[${functionName}] Metadata initialization completed`, {
            requestId,
            latencyMs: initLatency,
        });
        
        // Step 7b: Then update the cybrid data
        const updateParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
            UpdateExpression: 'SET #metadata.#cybrid = :cybridData, updatedAt = :updatedAt',
            ExpressionAttributeNames: {
                '#metadata': 'metadata',
                '#cybrid': 'cybrid',
            },
            ExpressionAttributeValues: {
                ':cybridData': {
                    customerId: customer.guid,
                },
                ':updatedAt': DateUtil.now(),
            },
            ReturnValues: 'NONE' as const,
        };

        logger.debug(`[${functionName}] Step 7b: Updating Cybrid customer data`, {
            requestId,
            updateParams,
        });
        
        const updateStartTime = Date.now();
        await dynamoDB.update(updateParams);
        const updateLatency = Date.now() - updateStartTime;
        
        logger.info(`[${functionName}] User record successfully updated with Cybrid data`, {
            requestId,
            userId,
            cybridCustomerId: customer.guid,
            updateLatencyMs: updateLatency,
        });

        // Step 8: Prepare and return response
        const cybridCustomerResponse: CreateCyCustomerResponse = {
            success: true,
            message: 'Customer created successfully',
            guid: customer.guid,
            state: customer.state,
        };

        const createCustomerResponse: CreateCustomerResponse = {
            message: 'Customer created and stored in banking provider',
            data: cybridCustomerResponse,
        };

        logger.info(`[${functionName}] Customer creation completed successfully`, {
            requestId,
            userId,
            cybridCustomerId: customer.guid,
            customerState: customer.state,
            totalExecutionTime: Date.now() - startTime,
        });

        return responseBuilder(createCustomerResponse, 200);
    } catch (error: any) {
        const errorDetails = {
            requestId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            errorStatus: error.status,
            errorResponse: error.response?.data,
            totalExecutionTime: Date.now() - startTime,
        };
        
        logger.error(`[${functionName}] Unhandled error during customer creation process`, errorDetails);

        let errorMessage = 'Internal server error';
        let statusCode = 500;

        if (error.status) {
            errorMessage = error.message || 'Cybrid API request failed';
            statusCode = error.status || 500;
        } else if (error instanceof Error) {
            errorMessage = error.message;
        }

        logger.error(`[${functionName}] Returning error response`, {
            requestId,
            statusCode,
            errorMessage,
        });

        return responseBuilder(errorMessage, statusCode);
    }
};
</file>

<file path="lambdas/cybrid/externalAccounts/verifyAccounts/app.ts">
// clkk-aws/lambdas/cybrid/externalAccounts/verifyAccounts/app.ts
import { Logger } from '@aws-lambda-powertools/logger';
import { DynamoDB } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { type SQSEvent, type SQSHandler } from 'aws-lambda';
import { AWS_SECRETS } from 'commons/utils/constants';
import { DYNAMO_TABLES } from 'commons/utils/constants';
import { getSecret } from 'commons/utils/getSecret';
import { getCybridToken } from 'commons/utils/cybrid-auth';

export enum Currency {
    USD = 2,
    BTC = 8,
    ETH = 18,
}

export const toBaseUnit = (amount: number, currency: Currency): number => {
    return amount * Math.pow(10, currency);
};

export const fromBaseUnit = (amount: number, currency: Currency): number => {
    return amount / Math.pow(10, currency);
};

export const CybridConfig = {
    URL_SCHEME: process.env.CYBRID_URL_SCHEME || 'https',
    BASE_URL: process.env.CYBRID_BASE_URL || 'api.cybrid.dev',
    TIMEOUT: 30000, // 30 seconds
} as const;

export const CybridEndpoints = {
    BASE: {
        SANDBOX: 'sandbox.cybrid.app/api',
        PRODUCTION: 'production.cybrid.app/api',
    },
    URL_SCHEME: 'https',
    PATHS: {
        ACCOUNTS: '/api/accounts',
        CUSTOMERS: '/api/customers',
        EXTERNAL_BANK_ACCOUNTS: '/api/external_bank_accounts',
        IDENTITY_VERIFICATIONS: '/api/identity_verifications',
    },
    getBaseUrl: () => `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}`,
    getFullUrl: (path: string) => `${CybridEndpoints.getBaseUrl()}${path}`,
};

// Helper functions for common URL constructions
export const getCybridUrl = {
    accounts: () => CybridEndpoints.getFullUrl(CybridEndpoints.PATHS.ACCOUNTS),
    customers: () => CybridEndpoints.getFullUrl(CybridEndpoints.PATHS.CUSTOMERS),
    externalBankAccounts: () => CybridEndpoints.getFullUrl(CybridEndpoints.PATHS.EXTERNAL_BANK_ACCOUNTS),
    identityVerifications: () => CybridEndpoints.getFullUrl(CybridEndpoints.PATHS.IDENTITY_VERIFICATIONS),
    // Add specific account/customer/etc by ID
    accountById: (id: string) => `${getCybridUrl.accounts()}/${id}`,
    customerById: (id: string) => `${getCybridUrl.customers()}/${id}`,
    externalBankAccountById: (id: string) => `${getCybridUrl.externalBankAccounts()}/${id}`,
};

import {
    type AttestedOwnershipVerification,
    type CybridVerificationRequest,
    type IdentityVerificationResponse,
    type SQSMessageBody,
} from '../../../cybrid/types';
import { PlaidService } from '../../../cybrid/utils/plaidService';
import { PlaidTokenService } from '../../../cybrid/utils/plaidTokenService';
import { getPersonaUrl } from '../../utils/personaUrl';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../../../plaid/utils/single-table-keys';

export enum IdentityVerificationSource {
    PLAID = 'plaid',
    CYBRID = 'cybrid',
}

export interface IdentityVerificationRecord {
    identityVerificationId: string;
    customerId: string;
    userId: string;
    personaInquiryId: string | null;
    personaUrl: string | null;
    status: string;
    createdAt: string;
    updatedAt?: string;
    source: IdentityVerificationSource;
    outcome?: string;
    failure_codes?: string[];
    metadata?: {
        plaidAccessToken?: string;
        plaidAccountId?: string;
        plaidInstitutionId?: string;
        externalBankAccountGuid?: string;
        [key: string]: any;
    };
}
const logger = new Logger({ serviceName: 'cybrid-bank-account-verification' });
const dynamoDb = DynamoDBDocument.from(new DynamoDB({}));
const plaidTokenService = new PlaidTokenService();
const plaidService = new PlaidService();

export const lambdaHandler: SQSHandler = async (event: SQSEvent): Promise<void> => {
    logger.info('Incoming SQS event', { event });

    let cybridApiKey: string;
    try {
        cybridApiKey = await getCybridToken();
    } catch (error) {
        logger.error('Failed to get Cybrid authentication token', { error });
        return;
    }

    for (const record of event.Records) {
        let messageBody: SQSMessageBody;
        try {
            messageBody = JSON.parse(record.body);
            logger.info('Parsed message body', { messageBody });
        } catch (error) {
            logger.error('Invalid JSON in SQS message body', { error, messageId: record.messageId });
            continue; // Process next message
        }

        const eventType = record.messageAttributes?.eventType?.stringValue;
        const eventSource = record.messageAttributes?.eventSource?.stringValue;

        if (!eventType || eventType !== 'bank_account') {
            logger.error('Invalid verification type in SQS message', {
                type: eventType,
                messageId: record.messageId,
                messageBody,
            });
            continue; // Process next message
        }

        if (!eventSource || eventSource !== 'cybrid') {
            logger.error('Invalid verification method in SQS message', {
                method: eventSource,
                messageId: record.messageId,
                messageBody,
            });
            continue; // Process next message
        }

        logger.info('Valid verification type and method in SQS message', {
            eventType,
            eventSource,
            messageId: record.messageId,
            messageBody,
        });
        logger.info('Checking if message body has required fields', {
            customer_guid: messageBody.customer_guid,
            external_bank_account_guid: messageBody.external_bank_account_guid,
            messageId: record.messageId,
        });

        if (!messageBody.customer_guid || !messageBody.external_bank_account_guid || !messageBody.userId) {
            logger.warn('Missing required guids in SQS message', {
                customer_guid: messageBody.customer_guid,
                external_bank_account_guid: messageBody.external_bank_account_guid,
                userId: messageBody.userId,
                messageId: record.messageId,
            });
            continue; // Process next message
        }

        let cybridRequestBody: CybridVerificationRequest;
        try {
            // Fetch processor token from DynamoDB
            const processorToken = await plaidTokenService.getProcessorToken(messageBody.userId);
            if (processorToken) {
                // Fetch customer details from Plaid
                const plaidData = await plaidService.fetchPlaidIdentity(processorToken);
                logger.info('Successfully fetched Plaid identity', { plaidData });
                cybridRequestBody = {
                    type: 'attested_ownership',
                    method: 'attested_ownership',
                    name: {
                        first: plaidData.firstName,
                        last: plaidData.lastName,
                        full: `${plaidData.firstName} ${plaidData.lastName}`,
                    },
                    address: {
                        street: plaidData.address,
                        city: plaidData.city,
                        subdivision: plaidData.state,
                        postal_code: plaidData.postalCode,
                        country_code: plaidData.countryCode,
                    },
                    customer_guid: messageBody.customer_guid,
                    country_code: plaidData.countryCode,
                    date_of_birth: plaidData.dateOfBirth,
                    phone_number: plaidData.phoneNumber,
                    email_address: plaidData.emailAddress,
                    identification_numbers: plaidData.identificationNumbers,
                    external_bank_account_guid: messageBody.external_bank_account_guid,
                } as AttestedOwnershipVerification;
            } else {
                // Use customer details from SQS message
                if (
                    !messageBody.name ||
                    !messageBody.address ||
                    !messageBody.country_code ||
                    !messageBody.date_of_birth ||
                    !messageBody.phone_number ||
                    !messageBody.email_address ||
                    !messageBody.identification_numbers
                ) {
                    logger.warn('Missing required fields for attested_ownership in SQS message', {
                        messageBody,
                        messageId: record.messageId,
                    });
                    continue; // Process next message
                }
                cybridRequestBody = {
                    type: 'attested_ownership',
                    method: 'attested_ownership',
                    name: messageBody.name,
                    address: messageBody.address,
                    customer_guid: messageBody.customer_guid,
                    country_code: messageBody.country_code,
                    date_of_birth: messageBody.date_of_birth,
                    phone_number: messageBody.phone_number,
                    email_address: messageBody.email_address,
                    identification_numbers: messageBody.identification_numbers,
                    external_bank_account_guid: messageBody.external_bank_account_guid,
                } as AttestedOwnershipVerification;
            }
        } catch (error) {
            logger.error('Error fetching Plaid data or constructing request body', {
                error,
                messageId: record.messageId,
            });
            continue;
        }

        logger.info('Sending verification request to Cybrid', { cybridRequestBody });

        let cybridResponseData: IdentityVerificationResponse;
        try {
            const cybridResponse = await fetch(
                getCybridUrl.identityVerifications(),
                {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${cybridApiKey}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(cybridRequestBody),
                },
            );

            if (!cybridResponse.ok) {
                const errorBody = await cybridResponse.json();
                logger.error('Error creating identity verification', {
                    error: errorBody,
                    messageId: record.messageId,
                    status: cybridResponse.status,
                });
                continue;
            }

            cybridResponseData = await cybridResponse.json();
            logger.info('Successfully created identity verification', {
                cybridResponse: cybridResponseData,
                messageId: record.messageId,
            });
        } catch (error) {
            logger.error('Error creating identity verification', { error, messageId: record.messageId });
            continue;
        }

        // Store the identity verification in the single table
        try {
            const now = new Date().toISOString();
            const processorToken = await plaidTokenService.getProcessorToken(messageBody.userId);
            
            // Create identity verification record
            const identityVerificationRecord: IdentityVerificationRecord = {
                identityVerificationId: cybridResponseData.guid,
                customerId: messageBody.customer_guid,
                userId: messageBody.userId,
                personaInquiryId: null,
                personaUrl: null,
                status: cybridResponseData.state,
                createdAt: now,
                updatedAt: now,
                source: processorToken ? IdentityVerificationSource.PLAID : IdentityVerificationSource.CYBRID,
                outcome: cybridResponseData.outcome,
                failure_codes: cybridResponseData.failure_codes,
                metadata: {
                    externalBankAccountGuid: messageBody.external_bank_account_guid,
                    plaidAccessToken: processorToken || undefined,
                    compliance_checks: cybridResponseData.compliance_checks,
                    compliance_decisions: cybridResponseData.compliance_decisions,
                },
            };

            // Store using single table keys
            const verificationKeys = SingleTableKeys.cybridIdentityVerification(
                messageBody.userId,
                cybridResponseData.guid,
                now
            );
            
            const params = {
                TableName: SINGLE_TABLE_NAME,
                Item: {
                    ...verificationKeys,
                    ...identityVerificationRecord,
                },
                ConditionExpression: 'attribute_not_exists(PK)',
            };
            
            await dynamoDb.put(params);
            logger.info('Successfully stored identity verification in single table', {
                identityVerificationId: cybridResponseData.guid,
                userId: messageBody.userId,
                source: identityVerificationRecord.source,
                messageId: record.messageId,
            });
        } catch (error) {
            logger.error('Error storing identity verification', {
                error,
                messageId: record.messageId,
                identityVerificationGuid: cybridResponseData.guid,
            });
            continue;
        }

        if (cybridResponseData.state === 'completed' && cybridResponseData.outcome === 'passed') {
            // Update the fiat account state in single table
            try {
                const fiatAccountKeys = SingleTableKeys.cybridFiatAccount(
                    messageBody.userId,
                    messageBody.external_bank_account_guid
                );
                
                const params = {
                    TableName: SINGLE_TABLE_NAME,
                    Key: fiatAccountKeys,
                    UpdateExpression: 'SET #state = :state, #updatedAt = :updatedAt',
                    ExpressionAttributeNames: {
                        '#state': 'state',
                        '#updatedAt': 'updatedAt',
                    },
                    ExpressionAttributeValues: {
                        ':state': 'verified',
                        ':updatedAt': new Date().toISOString(),
                    },
                    ConditionExpression: 'attribute_exists(PK)',
                };
                
                await dynamoDb.update(params);
                logger.info('Successfully updated fiat account state to verified', {
                    userId: messageBody.userId,
                    externalBankAccountGuid: messageBody.external_bank_account_guid,
                    messageId: record.messageId,
                });
            } catch (error) {
                logger.error('Error updating fiat account state', {
                    error,
                    messageId: record.messageId,
                    userId: messageBody.userId,
                    externalBankAccountGuid: messageBody.external_bank_account_guid,
                });
            }
            continue;
        } else {
            // Fetch persona URL and update the identity verification record
            try {
                const personaUrlData = await getPersonaUrl(cybridResponseData.guid);
                const now = new Date().toISOString();
                
                // Get the original creation timestamp to maintain the same SK
                const queryParams = {
                    TableName: SINGLE_TABLE_NAME,
                    KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
                    ExpressionAttributeValues: {
                        ':pk': `USER#${messageBody.userId}`,
                        ':skPrefix': `CYBRID_KYC#`,
                    },
                    ScanIndexForward: false,
                    Limit: 10, // Get recent verifications
                };
                
                const queryResult = await dynamoDb.query(queryParams);
                const existingRecord = queryResult.Items?.find(
                    (item: any) => item.identityVerificationId === cybridResponseData.guid
                );
                
                if (existingRecord) {
                    // Update the existing record with persona URL
                    const updateParams = {
                        TableName: SINGLE_TABLE_NAME,
                        Key: {
                            PK: existingRecord.PK,
                            SK: existingRecord.SK,
                        },
                        UpdateExpression: 'SET personaInquiryId = :personaInquiryId, personaUrl = :personaUrl, updatedAt = :updatedAt',
                        ExpressionAttributeValues: {
                            ':personaInquiryId': personaUrlData.inquiryId,
                            ':personaUrl': personaUrlData.url,
                            ':updatedAt': now,
                        },
                    };
                    
                    await dynamoDb.update(updateParams);
                    logger.info('Successfully updated identity verification with persona URL', {
                        personaUrl: personaUrlData.url,
                        personaInquiryId: personaUrlData.inquiryId,
                        identityVerificationId: cybridResponseData.guid,
                        userId: messageBody.userId,
                        messageId: record.messageId,
                    });
                } else {
                    logger.warn('Could not find existing identity verification record to update', {
                        identityVerificationId: cybridResponseData.guid,
                        userId: messageBody.userId,
                        messageId: record.messageId,
                    });
                }
            } catch (error) {
                logger.error('Error updating identity verification with persona URL', {
                    error,
                    messageId: record.messageId,
                    identityVerificationGuid: cybridResponseData.guid,
                    userId: messageBody.userId,
                });
            }
            continue;
        }
    }
};
</file>

<file path="lambdas/cybrid/externalAccounts/app.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import axios from 'axios';
import { CybridConfig, dynamoDB, getCybridToken, SQSService } from 'commons';
import { type Entity } from 'commons/types/users/entities.i';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'cybrid-external-accounts',
});

const sqsService = new SQSService(process.env.VERIFICATION_QUEUE_URL || '');

// Request/Response types
export interface CreateExternalAccountRequest {
    userId: string;
    externalBankAccountData: {
        customer_guid: string;
        account_owner_name: string;
        account_number: string;
        routing_number: string;
        account_type?: string;
        asset?: string;
    };
}

export interface CreateExternalAccountResponse {
    message: string;
    externalAccountGuid?: string;
}

export const createExternalBankAccountHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'CreateCybridExternalAccount';
    let userId: string | undefined;
    
    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });
    
    try {
        // Step 1: Parse and validate request body
        logger.info(`[${functionName}] Step 1: Parsing request body`, {
            requestId,
        });
        
        const body = JSON.parse(event.body || '{}');
        userId = body.userId;
        const externalBankAccountData = body.externalBankAccountData;

        logger.info(`[${functionName}] Request body parsed`, {
            requestId,
            hasUserId: !!userId,
            hasExternalBankAccountData: !!externalBankAccountData,
            accountDataFields: externalBankAccountData ? Object.keys(externalBankAccountData) : [],
        });

        if (!userId || !externalBankAccountData) {
            logger.error(`[${functionName}] Missing required fields in request body`, {
                requestId,
                hasUserId: !!userId,
                hasExternalBankAccountData: !!externalBankAccountData,
            });
            return {
                statusCode: 400,
                body: JSON.stringify({ message: 'Missing userId or externalBankAccountData' }),
            };
        }

        // Step 2: Retrieve user record from DynamoDB
        logger.info(`[${functionName}] Step 2: Retrieving user record`, {
            requestId,
            userId,
            tableName: SINGLE_TABLE_NAME,
        });
        
        const userKeys = SingleTableKeys.user(userId);
        const getUserParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
        };

        logger.debug(`[${functionName}] DynamoDB GetItem parameters`, {
            requestId,
            params: getUserParams,
        });

        const dbStartTime = Date.now();
        const userRecord = await dynamoDB.get(getUserParams) as Entity | null;
        const dbLatency = Date.now() - dbStartTime;
        
        logger.info(`[${functionName}] User record retrieval completed`, {
            requestId,
            userId,
            recordFound: !!userRecord,
            latencyMs: dbLatency,
        });
        
        if (!userRecord) {
            logger.error(`[${functionName}] User record not found`, {
                requestId,
                userId,
            });
            return {
                statusCode: 404,
                body: JSON.stringify({ message: 'User record not found' }),
            };
        }
        
        logger.info(`[${functionName}] User record details`, {
            requestId,
            userId,
            userEmail: userRecord.email,
            hasMetadata: !!userRecord.metadata,
            hasCybridMetadata: !!userRecord.metadata?.cybrid,
        });

        // Step 3: Create external bank account in Cybrid
        logger.info(`[${functionName}] Step 3: Creating external bank account in Cybrid`, {
            requestId,
            userId,
            accountOwnerName: externalBankAccountData.account_owner_name,
            accountType: externalBankAccountData.account_type,
            asset: externalBankAccountData.asset,
        });
        
        const cybridToken = await getCybridToken();
        const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/external_bank_accounts`;

        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };
        
        logger.debug(`[${functionName}] Cybrid API request details`, {
            requestId,
            url: apiUrl,
            accountDataFields: Object.keys(externalBankAccountData),
        });

        const cybridStartTime = Date.now();
        const response = await axios.post(apiUrl, externalBankAccountData, { headers });
        const cybridLatency = Date.now() - cybridStartTime;
        
        const externalAccount = response.data;
        
        logger.info(`[${functionName}] External account created successfully`, {
            requestId,
            userId,
            externalAccountId: externalAccount.guid,
            accountState: externalAccount.state,
            accountAsset: externalAccount.asset,
            cybridLatencyMs: cybridLatency,
        });

        // Step 4: Update user record with external account
        logger.info(`[${functionName}] Step 4: Updating user record with external account`, {
            requestId,
            userId,
            externalAccountId: externalAccount.guid,
        });
        
        // Step 4a: First ensure metadata exists
        const initParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
            UpdateExpression: 'SET #metadata = if_not_exists(#metadata, :emptyMetadata)',
            ExpressionAttributeNames: {
                '#metadata': 'metadata',
            },
            ExpressionAttributeValues: {
                ':emptyMetadata': {},
            },
            ReturnValues: 'NONE' as const,
        };
        
        logger.debug(`[${functionName}] Initializing metadata`, {
            requestId,
            params: initParams,
        });
        
        const initStartTime = Date.now();
        await dynamoDB.update(initParams);
        const initLatency = Date.now() - initStartTime;
        
        logger.info(`[${functionName}] Metadata initialization completed`, {
            requestId,
            latencyMs: initLatency,
        });
        
        // Step 4b: Then update the external account
        const updateParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
            UpdateExpression: 'SET #metadata.#cybrid.#externalAccount = :externalAccount',
            ExpressionAttributeNames: {
                '#metadata': 'metadata',
                '#cybrid': 'cybrid',
                '#externalAccount': 'externalAccount',
            },
            ExpressionAttributeValues: {
                ':externalAccount': externalAccount,
            },
        };

        logger.debug(`[${functionName}] Updating external account data`, {
            requestId,
            params: updateParams,
        });
        
        const updateStartTime = Date.now();
        await dynamoDB.update(updateParams);
        const updateLatency = Date.now() - updateStartTime;
        
        logger.info(`[${functionName}] User record updated successfully`, {
            requestId,
            userId,
            externalAccountId: externalAccount.guid,
            updateLatencyMs: updateLatency,
        });

        // Step 5: Send SQS message to start verification process
        logger.info(`[${functionName}] Step 5: Sending verification message to SQS`, {
            requestId,
            userId,
            externalAccountId: externalAccount.guid,
        });
        
        try {
            const verificationMessage = {
                customer_guid: userRecord.metadata?.cybrid?.customerId,
                external_bank_account_guid: externalAccount.guid,
                userId,
            };

            logger.debug(`[${functionName}] Verification message details`, {
                requestId,
                verificationMessage,
            });
            
            const sqsStartTime = Date.now();
            const message = SQSService.createMessage(verificationMessage, 'cybrid', 'bank_account');
            await sqsService.sendMessage(message);
            const sqsLatency = Date.now() - sqsStartTime;
            
            logger.info(`[${functionName}] SQS message sent successfully`, {
                requestId,
                externalAccountId: externalAccount.guid,
                customerGuid: userRecord.metadata?.cybrid?.customerId,
                userId,
                sqsLatencyMs: sqsLatency,
            });
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to send SQS message`, {
                requestId,
                errorMessage: error.message,
                externalAccountId: externalAccount.guid,
                customerGuid: userRecord.metadata?.cybrid?.customerId,
            });
            // Not throwing error as this is non-critical
        }

        // Step 6: Return success response
        const successResponse = {
            message: 'External bank account created successfully',
            externalAccountGuid: externalAccount.guid,
            externalAccount: response.data,
        };
        
        logger.info(`[${functionName}] External account creation completed successfully`, {
            requestId,
            userId,
            externalAccountId: externalAccount.guid,
            totalExecutionTime: Date.now() - startTime,
        });

        return {
            statusCode: 200,
            body: JSON.stringify(successResponse),
        };
    } catch (error: any) {
        const errorDetails = {
            requestId,
            userId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            errorStatus: axios.isAxiosError(error) ? error.response?.status : undefined,
            errorResponse: axios.isAxiosError(error) ? error.response?.data : undefined,
            totalExecutionTime: Date.now() - startTime,
        };
        
        logger.error(`[${functionName}] Error creating external bank account`, errorDetails);
        
        const statusCode = axios.isAxiosError(error) ? (error.response?.status || 500) : 500;
        
        return {
            statusCode,
            body: JSON.stringify({
                message: 'Error creating external bank account',
                error: axios.isAxiosError(error)
                    ? error.response?.data
                    : error instanceof Error
                    ? error.message
                    : 'Unknown error',
            }),
        };
    }
};

export const getExternalBankAccountHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    try {
        const guid = event.pathParameters?.guid;
        if (!guid) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: 'Missing external bank account GUID' }),
            };
        }

        const cybridToken = await getCybridToken();
        const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/external_bank_accounts/${guid}`;

        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        const params = {
            force_balance_refresh: event.queryStringParameters?.force_balance_refresh === 'true',
            include_balances: event.queryStringParameters?.include_balances === 'true',
            include_pii: event.queryStringParameters?.include_pii === 'true',
        };

        const response = await axios.get(apiUrl, { headers, params });

        return {
            statusCode: 200,
            body: JSON.stringify(response.data),
        };
    } catch (error) {
        logger.error('Error getting external bank account', {
            error,
            response: axios.isAxiosError(error) ? error.response?.data : undefined,
        });
        return {
            statusCode: 500,
            body: JSON.stringify({
                message: 'Error getting external bank account',
                error: axios.isAxiosError(error)
                    ? error.response?.data
                    : error instanceof Error
                    ? error.message
                    : 'Unknown error',
            }),
        };
    }
};

export const deleteExternalBankAccountHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    try {
        const guid = event.pathParameters?.guid;
        const userId = event.queryStringParameters?.userId || event.queryStringParameters?.clerkUserId;

        if (!guid) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: 'Missing external bank account GUID' }),
            };
        }

        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: 'Missing userId or clerkUserId' }),
            };
        }

        // 1. Delete from Cybrid
        const cybridToken = await getCybridToken();
        const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/external_bank_accounts/${guid}`;

        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        await axios.delete(apiUrl, { headers });

        // 2. Remove External Account from User Record
        const userKeys = SingleTableKeys.user(userId);
        const updateParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
            UpdateExpression: 'REMOVE cybrid.externalAccount',
        };

        await dynamoDB.update(updateParams);
        logger.info('Removed external account from user record', { userId, externalAccountGuid: guid });

        return {
            statusCode: 200,
            body: JSON.stringify({ message: 'External bank account deleted successfully' }),
        };
    } catch (error) {
        logger.error('Error deleting external bank account', {
            error,
            response: axios.isAxiosError(error) ? error.response?.data : undefined,
        });
        return {
            statusCode: 500,
            body: JSON.stringify({
                message: 'Error deleting external bank account',
                error: axios.isAxiosError(error)
                    ? error.response?.data
                    : error instanceof Error
                    ? error.message
                    : 'Unknown error',
            }),
        };
    }
};
</file>

<file path="lambdas/cybrid/identities/app.ts">
import { type IdentityVerificationBankModel } from '@cybrid/cybrid-api-bank-typescript';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import axios from 'axios';
import { CybridConfig } from 'commons';
import {
    DateUtil,
    dynamoDB,
    type IdentityVerificationDynamoItem,
    type KYC,
    logger,
    responseBuilder,
} from 'commons';
import { type Entity } from 'commons/types/users/entities.i';
import { getCybridToken } from 'commons/utils/cybrid-auth';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';
import { PERSONA } from '../utils/constants';

// Add this at the top level of the file (not inside handler)
function isValidVerification(iv: IdentityVerificationDynamoItem): boolean {
    return iv.status === 'completed' || iv.status === 'waiting';
}

// Request/Response types
export interface CreateIdentityVerificationRequest {
    // No body params needed, userId comes from auth context
}

export interface CreateIdentityVerificationResponse {
    message: string;
    data?: {
        verificationId: string;
        verificationUrl?: string;
        status?: string;
    };
}

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'CreateCybridIdentityVerification';
    
    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });

    // Step 1: Extract and validate user ID
    const userId = event.requestContext.authorizer?.userId;

    logger.info(`[${functionName}] Step 1: Extracting user ID from authorizer`, {
        requestId,
        userIdFound: !!userId,
        authorizerContext: event.requestContext.authorizer,
    });

    if (!userId) {
        logger.error(`[${functionName}] Authorization failed - User ID not found`, {
            requestId,
            authorizerContext: event.requestContext.authorizer,
        });
        return responseBuilder('Forbidden', 403);
    }

    try {
        // Step 2: Get Cybrid Customer ID from DynamoDB
        logger.info(`[${functionName}] Step 2: Retrieving user record from DynamoDB`, {
            requestId,
            userId,
            tableName: SINGLE_TABLE_NAME,
        });
        
        const userKeys = SingleTableKeys.user(userId);
        const getParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
        };

        logger.debug(`[${functionName}] DynamoDB GetItem parameters`, {
            requestId,
            params: getParams,
        });

        const dbStartTime = Date.now();
        const response = await dynamoDB.get(getParams);
        const dbLatency = Date.now() - dbStartTime;
        
        logger.info(`[${functionName}] User record retrieved`, {
            requestId,
            userId,
            recordFound: !!response,
            latencyMs: dbLatency,
        });
        
        const userRecord = response as Entity | null;
        const cybridCustomerId = userRecord?.metadata?.cybrid?.customerId;
        
        logger.info(`[${functionName}] Cybrid customer ID extraction`, {
            requestId,
            userId,
            hasCybridCustomerId: !!cybridCustomerId,
            cybridCustomerId,
            hasMetadata: !!userRecord?.metadata,
            hasCybridMetadata: !!userRecord?.metadata?.cybrid,
        });
        
        if (!cybridCustomerId) {
            logger.error(`[${functionName}] Cybrid customer not found for user`, {
                requestId,
                userId,
                metadata: userRecord?.metadata,
            });
            return responseBuilder('Cybrid customer not found for this user', 404);
        }

        // Step 3: Check for existing identity verification
        logger.info(`[${functionName}] Step 3: Checking for existing identity verification`, {
            requestId,
            userId,
            cybridCustomerId,
        });
        
        // Query using the primary key instead of GSI
        const listIdentityVerificationsParams = {
            TableName: SINGLE_TABLE_NAME,
            KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
            FilterExpression: 'customerId = :customerId',
            ExpressionAttributeValues: {
                ':pk': `USER#${userId}`,
                ':skPrefix': 'CYBRID_KYC#',
                ':customerId': cybridCustomerId,
            },
        };

        logger.debug(`[${functionName}] DynamoDB Query parameters`, {
            requestId,
            params: listIdentityVerificationsParams,
        });

        const queryStartTime = Date.now();
        const result = (await dynamoDB.query(listIdentityVerificationsParams)) as {
            Items?: IdentityVerificationDynamoItem[];
        };
        const queryLatency = Date.now() - queryStartTime;
        
        logger.info(`[${functionName}] Identity verification query completed`, {
            requestId,
            verificationsFound: result.Items?.length || 0,
            latencyMs: queryLatency,
        });
        
        const existingVerifications = (result.Items || []) as IdentityVerificationDynamoItem[];

        // Type guard for verification status
        const validVerification = existingVerifications.find(isValidVerification);

        if (validVerification) {
            logger.info(`[${functionName}] Existing valid verification found - returning existing`, {
                requestId,
                userId,
                verificationId: validVerification.identityVerificationId,
                status: validVerification.status,
                totalExecutionTime: Date.now() - startTime,
            });

            return {
                statusCode: 200,
                body: JSON.stringify({
                    status: validVerification.status,
                    personaUrl: validVerification.personaUrl,
                    identityVerificationId: validVerification.identityVerificationId,
                    message: `Verification ${validVerification.status}`,
                }),
            };
        }

        logger.info(`[${functionName}] No existing verification found, proceeding with creation`, {
            requestId,
            userId,
            cybridCustomerId,
        });

        // Step 4: Create new identity verification
        logger.info(`[${functionName}] Step 4: Creating new identity verification`, {
            requestId,
            userId,
            cybridCustomerId,
        });
        
        const createStartTime = Date.now();
        const identityVerificationData = await createIdentityVerification(cybridCustomerId, userId, requestId);
        const createLatency = Date.now() - createStartTime;

        logger.info(`[${functionName}] Identity verification creation completed`, {
            requestId,
            verificationId: identityVerificationData?.guid,
            verificationState: identityVerificationData?.state,
            latencyMs: createLatency,
        });
        
        if (!identityVerificationData?.guid) {
            logger.error(`[${functionName}] Invalid verification data received - missing GUID`, {
                requestId,
                userId,
                verificationData: identityVerificationData,
            });
            throw new Error('Failed to create identity verification - missing GUID');
        }

        // Step 5: Process and store the verification
        logger.info(`[${functionName}] Step 5: Processing verification for storage`, {
            requestId,
            userId,
            verificationId: identityVerificationData.guid,
            verificationState: identityVerificationData.state,
        });
        
        // Step 5a: Poll for Persona inquiry ID
        logger.info(`[${functionName}] Step 5a: Polling for Persona inquiry ID`, {
            requestId,
            verificationId: identityVerificationData.guid,
        });
        
        const pollStartTime = Date.now();
        const personaInquiryId = await pollForPersonaInquiryId(identityVerificationData.guid, requestId);
        const pollLatency = Date.now() - pollStartTime;
        
        logger.info(`[${functionName}] Persona inquiry ID received`, {
            requestId,
            personaInquiryId,
            pollLatencyMs: pollLatency,
        });
        
        const personaUrl = personaInquiryId ? `${PERSONA.BASE_URL}${personaInquiryId}` : null;
        
        logger.info(`[${functionName}] Persona URL generated`, {
            requestId,
            personaUrl,
        });

        const now = DateUtil.now();
        const timestamp = new Date().toISOString();

        // Create transaction items
        const transactionItems = [
            {
                // Update Users table
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: userKeys,
                    UpdateExpression: 'SET kyc = :kyc, updatedAt = :updatedAt',
                    ExpressionAttributeValues: {
                        ':kyc': {
                            identityVerificationId: identityVerificationData.guid,
                            personaInquiryId,
                            personaUrl,
                            status: identityVerificationData.state,
                            createdAt: now,
                            updatedAt: now,
                        } as KYC,
                        ':updatedAt': now,
                    },
                    ConditionExpression: 'attribute_exists(PK) AND attribute_exists(SK)',
                },
            },
            {
                // Put Identity Verification record (will overwrite if exists)
                Put: {
                    TableName: SINGLE_TABLE_NAME,
                    Item: {
                        ...SingleTableKeys.cybridIdentityVerification(userId, identityVerificationData.guid, timestamp),
                        identityVerificationId: identityVerificationData.guid,
                        customerId: cybridCustomerId,
                        personaInquiryId,
                        personaUrl,
                        status: identityVerificationData.state,
                        createdAt: now,
                        userId,
                    },
                },
            },
        ];

        // Step 5b: Execute DynamoDB transaction
        logger.info(`[${functionName}] Step 5b: Executing DynamoDB transaction`, {
            requestId,
            userId,
            transactionItemsCount: transactionItems.length,
        });
        
        try {
            const transactStartTime = Date.now();
            await dynamoDB.transactWrite({ TransactItems: transactionItems });
            const transactLatency = Date.now() - transactStartTime;
            
            logger.info(`[${functionName}] Transaction completed successfully`, {
                requestId,
                userId,
                verificationId: identityVerificationData.guid,
                transactionLatencyMs: transactLatency,
            });

            const successResponse = {
                personaUrl,
                identityVerificationId: identityVerificationData.guid,
                customerId: cybridCustomerId,
                userId,
            };
            
            logger.info(`[${functionName}] Identity verification processed successfully`, {
                requestId,
                ...successResponse,
                totalExecutionTime: Date.now() - startTime,
            });

            return {
                statusCode: 200,
                body: JSON.stringify(successResponse),
            };
        } catch (error: any) {
            // If transaction fails due to condition check, it means items already exist
            // which is fine - just return success
            if (error.name === 'TransactionCanceledException') {
                logger.info(`[${functionName}] Verification already stored, returning success`, {
                    requestId,
                    userId,
                    verificationId: identityVerificationData.guid,
                });
                
                const successResponse = {
                    personaUrl,
                    identityVerificationId: identityVerificationData.guid,
                    customerId: cybridCustomerId,
                    userId,
                };
                
                return {
                    statusCode: 200,
                    body: JSON.stringify(successResponse),
                };
            }
            
            logger.error(`[${functionName}] Transaction failed`, {
                requestId,
                userId,
                errorMessage: error.message,
                errorType: error.constructor.name,
            });
            throw error;
        }
    } catch (error: any) {
        const errorDetails = {
            requestId,
            userId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            details: error.details, // From our enhanced error
            responseData: error.response?.data,
            responseStatus: error.response?.status,
            cybridRequestId: error.response?.headers?.['x-request-id'],
            totalExecutionTime: Date.now() - startTime,
        };

        // Log different levels based on error type
        if (error.response?.status === 409) {
            logger.warn(`[${functionName}] Identity verification conflict (409)`, errorDetails);
            return {
                statusCode: 409,
                body: JSON.stringify({
                    message: 'Identity verification already in progress',
                    code: 'VERIFICATION_EXISTS',
                }),
            };
        }

        logger.error(`[${functionName}] Error processing identity verification`, errorDetails);
        
        return {
            statusCode: error.response?.status || 500,
            body: JSON.stringify({
                message: 'Error processing identity verification',
                code: error.response?.data?.message_code || 'INTERNAL_ERROR',
            }),
        };
    }
};

// Helper functions

async function createIdentityVerification(customerId: string, userId: string, requestId: string): Promise<IdentityVerificationBankModel> {
    const functionName = 'createIdentityVerification';
    
    logger.info(`[${functionName}] Starting identity verification creation`, {
        requestId,
        customerId,
        userId,
    });
    // 1. Check for Existing Identity Verification
    const listIdentityVerificationsParams = {
        TableName: SINGLE_TABLE_NAME,
        KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
        FilterExpression: 'customerId = :customerId',
        ExpressionAttributeValues: {
            ':pk': `USER#${userId}`,
            ':skPrefix': 'CYBRID_KYC#',
            ':customerId': customerId,
        },
    };

    const result = (await dynamoDB.query(listIdentityVerificationsParams)) as {
        Items?: IdentityVerificationDynamoItem[];
    };
    logger.info(`[${functionName}] Query completed`, {
        requestId,
        itemsFound: result.Items?.length || 0,
    });
    
    const existingVerifications = (result.Items || []) as IdentityVerificationDynamoItem[];
    
    logger.debug(`[${functionName}] Existing verifications details`, {
        requestId,
        verificationsCount: existingVerifications.length,
        verifications: existingVerifications.map(v => ({
            id: v.identityVerificationId,
            status: v.status,
        })),
    });

    // Explicit check for valid verification data
    const existingVerification = existingVerifications.find(isValidVerification);
    if (existingVerification) {
        logger.info(`[${functionName}] Found existing valid verification in database`, {
            requestId,
            customerId,
            verificationId: existingVerification.identityVerificationId,
            status: existingVerification.status,
        });
        
        // Transform DynamoDB item to match Cybrid API response format
        return {
            guid: existingVerification.identityVerificationId,
            state: existingVerification.status,
            persona_inquiry_id: existingVerification.personaInquiryId,
        } as IdentityVerificationBankModel;
    }

    // 2. Create New Identity Verification
    logger.info(`[${functionName}] Creating new identity verification in Cybrid`, {
        requestId,
        customerId,
    });
    
    const cybridToken = await getCybridToken();
    const identityVerificationsApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications`;

    const identityVerificationData = {
        customer_guid: customerId,
        type: 'kyc',
        method: 'id_and_selfie',
    };

    logger.debug(`[${functionName}] Cybrid API request details`, {
        requestId,
        url: identityVerificationsApiUrl,
        payload: identityVerificationData,
    });

    try {
        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        const startTime = Date.now();
        const response = await axios.post(identityVerificationsApiUrl, identityVerificationData, { headers });
        const latency = Date.now() - startTime;
        
        logger.info(`[${functionName}] Identity verification created successfully`, {
            requestId,
            customerId,
            verificationId: response.data.guid,
            verificationState: response.data.state,
            cybridLatencyMs: latency,
        });
        
        return response.data as IdentityVerificationBankModel;
    } catch (error: any) {
        const errorDetails = {
            message: error.message,
            status: error.response?.status,
            errorMessage: error.response?.data?.error_message,
            messageCode: error.response?.data?.message_code,
            requestId: error.response?.headers?.['x-request-id'],
            customerId,
        };

        // log customerId
        logger.info('Customer ID:', { customerId });

        if (error.response?.status === 409) {
            logger.warn('Identity verification already exists for customer', errorDetails);

            // Fetch the existing identity verification from DynamoDB
            const getIdentityVerificationParams = {
                TableName: SINGLE_TABLE_NAME,
                KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
                FilterExpression: 'customerId = :customerId',
                ExpressionAttributeValues: {
                    ':pk': `USER#${userId}`,
                    ':skPrefix': 'CYBRID_KYC#',
                    ':customerId': customerId,
                },
            };
            logger.info('Get identity verification params:', { getIdentityVerificationParams });
            const result = await dynamoDB.query(getIdentityVerificationParams);
            logger.info('Get identity verification result:', { result });

            // FIX: Handle result as an array directly with proper typing
            const existingVerifications = Array.isArray(result) ? result : (result as any).Items || [];
            logger.info('Existing identity table:', { existingVerifications });
            const existingVerification = existingVerifications.find(isValidVerification);
            logger.info('Existing identity verification after query:', { existingVerification });

            // Transform DynamoDB item to match Cybrid API response format
            if (existingVerification) {
                return {
                    guid: existingVerification.identityVerificationId,
                    state: existingVerification.status,
                    persona_inquiry_id: existingVerification.personaInquiryId,
                } as IdentityVerificationBankModel;
            }

            // If no valid verification found in DynamoDB, fetch from Cybrid
            logger.info(`[${functionName}] No verification found in DynamoDB, fetching from Cybrid`, {
                requestId,
                customerId,
            });
            
            // Fetch the existing verification from Cybrid
            const cybridToken = await getCybridToken();
            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
            };
            
            // List identity verifications for this customer
            const listUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications?customer_guid=${customerId}`;
            const listResponse = await axios.get(listUrl, { headers });
            
            if (listResponse.data.objects && listResponse.data.objects.length > 0) {
                // Return the first active verification
                const activeVerification = listResponse.data.objects.find((v: any) => 
                    v.state === 'storing' || v.state === 'waiting' || v.state === 'completed'
                );
                
                if (activeVerification) {
                    logger.info(`[${functionName}] Found existing verification in Cybrid`, {
                        requestId,
                        verificationId: activeVerification.guid,
                        state: activeVerification.state,
                    });
                    return activeVerification as IdentityVerificationBankModel;
                }
            }
            
            // If still no verification found, throw error
            throw new Error('No valid identity verification found for customer');
        } else {
            logger.error('Failed to create identity verification', errorDetails);
        }

        throw {
            ...error,
            details: errorDetails,
        };
    }
}

async function pollForPersonaInquiryId(identityVerificationGuid: string, requestId: string): Promise<string> {
    const functionName = 'pollForPersonaInquiryId';
    
    logger.info(`[${functionName}] Starting polling for Persona inquiry ID`, {
        requestId,
        identityVerificationGuid,
    });
    const cybridToken = await getCybridToken();
    const identityVerificationApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications/${identityVerificationGuid}`;

    const headers = {
        Authorization: `Bearer ${cybridToken}`,
        'Content-Type': 'application/json',
    };

    return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 12; // 1 minute maximum (12 * 5 seconds)

        const pollingInterval = setInterval(async () => {
            attempts++;
            logger.info(`[${functionName}] Polling attempt`, {
                requestId,
                attempt: attempts,
                maxAttempts,
                identityVerificationGuid,
            });

            try {
                const response = await axios.get(identityVerificationApiUrl, { headers });
                const identityVerification = response.data;

                if (identityVerification.persona_inquiry_id) {
                    clearInterval(pollingInterval);
                    logger.info(`[${functionName}] Persona inquiry ID found`, {
                        requestId,
                        attempts,
                        personaInquiryId: identityVerification.persona_inquiry_id,
                        totalPollingTime: attempts * 5000,
                    });
                    resolve(identityVerification.persona_inquiry_id);
                }

                if (attempts >= maxAttempts) {
                    clearInterval(pollingInterval);
                    const error = new Error('Max polling attempts reached');
                    logger.error(`[${functionName}] Polling timeout - max attempts reached`, {
                        requestId,
                        attempts,
                        maxAttempts,
                        identityVerificationGuid,
                    });
                    reject(error);
                }
            } catch (error: any) {
                logger.error(`[${functionName}] Error during polling`, {
                    requestId,
                    attempts,
                    errorMessage: error.message,
                    errorResponse: error.response?.data,
                });
                clearInterval(pollingInterval);
                reject(error);
            }
        }, 5000); // Poll every 5 seconds
    });
}

/**
 * Handles failed or expired identity verifications by cleaning up records
 * @param verification The verification record to check
 * @param userId The user ID
 * @returns Boolean indicating if a new verification should be created
 */
async function handleFailedOrExpiredVerification(verification: any, userId: string, requestId: string): Promise<boolean> {
    const functionName = 'handleFailedOrExpiredVerification';
    
    if (!verification || !['failed', 'expired'].includes(verification.status)) {
        logger.debug(`[${functionName}] Verification not failed/expired`, {
            requestId,
            verificationExists: !!verification,
            status: verification?.status,
        });
        return false; // Not failed or expired, don't treat as new
    }

    logger.info(`[${functionName}] Found failed/expired verification - cleaning up`, {
        requestId,
        userId,
        status: verification.status,
        verificationId: verification.identityVerificationId,
    });

    try {
        // 1. Delete from single table - need to find the exact record first
        const deleteParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: {
                PK: verification.PK,
                SK: verification.SK,
            },
        };
        await dynamoDB.delete(deleteParams);

        // 2. Update user record to remove KYC data
        const userUpdateKeys = SingleTableKeys.user(userId);
        await dynamoDB.update({
            TableName: SINGLE_TABLE_NAME,
            Key: userUpdateKeys,
            UpdateExpression: 'REMOVE kyc',
            ConditionExpression: 'attribute_exists(entityId)',
        });

        logger.info(`[${functionName}] Successfully cleaned up failed/expired verification`, {
            requestId,
            userId,
            verificationId: verification.identityVerificationId,
        });
        return true; // Treat as new verification
    } catch (error: any) {
        logger.error(`[${functionName}] Error cleaning up failed/expired verification`, {
            requestId,
            userId,
            verificationId: verification.identityVerificationId,
            errorMessage: error.message,
            errorType: error.constructor.name,
        });
        throw error;
    }
}
</file>

<file path="lambdas/cybrid/identities/business-identity-verification.ts">
import {
    IdentityVerificationBankModel,
    PostIdentityVerificationBankModel,
    PostIdentityVerificationBankModelMethodEnum,
    PostIdentityVerificationBankModelTypeEnum,
    PostIdentificationNumberBankModelTypeEnum,
} from '@cybrid/cybrid-api-bank-typescript';
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import axios from 'axios';
import { CybridConfig, DateUtil, DYNAMO_TABLES, dynamoDB, Entity, logger, responseBuilder } from 'commons';
import { getCybridToken } from 'commons/utils/cybrid-auth';
import { v4 as uuidv4 } from 'uuid';

// Identity verification status
type IdentityVerificationStatus = 'storing' | 'waiting' | 'completed' | 'failed' | 'expired';

// Business identity verification request interface
interface BusinessIdentityVerificationRequest {
    customer_guid: string;
    name: {
        full: string;
    };
    address: {
        street: string;
        street2?: string;
        city: string;
        postal_code: string;
        country_code: string;
        subdivision: string;
    };
    aliases?: Array<{
        full: string;
    }>;
    phone_number: string;
    email_address: string;
    website?: string;
    nature_of_business: string;
    identification_numbers: Array<{
        type: 'business_registration_number' | 'employer_identification_number' | 'tax_identification_number';
        issuing_country_code: string;
        identification_number: string;
    }>;
    director_customer_guids: string[];
    ultimate_beneficial_owners: Array<{
        customer_guid: string;
        ownership_percentage: number;
    }>;
    supporting_file_guids: string[];
}

// Identity verification record for DynamoDB
interface IdentityVerificationRecord {
    identityVerificationId: string;
    customerId: string;
    userId: string;
    status: IdentityVerificationStatus;
    createdAt: string;
    updatedAt?: string;
    verificationType: string;
    personaInquiryId?: string;
    personaUrl?: string;
}

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    logger.info('BusinessIdentityVerificationFunction invoked', { event });

    const userId = event.requestContext.authorizer?.userId;

    logger.info('User ID from event:', { userId });

    if (!userId) {
        logger.error('User ID not found in the context');
        return responseBuilder('Forbidden', 403);
    }

    if (!event.body) {
        logger.error('Request body is missing');
        return responseBuilder('Request body is required', 400);
    }

    try {
        // Parse request body
        const businessVerificationRequest: BusinessIdentityVerificationRequest = JSON.parse(event.body);
        logger.info('Business verification request', { businessVerificationRequest });

        // Validate required fields
        if (!businessVerificationRequest.customer_guid) {
            return responseBuilder('Customer GUID is required', 400);
        }

        if (!businessVerificationRequest.name || !businessVerificationRequest.name.full) {
            return responseBuilder('Business name is required', 400);
        }

        if (
            !businessVerificationRequest.address ||
            !businessVerificationRequest.address.street ||
            !businessVerificationRequest.address.city ||
            !businessVerificationRequest.address.postal_code ||
            !businessVerificationRequest.address.country_code
        ) {
            return responseBuilder('Complete business address is required', 400);
        }

        if (
            !businessVerificationRequest.identification_numbers ||
            businessVerificationRequest.identification_numbers.length === 0
        ) {
            return responseBuilder('At least one identification number is required', 400);
        }

        if (!businessVerificationRequest.nature_of_business) {
            return responseBuilder('Nature of business is required', 400);
        }

        if (
            !businessVerificationRequest.ultimate_beneficial_owners ||
            businessVerificationRequest.ultimate_beneficial_owners.length === 0
        ) {
            return responseBuilder('At least one ultimate beneficial owner is required', 400);
        }

        if (
            !businessVerificationRequest.director_customer_guids ||
            businessVerificationRequest.director_customer_guids.length === 0
        ) {
            return responseBuilder('At least one director customer GUID is required', 400);
        }

        if (
            !businessVerificationRequest.supporting_file_guids ||
            businessVerificationRequest.supporting_file_guids.length === 0
        ) {
            return responseBuilder('At least one supporting file GUID is required', 400);
        }

        // 1. Get User Record from DynamoDB
        const getParams = {
            TableName: DYNAMO_TABLES.ENTITIES,
            Key: {
                entityId: userId,
            },
        };

        const response = (await dynamoDB.get(getParams)) as Entity | null;
        logger.info('User record:', { response });

        if (!response) {
            return responseBuilder('User record not found', 404);
        }

        // Verify the customer_guid belongs to this user
        const cybridMetadata = response.metadata as any;
        const cybridBusinessCustomerId = cybridMetadata?.cybrid?.businessCustomerId;

        if (cybridBusinessCustomerId !== businessVerificationRequest.customer_guid) {
            logger.error('Customer GUID does not match the business customer ID associated with this user', {
                providedGuid: businessVerificationRequest.customer_guid,
                expectedGuid: cybridBusinessCustomerId,
            });
            return responseBuilder('Invalid customer GUID', 400);
        }

        // 2. Check for Existing Business Identity Verification
        const listIdentityVerificationsParams = {
            TableName: DYNAMO_TABLES.CYBRID_IDENTITY_VERIFICATIONS,
            IndexName: 'customerId-index',
            KeyConditionExpression: 'customerId = :customerId',
            FilterExpression: 'verificationType = :verificationType',
            ExpressionAttributeValues: {
                ':customerId': cybridBusinessCustomerId,
                ':verificationType': 'business',
            },
        };

        logger.info('List identity verifications params:', { listIdentityVerificationsParams });

        const result = (await dynamoDB.query(listIdentityVerificationsParams)) as {
            Items?: IdentityVerificationRecord[];
        };

        logger.info('List identity verifications result:', { result });
        const existingVerifications = (result.Items || []) as IdentityVerificationRecord[];

        // Find any verification that is in progress or completed
        const activeVerification = existingVerifications.find(
            (iv) => iv.status === 'completed' || iv.status === 'waiting',
        );

        if (activeVerification) {
            logger.info('Existing active business verification found', {
                id: activeVerification.identityVerificationId,
                status: activeVerification.status,
            });

            return {
                statusCode: 200,
                body: JSON.stringify({
                    status: activeVerification.status,
                    identityVerificationId: activeVerification.identityVerificationId,
                    message: `Business verification ${activeVerification.status}`,
                }),
            };
        }

        logger.info('No existing business verification found, creating new');

        // 3. Create Identity Verification in Cybrid
        // Convert business types to Cybrid API types
        const mappedIdentificationNumbers = businessVerificationRequest.identification_numbers.map((idNum) => {
            // Convert string types to enum values
            let idType: PostIdentificationNumberBankModelTypeEnum;

            switch (idNum.type) {
                case 'business_registration_number':
                    idType = PostIdentificationNumberBankModelTypeEnum.DriversLicense; // Using an existing type as fallback
                    break;
                case 'employer_identification_number':
                    idType = PostIdentificationNumberBankModelTypeEnum.Passport; // Using an existing type as fallback
                    break;
                case 'tax_identification_number':
                    idType = PostIdentificationNumberBankModelTypeEnum.TaxIdentificationNumber;
                    break;
                default:
                    idType = PostIdentificationNumberBankModelTypeEnum.TaxIdentificationNumber;
            }

            return {
                type: idType,
                issuing_country_code: idNum.issuing_country_code,
                identification_number: idNum.identification_number,
            };
        });

        // Create the basic verification model
        const postIdentityVerificationBankModel: PostIdentityVerificationBankModel = {
            type: PostIdentityVerificationBankModelTypeEnum.Kyc,
            method: PostIdentityVerificationBankModelMethodEnum.BusinessRegistration,
            customer_guid: businessVerificationRequest.customer_guid,
            identification_numbers: mappedIdentificationNumbers,
        };

        // Add additional properties needed by Cybrid but not in the type
        // (Necessary due to type definition limitations)
        const enhancedVerificationData: any = {
            ...postIdentityVerificationBankModel,
            name: {
                full: businessVerificationRequest.name.full,
            },
            address: {
                street: businessVerificationRequest.address.street,
                street2: businessVerificationRequest.address.street2,
                city: businessVerificationRequest.address.city,
                subdivision: businessVerificationRequest.address.subdivision,
                postal_code: businessVerificationRequest.address.postal_code,
                country_code: businessVerificationRequest.address.country_code,
            },
            phone_number: businessVerificationRequest.phone_number,
            email_address: businessVerificationRequest.email_address,
            nature_of_business: businessVerificationRequest.nature_of_business,
            director_customer_guids: businessVerificationRequest.director_customer_guids,
            ultimate_beneficial_owners: businessVerificationRequest.ultimate_beneficial_owners,
            supporting_file_guids: businessVerificationRequest.supporting_file_guids,
        };

        // Add optional fields if provided
        if (businessVerificationRequest.aliases) {
            enhancedVerificationData.aliases = businessVerificationRequest.aliases;
        }

        if (businessVerificationRequest.website) {
            enhancedVerificationData.website = businessVerificationRequest.website;
        }

        logger.info('Creating business identity verification in Cybrid', { enhancedVerificationData });

        const identityVerificationData = await createBusinessIdentityVerification(enhancedVerificationData);

        logger.info('Business identity verification data:', { identityVerificationData });
        if (!identityVerificationData?.guid) {
            logger.error('Invalid verification data received');
            throw new Error('Failed to create business identity verification - missing GUID');
        }

        // 4. Store verification details in DynamoDB
        const now = DateUtil.now();

        // Create the identity verification record
        const identityVerificationItem: IdentityVerificationRecord = {
            identityVerificationId: identityVerificationData.guid,
            customerId: businessVerificationRequest.customer_guid,
            userId,
            status: (identityVerificationData.state as IdentityVerificationStatus) || 'waiting',
            createdAt: now,
            updatedAt: now,
            verificationType: 'business', // Mark as business verification
        };

        const putParams = {
            TableName: DYNAMO_TABLES.CYBRID_IDENTITY_VERIFICATIONS,
            Item: identityVerificationItem,
            ConditionExpression: 'attribute_not_exists(identityVerificationId)',
        };

        try {
            await dynamoDB.put(putParams);
            logger.info('Successfully created business identity verification record');
        } catch (error) {
            logger.error('Error creating business identity verification record:', { error });
            throw error;
        }

        // 5. Also update the user's metadata with the business verification ID
        const updateParams = {
            TableName: DYNAMO_TABLES.ENTITIES,
            Key: {
                entityId: userId,
            },
            UpdateExpression: 'SET metadata.#cybrid.#businessVerificationId = :verificationId, updatedAt = :updatedAt',
            ExpressionAttributeNames: {
                '#cybrid': 'cybrid',
                '#businessVerificationId': 'businessVerificationId',
            },
            ExpressionAttributeValues: {
                ':verificationId': identityVerificationData.guid,
                ':updatedAt': now,
            },
            ReturnValues: 'NONE' as const,
        };

        await dynamoDB.update(updateParams);
        logger.info('User record updated with business verification data', {
            userId,
            businessVerificationId: identityVerificationData.guid,
        });

        return {
            statusCode: 200,
            body: JSON.stringify({
                status: identityVerificationData.state,
                identityVerificationId: identityVerificationData.guid,
                message: 'Business identity verification created successfully',
            }),
        };
    } catch (error: any) {
        logger.error('Error processing business identity verification:', error);

        const errorDetails = {
            message: error.message,
            details: error.details,
            responseData: error.response?.data,
            responseStatus: error.response?.status,
            requestId: error.response?.headers?.['x-request-id'],
        };

        // Log different levels based on error type
        if (error.response?.status === 409) {
            logger.warn('Business identity verification conflict', errorDetails);
            return {
                statusCode: 409,
                body: JSON.stringify({
                    message: 'Business identity verification already in progress',
                    code: 'VERIFICATION_EXISTS',
                }),
            };
        }

        logger.error('Error processing business identity verification:', errorDetails);
        return {
            statusCode: error.response?.status || 500,
            body: JSON.stringify({
                message: 'Error processing business identity verification',
                code: error.response?.data?.message_code || 'INTERNAL_ERROR',
            }),
        };
    }
};

// Helper function to create business identity verification
async function createBusinessIdentityVerification(data: any): Promise<IdentityVerificationBankModel> {
    try {
        const cybridToken = await getCybridToken();
        const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications`;
        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
            'Idempotency-Key': uuidv4(), // Generate unique idempotency key for each request
        };

        logger.info('Creating business identity verification in Cybrid', { apiUrl, data });
        const response = await axios.post<IdentityVerificationBankModel>(apiUrl, data, { headers });
        logger.info('Business identity verification created in Cybrid', { response: response.data });

        return response.data;
    } catch (error: any) {
        logger.error('Error creating business identity verification in Cybrid', { error });

        // Enhanced error object with more details for diagnosis
        const enhancedError = new Error(`Failed to create business identity verification: ${error.message}`);
        (enhancedError as any).details = {
            status: error.response?.status,
            data: error.response?.data,
            requestId: error.response?.headers?.['x-request-id'],
        };

        throw enhancedError;
    }
}
</file>

<file path="lambdas/cybrid/identities/check-business-verification-status.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { Logger } from '@aws-lambda-powertools/logger';
import { DYNAMO_TABLES, dynamoDB, responseBuilder } from 'commons';
import { BusinessVerificationService } from '../services/business-verification-service';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'check-business-verification-status',
});

// Interface for verification record from DynamoDB
interface VerificationRecord {
    identityVerificationId: string;
    customerId: string;
    userId: string;
    status: string;
    createdAt: string;
    updatedAt: string;
    verificationType: string;
    uboVerifications?: Array<{
        customer_guid: string;
        verification_id: string;
    }>;
    directorVerifications?: Array<{
        customer_guid: string;
        verification_id: string;
    }>;
    documentGuids?: string[];
}

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    logger.info('CheckBusinessVerificationStatusFunction invoked', { event });

    try {
        // Extract and validate user ID
        const userId = event.requestContext.authorizer?.userId;
        if (!userId) {
            logger.error('User ID not found in the context');
            return responseBuilder('Forbidden', 403);
        }

        // Extract verification ID from path parameter or query parameter
        const verificationId = event.pathParameters?.id || event.queryStringParameters?.verification_id;

        // Initialize verification service
        const verificationService = new BusinessVerificationService();

        // 1. Get verification records from DynamoDB
        let verificationRecords: VerificationRecord[];

        if (verificationId) {
            // Get specific verification record
            const getParams = {
                TableName: DYNAMO_TABLES.CYBRID_IDENTITY_VERIFICATIONS,
                Key: {
                    identityVerificationId: verificationId,
                },
            };

            const response = await dynamoDB.get(getParams);

            if (!response) {
                return responseBuilder(
                    {
                        message: 'Verification record not found',
                        code: 'VERIFICATION_NOT_FOUND',
                    },
                    404,
                );
            }

            verificationRecords = [response as VerificationRecord];
        } else {
            // Get all verification records for user
            const records = await verificationService.getVerificationRecords(userId);

            if (!records || records.length === 0) {
                return responseBuilder(
                    {
                        message: 'No verification records found',
                        code: 'NO_VERIFICATIONS',
                    },
                    404,
                );
            }

            verificationRecords = records as VerificationRecord[];
        }

        // 2. Process and check statuses for each verification record
        const resultPromises = verificationRecords.map(async (record: VerificationRecord) => {
            try {
                // Skip non-business verification records
                if (record.verificationType !== 'business') {
                    return null;
                }

                // Get business verification status
                const businessVerificationStatus = await verificationService.getVerificationStatus(
                    record.identityVerificationId,
                );

                // Get UBO verification statuses
                const uboPromises = (record.uboVerifications || []).map(async (ubo) => {
                    const status = await verificationService.getVerificationStatus(ubo.verification_id);
                    return {
                        customer_guid: ubo.customer_guid,
                        verification_id: ubo.verification_id,
                        state: status.state,
                        outcome: status.outcome,
                    };
                });

                // Get director verification statuses
                const directorPromises = (record.directorVerifications || []).map(async (director) => {
                    const status = await verificationService.getVerificationStatus(director.verification_id);

                    // Check for watchlist compliance decision
                    const complianceDecisions = status.compliance_decisions || [];
                    const watchlistDecision = complianceDecisions.find(
                        (decision: { type: string; state: string }) => decision.type === 'person_watchlists',
                    );

                    return {
                        customer_guid: director.customer_guid,
                        verification_id: director.verification_id,
                        state: status.state,
                        outcome: status.outcome,
                        watchlist_status: watchlistDecision?.state || 'pending',
                    };
                });

                // Resolve all promises
                const [uboStatuses, directorStatuses] = await Promise.all([
                    Promise.all(uboPromises),
                    Promise.all(directorPromises),
                ]);

                // Determine overall status
                let overallStatus;

                if (
                    businessVerificationStatus.state === 'completed' &&
                    businessVerificationStatus.outcome === 'passed'
                ) {
                    // Business verification is completed and passed

                    // Check if all UBOs are verified
                    const allUbosVerified = uboStatuses.every(
                        (ubo) => ubo.state === 'completed' && ubo.outcome === 'passed',
                    );

                    // Check if all directors passed watchlist screening
                    const allDirectorsScreened = directorStatuses.every((director) => {
                        if (director.state !== 'completed') {
                            return false;
                        }

                        return director.watchlist_status === 'passed';
                    });

                    if (allUbosVerified && allDirectorsScreened) {
                        overallStatus = 'verified';
                    } else {
                        overallStatus = 'partially_verified';
                    }
                } else if (
                    businessVerificationStatus.state === 'completed' &&
                    businessVerificationStatus.outcome === 'failed'
                ) {
                    overallStatus = 'failed';
                } else {
                    overallStatus = 'processing';
                }

                // Update status in DynamoDB if needed
                if (record.status !== overallStatus) {
                    await verificationService.updateVerificationStatus(record.identityVerificationId, overallStatus);
                }

                // Return comprehensive status information
                return {
                    verification_id: record.identityVerificationId,
                    customer_id: record.customerId,
                    created_at: record.createdAt,
                    updated_at: record.updatedAt,
                    overall_status: overallStatus,
                    business_verification: {
                        state: businessVerificationStatus.state,
                        outcome: businessVerificationStatus.outcome,
                    },
                    ubos: uboStatuses,
                    directors: directorStatuses,
                };
            } catch (error) {
                logger.error('Error processing verification record', {
                    verificationId: record.identityVerificationId,
                    error,
                });

                return {
                    verification_id: record.identityVerificationId,
                    error: 'Error processing verification record',
                    status: 'error',
                };
            }
        });

        // Resolve all verification records
        const results = (await Promise.all(resultPromises)).filter((result) => result !== null);

        if (results.length === 0) {
            return responseBuilder(
                {
                    message: 'No business verification records found',
                    code: 'NO_BUSINESS_VERIFICATIONS',
                },
                404,
            );
        }

        // Return single record or array based on request
        if (verificationId) {
            return responseBuilder(
                {
                    message: 'Business verification status retrieved',
                    data: results[0],
                },
                200,
            );
        } else {
            return responseBuilder(
                {
                    message: 'Business verification statuses retrieved',
                    count: results.length,
                    data: results,
                },
                200,
            );
        }
    } catch (error: any) {
        logger.error('Error checking business verification status:', error);

        return responseBuilder(
            {
                message: 'Error checking business verification status',
                error: error.message,
                code: error.response?.data?.message_code || 'INTERNAL_ERROR',
            },
            error.response?.status || 500,
        );
    }
};
</file>

<file path="lambdas/cybrid/identities/complete-business-verification.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { Logger } from '@aws-lambda-powertools/logger';
import { responseBuilder } from 'commons';
import { BusinessVerificationService } from '../services/business-verification-service';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'complete-business-verification',
});

// Request interface for ultimate beneficial owners (UBOs)
interface UboRequest {
    full_name: string;
    first_name: string;
    middle_name: string;
    last_name: string;
    date_of_birth: string;
    address: {
        street: string;
        street2?: string;
        city: string;
        postal_code: string;
        country_code: string;
        subdivision: string;
    };
    phone_number: string;
    email_address: string;
    identification_numbers?: Array<{
        type: string;
        issuing_country_code: string;
        identification_number: string;
    }>;
    ownership_percentage: number;
}

// Request interface for directors
interface DirectorRequest {
    full_name: string;
    first_name: string;
    middle_name: string;
    last_name: string;
    date_of_birth: string;
    address: {
        street: string;
        street2?: string;
        city: string;
        postal_code: string;
        country_code: string;
        subdivision: string;
    };
    phone_number: string;
    email_address: string;
    identification_numbers?: Array<{
        type: string;
        issuing_country_code: string;
        identification_number: string;
    }>;
}

// Document request interface
interface DocumentRequest {
    type: 'incorporation_certificate' | 'tax_document' | 'ein_letter' | 'proof_of_beneficial_ownership';
    filename: string;
    content_type: string;
    data: string; // Base64 encoded content
}

// Main business verification request
interface CompleteBusinessVerificationRequest {
    business_customer_guid: string;
    business_details: {
        name: {
            full: string;
        };
        address: {
            street: string;
            street2?: string;
            city: string;
            postal_code: string;
            country_code: string;
            subdivision: string;
        };
        aliases?: Array<{
            full: string;
        }>;
        phone_number: string;
        email_address: string;
        website?: string;
        nature_of_business: string;
        identification_numbers: Array<{
            type: 'business_registration_number' | 'employer_identification_number' | 'tax_identification_number';
            issuing_country_code: string;
            identification_number: string;
        }>;
    };
    ultimate_beneficial_owners: UboRequest[];
    directors: DirectorRequest[];
    supporting_documents: DocumentRequest[];
}

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    logger.info('CompleteBusinessVerificationFunction invoked', { event });

    try {
        // Extract and validate user ID
        const userId = event.requestContext.authorizer?.userId;

        if (!userId) {
            logger.error('User ID not found in the context');
            return responseBuilder('Forbidden', 403);
        }

        // Parse and validate request body
        if (!event.body) {
            logger.error('Request body is missing');
            return responseBuilder('Request body is required', 400);
        }

        const request: CompleteBusinessVerificationRequest = JSON.parse(event.body);

        // Basic validation
        if (!request.business_customer_guid) {
            return responseBuilder('Business customer GUID is required', 400);
        }

        if (!request.business_details || !request.business_details.name || !request.business_details.name.full) {
            return responseBuilder('Business name is required', 400);
        }

        if (!request.ultimate_beneficial_owners || request.ultimate_beneficial_owners.length === 0) {
            return responseBuilder('At least one ultimate beneficial owner (UBO) is required', 400);
        }

        if (!request.directors || request.directors.length === 0) {
            return responseBuilder('At least one director is required', 400);
        }

        if (!request.supporting_documents || request.supporting_documents.length === 0) {
            return responseBuilder('At least one supporting document is required', 400);
        }

        // Validate UBO ownership percentages total 100%
        const totalOwnership = request.ultimate_beneficial_owners.reduce(
            (total, ubo) => total + ubo.ownership_percentage,
            0,
        );

        if (Math.round(totalOwnership) !== 100) {
            return responseBuilder(`UBO ownership percentages must total 100%. Current total: ${totalOwnership}%`, 400);
        }

        // Initialize business verification service
        const verificationService = new BusinessVerificationService();

        // 1. Process UBOs - create and verify
        logger.info('Processing UBOs', { count: request.ultimate_beneficial_owners.length });

        const uboResults = await Promise.all(
            request.ultimate_beneficial_owners.map((uboData) => verificationService.createAndVerifyUbo(uboData)),
        );

        logger.info('UBO processing completed', {
            count: uboResults.length,
            results: uboResults,
        });

        // 2. Process Directors - create and screen
        logger.info('Processing Directors', { count: request.directors.length });

        const directorResults = await Promise.all(
            request.directors.map((directorData) => verificationService.createAndScreenDirector(directorData)),
        );

        logger.info('Director processing completed', {
            count: directorResults.length,
            results: directorResults,
        });

        // 3. Upload Supporting Documents
        logger.info('Processing Supporting Documents', { count: request.supporting_documents.length });

        const documentGuids = await Promise.all(
            request.supporting_documents.map((document) => verificationService.uploadSupportingDocument(document)),
        );

        logger.info('Document processing completed', {
            count: documentGuids.length,
            guids: documentGuids,
        });

        // 4. Map UBO data for business verification
        const mappedUboData = uboResults.map((result, index) => ({
            customer_guid: result.customer_guid,
            ownership_percentage: request.ultimate_beneficial_owners[index].ownership_percentage,
        }));

        // 5. Map director GUIDs
        const directorGuids = directorResults.map((result) => result.customer_guid);

        // 6. Create Business Verification
        const businessData = {
            customer_guid: request.business_customer_guid,
            name: request.business_details.name,
            address: request.business_details.address,
            phone_number: request.business_details.phone_number,
            email_address: request.business_details.email_address,
            nature_of_business: request.business_details.nature_of_business,
            identification_numbers: request.business_details.identification_numbers,
        };

        if (request.business_details.aliases) {
            (businessData as any).aliases = request.business_details.aliases;
        }

        if (request.business_details.website) {
            (businessData as any).website = request.business_details.website;
        }

        // Create the business verification
        const businessVerification = await verificationService.createBusinessVerification(
            businessData,
            mappedUboData,
            directorGuids,
            documentGuids,
        );

        // 7. Store verification status
        await verificationService.storeVerificationStatus(
            userId,
            businessVerification.guid,
            request.business_customer_guid,
            uboResults,
            directorResults,
            documentGuids,
            businessVerification.state,
        );

        // 8. Return the verification details
        return responseBuilder(
            {
                message: 'Business verification process initiated',
                verification_id: businessVerification.guid,
                status: businessVerification.state,
                ubos: uboResults.map((ubo, index) => ({
                    name: request.ultimate_beneficial_owners[index].full_name,
                    customer_guid: ubo.customer_guid,
                    verification_id: ubo.verification_id,
                })),
                directors: directorResults.map((director, index) => ({
                    name: request.directors[index].full_name,
                    customer_guid: director.customer_guid,
                    verification_id: director.verification_id,
                })),
                document_count: documentGuids.length,
            },
            200,
        );
    } catch (error: any) {
        logger.error('Error processing business verification:', error);

        // Handle specific errors
        if (error.response?.status === 409) {
            return responseBuilder(
                {
                    message: 'A verification process is already in progress',
                    error: error.message,
                    code: 'VERIFICATION_EXISTS',
                },
                409,
            );
        }

        return responseBuilder(
            {
                message: 'Error processing business verification',
                error: error.message,
                code: error.response?.data?.message_code || 'INTERNAL_ERROR',
            },
            error.response?.status || 500,
        );
    }
};
</file>

<file path="lambdas/cybrid/identities/get-business-identity.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { DynamoDB, GetItemCommandOutput } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import axios from 'axios';
import { CybridConfig, type Entity, getCybridToken, responseBuilder } from 'commons';
import { DYNAMO_TABLES } from 'commons/utils/constants';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'getBusinessKycStatus',
});

const dynamoDb = DynamoDBDocument.from(new DynamoDB({}));

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        logger.error('User ID not found in the context');
        return responseBuilder({ message: 'User not found' }, 404);
    }

    try {
        const businessKycStatusResponse = await getBusinessKycStatus(userId);
        return responseBuilder(businessKycStatusResponse, 200);
    } catch (error) {
        logger.error('Error getting business KYC status:', { error });
        return responseBuilder({ message: 'Error getting business KYC status' }, 500);
    }
};

async function getBusinessKycStatus(userId: string): Promise<{ status: string; details?: any }> {
    // 1. Fetch User and Identity Verification from DynamoDB
    const user = await getUser(userId);
    if (!user) {
        throw new Error('User not found');
    }

    // Check for business customer ID
    const businessCustomerId = user.metadata?.cybrid?.businessCustomerId;
    if (!businessCustomerId) {
        return { status: 'not_started', details: { message: 'Business customer not created yet' } };
    }

    const latestIdentityVerification = await getLatestBusinessIdentityVerification(businessCustomerId);
    logger.info('Latest business identity verification:', { latestIdentityVerification });

    // 2. Check DynamoDB Status
    if (!latestIdentityVerification) {
        return { status: 'not_verified', details: { message: 'No business verification found' } };
    }

    // 3. Check status and return appropriate response
    if (latestIdentityVerification.status === 'completed') {
        const isVerifiedWithCybrid = await verifyBusinessWithCybrid(
            latestIdentityVerification.identityVerificationId,
            businessCustomerId,
        );

        logger.info('isBusinessVerifiedWithCybrid', { isVerifiedWithCybrid });

        if (isVerifiedWithCybrid) {
            return {
                status: 'verified',
                details: {
                    identityVerificationId: latestIdentityVerification.identityVerificationId,
                    customerId: businessCustomerId,
                },
            };
        } else {
            logger.error('Business KYC status mismatch between DynamoDB and Cybrid', {
                userId,
                identityVerificationId: latestIdentityVerification.identityVerificationId,
            });
            return { status: 'verification_mismatch', details: { message: 'Verification status mismatch' } };
        }
    } else if (latestIdentityVerification.status === 'storing') {
        return { status: 'processing', details: { message: 'Business verification in progress' } };
    } else if (latestIdentityVerification.status === 'failed') {
        return {
            status: 'failed',
            details: {
                message: 'Business verification failed',
                identityVerificationId: latestIdentityVerification.identityVerificationId,
            },
        };
    } else if (latestIdentityVerification.status === 'waiting') {
        return {
            status: 'waiting',
            details: {
                message: 'Business verification waiting for processing',
                identityVerificationId: latestIdentityVerification.identityVerificationId,
            },
        };
    } else if (latestIdentityVerification.status === 'expired') {
        return {
            status: 'expired',
            details: {
                message: 'Business verification expired',
                identityVerificationId: latestIdentityVerification.identityVerificationId,
            },
        };
    } else {
        return {
            status: 'unknown',
            details: {
                message: 'Unknown verification status',
                status: latestIdentityVerification.status,
                identityVerificationId: latestIdentityVerification.identityVerificationId,
            },
        };
    }
}

// Helper Functions

async function getLatestBusinessIdentityVerification(customerId: string): Promise<any> {
    const params = {
        TableName: DYNAMO_TABLES.CYBRID_IDENTITY_VERIFICATIONS,
        IndexName: 'customerId-index',
        KeyConditionExpression: 'customerId = :customerId',
        FilterExpression: 'verificationType = :verificationType',
        ExpressionAttributeValues: {
            ':customerId': customerId,
            ':verificationType': 'business',
        },
        ScanIndexForward: false, // Get the latest first
        Limit: 1,
    };
    const { Items } = await dynamoDb.query(params);
    return Items?.[0];
}

async function verifyBusinessWithCybrid(identityVerificationId: string, customerId: string): Promise<boolean> {
    const cybridToken = await getCybridToken();
    const headers = {
        Authorization: `Bearer ${cybridToken}`,
        'Content-Type': 'application/json',
    };

    try {
        // 1. Check Identity Verification Status
        const identityVerificationApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications/${identityVerificationId}`;
        const identityVerificationResponse = await axios.get(identityVerificationApiUrl, { headers });
        const identityVerification = identityVerificationResponse.data;

        logger.info('Cybrid business identity verification:', { identityVerification });

        // For business verification, we need to check the state and outcome
        if (identityVerification.state !== 'completed' || identityVerification.outcome !== 'passed') {
            return false;
        }

        // 2. Check Customer Status
        const customerApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/customers/${customerId}`;
        const customerResponse = await axios.get(customerApiUrl, { headers });
        const customer = customerResponse.data;

        logger.info('Cybrid business customer:', { customer });

        // For business, we need to make sure the customer is verified
        return customer.state === 'verified' && customer.type === 'business';
    } catch (error) {
        logger.error('Error verifying business with Cybrid:', { error });
        return false;
    }
}

async function getUser(userId: string): Promise<Entity> {
    const { Item }: GetItemCommandOutput = await dynamoDb.get({
        TableName: DYNAMO_TABLES.ENTITIES,
        Key: { entityId: userId },
    });

    if (!Item) {
        throw new Error('User not found');
    }

    return Item as unknown as Entity;
}
</file>

<file path="lambdas/cybrid/identities/get-identity.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { DynamoDB, GetItemCommandOutput } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import axios from 'axios';
import { CybridConfig, Entity, getCybridToken, responseBuilder } from 'commons';
import { PERSONA } from 'commons/utils/constants';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';
const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'getKycStatus',
});

const dynamoDb = DynamoDBDocument.from(new DynamoDB({}));

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        logger.error('User ID not found in the context');
        return responseBuilder({ message: 'User not found' }, 404);
    }

    try {
        const kycStatusResponse = await getKycStatus(userId);

        return responseBuilder(kycStatusResponse, 200);
    } catch (error) {
        logger.error('Error getting KYC status:', { error });
        return responseBuilder({ message: 'Error getting KYC status' }, 500);
    }
};

async function getKycStatus(userId: string): Promise<{ status: string; personaUrl?: string }> {
    // 1. Fetch User and Identity Verification from DynamoDB
    const user = await getUser(userId);
    if (!user) {
        throw new Error('User not found');
    }
    //TODO: Add check for cybrid customer in model
    const customerId = user.cybrid?.customer?.guid;
    if (!customerId) {
        return { status: 'storing' };
    }

    const latestIdentityVerification = await getLatestIdentityVerification(customerId);
    logger.info('Latest identity verification:', { latestIdentityVerification });

    // 2. Check DynamoDB Status
    if (!latestIdentityVerification) {
        return { status: 'storing' };
    }

    if (latestIdentityVerification.status === 'completed') {
        const isVerifiedWithCybrid = await verifyWithCybrid(
            latestIdentityVerification.identityVerificationId,
            customerId,
        );

        logger.info('isVerifiedWithCybrid', { isVerifiedWithCybrid });

        if (isVerifiedWithCybrid) {
            return { status: 'completed' };
        } else {
            logger.error('KYC status mismatch between DynamoDB and Cybrid', {
                userId,
                identityVerificationId: latestIdentityVerification.identityVerificationId,
            });
            return { status: 'unknown' };
        }
    } else if (latestIdentityVerification.status === 'storing') {
        return { status: 'storing' };
    } else if (latestIdentityVerification.status === 'failed') {
        return { status: 'failed' };
    } else if (latestIdentityVerification.status === 'waiting') {
        const personaUrl = `${PERSONA.BASE_URL}${latestIdentityVerification.personaInquiryId}`;
        return { status: 'waiting', personaUrl };
    } else if (latestIdentityVerification.status === 'expired') {
        return { status: 'expired' };
    } else {
        return { status: 'unknown' }; // Handle other statuses as needed
    }
}

// Helper Functions

async function getLatestIdentityVerification(customerId: string): Promise<any> {
    const gsiKeys = SingleTableKeys.gsiKeys.identityVerificationByCustomerId(customerId);
    const params = {
        TableName: SINGLE_TABLE_NAME,
        IndexName: 'EntityTypeIndex',
        KeyConditionExpression: 'EntityTypeKey = :etk AND EntityStatusSortKey = :essk',
        ExpressionAttributeValues: {
            ':etk': gsiKeys.EntityTypeKey,
            ':essk': gsiKeys.EntityStatusSortKey,
        },
        ScanIndexForward: false, // Get the latest first
        Limit: 1,
    };
    const { Items } = await dynamoDb.query(params);
    return Items?.[0];
}

async function verifyWithCybrid(identityVerificationId: string, customerId: string): Promise<boolean> {
    const cybridToken = await getCybridToken();
    const headers = {
        Authorization: `Bearer ${cybridToken}`,
        'Content-Type': 'application/json',
    };

    try {
        // 1. Check Identity Verification Status
        const identityVerificationApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications/${identityVerificationId}`;
        const identityVerificationResponse = await axios.get(identityVerificationApiUrl, { headers });
        const identityVerification = identityVerificationResponse.data;

        logger.info('Cybrid identity verification:', { identityVerification });

        if (
            identityVerification.state !== 'completed' ||
            identityVerification.outcome !== 'passed' ||
            identityVerification.persona_state !== 'completed'
        ) {
            return false;
        }

        // 2. Check Customer Status
        const customerApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/customers/${customerId}`;
        const customerResponse = await axios.get(customerApiUrl, { headers });
        const customer = customerResponse.data;

        logger.info('Cybrid customer:', { customer });

        return customer.state === 'verified';
    } catch (error) {
        logger.error('Error verifying with Cybrid:', { error });
        return false; // Or handle the error as appropriate for your application
    }
}

async function getUser(userId: string): Promise<Entity> {
    const keys = SingleTableKeys.user(userId);
    const { Item }: GetItemCommandOutput = await dynamoDb.get({
        TableName: SINGLE_TABLE_NAME,
        Key: keys,
    });

    if (!Item) {
        throw new Error('User not found');
    }

    return Item as unknown as Entity;
}
</file>

<file path="lambdas/cybrid/identities/list-business-files.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import axios from 'axios';
import { CybridConfig, responseBuilder } from 'commons';
import { getCybridToken } from 'commons/utils/cybrid-auth';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'getBusinessFiles',
});

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        logger.error('User ID not found in the context');
        return responseBuilder({ message: 'User not found' }, 404);
    }

    // Get the page query parameter (for pagination)
    const page = event.queryStringParameters?.page || '1';
    const perPage = event.queryStringParameters?.per_page || '10';
    const fileType = event.queryStringParameters?.file_type;

    try {
        const filesResponse = await listBusinessFiles(page, perPage, fileType);
        return responseBuilder(filesResponse, 200);
    } catch (error: any) {
        logger.error('Error getting business files:', { error, userId });
        return responseBuilder(
            {
                message: 'Error getting business files',
                error: error.message || 'Unknown error',
            },
            error.status || 500,
        );
    }
};

async function listBusinessFiles(page: string, perPage: string, fileType?: string): Promise<any> {
    const cybridToken = await getCybridToken();
    const headers = {
        Authorization: `Bearer ${cybridToken}`,
        'Content-Type': 'application/json',
    };

    try {
        // Construct the URL with query parameters
        let filesApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/files?page=${page}&per_page=${perPage}`;

        // Add file_type parameter if provided
        if (fileType) {
            filesApiUrl += `&file_type=${fileType}`;
        }

        logger.info('Getting business files:', { filesApiUrl });

        const response = await axios.get(filesApiUrl, { headers });

        // Return both the files and pagination info
        return {
            files: response.data.results || [],
            total: response.data.total || 0,
            page: parseInt(page),
            per_page: parseInt(perPage),
            total_pages: Math.ceil((response.data.total || 0) / parseInt(perPage)),
        };
    } catch (error: any) {
        logger.error('Error fetching business files from Cybrid:', { error });

        const enhancedError = new Error(`Failed to get business files: ${error.message}`);
        (enhancedError as any).status = error.response?.status || 500;
        (enhancedError as any).details = {
            data: error.response?.data,
            status: error.response?.status,
        };

        throw enhancedError;
    }
}
</file>

<file path="lambdas/cybrid/identities/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/cybrid/identities/upload-business-file.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import axios from 'axios';
import { CybridConfig, responseBuilder } from 'commons';
import { getCybridToken } from 'commons/utils/cybrid-auth';
import { v4 as uuidv4 } from 'uuid';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'uploadBusinessFile',
});

interface UploadBusinessFileRequest {
    file_name: string;
    file_type: string; // eg: incorporation_certificate, tax_document, proof_of_ownership, etc.
    mime_type: string; // eg: application/pdf, image/jpeg, etc.
    content: string; // Base64 encoded file content
}

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        logger.error('User ID not found in the context');
        return responseBuilder({ message: 'User not found' }, 404);
    }

    if (!event.body) {
        logger.error('Request body is missing');
        return responseBuilder('Request body is required', 400);
    }

    try {
        // Parse request body
        const uploadRequest: UploadBusinessFileRequest = JSON.parse(event.body);

        // Validate required fields
        if (
            !uploadRequest.file_name ||
            !uploadRequest.file_type ||
            !uploadRequest.mime_type ||
            !uploadRequest.content
        ) {
            return responseBuilder('Missing required fields: file_name, file_type, mime_type, content', 400);
        }

        // Validate file type
        const validBusinessFileTypes = [
            'incorporation_certificate',
            'tax_document',
            'ein_letter',
            'proof_of_beneficial_ownership',
            'photo',
        ];

        if (!validBusinessFileTypes.includes(uploadRequest.file_type)) {
            return responseBuilder(`Invalid file_type. Must be one of: ${validBusinessFileTypes.join(', ')}`, 400);
        }

        // Validate mime type
        const validMimeTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/heic'];

        if (!validMimeTypes.includes(uploadRequest.mime_type)) {
            return responseBuilder(`Invalid mime_type. Must be one of: ${validMimeTypes.join(', ')}`, 400);
        }

        // Check base64 content
        if (!isValidBase64(uploadRequest.content)) {
            return responseBuilder('Invalid base64 content', 400);
        }

        // Remove data URL prefix if present
        const content = uploadRequest.content.replace(/^data:.*?;base64,/, '');

        // Upload file
        const uploadResponse = await uploadFileToCybrid({
            ...uploadRequest,
            content, // Cleaned content
        });

        return responseBuilder(
            {
                message: 'File uploaded successfully',
                data: uploadResponse,
            },
            201,
        );
    } catch (error: any) {
        logger.error('Error uploading business file:', { error, userId });

        return responseBuilder(
            {
                message: 'Error uploading business file',
                error: error.message || 'Unknown error',
            },
            error.status || 500,
        );
    }
};

async function uploadFileToCybrid(fileData: UploadBusinessFileRequest): Promise<any> {
    const cybridToken = await getCybridToken();
    const headers = {
        Authorization: `Bearer ${cybridToken}`,
        'Content-Type': 'application/json',
        'Idempotency-Key': uuidv4(), // Generate unique idempotency key for each upload
    };

    try {
        const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/files`;

        const payload = {
            file_name: fileData.file_name,
            file_type: fileData.file_type,
            mime_type: fileData.mime_type,
            content: fileData.content,
        };

        logger.info('Uploading file to Cybrid:', {
            fileName: fileData.file_name,
            fileType: fileData.file_type,
            mimeType: fileData.mime_type,
        });

        const response = await axios.post(apiUrl, payload, { headers });

        logger.info('File uploaded successfully:', {
            fileGuid: response.data.guid,
            fileName: response.data.file_name,
        });

        return {
            guid: response.data.guid,
            file_name: response.data.file_name,
            file_type: response.data.file_type,
            mime_type: response.data.mime_type,
            created_at: response.data.created_at,
        };
    } catch (error: any) {
        logger.error('Error uploading file to Cybrid:', { error });

        const enhancedError = new Error(`Failed to upload file: ${error.message}`);
        (enhancedError as any).status = error.response?.status || 500;
        (enhancedError as any).details = {
            data: error.response?.data,
            status: error.response?.status,
        };

        throw enhancedError;
    }
}

// Helper function to check if a string is valid base64
function isValidBase64(str: string): boolean {
    // Remove data URL prefix if present
    const base64Content = str.replace(/^data:.*?;base64,/, '');

    try {
        // Try to decode and see if it's valid
        return btoa(atob(base64Content)) === base64Content;
    } catch (e) {
        return false;
    }
}
</file>

<file path="lambdas/cybrid/identities/upload-file.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { responseBuilder } from 'commons';
import { FileUploadService, type FileUploadRequest } from '../services/file-upload-service';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'uploadFile',
});

const fileUploadService = new FileUploadService();

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        logger.error('User ID not found in the context');
        return responseBuilder({ message: 'User not found' }, 404);
    }

    if (!event.body) {
        logger.error('Request body is missing');
        return responseBuilder('Request body is required', 400);
    }

    try {
        // Parse request body
        const uploadRequest: FileUploadRequest = JSON.parse(event.body);

        // Validate required fields
        if (
            !uploadRequest.type ||
            !uploadRequest.filename ||
            !uploadRequest.customer_guid ||
            !uploadRequest.content_type
        ) {
            return responseBuilder('Missing required fields: type, filename, customer_guid, content_type', 400);
        }

        // Validate file type
        const validFileTypes = [
            'drivers_license_front',
            'drivers_license_back',
            'selfie',
            'selfie_right',
            'selfie_left',
            'incorporation_certificate',
            'tax_document',
            'ein_letter',
            'proof_of_beneficial_ownership',
            'photo',
        ];

        if (!validFileTypes.includes(uploadRequest.type)) {
            return responseBuilder(`Invalid file_type. Must be one of: ${validFileTypes.join(', ')}`, 400);
        }

        // Validate mime type
        const validMimeTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/heic'];

        if (!validMimeTypes.includes(uploadRequest.content_type)) {
            return responseBuilder(`Invalid mime_type. Must be one of: ${validMimeTypes.join(', ')}`, 400);
        }

        // Check base64 content if provided
        if (uploadRequest.data && !isValidBase64(uploadRequest.data)) {
            return responseBuilder('Invalid base64 content', 400);
        }

        // Remove data URL prefix if present
        if (uploadRequest.data) {
            uploadRequest.data = uploadRequest.data.replace(/^data:.*?;base64,/, '');
        }

        // Upload file
        const uploadResponse = await fileUploadService.uploadFile(uploadRequest);

        return responseBuilder(
            {
                message: 'File uploaded successfully',
                data: uploadResponse,
            },
            201,
        );
    } catch (error: any) {
        logger.error('Error uploading file:', { error, userId });

        return responseBuilder(
            {
                message: 'Error uploading file',
                error: error.message || 'Unknown error',
            },
            error.status || 500,
        );
    }
};

// Helper function to check if a string is valid base64
function isValidBase64(str: string): boolean {
    // Remove data URL prefix if present
    const base64Content = str.replace(/^data:.*?;base64,/, '');

    try {
        // Try to decode and see if it's valid
        return btoa(atob(base64Content)) === base64Content;
    } catch (e) {
        return false;
    }
}
</file>

<file path="lambdas/cybrid/quotes/services/package.json">
{
  "name": "plaid",
  "version": "1.0.0",
  "description": "plaid lambda",
  "main": "app.js",
  "author": "CLKK",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^2.11.0",
    "@aws-sdk/client-eventbridge": "^3.705.0",
    "@aws-sdk/client-sns": "^3.705.0",
    "@aws-sdk/util-dynamodb": "^3.705.0",
    "@aws-sdk/client-dynamodb": "^3.705.0",
    "@aws-sdk/client-lambda": "^3.716.0",
    "@aws-sdk/client-secrets-manager": "^3.699.0",
    "@aws-sdk/client-sqs": "^3.716.0",
    "@aws-sdk/lib-dynamodb": "^3.705.0",
    "@cybrid/cybrid-api-bank-typescript": "^0.123.122",
    "axios": "^1.7.9",
    "esbuild": "^0.14.14",
    "jsonwebtoken": "^9.0.2",
    "plaid": "^30.0.0",
    "svix": "^1.43.0"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "@types/aws-lambda": "^8.10.146",
    "@types/jest": "^29.2.0",
    "@types/node": "^18.11.4",
    "@typescript-eslint/eslint-plugin": "^5.10.2",
    "@typescript-eslint/parser": "^5.10.2",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.2.1",
    "prettier": "^2.5.1",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
</file>

<file path="lambdas/cybrid/quotes/services/quote-service.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { getSecret } from 'commons/utils/getSecret';
import { AWS_SECRETS } from 'commons/utils/constants';
import { QuoteBankModel, PostQuoteBankModel, TransferBankModel } from '@cybrid/cybrid-api-bank-typescript';
import { CybridConfig } from 'commons/utils/cybrid';
import axios from 'axios';
import { getCybridToken } from 'commons/utils/cybrid-auth';

const logger = new Logger({ serviceName: 'cybrid-quotes' });

export class QuoteService {
    private baseUrl: string;

    constructor() {
        this.baseUrl = process.env.CYBRID_BASE_URL || '';
    }

    async createQuote(request: QuoteBankModel): Promise<QuoteBankModel> {
        logger.info('Creating quote from quote service', { request });
        const cybridToken = await getCybridToken();
        logger.info('Cybrid token REQUEST RECEIVED FROM QUOTE SERVICE');

        //log baseUrl
        logger.info('Base URL', { baseUrl: this.baseUrl });

        //TODO:use service to create quote
        try {
            const response = await axios.post(
                `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/quotes`,
                request,
                {
                    headers: {
                        'Content-Type': 'application/json',
                        Authorization: `Bearer ${cybridToken}`,
                    },
                },
            );

            logger.info('Quote response', { response: response.data });
            if (response.status !== 200 && response.status !== 201) {
                const error = response.data;
                logger.error('Failed to create quote', { error, status: response.status });
                throw new Error(`Failed to create quote: ${response.status} - ${JSON.stringify(error)}`);
            }

            const data = response.data;
            logger.info('Successfully created quote', { data });
            return data as QuoteBankModel;
        } catch (error) {
            logger.error('Error creating quote', { error });
            throw error;
        }
    }

    async getQuote(quoteId: string): Promise<QuoteBankModel> {
        logger.info('Getting quote', { quoteId });
        const cybridToken = await getCybridToken();

        try {
            const response = await axios.get(
                `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/quotes/${quoteId}`,
                {
                    headers: {
                        'Content-Type': 'application/json',
                        Authorization: `Bearer ${cybridToken}`,
                    },
                },
            );

            if (response.status !== 200) {
                const error = response.data;
                logger.error('Failed to get quote', { error, status: response.status, quoteId });
                throw new Error(`Failed to get quote: ${response.status} - ${JSON.stringify(error)}`);
            }

            const data = response.data;
            logger.info('Successfully retrieved quote', { data });
            return data as QuoteBankModel;
        } catch (error) {
            logger.error('Error getting quote', { error, quoteId });
            throw error;
        }
    }

    async createTransfer(request: any): Promise<TransferBankModel> {
        const cybridToken = await getCybridToken();
        const url = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/transfers`;
        logger.info('Creating transfer', { url, request });

        const headers = {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${cybridToken}`,
        };

        const response = await axios.post(url, request, { headers });

        if (response.status !== 200 && response.status !== 201) {
            const error = response.data;
            logger.error('Error creating transfer', { error, status: response.status });
            throw new Error(JSON.stringify(error));
        }

        const data: TransferBankModel = response.data;
        logger.info('Transfer created successfully', { data });
        return data;
    }
}
</file>

<file path="lambdas/cybrid/quotes/services/transaction-service.ts">
import { DynamoDB } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from '@aws-lambda-powertools/logger';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../../utils/single-table-keys';

const logger = new Logger({ serviceName: 'transaction-service' });
const dynamoDb = DynamoDBDocument.from(new DynamoDB());

export enum TransactionType {
    DEPOSIT = 'deposit',
    WITHDRAWAL = 'withdrawal',
    P2P_TRANSFER = 'p2p_transfer',
    P2B_TRANSFER = 'p2b_transfer',
    TRADE = 'trade',
}

export enum TransactionStatus {
    PENDING = 'pending',
    COMPLETED = 'completed',
    FAILED = 'failed',
    CANCELLED = 'cancelled',
}

export interface Transaction {
    userId: string;
    transactionId: string;
    type: TransactionType;
    status: TransactionStatus;
    amount: number;
    asset: string;
    createdAt: string;
    updatedAt: string;
    sourceAccountId?: string;
    destinationAccountId?: string;
    quoteGuid?: string;
    paymentProviderId?: string;
    recipientId?: string;
    memo?: string;
    senderName?: string;
    senderClkktag?: string;
    recipientName?: string;
    recipientClkktag?: string;
    transferState?: string;
    failureCode?: string;
    returnCode?: string;
    recipientEntityId: string;
    senderEntityId: string;
    recipient_entity_type?: string;
    sender_entity_type?: string;
    recipient_current_email?: string;
    sender_current_email?: string;
    source_account_guid?: string;
    destination_account_guid?: string;
    recipient_cy_guid?: string;
    sender_cy_guid?: string;
    sender_name?: string;
    recipient_name?: string;
    sender_clkktag?: string;
    recipient_clkktag?: string;
    fees?: Fee;
    fee_amount?: number;
    fee_pending?: boolean;
    fee_percentage?: number;
    net_amount?: number;
}

export interface Fee {
    type: string;
    rate: number;
    spread_fee: number;
    fixed_fee: number;
}

export class TransactionService {
    /**
     * Create a new transaction record
     */
    static async createTransaction(
        transaction: Omit<Transaction, 'transactionId' | 'createdAt' | 'updatedAt'>,
    ): Promise<Transaction> {
        const now = new Date().toISOString();
        const transactionId = uuidv4();

        const newTransaction: Transaction = {
            ...transaction,
            transactionId,
            createdAt: now,
            updatedAt: now,
        };

        // Determine if this is a business or user transaction
        const isBusinessTransaction = transaction.recipientEntityId?.startsWith('business_') || 
                                     transaction.recipient_entity_type === 'business';
        
        // Create single table keys
        const keys = isBusinessTransaction && transaction.recipientEntityId
            ? SingleTableKeys.businessTransaction(transaction.recipientEntityId, now, transactionId)
            : SingleTableKeys.transaction(transaction.userId, now, transactionId);

        // Create item with single table keys
        const item = {
            ...keys,
            ...newTransaction,
            // Add GSI keys for querying
            TransactionIdKey: SingleTableKeys.gsiKeys.transactionById(transactionId).TransactionIdKey,
            SenderIdKey: transaction.senderEntityId ? SingleTableKeys.gsiKeys.transactionsBySender(transaction.senderEntityId).SenderIdKey : undefined,
            RecipientIdKey: transaction.recipientEntityId ? SingleTableKeys.gsiKeys.transactionsByRecipient(transaction.recipientEntityId).RecipientIdKey : undefined,
        };

        logger.info('Creating transaction in single table', { item });

        await dynamoDb.put({
            TableName: SINGLE_TABLE_NAME,
            Item: item,
        });

        return newTransaction;
    }

    /**
     * Update an existing transaction
     */
    static async updateTransaction(
        transactionId: string,
        updates: Partial<Omit<Transaction, 'transactionId' | 'userId' | 'createdAt'>>,
    ): Promise<Transaction> {
        const now = new Date().toISOString();

        const allUpdates = {
            ...updates,
            updatedAt: now,
        };

        let updateExpression = 'SET';
        const expressionAttributeValues: Record<string, any> = {};
        const expressionAttributeNames: Record<string, string> = {};

        Object.entries(allUpdates).forEach(([key, value], index) => {
            if (value !== undefined) {
                const prefix = index === 0 ? ' ' : ', ';
                updateExpression += `${prefix}#${key} = :${key}`;
                expressionAttributeValues[`:${key}`] = value;
                expressionAttributeNames[`#${key}`] = key;
            }
        });

        logger.info('Updating transaction', {
            transactionId,
            updates: allUpdates,
            updateExpression,
            expressionAttributeValues,
            expressionAttributeNames,
        });

        // First, get the transaction to find its PK/SK
        const existingTransaction = await this.getTransactionById(transactionId);
        if (!existingTransaction) {
            throw new Error(`Transaction not found: ${transactionId}`);
        }

        // Reconstruct the keys
        const isBusinessTransaction = existingTransaction.recipientEntityId?.startsWith('business_') || 
                                     existingTransaction.recipient_entity_type === 'business';
        
        const keys = isBusinessTransaction && existingTransaction.recipientEntityId
            ? SingleTableKeys.businessTransaction(existingTransaction.recipientEntityId, existingTransaction.createdAt, transactionId)
            : SingleTableKeys.transaction(existingTransaction.userId, existingTransaction.createdAt, transactionId);

        const result = await dynamoDb.update({
            TableName: SINGLE_TABLE_NAME,
            Key: keys,
            UpdateExpression: updateExpression,
            ExpressionAttributeValues: expressionAttributeValues,
            ExpressionAttributeNames: expressionAttributeNames,
            ReturnValues: 'ALL_NEW',
        });

        // Remove single table keys before returning
        const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = result.Attributes as any;
        return transaction as Transaction;
    }

    /**
     * Get a transaction by ID
     */
    static async getTransaction(transactionId: string): Promise<Transaction | null> {
        return this.getTransactionById(transactionId);
    }

    /**
     * Get a transaction by ID using GSI
     */
    static async getTransactionById(transactionId: string): Promise<Transaction | null> {
        logger.info('Getting transaction by ID', { transactionId });

        const result = await dynamoDb.query({
            TableName: SINGLE_TABLE_NAME,
            IndexName: 'TransactionIdIndex',
            KeyConditionExpression: 'TransactionIdKey = :tid',
            ExpressionAttributeValues: {
                ':tid': SingleTableKeys.gsiKeys.transactionById(transactionId).TransactionIdKey,
            },
            Limit: 1,
        });

        if (!result.Items || result.Items.length === 0) {
            return null;
        }

        // Remove single table keys before returning
        const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = result.Items[0] as any;
        return transaction as Transaction;
    }

    /**
     * Get all transactions for a user
     */
    static async getUserTransactions(userId: string, limit = 50): Promise<Transaction[]> {
        logger.info('Getting user transactions', { userId, limit });

        const result = await dynamoDb.query({
            TableName: SINGLE_TABLE_NAME,
            KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
            ExpressionAttributeValues: {
                ':pk': `USER#${userId}`,
                ':skPrefix': 'TXN#',
            },
            ScanIndexForward: false, // descending order (newest first)
            Limit: limit,
        });

        // Remove single table keys from each item before returning
        return (result.Items || []).map((item: any) => {
            const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = item;
            return transaction as Transaction;
        });
    }

    /**
     * Get transactions by payment provider ID (e.g., Cybrid transfer GUID)
     */
    static async getTransactionsByPaymentProviderId(paymentProviderId: string): Promise<Transaction[]> {
        logger.info('Getting transactions by payment provider ID', { paymentProviderId });

        // Since we don't have a GSI for paymentProviderId, we need to scan with filter
        // In production, you might want to add a GSI for this access pattern
        const result = await dynamoDb.scan({
            TableName: SINGLE_TABLE_NAME,
            FilterExpression: 'paymentProviderId = :ppid AND begins_with(SK, :skPrefix)',
            ExpressionAttributeValues: {
                ':ppid': paymentProviderId,
                ':skPrefix': 'TXN#',
            },
        });

        // Remove single table keys from each item before returning
        return (result.Items || []).map((item: any) => {
            const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = item;
            return transaction as Transaction;
        });
    }
}
</file>

<file path="lambdas/cybrid/quotes/services/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/cybrid/quotes/types/user.types.ts">
/**
 * User types based on actual database structure
 */

export interface UserInfo {
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    profilePictureUrl?: string;
}

export interface CybridExternalAccount {
    guid: string;
    name: string;
    state: string;
    asset: string;
    account_kind: string;
    bank_guid: string;
    customer_guid: string;
    created_at: string;
    updated_at: string;
    environment: string;
    counterparty_guid?: string | null;
    failure_code?: string | null;
    exchange_guid?: string | null;
    holder?: {
        type: string;
        guid: string;
    };
}

export interface CybridMetadata {
    customerId: string;
    fiatAccountId?: string;
    externalAccount?: CybridExternalAccount;
    customerData?: {
        name?: {
            first: string;
            last: string;
            full?: string;
        };
        date_of_birth?: string;
        phone_number?: string;
        identification_numbers?: Array<{
            type: string;
            issuing_country_code: string;
            identification_number: string;
        }>;
        address?: {
            street: string;
            street2?: string;
            city: string;
            subdivision: string;
            postal_code: string;
            country_code: string;
        };
    };
}

export interface KYCData {
    status: 'pending' | 'success' | 'failed' | 'waiting';
    verifiedBy?: string;
    timestamp?: string;
    requester?: string;
    metadata?: {
        cybridVerificationGuid?: string;
        personaInquiryId?: string;
        personaUrl?: string;
    };
}

export interface PlaidMetadata {
    metadata?: {
        linkSessionId?: string;
        institution?: {
            id: string;
            name: string;
        };
        accounts?: Array<{
            id: string;
            name: string;
            mask: string;
            type: string;
            subtype: string;
            verificationStatus?: string;
        }>;
        metadataJson?: string;
    };
}

export interface UserEntity {
    PK: string;
    SK: string;
    id: string;
    email: string;
    displayName?: string;
    username?: string;
    type: 'USER';
    role?: string;
    status?: string;
    createdAt: string;
    updatedAt?: string;
    
    // User info from onboarding
    userInfo?: UserInfo;
    
    // Metadata containing integrations
    metadata?: {
        cybrid?: CybridMetadata;
    };
    
    // KYC status
    kyc?: KYCData;
    
    // Plaid integration
    plaid?: PlaidMetadata;
    
    // Computed/derived fields
    name?: string;
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    clkktag?: string;
    profileImageUrl?: string;
}

/**
 * Get safe nested value with logging
 */
export function getSafeValue<T>(
    obj: any,
    path: string,
    defaultValue: T,
    logger?: { warn: (msg: string, data?: any) => void }
): T {
    const keys = path.split('.');
    let current = obj;
    
    for (const key of keys) {
        if (current?.[key] === undefined || current?.[key] === null) {
            if (logger) {
                logger.warn(`Missing value at path: ${path}`, {
                    attemptedPath: path,
                    failedAt: key,
                    currentValue: current
                });
            }
            return defaultValue;
        }
        current = current[key];
    }
    
    return current as T;
}
</file>

<file path="lambdas/cybrid/quotes/app.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { Logger } from '@aws-lambda-powertools/logger';
import { DYNAMO_TABLES, Entity, responseBuilder } from 'commons';
import { QuoteService } from './services/quote-service';
import {
    CreateQuoteRequest,
    GetQuoteRequest,
    DepositQuoteRequest,
    P2PTransferQuoteRequest,
    P2BTransferQuoteRequest,
} from './types';
import { DynamoDB, type GetItemCommandOutput } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { UnifiedTransactionService } from '../../shared/services/unified-transaction-service';
import {
    TransactionType,
    TransactionStatus,
    EntityType,
    PaymentProvider,
} from '../../shared/types/transaction.types';
import { feeService } from '../../services/feeService';
import { CurrencyService } from '../../services/currencyService';
import { UserEntity, getSafeValue } from './types/user.types';

// --- Constants ---
const MASTER_FEE_WALLET_ID = process.env.MASTER_FEE_WALLET_ID || 'master-fee-wallet';
const SINGLE_TABLE_NAME = process.env.SINGLE_TABLE_NAME || 'clkk-app-table-dev';

// --- Interfaces ---
interface TransferResponse {
    message: string;
    quoteGuid: string;
    transferGuid: string;
    amount: number;
    fee?: number;
    net_amount?: number;
}

// --- DynamoDB ---
const dynamoDb = DynamoDBDocument.from(new DynamoDB({}));

const logger = new Logger({ serviceName: 'cybrid-quotes' });
const quoteService = new QuoteService();

// --- Type Guards ---
function isDepositQuoteRequest(request: CreateQuoteRequest): request is DepositQuoteRequest {
    return request.product_type === 'funding' && request.side === 'deposit';
}

function isP2BTransferQuoteRequest(request: CreateQuoteRequest): request is P2BTransferQuoteRequest {
    // Check explicitly for isBusiness being true or recipient_entity_type being "business"
    return (
        request.product_type === 'book_transfer' &&
        (request.isBusiness === true || request.recipient_entity_type === 'business')
    );
}

function isP2PTransferQuoteRequest(request: CreateQuoteRequest): request is P2PTransferQuoteRequest {
    // This should only match non-business transfers
    return request.product_type === 'book_transfer' && !isP2BTransferQuoteRequest(request); // Make sure P2B check runs first
}

/**
 * Get user data from single table design
 * @param userId - The user ID (without USER# prefix)
 * @returns UserEntity with all user data including Cybrid integration
 */
const getUserData = async (userId: string): Promise<UserEntity> => {
    logger.info('Fetching user data', { 
        userId,
        table: SINGLE_TABLE_NAME,
        pk: `USER#${userId}`,
        sk: 'PROFILE'
    });

    const { Item } = await dynamoDb.get({
        TableName: SINGLE_TABLE_NAME,
        Key: { 
            PK: `USER#${userId}`,
            SK: 'PROFILE'
        },
    });

    logger.info('Raw user data retrieved', { 
        userId,
        hasItem: !!Item,
        itemKeys: Item ? Object.keys(Item) : [],
        hasMetadata: !!Item?.metadata,
        hasCybrid: !!Item?.metadata?.cybrid,
        hasKYC: !!Item?.kyc,
        hasPlaid: !!Item?.plaid,
    });

    if (!Item) {
        logger.error('User not found in database', { userId });
        throw new Error(`User not found: ${userId}`);
    }

    // Log detailed Cybrid data structure
    if (Item.metadata?.cybrid) {
        logger.info('User Cybrid metadata structure', {
            userId,
            hasCustomerId: !!Item.metadata.cybrid.customerId,
            customerId: Item.metadata.cybrid.customerId,
            hasFiatAccountId: !!Item.metadata.cybrid.fiatAccountId,
            fiatAccountId: Item.metadata.cybrid.fiatAccountId,
            hasExternalAccount: !!Item.metadata.cybrid.externalAccount,
            externalAccountGuid: Item.metadata.cybrid.externalAccount?.guid,
            externalAccountState: Item.metadata.cybrid.externalAccount?.state,
        });
    }

    // Populate computed fields from userInfo if main fields are missing
    const userEntity = Item as UserEntity;
    if (!userEntity.firstName && userEntity.userInfo?.firstName) {
        userEntity.firstName = userEntity.userInfo.firstName;
    }
    if (!userEntity.lastName && userEntity.userInfo?.lastName) {
        userEntity.lastName = userEntity.userInfo.lastName;
    }
    if (!userEntity.phoneNumber && userEntity.userInfo?.phoneNumber) {
        userEntity.phoneNumber = userEntity.userInfo.phoneNumber;
    }
    
    // Set name field
    userEntity.name = userEntity.displayName || 
                     `${userEntity.firstName || ''} ${userEntity.lastName || ''}`.trim() ||
                     userEntity.username || 
                     'User';

    // Set clkktag from username if not present
    if (!userEntity.clkktag && userEntity.username) {
        userEntity.clkktag = userEntity.username;
    }

    logger.info('Processed user entity', {
        userId,
        name: userEntity.name,
        email: userEntity.email,
        clkktag: userEntity.clkktag,
        kycStatus: userEntity.kyc?.status,
        hasCybridIntegration: !!userEntity.metadata?.cybrid,
    });

    return userEntity;
};

/**
 * Creates a transfer for deposit quote
 *
 * IMPORTANT: quote.receive_amount from Cybrid is ALREADY in cents (smallest unit)
 */
const handleDepositTransfer = async (quote: any, externalBankAccountGuid: string, userId: string) => {
    logger.info('Deposit quote request about to create transfer', { quote });
    const transferRequest = {
        quote_guid: quote.guid,
        transfer_type: 'funding',
        external_bank_account_guid: externalBankAccountGuid,
        source_participants: [
            {
                type: 'customer',
                amount: quote.receive_amount, // ALREADY in cents from Cybrid - DO NOT convert again
                guid: quote.customer_guid,
            },
        ],
        destination_participants: [
            {
                type: 'customer',
                amount: quote.receive_amount, // ALREADY in cents from Cybrid - DO NOT convert again
                guid: quote.customer_guid,
            },
        ],
    };

    logger.info('Creating transfer', { transferRequest });
    const transfer = await quoteService.createTransfer(transferRequest);
    logger.info('Transfer created successfully', { transfer });

    // Update transaction with transfer information
    if (transfer.guid && quote.guid) {
        try {
            // Find transaction by querying recent transactions
            const transactions = await UnifiedTransactionService.queryTransactions({
                userId,
                status: TransactionStatus.PENDING,
                type: TransactionType.DEPOSIT,
                limit: 5,
            }, 'transfer-update');
            
            // Find the transaction without a paymentProviderId yet
            const matchingTransaction = transactions.find((t) => !t.paymentProviderId);

            if (matchingTransaction) {
                await UnifiedTransactionService.updateTransaction({
                    transactionId: matchingTransaction.transactionId,
                    paymentProviderId: transfer.guid,
                    quoteGuid: quote.guid,
                    status: TransactionStatus.PROCESSING,
                }, 'transfer-update');
                logger.info('Updated transaction to PROCESSING status', {
                    transactionId: matchingTransaction.transactionId,
                    transferGuid: transfer.guid,
                });
            }
        } catch (error) {
            logger.error('Error updating transaction with transfer info', { error });
        }
    }

    return {
        message: 'Transfer created successfully',
        quoteGuid: quote.guid || '',
        transferGuid: transfer.guid || '',
        amount: CurrencyService.fromSmallestUnit(quote.receive_amount, quote.asset ?? 'USD'),
    };
};

/**
 * Creates a transfer for P2P quote
 *
 * IMPORTANT: quote.receive_amount from Cybrid is ALREADY in cents (smallest unit)
 */
const handleP2PTransfer = async (quote: any, request: P2PTransferQuoteRequest, userId: string) => {
    logger.info('P2P transfer quote request about to create transfer', { request });

    if (!quote.guid || !quote.receive_amount) {
        logger.error('Quote guid or receive amount not found');
        throw new Error('Quote guid or receive amount not found');
    }

    const p2pRequest = request as P2PTransferQuoteRequest;
    const p2pTransferRequest = {
        quote_guid: quote.guid,
        source_account_guid: p2pRequest.source_account_guid,
        destination_account_guid: p2pRequest.recipient_account_guid,
        transfer_type: 'book',
        source_participants: [
            {
                type: 'customer',
                amount: quote.receive_amount, // ALREADY in cents from Cybrid - DO NOT convert again
                guid: p2pRequest.sender_cy_guid,
            },
        ],
        destination_participants: [
            {
                type: 'customer',
                amount: quote.receive_amount, // ALREADY in cents from Cybrid - DO NOT convert again
                guid: p2pRequest.recipient_cy_guid,
            },
        ],
    };

    logger.info('Creating P2P transfer', { p2pTransferRequest });
    const transfer = await quoteService.createTransfer(p2pTransferRequest);
    logger.info('P2P transfer created successfully', { transfer });

    // Update transaction with transfer information
    if (transfer.guid && quote.guid) {
        logger.info('Updating transaction with transfer information', { transfer, quote });
        try {
            // Find transaction by querying recent P2P transactions
            const transactions = await UnifiedTransactionService.queryTransactions({
                userId,
                status: TransactionStatus.PENDING,
                type: TransactionType.P2P_TRANSFER,
                limit: 5,
            }, 'p2p-transfer-update');
            logger.info('User transactions', { transactions });
            
            // Find the transaction without a paymentProviderId yet
            const matchingTransaction = transactions.find((t) => !t.paymentProviderId);
            logger.info('Matching transaction', { matchingTransaction });
            
            if (matchingTransaction) {
                logger.info('Updating transaction', {
                    paymentProviderId: transfer.guid,
                    status: TransactionStatus.PROCESSING,
                });
                await UnifiedTransactionService.updateTransaction({
                    transactionId: matchingTransaction.transactionId,
                    paymentProviderId: transfer.guid,
                    quoteGuid: quote.guid,
                    status: TransactionStatus.PROCESSING,
                }, 'p2p-transfer-update');
                logger.info('Updated transaction to PROCESSING status', {
                    transactionId: matchingTransaction.transactionId,
                    transferGuid: transfer.guid,
                });
            }
        } catch (error) {
            logger.error('Error updating transaction with transfer info', { error });
        }
    }

    return {
        message: 'Transfer created successfully',
        quoteGuid: quote.guid || '',
        transferGuid: transfer.guid || '',
        amount: CurrencyService.fromSmallestUnit(quote.receive_amount, quote.asset ?? 'USD'),
    };
};

/**
 * Creates a transfer for P2B quote with fees
 *
 * IMPORTANT: all monetary values stored in the transaction record must be in cents
 */
const handleP2BTransfer = async (quote: any, request: P2BTransferQuoteRequest, userId: string) => {
    logger.info('P2B transfer quote request about to create transfer', { request });

    if (!quote.guid || !quote.receive_amount) {
        logger.error('Quote guid or receive amount not found');
        throw new Error('Quote guid or receive amount not found');
    }

    // Get the recipient business profile to determine fee structure
    const businessId = request.recipient_entity_guid;

    logger.info('Business ID Recipient', { businessId });

    // IMPORTANT: quote.receive_amount from Cybrid is ALREADY in cents
    const quoteAmountInCents = quote.receive_amount;

    // Convert to dollars for fee service (requires dollar amount)
    const quoteAmountInDollars = CurrencyService.fromSmallestUnit(quoteAmountInCents, quote.asset ?? 'USD');
    const { feePercentage } = await feeService.calculateFee(quoteAmountInDollars, businessId, quote.asset ?? 'USD');

    // Calculate fee in cents directly
    const feeAmountInCents = Math.round(quoteAmountInCents * feePercentage);
    const recipientAmountInCents = quoteAmountInCents - feeAmountInCents;

    // Create initial transfer for full amount to business
    const p2bRequest = request as P2BTransferQuoteRequest;
    const p2bTransferRequest = {
        quote_guid: quote.guid,
        source_account_guid: p2bRequest.source_account_guid,
        destination_account_guid: p2bRequest.recipient_account_guid,
        transfer_type: 'book',
        source_participants: [
            {
                type: 'customer',
                amount: quote.receive_amount, // ALREADY in cents from Cybrid - DO NOT convert again
                guid: p2bRequest.sender_cy_guid,
            },
        ],
        destination_participants: [
            {
                type: 'customer',
                amount: quote.receive_amount, // ALREADY in cents from Cybrid - DO NOT convert again
                guid: p2bRequest.recipient_cy_guid,
            },
        ],
    };

    logger.info('Creating P2B transfer (full amount)', { p2bTransferRequest });
    const transfer = await quoteService.createTransfer(p2bTransferRequest);
    logger.info('P2B transfer created successfully', { transfer });

    // Update transaction with ALL monetary values in cents
    if (transfer.guid && quote.guid) {
        try {
            // Find transaction by querying recent P2B transactions
            const transactions = await UnifiedTransactionService.queryTransactions({
                userId,
                status: TransactionStatus.PENDING,
                type: TransactionType.P2B_TRANSFER,
                limit: 5,
            }, 'p2b-transfer-update');
            
            // Find the transaction without a paymentProviderId yet
            const matchingTransaction = transactions.find((t) => !t.paymentProviderId);

            if (matchingTransaction) {
                await UnifiedTransactionService.updateTransaction({
                    transactionId: matchingTransaction.transactionId,
                    paymentProviderId: transfer.guid,
                    quoteGuid: quote.guid,
                    status: TransactionStatus.PROCESSING,
                    metadata: {
                        ...matchingTransaction.metadata,
                        fee_pending: true,
                        transferGuid: transfer.guid,
                    },
                }, 'p2b-transfer-update');

                logger.info('Updated transaction to PROCESSING status with fee tracking', {
                    transactionId: matchingTransaction.transactionId,
                    transferGuid: transfer.guid,
                    feeAmount: CurrencyService.fromSmallestUnit(feeAmountInCents, quote.asset ?? 'USD'),
                    recipientAmount: CurrencyService.fromSmallestUnit(recipientAmountInCents, quote.asset ?? 'USD'),
                    fee_pending: true,
                });
            }
        } catch (error) {
            logger.error('Error updating transaction with transfer info', { error });
        }
    }

    // For API responses, convert back to dollars
    return {
        message: 'Transfer created successfully',
        quoteGuid: quote.guid || '',
        transferGuid: transfer.guid || '',
        amount: quoteAmountInDollars,
        fee: CurrencyService.fromSmallestUnit(feeAmountInCents, quote.asset ?? 'USD'),
        net_amount: CurrencyService.fromSmallestUnit(recipientAmountInCents, quote.asset ?? 'USD'),
        fee_pending: true,
    };
};

export const createQuote = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    if (!event.body) {
        logger.error('No body provided');
        return responseBuilder({ message: 'No body provided' }, 400);
    }

    const userId = event.requestContext.authorizer?.userId;
    logger.info('Processing quote request', { 
        userId,
        requestId: event.requestContext.requestId,
        path: event.path,
        httpMethod: event.httpMethod
    });

    if (!userId) {
        logger.error('userId not found in authorizer claims');
        return responseBuilder({ message: 'Unauthorized' }, 401);
    }

    // Query the user's profile from single table
    const userProfile = await getUserData(userId);

    // Check if user has Cybrid integration
    if (!userProfile.metadata?.cybrid) {
        logger.error('User does not have Cybrid integration', { 
            userId,
            hasMetadata: !!userProfile.metadata,
            metadataKeys: userProfile.metadata ? Object.keys(userProfile.metadata) : []
        });
        return responseBuilder({ message: 'User does not have Cybrid integration configured' }, 400);
    }

    // Check if user has external bank account
    if (!userProfile.metadata.cybrid.externalAccount?.guid) {
        logger.error('User does not have an external bank account', {
            userId,
            hasExternalAccount: !!userProfile.metadata.cybrid.externalAccount,
            externalAccountData: userProfile.metadata.cybrid.externalAccount
        });
        return responseBuilder({ message: 'User does not have an external bank account configured' }, 400);
    }

    // Check if external bank account is verified
    const externalAccountState = userProfile.metadata.cybrid.externalAccount.state;
    if (externalAccountState !== 'verified' && externalAccountState !== 'storing') {
        logger.warn('External bank account not verified', {
            userId,
            externalAccountState,
            externalAccountGuid: userProfile.metadata.cybrid.externalAccount.guid
        });
        // For now, allow 'storing' state as well since verification might be in progress
    }

    const externalBankAccountGuid = userProfile.metadata.cybrid.externalAccount.guid;
    const cybridCustomerGuid = userProfile.metadata.cybrid.customerId;

    logger.info('User Cybrid configuration', {
        userId,
        externalBankAccountGuid,
        cybridCustomerGuid,
        fiatAccountId: userProfile.metadata.cybrid.fiatAccountId,
        externalAccountState,
        kycStatus: userProfile.kyc?.status
    });

    try {
        const request: CreateQuoteRequest = JSON.parse(event.body);
        logger.info('Creating quote', { request });

        let baseUnitRequest: CreateQuoteRequest = { ...request };

        logger.info('BASE UNIT REQUEST', { baseUnitRequest });

        if (isDepositQuoteRequest(request)) {
            logger.info('THIS IS A DEPOSIT QUOTE REQUEST', { request });
            if (!request.receive_amount) {
                logger.warn('Invalid deposit request body', { request });
                return responseBuilder({ message: 'Invalid deposit request body' }, 400);
            }

            // Convert from dollars to cents for Cybrid
            baseUnitRequest = {
                ...request,
                customer_guid: cybridCustomerGuid,
                receive_amount: CurrencyService.toSmallestUnit(request.receive_amount, request.asset ?? 'USD'),
            };
            logger.info('Deposit quote request after conversion request', { baseUnitRequest });

            // Create transaction record for deposit using unified service
            logger.info('Creating deposit transaction record', {
                userId,
                amount: request.receive_amount,
                amountInCents: CurrencyService.toSmallestUnit(request.receive_amount, request.asset ?? 'USD'),
                asset: request.asset || 'USD',
                externalBankAccountGuid,
                fiatAccountId: userProfile.metadata?.cybrid?.fiatAccountId,
                userName: userProfile.name,
                userClkktag: userProfile.clkktag,
                userEmail: userProfile.email
            });

            await UnifiedTransactionService.createTransaction({
                type: TransactionType.DEPOSIT,
                provider: PaymentProvider.CYBRID,
                amount: CurrencyService.toSmallestUnit(request.receive_amount, request.asset ?? 'USD'),
                asset: request.asset ?? 'USD',
                sender: {
                    entityId: 'system', // Deposits come from the system
                    entityType: EntityType.SYSTEM,
                    name: 'CLKK System',
                },
                recipient: {
                    entityId: userId,
                    entityType: EntityType.USER,
                    name: userProfile.name || userProfile.clkktag || 'User',
                    clkktag: userProfile.clkktag,
                    email: userProfile.email,
                },
                sourceAccountId: externalBankAccountGuid,
                destinationAccountId: userProfile.metadata?.cybrid?.fiatAccountId,
            }, event.requestContext?.requestId || 'unknown');
        } else if (isP2BTransferQuoteRequest(request)) {
            logger.info('THIS IS A P2B TRANSFER QUOTE REQUEST', { request });
            const p2bRequest = request as P2BTransferQuoteRequest;
            if (
                !p2bRequest.receive_amount ||
                !p2bRequest.asset ||
                !p2bRequest.sender_clkktag ||
                !p2bRequest.recipient_clkktag ||
                !p2bRequest.sender_cy_guid ||
                !p2bRequest.recipient_cy_guid
            ) {
                logger.warn('Invalid P2B transfer request body', { request });
                return responseBuilder({ message: 'Invalid P2B transfer request body' }, 400);
            }

            const { originalAmount, feeAmount, recipientAmount, feePercentage } = await feeService.calculateFee(
                p2bRequest.receive_amount,
                p2bRequest.recipient_entity_guid,
                p2bRequest.asset ?? 'USD',
            );

            logger.info('Fee calculation for P2B transfer', {
                originalAmount,
                feeAmount,
                recipientAmount,
                feePercentage,
            });

            baseUnitRequest = {
                ...p2bRequest,
                receive_amount: CurrencyService.toSmallestUnit(p2bRequest.receive_amount, p2bRequest.asset ?? 'USD'),
                net_amount: CurrencyService.toSmallestUnit(recipientAmount, p2bRequest.asset ?? 'USD'),
            };

            // Create transaction record for P2B transfer using unified service
            const transaction = await UnifiedTransactionService.createTransaction({
                type: TransactionType.P2B_TRANSFER,
                provider: PaymentProvider.CYBRID,
                amount: CurrencyService.toSmallestUnit(p2bRequest.receive_amount, p2bRequest.asset ?? 'USD'),
                asset: p2bRequest.asset ?? 'USD',
                sender: {
                    entityId: p2bRequest.sender_entity_guid,
                    entityType: EntityType.USER,
                    name: p2bRequest.metadata?.senderName || userProfile.name || '',
                    clkktag: p2bRequest.sender_clkktag,
                    email: userProfile.email,
                },
                recipient: {
                    entityId: p2bRequest.recipient_entity_guid,
                    entityType: EntityType.BUSINESS,
                    name: p2bRequest.metadata?.businessName ||
                          p2bRequest.metadata?.recipientName ||
                          p2bRequest.recipient_clkktag,
                    clkktag: p2bRequest.recipient_clkktag,
                    email: p2bRequest.metadata?.recipientCurrentEmail,
                },
                fees: {
                    amount: CurrencyService.toSmallestUnit(feeAmount, p2bRequest.asset ?? 'USD'),
                    percentage: feePercentage,
                    isPending: true,
                },
                memo: p2bRequest.memo,
                sourceAccountId: p2bRequest.source_account_guid,
                destinationAccountId: p2bRequest.recipient_account_guid,
                metadata: {
                    sender_cy_guid: p2bRequest.sender_cy_guid,
                    recipient_cy_guid: p2bRequest.recipient_cy_guid,
                    ...p2bRequest.metadata,
                },
            }, event.requestContext?.requestId || 'unknown');
            logger.info('P2B TRANSACTION RECORD CREATED', { transaction });
        } else if (isP2PTransferQuoteRequest(request)) {
            logger.info('THIS IS A P2P TRANSFER QUOTE REQUEST', { request });
            const p2pRequest = request as P2PTransferQuoteRequest;
            if (
                !p2pRequest.receive_amount ||
                !p2pRequest.asset ||
                !p2pRequest.sender_clkktag ||
                !p2pRequest.recipient_clkktag ||
                !p2pRequest.sender_cy_guid ||
                !p2pRequest.recipient_cy_guid
            ) {
                logger.warn('Invalid P2P transfer request body', { request });
                return responseBuilder({ message: 'Invalid P2P transfer request body' }, 400);
            }
            baseUnitRequest = {
                ...p2pRequest,
                receive_amount: CurrencyService.toSmallestUnit(p2pRequest.receive_amount, p2pRequest.asset ?? 'USD'),
            };

            // Create transaction record for P2P transfer using unified service
            const transaction = await UnifiedTransactionService.createTransaction({
                type: TransactionType.P2P_TRANSFER,
                provider: PaymentProvider.CYBRID,
                amount: CurrencyService.toSmallestUnit(p2pRequest.receive_amount, p2pRequest.asset ?? 'USD'),
                asset: p2pRequest.asset ?? 'USD',
                sender: {
                    entityId: p2pRequest.sender_entity_guid,
                    entityType: EntityType.USER,
                    name: p2pRequest.metadata?.senderName || userProfile.name || '',
                    clkktag: p2pRequest.sender_clkktag,
                    email: userProfile.email,
                },
                recipient: {
                    entityId: p2pRequest.recipient_entity_guid,
                    entityType: EntityType.USER,
                    name: p2pRequest.metadata?.recipientName || '',
                    clkktag: p2pRequest.recipient_clkktag,
                    email: p2pRequest.metadata?.recipientCurrentEmail,
                },
                memo: p2pRequest.memo,
                sourceAccountId: p2pRequest.source_account_guid,
                destinationAccountId: p2pRequest.recipient_account_guid,
                metadata: {
                    sender_cy_guid: p2pRequest.sender_cy_guid,
                    recipient_cy_guid: p2pRequest.recipient_cy_guid,
                    ...p2pRequest.metadata,
                },
            }, event.requestContext?.requestId || 'unknown');
            logger.info('TRANSACTION RECORD CREATED', { transaction });
        }

        logger.info('BASE UNIT REQUEST AFTER CONVERSION', { baseUnitRequest });

        const quote = await quoteService.createQuote(baseUnitRequest);
        logger.info('Quote created successfully', { quote });

        // Update transaction with quote information
        if (quote.guid) {
            try {
                logger.info('Updating transaction with quote information', { quote });
                // Query for the most recent pending transaction for this user
                const transactions = await UnifiedTransactionService.queryTransactions({
                    userId,
                    status: TransactionStatus.PENDING,
                    limit: 1,
                }, event.requestContext?.requestId || 'unknown');
                
                if (transactions.length > 0) {
                    logger.info('User transactions is not empty', { transactions });
                    const latestTransaction = transactions[0];
                    await UnifiedTransactionService.updateTransaction({
                        transactionId: latestTransaction.transactionId,
                        quoteGuid: quote.guid,
                        status: TransactionStatus.PENDING, // Still pending until transfer is complete
                    }, event.requestContext?.requestId || 'unknown');
                }
            } catch (error) {
                logger.error('Error updating transaction with quote info', { error });
                // Continue with the flow even if transaction update fails
            }
        }

        // Handle different types of transfers
        if (isDepositQuoteRequest(request)) {
            const transferResponse = await handleDepositTransfer(quote, externalBankAccountGuid, userId);
            return responseBuilder(transferResponse, 201);
        } else if (isP2PTransferQuoteRequest(request)) {
            const transferResponse = await handleP2PTransfer(quote, request, userId);
            return responseBuilder(transferResponse, 201);
        } else if (isP2BTransferQuoteRequest(request)) {
            const transferResponse = await handleP2BTransfer(quote, request, userId);
            return responseBuilder(transferResponse, 201);
        }
    } catch (error) {
        logger.error('Error creating quote', { error });
        return responseBuilder({ message: 'Internal server error' }, 500);
    }

    return responseBuilder({ message: 'Quote created successfully' }, 201);
};

export const getQuote = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const quoteGuid = event.pathParameters?.quoteGuid;

    if (!quoteGuid) {
        logger.error('No quoteGuid provided');
        return responseBuilder({ message: 'No quoteGuid provided' }, 400);
    }

    try {
        const request: GetQuoteRequest = { quoteGuid };
        logger.info('Getting quote', { request });

        const quote = await quoteService.getQuote(request.quoteGuid);
        logger.info('Quote retrieved successfully', { quote });

        let humanReadableQuote = { ...quote };

        if (quote.receive_amount) {
            humanReadableQuote = {
                ...humanReadableQuote,
                receive_amount: CurrencyService.fromSmallestUnit(quote.receive_amount, quote.asset ?? 'USD'),
            };
        }
        if (quote.deliver_amount) {
            humanReadableQuote = {
                ...humanReadableQuote,
                deliver_amount: CurrencyService.fromSmallestUnit(quote.deliver_amount, quote.asset ?? 'USD'),
            };
        }

        return responseBuilder({ quote: humanReadableQuote }, 200);
    } catch (error) {
        logger.error('Error getting quote', { error });
        return responseBuilder({ message: 'Internal server error' }, 500);
    }
};
</file>

<file path="lambdas/cybrid/quotes/types.ts">
export interface Fee {
    type: string;
    spread_fee: number;
    fixed_fee: number;
}

export interface DestinationAccount {
    type: string;
    guid: string;
    receive_amount: number;
    deliver_amount: number;
}

export interface BaseQuoteRequest {
    product_type: string;
    customer_guid: string;
    asset: string;
    side: string;
}

export interface DepositQuoteRequest extends BaseQuoteRequest {
    product_type: 'funding';
    side: 'deposit';
    receive_amount: number;
    customer_guid: string;
    asset: string;
}

export interface WithdrawalQuoteRequest extends BaseQuoteRequest {
    product_type: 'funding';
    side: 'withdrawal';
    deliver_amount: number;
    network_address: string;
}

export interface P2PTransferQuoteRequest extends BaseQuoteRequest {
    product_type: 'book_transfer';
    receive_amount: number;
    asset: string;
    sender_clkktag: string;
    sender_cy_guid: string;
    source_account_guid: string;
    sender_entity_type: string;
    recipient_clkktag: string;
    recipient_cy_guid: string;
    recipient_entity_guid: string;
    recipient_account_guid: string;
    metadata: {
        recipientName: string;
        recipientCurrentEmail: string;
        senderName: string;
        senderCurrentEmail: string;
    };
    sender_entity_guid: string;
    recipient_entity_type: string;
    memo: string;
}

interface Fee {
    type: string;
    rate: number;
    spread_fee: number;
    fixed_fee: number;
}

/**
 * Represents a P2B transfer quote request.
 * This type extends the BaseQuoteRequest interface with additional properties
 * specific to P2B transfer quotes.
 *
 * @extends BaseQuoteRequest
 */
export interface P2BTransferQuoteRequest extends BaseQuoteRequest {
    product_type: 'book_transfer';
    isBusiness: boolean;
    receive_amount: number;
    net_amount: number;
    asset: string;
    sender_clkktag: string;
    sender_cy_guid: string;
    source_account_guid: string;
    sender_entity_type: string;
    recipient_clkktag: string;
    recipient_cy_guid: string;
    recipient_entity_guid: string;
    recipient_account_guid: string;
    metadata: {
        recipientName: string;
        recipientCurrentEmail: string;
        senderName: string;
        senderCurrentEmail: string;
        businessName?: string;
    };
    sender_entity_guid: string;
    recipient_entity_type: string;
    memo: string;
}

export interface TradingQuoteRequest extends BaseQuoteRequest {
    product_type: 'trading';
    side: 'buy' | 'sell';
    symbol: string;
    receive_amount?: number;
    deliver_amount?: number;
    source_account_guid: string;
    destination_account_guid: string;
}

export type CreateQuoteRequest =
    | DepositQuoteRequest
    | WithdrawalQuoteRequest
    | TradingQuoteRequest
    | P2PTransferQuoteRequest
    | P2BTransferQuoteRequest;

export interface GetQuoteRequest {
    quoteGuid: string;
}

export interface QuoteBankModel {
    guid: string;
    product_type: string;
    bank_guid: string;
    customer_guid: string;
    receive_amount: number;
    deliver_amount: number;
    asset: string;
    network_address?: string;
    fees: Fee[];
    side: string;
    symbol: string;
    destination_accounts?: DestinationAccount[];
    reference_trade_guid?: string;
    source_account_guid?: string;
    destination_account_guid?: string;
    created_at: string;
    updated_at: string;
}
</file>

<file path="lambdas/cybrid/services/auth/auth-service.ts">
import { DynamoDB } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { AuthProvider, AuthUser } from '../../types/auth';
import { DYNAMO_TABLES } from 'commons/utils/constants';
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'clerk-webhook' });

export class AuthService {
    private dynamoDb: DynamoDBDocument;
    private provider: AuthProvider;

    constructor(provider: AuthProvider) {
        this.dynamoDb = DynamoDBDocument.from(new DynamoDB({}));
        this.provider = provider;
    }

    async verifyWebhook(payload: string, headers: Record<string, string>): Promise<boolean> {
        const event = await this.provider.verifyWebhook(payload, headers);
        return !!event;
    }

    async processWebhookEvent(event: any) {
        // Parse the raw webhook event data
        const parsedUser = this.provider.parseUser(event.data);

        switch (event.type) {
            case 'user.created':
                logger.info('Saving user', { parsedUser });
                await this.saveUser(parsedUser);
                break;
            case 'user.updated':
                logger.info('Updating user', { parsedUser });
                await this.updateUser(parsedUser);
                break;
            case 'user.deleted':
                logger.info('Deleting user', { parsedUser });
                await this.deleteUser(parsedUser);
                break;
            default:
                logger.info('Unhandled event type', { type: event.type });
        }
    }

    private async saveUser(user: AuthUser) {
        const params = {
            TableName: DYNAMO_TABLES.USERS,
            Item: this.formatUserData(user),
            ConditionExpression: 'attribute_not_exists(userId)',
        };

        await this.dynamoDb.put(params);
    }

    private async updateUser(user: AuthUser) {
        const params = {
            TableName: DYNAMO_TABLES.USERS,
            Key: {
                userId: user.id,
                email: user.email,
            },
            UpdateExpression: `
                SET firstName = :fn,
                    lastName = :ln,
                    phoneNumber = :pn,
                    username = :un,
                    updatedAt = :ua,
                    providerData = :pd
            `,
            ExpressionAttributeValues: {
                ':fn': user.firstName,
                ':ln': user.lastName,
                ':pn': user.phoneNumber,
                ':un': user.username,
                ':ua': new Date().toISOString(),
                ':pd': user.clerk,
            },
            ReturnValues: 'NONE' as const,
        };

        await this.dynamoDb.update(params);
    }

    private async deleteUser(user: AuthUser) {
        const params = {
            TableName: DYNAMO_TABLES.USERS,
            Key: {
                userId: user.id,
                email: user.email,
            },
        };

        await this.dynamoDb.delete(params);
    }

    private formatUserData(user: AuthUser) {
        return {
            userId: user.id,
            email: user.email,
            phoneNumber: user.phoneNumber,
            firstName: user.firstName,
            lastName: user.lastName,
            username: user.username,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt,
            imageUrl: user.imageUrl,
            profileImageUrl: user.profileImageUrl,
            clerk: user.clerk,
            primaryEmailAddressId: user.primaryEmailAddressId,
            primaryPhoneNumberId: user.primaryPhoneNumberId,
            emailAddresses: user.emailAddresses,
            phoneNumbers: user.phoneNumbers,
        };
    }
}
</file>

<file path="lambdas/cybrid/services/auth/clerk-provider.ts">
import { Webhook } from 'svix';
import { AuthProvider, AuthUser, AuthWebhookEvent } from '../../types/auth';
import { getSecret } from 'commons/utils/getSecret';
import { AWS_SECRETS } from 'commons/utils/constants';

export class ClerkAuthProvider implements AuthProvider {
    async verifyWebhook(payload: string, headers: Record<string, string>): Promise<AuthWebhookEvent | null> {
        const secret = await getSecret(AWS_SECRETS.CLERK.SECRET_NAME, AWS_SECRETS.CLERK.KEYS.WEBHOOK_SECRET);
        if (!secret) return null;

        const wh = new Webhook(secret);

        try {
            const evt = wh.verify(payload, {
                'svix-id': headers['svix-id'],
                'svix-timestamp': headers['svix-timestamp'],
                'svix-signature': headers['svix-signature'],
            }) as { type: string; data: any };

            return {
                type: evt.type,
                data: this.parseUser(evt.data),
            };
        } catch (error) {
            console.error('Webhook verification failed:', error);
            return null;
        }
    }

    parseUser(data: any): AuthUser {
        const primaryEmail = data.email_addresses?.find(
            (email: any) => email.id === data.primary_email_address_id,
        )?.email_address;

        const primaryPhone = data.phone_numbers?.find(
            (phone: any) => phone.id === data.primary_phone_number_id,
        )?.phone_number;

        if (!primaryEmail) {
            throw new Error('User must have a primary email address');
        }

        return {
            id: data.id,
            email: primaryEmail,
            phoneNumber: primaryPhone || null,
            firstName: data.first_name || null,
            lastName: data.last_name || null,
            username: data.username || null,
            createdAt: new Date(data.created_at).getTime(),
            updatedAt: new Date(data.updated_at).getTime(),
            imageUrl: data.image_url || null,
            profileImageUrl: data.profile_image_url || null,
            clerk: {
                emailId: data.primary_email_address_id,
                phoneId: data.primary_phone_number_id,
                userId: data.id,
            },
            primaryEmailAddressId: data.primary_email_address_id,
            primaryPhoneNumberId: data.primary_phone_number_id,
            emailAddresses: data.email_addresses || [],
            phoneNumbers: data.phone_numbers || [],
        };
    }
}
</file>

<file path="lambdas/cybrid/services/cybrid/cybrid-provider.ts">
import { Webhook } from 'svix';
import { AuthProvider, AuthUser, AuthWebhookEvent } from '../../types/auth';
import { getSecret } from 'commons/utils/getSecret';
import { AWS_SECRETS } from 'commons/utils/constants';

export class ClerkAuthProvider implements AuthProvider {
    async verifyWebhook(payload: string, headers: Record<string, string>): Promise<AuthWebhookEvent | null> {
        const secret = await getSecret(AWS_SECRETS.CLERK.SECRET_NAME, AWS_SECRETS.CLERK.KEYS.WEBHOOK_SECRET);
        if (!secret) return null;

        const wh = new Webhook(secret);

        try {
            const evt = wh.verify(payload, {
                'svix-id': headers['svix-id'],
                'svix-timestamp': headers['svix-timestamp'],
                'svix-signature': headers['svix-signature'],
            }) as { type: string; data: any };

            return {
                type: evt.type,
                data: this.parseUser(evt.data),
            };
        } catch (error) {
            console.error('Webhook verification failed:', error);
            return null;
        }
    }

    parseUser(data: any): AuthUser {
        const primaryEmail = data.email_addresses?.find(
            (email: any) => email.id === data.primary_email_address_id,
        )?.email_address;

        const primaryPhone = data.phone_numbers?.find(
            (phone: any) => phone.id === data.primary_phone_number_id,
        )?.phone_number;

        if (!primaryEmail) {
            throw new Error('User must have a primary email address');
        }

        return {
            id: data.id,
            email: primaryEmail,
            phoneNumber: primaryPhone || null,
            firstName: data.first_name || null,
            lastName: data.last_name || null,
            username: data.username || null,
            createdAt: new Date(data.created_at).getTime(),
            updatedAt: new Date(data.updated_at).getTime(),
            imageUrl: data.image_url || null,
            profileImageUrl: data.profile_image_url || null,
            clerk: {
                emailId: data.primary_email_address_id,
                phoneId: data.primary_phone_number_id,
                userId: data.id,
            },
            primaryEmailAddressId: data.primary_email_address_id,
            primaryPhoneNumberId: data.primary_phone_number_id,
            emailAddresses: data.email_addresses || [],
            phoneNumbers: data.phone_numbers || [],
        };
    }
}
</file>

<file path="lambdas/cybrid/services/email/email-templates.ts">
export interface EmailTemplate {
    subject: string;
    body: string;
    text?: string;
}

export const IdentityVerificationTemplates = {
    verificationEmail: (personaUrl: string, userName: string): EmailTemplate => ({
        subject: 'Complete Your Identity Verification',
        body: `
      <html>
        <body>
          <h1>Hi ${userName},</h1>
          <p>Please complete your identity verification by clicking the link below:</p>
          <a href="${personaUrl}">Verify Identity</a>
          <p>This link will expire in 24 hours.</p>
        </body>
      </html>
    `,
        text: `Hi ${userName},\n\nPlease complete your identity verification by visiting this link: ${personaUrl}\n\nThis link will expire in 24 hours.`,
    }),

    verificationSuccessEmail: (userName: string): EmailTemplate => ({
        subject: 'Identity Verification Completed',
        body: `
      <html>
        <body>
          <h1>Congratulations ${userName}!</h1>
          <p>Your identity verification was successfully completed.</p>
        </body>
      </html>
    `,
        text: `Congratulations ${userName}!\n\nYour identity verification was successfully completed.`,
    }),
};
</file>

<file path="lambdas/cybrid/services/queues/sqsService.ts">
import {
    SQSClient,
    SendMessageCommand,
    SendMessageCommandInput,
    SendMessageBatchCommand,
    SendMessageBatchRequestEntry,
    SendMessageBatchResultEntry,
    BatchResultErrorEntry,
} from '@aws-sdk/client-sqs';
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'sqs-service' });

export interface QueueMessage {
    body: string | Record<string, unknown>;
    attributes?: Record<
        string,
        {
            DataType: string;
            StringValue?: string;
            BinaryValue?: Uint8Array;
        }
    >;
    groupId?: string;
    deduplicationId?: string;
}

export class SQSService {
    private sqs: SQSClient;
    private queueUrl: string;

    constructor(queueUrl: string) {
        this.sqs = new SQSClient({});
        this.queueUrl = queueUrl;
    }

    async sendMessage(message: QueueMessage): Promise<string> {
        try {
            logger.info('Sending message to SQS', { message });
            const params: SendMessageCommandInput = {
                QueueUrl: this.queueUrl,
                MessageBody: typeof message.body === 'string' ? message.body : JSON.stringify(message.body),
                MessageAttributes: message.attributes,
            };

            // Add FIFO queue specific attributes if provided
            if (message.groupId) {
                params.MessageGroupId = message.groupId;
            }
            if (message.deduplicationId) {
                params.MessageDeduplicationId = message.deduplicationId;
            }

            const command = new SendMessageCommand(params);
            const result = await this.sqs.send(command);

            logger.info('Message sent successfully', {
                messageId: result.MessageId,
                queueUrl: this.queueUrl,
            });

            return result.MessageId || '';
        } catch (error) {
            logger.error('Error sending message to SQS', {
                error,
                queueUrl: this.queueUrl,
            });
            throw error;
        }
    }

    async sendBatchMessages(messages: QueueMessage[]): Promise<{
        successful: string[];
        failed: string[];
    }> {
        try {
            const entries: SendMessageBatchRequestEntry[] = messages.map((msg, index) => ({
                Id: index.toString(),
                MessageBody: typeof msg.body === 'string' ? msg.body : JSON.stringify(msg.body),
                MessageAttributes: msg.attributes,
                MessageGroupId: msg.groupId,
                MessageDeduplicationId: msg.deduplicationId,
            }));

            const command = new SendMessageBatchCommand({
                QueueUrl: this.queueUrl,
                Entries: entries,
            });

            const result = await this.sqs.send(command);

            const successful = result.Successful?.map((s: SendMessageBatchResultEntry) => s.MessageId || '') || [];
            const failed = result.Failed?.map((f: BatchResultErrorEntry) => f.Id || '') || [];

            logger.info('Batch messages sent', {
                successful: successful.length,
                failed: failed.length,
                queueUrl: this.queueUrl,
            });

            return { successful, failed };
        } catch (error) {
            logger.error('Error sending batch messages to SQS', {
                error,
                queueUrl: this.queueUrl,
            });
            throw error;
        }
    }

    static createMessage(
        body: string | Record<string, unknown>,
        eventSource: string,
        eventType: string,
        additionalAttributes: Record<string, string> = {},
    ): QueueMessage {
        logger.info('Creating SQS message', { body, eventSource, eventType, additionalAttributes });

        return {
            body,
            attributes: {
                eventSource: {
                    DataType: 'String',
                    StringValue: eventSource,
                },
                eventType: {
                    DataType: 'String',
                    StringValue: eventType,
                },
                ...Object.entries(additionalAttributes).reduce(
                    (acc, [key, value]) => ({
                        ...acc,
                        [key]: {
                            DataType: 'String',
                            StringValue: value,
                        },
                    }),
                    {},
                ),
            },
        };
    }
}
</file>

<file path="lambdas/cybrid/services/business-verification-service.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import { CybridConfig, DateUtil, DYNAMO_TABLES, dynamoDB } from 'commons';
import { getCybridToken } from 'commons/utils/cybrid-auth';
import { FileUploadService, type FileUploadRequest } from './file-upload-service';

// Define interfaces for our service
interface Address {
    street: string;
    street2?: string;
    city: string;
    postal_code: string;
    country_code: string;
    subdivision: string;
}

interface IndividualData {
    full_name: string;
    first_name: string;
    last_name: string;
    middle_name: string;
    date_of_birth: string;
    address: Address;
    phone_number: string;
    email_address: string;
    identification_numbers?: Array<{
        type: string;
        issuing_country_code: string;
        identification_number: string;
    }>;
}

interface UboData extends IndividualData {
    ownership_percentage: number;
    supporting_file_guids?: string[];
}

interface DirectorData extends IndividualData {}

interface SupportingDocument {
    type: 'incorporation_certificate' | 'tax_document' | 'ein_letter' | 'proof_of_beneficial_ownership';
    filename: string;
    content_type: string;
    data: string; // Base64 encoded content
}

interface BusinessVerificationData {
    customer_guid: string;
    name: {
        full: string;
    };
    address: Address;
    aliases?: Array<{
        full: string;
    }>;
    phone_number: string;
    email_address: string;
    website?: string;
    nature_of_business: string;
    identification_numbers: Array<{
        type: 'business_registration_number' | 'employer_identification_number' | 'tax_identification_number';
        issuing_country_code: string;
        identification_number: string;
    }>;
}

interface VerificationStatus {
    guid: string;
    state: string;
    outcome?: string;
    [key: string]: any;
}

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'business-verification-service',
});

export class BusinessVerificationService {
    private readonly fileUploadService: FileUploadService;

    constructor() {
        this.fileUploadService = new FileUploadService();
    }

    /**
     * Create an individual customer in Cybrid
     * @param individualData Individual customer data
     * @returns Customer information including guid
     */
    async createIndividualCustomer(individualData: IndividualData): Promise<{ guid: string }> {
        try {
            const cybridToken = await getCybridToken();
            const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/customers`;

            const payload = {
                type: 'individual',
                name: {
                    first: individualData.first_name,
                    middle: individualData.middle_name || '',
                    last: individualData.last_name,
                },
                date_of_birth: individualData.date_of_birth,
                address: individualData.address,
                phone_number: individualData.phone_number,
                email_address: individualData.email_address,
                identification_numbers: individualData.identification_numbers || [],
            };

            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
                'Idempotency-Key': uuidv4(),
            };

            logger.info('Creating individual customer in Cybrid', {
                name: individualData.full_name,
                email: individualData.email_address,
            });

            const response = await axios.post(apiUrl, payload, { headers });

            logger.info('Individual customer created successfully', {
                customerGuid: response.data.guid,
                state: response.data.state,
            });

            return { guid: response.data.guid };
        } catch (error: any) {
            logger.error('Error creating individual customer', error);

            const enhancedError = new Error(`Failed to create individual customer: ${error.message}`);
            (enhancedError as any).details = {
                status: error.response?.status,
                data: error.response?.data,
                requestId: error.response?.headers?.['x-request-id'],
            };

            throw enhancedError;
        }
    }

    /**
     * Create and verify an Ultimate Beneficial Owner (UBO)
     * @param uboData UBO data including ownership percentage
     * @returns UBO verification information
     */
    async createAndVerifyUbo(uboData: UboData): Promise<{ customer_guid: string; verification_id: string }> {
        try {
            // 1. Create individual customer
            const customer = await this.createIndividualCustomer(uboData);

            logger.info('UBO customer created', {
                customer: customer,
            });

            // 2. Create identity verification using individual attestation
            const verificationData = {
                type: 'kyc',
                method: 'attested_id_and_selfie',
                customer_guid: customer.guid,
                name: {
                    first: uboData.first_name,
                    middle: uboData.middle_name,
                    last: uboData.last_name,
                },
                date_of_birth: uboData.date_of_birth,
                address: uboData.address,
                phone_number: uboData.phone_number,
                email_address: uboData.email_address,
                identification_numbers: uboData.identification_numbers,
                supporting_file_guids: [],
            };

            const verification = await this.createIdentityVerification(verificationData);

            logger.info('UBO verification created', {
                customer_guid: customer.guid,
                verification_id: verification.guid,
                state: verification.state,
            });

            return {
                customer_guid: customer.guid,
                verification_id: verification.guid,
            };
        } catch (error: any) {
            logger.error('Error creating and verifying UBO', error);
            throw error;
        }
    }

    /**
     * Create a director customer and perform watchlist screening
     * @param directorData Director data
     * @returns Director verification information
     */
    async createAndScreenDirector(
        directorData: DirectorData,
    ): Promise<{ customer_guid: string; verification_id: string }> {
        try {
            // 1. Create individual customer
            const customer = await this.createIndividualCustomer(directorData);

            // 2. Create watchlist screening
            const verificationData = {
                type: 'kyc',
                method: 'watchlists',
                customer_guid: customer.guid,
            };

            const verification = await this.createIdentityVerification(verificationData);

            logger.info('Director watchlist screening created', {
                customer_guid: customer.guid,
                verification_id: verification.guid,
                state: verification.state,
            });

            return {
                customer_guid: customer.guid,
                verification_id: verification.guid,
            };
        } catch (error: any) {
            logger.error('Error creating and screening director', error);
            throw error;
        }
    }

    /**
     * Upload a supporting document for business verification
     * @param documentData Document data to upload
     * @returns Document GUID
     */
    async uploadSupportingDocument(documentData: SupportingDocument): Promise<string> {
        try {
            // Validate document type
            const validDocumentTypes = [
                'incorporation_certificate',
                'tax_document',
                'ein_letter',
                'proof_of_beneficial_ownership',
            ];

            if (!validDocumentTypes.includes(documentData.type)) {
                throw new Error(`Invalid document type. Must be one of: ${validDocumentTypes.join(', ')}`);
            }

            // Validate mime type
            const validMimeTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/heic'];

            if (!validMimeTypes.includes(documentData.content_type)) {
                throw new Error(`Invalid mime type. Must be one of: ${validMimeTypes.join(', ')}`);
            }

            // Check base64 content
            if (!this.isValidBase64(documentData.data)) {
                throw new Error('Invalid base64 content');
            }

            // Remove data URL prefix if present
            const cleanBase64 = documentData.data.replace(/^data:.*?;base64,/, '');

            // Upload file using FileUploadService
            const uploadRequest: FileUploadRequest = {
                type: documentData.type,
                filename: documentData.filename,
                customer_guid: '', // This will be set by the business verification
                content_type: documentData.content_type,
                data: cleanBase64,
            };

            const uploadResponse = await this.fileUploadService.uploadFile(uploadRequest);

            logger.info('Supporting document uploaded successfully', {
                type: documentData.type,
                filename: documentData.filename,
                guid: uploadResponse.guid,
            });

            return uploadResponse.guid;
        } catch (error: any) {
            logger.error('Error uploading supporting document:', { error });
            throw new Error(`Failed to upload supporting document: ${error.message}`);
        }
    }

    /**
     * Helper method to check if a string is valid base64
     */
    private isValidBase64(str: string): boolean {
        try {
            // Remove data URL prefix if present
            const base64Content = str.replace(/^data:.*?;base64,/, '');
            return btoa(atob(base64Content)) === base64Content;
        } catch (e) {
            return false;
        }
    }

    /**
     * Create the final business verification
     * @param businessData Business data
     * @param uboGuids Array of UBO customer GUIDs with ownership percentages
     * @param directorGuids Array of director customer GUIDs
     * @param supportingDocumentGuids Array of supporting document GUIDs
     * @returns Business verification information
     */
    async createBusinessVerification(
        businessData: BusinessVerificationData,
        uboData: Array<{ customer_guid: string; ownership_percentage: number }>,
        directorGuids: string[],
        supportingDocumentGuids: string[],
    ): Promise<{ guid: string; state: string }> {
        try {
            const cybridToken = await getCybridToken();
            const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications`;

            const payload = {
                type: 'kyc',
                method: 'attested_business_registration',
                customer_guid: businessData.customer_guid,
                name: businessData.name,
                address: businessData.address,
                phone_number: businessData.phone_number,
                email_address: businessData.email_address,
                nature_of_business: businessData.nature_of_business,
                identification_numbers: businessData.identification_numbers,
                director_customer_guids: directorGuids,
                ultimate_beneficial_owners: uboData,
                supporting_file_guids: supportingDocumentGuids,
            };

            // Add optional fields if provided
            if (businessData.aliases) {
                (payload as any).aliases = businessData.aliases;
            }

            if (businessData.website) {
                (payload as any).website = businessData.website;
            }

            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
                'Idempotency-Key': uuidv4(),
            };

            logger.info('Creating business verification in Cybrid', {
                customerGuid: businessData.customer_guid,
                businessName: businessData.name.full,
                uboCount: uboData.length,
                directorCount: directorGuids.length,
                documentCount: supportingDocumentGuids.length,
            });

            const response = await axios.post(apiUrl, payload, { headers });

            logger.info('Business verification created successfully', {
                verificationGuid: response.data.guid,
                state: response.data.state,
            });

            return {
                guid: response.data.guid,
                state: response.data.state,
            };
        } catch (error: any) {
            logger.error('Error creating business verification', error);

            const enhancedError = new Error(`Failed to create business verification: ${error.message}`);
            (enhancedError as any).details = {
                status: error.response?.status,
                data: error.response?.data,
                requestId: error.response?.headers?.['x-request-id'],
            };

            throw enhancedError;
        }
    }

    /**
     * Get verification status from Cybrid
     * @param verificationId Verification ID
     * @returns Verification status
     */
    async getVerificationStatus(verificationId: string): Promise<VerificationStatus> {
        try {
            const cybridToken = await getCybridToken();
            const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications/${verificationId}`;

            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
            };

            const response = await axios.get(apiUrl, { headers });

            return response.data;
        } catch (error: any) {
            logger.error('Error getting verification status', error);

            const enhancedError = new Error(`Failed to get verification status: ${error.message}`);
            (enhancedError as any).details = {
                status: error.response?.status,
                data: error.response?.data,
                requestId: error.response?.headers?.['x-request-id'],
            };

            throw enhancedError;
        }
    }

    /**
     * Check if all UBOs are verified
     * @param uboVerifications Array of UBO verification IDs
     * @returns Boolean indicating if all UBOs are verified
     */
    async checkAllUbosVerified(uboVerifications: string[]): Promise<boolean> {
        try {
            const statuses = await Promise.all(uboVerifications.map((id) => this.getVerificationStatus(id)));

            return statuses.every((status) => status.state === 'completed' && status.outcome === 'passed');
        } catch (error: any) {
            logger.error('Error checking UBO verification status', error);
            return false;
        }
    }

    /**
     * Check if all directors passed watchlist screening
     * @param directorVerifications Array of director verification IDs
     * @returns Boolean indicating if all directors passed screening
     */
    async checkAllDirectorsScreened(directorVerifications: string[]): Promise<boolean> {
        try {
            const statuses = await Promise.all(directorVerifications.map((id) => this.getVerificationStatus(id)));

            return statuses.every((status) => {
                // Directors only need watchlist screening to pass
                if (status.state !== 'completed') {
                    return false;
                }

                // Check for passed watchlist compliance decision
                const complianceDecisions = status.compliance_decisions || [];
                return complianceDecisions.some(
                    (decision: { type: string; state: string }) =>
                        decision.type === 'person_watchlists' && decision.state === 'passed',
                );
            });
        } catch (error: any) {
            logger.error('Error checking director screening status', error);
            return false;
        }
    }

    /**
     * Store verification status in DynamoDB
     * @param userId User ID
     * @param businessVerificationId Business verification ID
     * @param businessCustomerId Business customer ID
     * @param uboVerifications UBO verification information
     * @param directorVerifications Director verification information
     * @param status Verification status
     */
    async storeVerificationStatus(
        userId: string,
        businessVerificationId: string,
        businessCustomerId: string,
        uboVerifications: Array<{ customer_guid: string; verification_id: string }>,
        directorVerifications: Array<{ customer_guid: string; verification_id: string }>,
        documentGuids: string[],
        status: string,
    ): Promise<void> {
        const now = DateUtil.now();

        const item = {
            identityVerificationId: businessVerificationId,
            customerId: businessCustomerId,
            userId: userId,
            status: status,
            createdAt: now,
            updatedAt: now,
            verificationType: 'business',
            uboVerifications: uboVerifications,
            directorVerifications: directorVerifications,
            documentGuids: documentGuids,
        };

        const putParams = {
            TableName: DYNAMO_TABLES.CYBRID_IDENTITY_VERIFICATIONS,
            Item: item,
            ConditionExpression: 'attribute_not_exists(identityVerificationId)',
        };

        try {
            await dynamoDB.put(putParams);
            logger.info('Stored verification status in DynamoDB', { businessVerificationId, status });
        } catch (error: any) {
            logger.error('Error storing verification status', error);
            throw error;
        }
    }

    /**
     * Update verification status in DynamoDB
     * @param businessVerificationId Business verification ID
     * @param status New status
     */
    async updateVerificationStatus(businessVerificationId: string, status: string): Promise<void> {
        const now = DateUtil.now();

        const updateParams = {
            TableName: DYNAMO_TABLES.CYBRID_IDENTITY_VERIFICATIONS,
            Key: {
                identityVerificationId: businessVerificationId,
            },
            UpdateExpression: 'SET #status = :status, updatedAt = :updatedAt',
            ExpressionAttributeNames: {
                '#status': 'status',
            },
            ExpressionAttributeValues: {
                ':status': status,
                ':updatedAt': now,
            },
        };

        try {
            await dynamoDB.update(updateParams);
            logger.info('Updated verification status in DynamoDB', { businessVerificationId, status });
        } catch (error: any) {
            logger.error('Error updating verification status', error);
            throw error;
        }
    }

    /**
     * Get verification records from DynamoDB
     * @param userId User ID
     * @returns Verification records
     */
    async getVerificationRecords(userId: string): Promise<any[]> {
        const params = {
            TableName: DYNAMO_TABLES.CYBRID_IDENTITY_VERIFICATIONS,
            IndexName: 'userId-index',
            KeyConditionExpression: 'userId = :userId',
            ExpressionAttributeValues: {
                ':userId': userId,
            },
        };

        try {
            const result = await dynamoDB.query(params);
            return (result as any).Items || [];
        } catch (error: any) {
            logger.error('Error getting verification records', error);
            throw error;
        }
    }

    /**
     * Helper method to create identity verification
     * @param data Verification data
     * @returns Verification information
     */
    private async createIdentityVerification(data: any): Promise<any> {
        try {
            const cybridToken = await getCybridToken();
            const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications`;

            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
                'Idempotency-Key': uuidv4(),
            };

            const response = await axios.post(apiUrl, data, { headers });
            return response.data;
        } catch (error: any) {
            logger.error('Error creating identity verification', error);

            const enhancedError = new Error(`Failed to create identity verification: ${error.message}`);
            (enhancedError as any).details = {
                status: error.response?.status,
                data: error.response?.data,
                requestId: error.response?.headers?.['x-request-id'],
            };

            throw enhancedError;
        }
    }
}
</file>

<file path="lambdas/cybrid/services/file-upload-service.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import { CybridConfig } from 'commons';
import { getCybridToken } from 'commons/utils/cybrid-auth';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'fileUploadService',
});

export interface FileUploadRequest {
    type: string;
    filename: string;
    customer_guid: string;
    content_type: string;
    data?: string; // Base64 encoded content for small files
}

export interface FileUploadResponse {
    guid: string;
    state: string;
    upload_url?: string;
    upload_expires_at?: string;
}

export class FileUploadService {
    private static readonly MAX_INLINE_SIZE = 10 * 1024 * 1024; // 10MB in bytes
    private readonly apiUrl: string;

    constructor() {
        this.apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/files`;
    }

    /**
     * Upload a file to Cybrid
     * @param fileData File data to upload
     * @returns File upload response
     */
    async uploadFile(fileData: FileUploadRequest): Promise<FileUploadResponse> {
        try {
            const cybridToken = await getCybridToken();

            // For large files, we'll get a pre-signed URL
            if (!fileData.data || this.isLargeFile(fileData.data)) {
                return this.handleLargeFileUpload(fileData, cybridToken);
            }

            // For small files, we'll upload directly
            return this.handleSmallFileUpload(fileData, cybridToken);
        } catch (error: any) {
            logger.error('Error uploading file to Cybrid:', { error });
            throw this.enhanceError(error);
        }
    }

    /**
     * Handle upload of large files using pre-signed URLs
     */
    private async handleLargeFileUpload(fileData: FileUploadRequest, token: string): Promise<FileUploadResponse> {
        const headers = {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json',
            'Idempotency-Key': uuidv4(),
        };

        // Request pre-signed URL
        const payload = {
            type: fileData.type,
            filename: fileData.filename,
            customer_guid: fileData.customer_guid,
            content_type: fileData.content_type,
        };

        logger.info('Requesting pre-signed URL for large file upload', {
            filename: fileData.filename,
            type: fileData.type,
        });

        const response = await axios.post(this.apiUrl, payload, { headers });

        if (!response.data.upload_url) {
            throw new Error('No upload URL received from Cybrid');
        }

        // Upload file to pre-signed URL if data is provided
        if (fileData.data) {
            await this.uploadToPresignedUrl(response.data.upload_url, fileData.data);
        }

        return {
            guid: response.data.guid,
            state: response.data.state,
            upload_url: response.data.upload_url,
            upload_expires_at: response.data.upload_expires_at,
        };
    }

    /**
     * Handle upload of small files directly
     */
    private async handleSmallFileUpload(fileData: FileUploadRequest, token: string): Promise<FileUploadResponse> {
        const headers = {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json',
            'Idempotency-Key': uuidv4(),
        };

        const payload = {
            type: fileData.type,
            filename: fileData.filename,
            customer_guid: fileData.customer_guid,
            content_type: fileData.content_type,
            data: fileData.data,
        };

        logger.info('Uploading small file directly to Cybrid', {
            filename: fileData.filename,
            type: fileData.type,
        });

        const response = await axios.post(this.apiUrl, payload, { headers });

        return {
            guid: response.data.guid,
            state: response.data.state,
        };
    }

    /**
     * Upload file to pre-signed URL
     */
    private async uploadToPresignedUrl(uploadUrl: string, fileData: string): Promise<void> {
        try {
            // Convert base64 to buffer
            const buffer = Buffer.from(fileData, 'base64');

            await axios.put(uploadUrl, buffer, {
                headers: {
                    'Content-Type': 'application/octet-stream',
                },
            });

            logger.info('Successfully uploaded file to pre-signed URL');
        } catch (error: any) {
            logger.error('Error uploading file to pre-signed URL:', { error });
            throw new Error(`Failed to upload file to pre-signed URL: ${error.message}`);
        }
    }

    /**
     * Check if file is too large for inline upload
     */
    private isLargeFile(base64Data: string): boolean {
        // Remove data URL prefix if present
        const cleanBase64 = base64Data.replace(/^data:.*?;base64,/, '');

        // Calculate size in bytes (base64 adds ~30% overhead)
        const size = Math.ceil(cleanBase64.length * 0.75);

        return size > FileUploadService.MAX_INLINE_SIZE;
    }

    /**
     * Enhance error with additional details
     */
    private enhanceError(error: any): Error {
        const enhancedError = new Error(`Failed to upload file: ${error.message}`);
        (enhancedError as any).details = {
            status: error.response?.status,
            data: error.response?.data,
            requestId: error.response?.headers?.['x-request-id'],
        };
        return enhancedError;
    }
}
</file>

<file path="lambdas/cybrid/services/userService.ts">
interface WebhookEvent {
    type: string;
    data: any;
}

export async function processUserEvent(event: WebhookEvent): Promise<void> {
    switch (event.type) {
        case 'user.created':
            await handleUserCreated(event.data);
            break;
        case 'user.updated':
            await handleUserUpdated(event.data);
            break;
        case 'user.deleted':
            await handleUserDeleted(event.data);
            break;
        default:
            console.log(`Unhandled event type: ${event.type}`);
    }
}

async function handleUserCreated(userData: any): Promise<void> {
    console.log('Processing user.created event:', userData);
    // Implement user creation logic
}

async function handleUserUpdated(userData: any): Promise<void> {
    console.log('Processing user.updated event:', userData);
    // Implement user update logic
}

async function handleUserDeleted(userData: any): Promise<void> {
    console.log('Processing user.deleted event:', userData);
    // Implement user deletion logic
}
</file>

<file path="lambdas/cybrid/streams/fiat-account-stream.ts">
import { type DynamoDBStreamHandler } from 'aws-lambda';
import { logger } from 'commons';
import { default as fetch, Request } from 'node-fetch';

interface GraphQLResult {
    data?: any;
    errors?: { message: string }[];
}

const GRAPHQL_ENDPOINT = process.env.API_CLKK_GRAPHQLAPIENDPOINTOUTPUT;
const GRAPHQL_API_KEY = 'da2-3km5n6kmgnao5jxl4pvhdqj4ui';

const UPDATE_BALANCE_MUTATION = `
  mutation UpdateBalance($userId: String!, $accountId: String!, $balance: Int!, $asset: String!) {
    updateBalance(userId: $userId, accountId: $accountId, balance: $balance, asset: $asset) {
      userId
      accountId
      balance
      asset
      customerId
      name
      state
      createdAt
    }
  }
`;

async function executeGraphQLOperation(operation: { query: string; variables: Record<string, any> }) {
    const options = {
        method: 'POST',
        headers: {
            'x-api-key': GRAPHQL_API_KEY!,
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(operation),
    };

    const request = new Request(GRAPHQL_ENDPOINT!, options);
    const response = await fetch(request);
    return response.json();
}

export const handler: DynamoDBStreamHandler = async (event) => {
    try {
        for (const record of event.Records) {
            if (record.eventName !== 'MODIFY') continue;

            const newImage = record.dynamodb?.NewImage;
            if (!newImage) {
                logger.warn('No NewImage found in MODIFY event');
                continue;
            }

            const userId = newImage.userId?.S;
            const accountId = newImage.accountId?.S;
            const amount = parseInt(newImage.amount?.N || '0');
            const asset = newImage.asset?.S;

            if (!userId || !accountId || !asset) {
                logger.warn('Missing required fields in stream record', { userId, accountId, asset });
                continue;
            }

            logger.info('Processing balance update', { userId, accountId, amount, asset });

            const graphqlResult = (await executeGraphQLOperation({
                query: UPDATE_BALANCE_MUTATION,
                variables: { userId, accountId, amount, asset },
            })) as GraphQLResult;

            logger.info('GraphQL Result', { graphqlResult });

            if (graphqlResult.errors) {
                logger.error('GraphQL operation failed', { errors: graphqlResult.errors });
                continue;
            }

            logger.info('Successfully updated balance via AppSync', { userId, accountId });
        }
    } catch (error) {
        logger.error('Error processing DynamoDB stream', { error });
        throw error;
    }
};
</file>

<file path="lambdas/cybrid/tests/unit/clerk-users/auth-service.test.ts">
import { AuthService } from '../../../../clerk-users/services/auth/auth-service';
import { AuthProvider } from '../../../../clerk-users/types/auth';
import { dynamoDB, EntityType } from 'commons';
import { Entity } from 'commons/types';
import { DateUtil } from 'commons/utils/date';

// Mock dependencies
jest.mock('commons');
jest.mock('commons/utils/date');

describe('AuthService', () => {
    let authService: AuthService;
    let mockProvider: jest.Mocked<AuthProvider>;

    beforeEach(() => {
        // Reset all mocks
        jest.clearAllMocks();

        // Create mock provider
        mockProvider = {
            verifyWebhook: jest.fn(),
            parseUser: jest.fn(),
        };

        // Initialize service
        authService = new AuthService(mockProvider);
    });

    describe('verifyWebhook', () => {
        it('should return true when webhook is valid', async () => {
            mockProvider.verifyWebhook.mockResolvedValue({ type: 'user.created' });
            const result = await authService.verifyWebhook('payload', {});
            console.log('result', result);
            expect(result).toBe(true);
        });

        it('should return false when webhook is invalid', async () => {
            mockProvider.verifyWebhook.mockResolvedValue(null);
            const result = await authService.verifyWebhook('payload', {});
            expect(result).toBe(false);
        });
    });

    describe('processWebhookEvent', () => {
        const mockUser: Entity = {
            entityId: 'user123',
            entityType: EntityType.User,
            name: 'Test User',
            email: 'test@example.com',
            firstName: 'Test',

            lastName: 'User',
            phoneNumber: '+1234567890',
            clkktag: 'testuser',
            profileImageUrl: 'https://example.com/image.jpg',
            metadata: {
                clerkUserId: 'clerk123',
                clerkEmailId: 'email123',
                clerkPhoneId: 'phone123',
            },
        };

        beforeEach(() => {
            mockProvider.parseUser.mockReturnValue(mockUser);
            (DateUtil.now as jest.Mock).mockReturnValue('2024-03-20T12:00:00.000Z');
        });

        it('should handle user.created event', async () => {
            const event = { type: 'user.created', data: mockUser };
            await authService.processWebhookEvent(event);

            expect(dynamoDB.put).toHaveBeenCalledWith(
                expect.objectContaining({
                    TableName: 'Entities',
                    Item: expect.objectContaining({
                        entityId: mockUser.entityId,
                        email: mockUser.email,
                    }),
                    ConditionExpression: 'attribute_not_exists(entityId)',
                }),
            );
        });

        it('should handle user.updated event', async () => {
            const event = { type: 'user.updated', data: mockUser };
            await authService.processWebhookEvent(event);

            expect(dynamoDB.update).toHaveBeenCalledWith(
                expect.objectContaining({
                    TableName: 'Entities',
                    Key: {
                        entityId: mockUser.entityId,
                        email: mockUser.email,
                    },
                }),
            );
        });

        it('should handle user.deleted event', async () => {
            const event = { type: 'user.deleted', data: mockUser };
            await authService.processWebhookEvent(event);

            expect(dynamoDB.delete).toHaveBeenCalledWith(
                expect.objectContaining({
                    TableName: 'Entities',
                    Key: {
                        entityId: mockUser.entityId,
                        email: mockUser.email,
                    },
                }),
            );
        });

        it('should ignore unhandled event types', async () => {
            const event = { type: 'unknown.event', data: mockUser };
            await authService.processWebhookEvent(event);

            expect(dynamoDB.put).not.toHaveBeenCalled();
            expect(dynamoDB.update).not.toHaveBeenCalled();
            expect(dynamoDB.delete).not.toHaveBeenCalled();
        });
    });
});
</file>

<file path="lambdas/cybrid/tests/unit/clerk-users/clerk-users.test.ts">
import { webhookHandler, webhookProcessor } from '../../../../clerk-users/app';
import { AuthService } from '../../../../clerk-users/services/auth/auth-service';
import { SQSService } from 'commons';
import { logger } from 'commons';

// Mock dependencies
jest.mock('../../../../clerk-users/services/auth/auth-service');
jest.mock('../../../../clerk-users/services/auth/clerk-provider');
jest.mock('commons');

describe('Clerk Lambda Handlers', () => {
    let mockEvent: any;

    beforeEach(() => {
        jest.clearAllMocks();
        process.env.WEBHOOK_QUEUE_URL = 'mock-queue-url';
    });

    describe('webhookHandler', () => {
        beforeEach(() => {
            mockEvent = {
                body: JSON.stringify({ type: 'user.created', data: {} }),
                headers: { 'svix-signature': 'mock-signature' },
            };
        });

        it('should successfully queue webhook event', async () => {
            (AuthService.prototype.verifyWebhook as jest.Mock).mockResolvedValue(true);

            const response = await webhookHandler(mockEvent);

            expect(response.statusCode).toBe(200);
            expect(SQSService.prototype.sendMessage).toHaveBeenCalled();
            expect(JSON.parse(response.body)).toEqual({
                success: true,
                message: 'Webhook queued for processing',
            });
        });

        it('should return 400 for invalid webhook signature', async () => {
            (AuthService.prototype.verifyWebhook as jest.Mock).mockResolvedValue(false);

            const response = await webhookHandler(mockEvent);

            expect(response.statusCode).toBe(400);
            expect(JSON.parse(response.body)).toEqual({
                success: false,
                message: 'Invalid webhook signature',
            });
        });

        it('should handle errors gracefully', async () => {
            (AuthService.prototype.verifyWebhook as jest.Mock).mockRejectedValue(new Error('Test error'));

            const response = await webhookHandler(mockEvent);

            expect(response.statusCode).toBe(500);
            expect(JSON.parse(response.body)).toEqual({
                success: false,
                message: 'Test error',
            });
        });
    });

    describe('webhookProcessor', () => {
        beforeEach(() => {
            mockEvent = {
                Records: [
                    {
                        messageId: 'mock-message-id',
                        body: JSON.stringify({ type: 'user.created', data: {} }),
                    },
                ],
            };
        });

        it('should process webhook events successfully', async () => {
            await webhookProcessor(mockEvent);

            expect(AuthService.prototype.processWebhookEvent).toHaveBeenCalled();
            expect(logger.info).toHaveBeenCalledWith('Successfully processed webhook event', {
                messageId: 'mock-message-id',
            });
        });

        it('should throw error when processing fails', async () => {
            const error = new Error('Processing failed');
            (AuthService.prototype.processWebhookEvent as jest.Mock).mockRejectedValue(error);

            await expect(webhookProcessor(mockEvent)).rejects.toThrow(error);
            expect(logger.error).toHaveBeenCalledWith('Error processing SQS message', {
                error,
                messageId: 'mock-message-id',
                body: mockEvent.Records[0].body,
            });
        });
    });
});
</file>

<file path="lambdas/cybrid/tests/unit/cybrid/accounts.test.ts">
import { type DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { type APIGatewayProxyEvent } from 'aws-lambda';
import axios from 'axios';
import { getCybridToken } from 'commons';

import { lambdaHandler } from '../../../accounts/cybrid-accounts';

// Mock dependencies
jest.mock('commons/utils/cybrid-auth');
jest.mock('@aws-sdk/lib-dynamodb');
jest.mock('axios');

// Mock types
const mockGetToken = getCybridToken as jest.MockedFunction<typeof getCybridToken>;
const mockDynamoDb = {
    get: jest.fn(),
    update: jest.fn(),
} as unknown as jest.Mocked<DynamoDBDocument>;

describe('Cybrid Accounts Lambda Handler', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    // Helper function to create mock event
    const createMockEvent = (body: any, userId?: string): APIGatewayProxyEvent =>
        ({
            body: JSON.stringify(body),
            requestContext: {
                authorizer: {
                    claims: {
                        sub: userId,
                    },
                    userId: userId,
                },
            },
            headers: {},
            multiValueHeaders: {},
            httpMethod: 'POST',
            isBase64Encoded: false,
            path: '/accounts',
            pathParameters: null,
            queryStringParameters: null,
            multiValueQueryStringParameters: null,
            stageVariables: null,
            resource: '',
        } as unknown as APIGatewayProxyEvent);

    describe('Input Validation', () => {
        it('should return 403 when userId is missing from context', async () => {
            const event = createMockEvent({ name: 'Test Account' }, undefined);
            const response = await lambdaHandler(event);

            expect(response.statusCode).toBe(403);
            expect(JSON.parse(response.body)).toEqual({
                payload: 'userId or clerkUserId not provided in the event body',
            });
        });

        it.only('should return 400 when request body is missing', async () => {
            const event = createMockEvent(null, 'user123');
            const response = await lambdaHandler(event);

            expect(response.statusCode).toBe(400);
            expect(JSON.parse(response.body)).toEqual({
                success: false,
                message: 'Missing required fields',
            });
        });

        it('should return 400 when required fields are missing', async () => {
            const event = createMockEvent({}, 'user123');
            const response = await lambdaHandler(event);

            expect(response.statusCode).toBe(400);
            expect(JSON.parse(response.body)).toEqual({
                success: false,
                message: 'Missing required fields',
            });
        });
    });

    describe('User Record Retrieval', () => {
        it('should return 404 when user record is not found', async () => {
            const event = createMockEvent({ name: 'Test Account' }, 'user123');
            mockDynamoDb.get.mockResolvedValueOnce({ Item: null } as never);

            const response = await lambdaHandler(event);

            expect(response.statusCode).toBe(404);
            expect(JSON.parse(response.body)).toEqual({
                success: false,
                message: 'User not found',
            });
        });

        it('should return 400 when user record is missing Cybrid customer data', async () => {
            const event = createMockEvent({ name: 'Test Account' }, 'user123');
            mockDynamoDb.get.mockResolvedValueOnce({
                Item: { userId: 'user123', email: 'test@example.com' },
            } as never);

            const response = await lambdaHandler(event);

            expect(response.statusCode).toBe(400);
            expect(JSON.parse(response.body)).toEqual({
                success: false,
                message: 'User is not registered with Cybrid',
            });
        });
    });

    describe('Cybrid API Integration', () => {
        const mockUserRecord = {
            userId: 'user123',
            email: 'test@example.com',
            cybrid: {
                customer: {
                    guid: 'customer-guid-123',
                },
            },
        };

        beforeEach(() => {
            mockDynamoDb.get.mockResolvedValue({ Item: mockUserRecord } as never);
            mockGetToken.mockResolvedValue('mock-token');
        });

        it('should handle Cybrid API errors gracefully', async () => {
            const event = createMockEvent({ name: 'Test Account' }, 'user123');
            const mockError = new Error('API Error');
            (mockError as any).response = {
                status: 422,
                data: { message: 'Invalid request' },
            };
            (axios.post as jest.Mock).mockRejectedValueOnce(mockError);

            const response = await lambdaHandler(event);

            expect(response.statusCode).toBe(422);
            expect(JSON.parse(response.body)).toEqual({
                success: false,
                message: 'Cybrid API error',
                error: { message: 'Invalid request' },
            });
        });

        it('should handle unexpected errors gracefully', async () => {
            const event = createMockEvent({ name: 'Test Account' }, 'user123');
            mockGetToken.mockRejectedValueOnce(new Error('Unexpected error'));

            const response = await lambdaHandler(event);

            expect(response.statusCode).toBe(500);
            expect(JSON.parse(response.body)).toEqual({
                success: false,
                message: 'Unexpected error',
            });
        });

        it('should successfully create a Cybrid account', async () => {
            const event = createMockEvent({ name: 'Test Account' }, 'user123');
            const mockCybridResponse = {
                data: {
                    guid: 'account-guid-123',
                    type: 'fiat',
                    state: 'active',
                },
            };
            (axios.post as jest.Mock).mockResolvedValueOnce(mockCybridResponse);

            const response = await lambdaHandler(event);

            expect(response.statusCode).toBe(201);
            expect(JSON.parse(response.body)).toEqual({
                success: true,
                message: 'Account created successfully',
                data: mockCybridResponse.data,
            });
            expect(mockDynamoDb.update).toHaveBeenCalled();
        });

        it('should handle DynamoDB update errors gracefully', async () => {
            const event = createMockEvent({ name: 'Test Account' }, 'user123');
            const mockCybridResponse = {
                data: {
                    guid: 'account-guid-123',
                    type: 'trading',
                    state: 'active',
                },
            };
            (axios.post as jest.Mock).mockResolvedValueOnce(mockCybridResponse);
            mockDynamoDb.update.mockRejectedValueOnce(new Error('DynamoDB error') as never);

            const response = await lambdaHandler(event);

            expect(response.statusCode).toBe(500);
            expect(JSON.parse(response.body)).toEqual({
                success: false,
                message: 'DynamoDB error',
            });
        });
    });
});
</file>

<file path="lambdas/cybrid/tests/unit/test-handler.test.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { lambdaHandler } from '../../app';
import { expect, describe, it } from '@jest/globals';

describe('Unit test for app handler', function () {
    it('verifies successful response', async () => {
        const event: APIGatewayProxyEvent = {
            httpMethod: 'get',
            body: '',
            headers: {},
            isBase64Encoded: false,
            multiValueHeaders: {},
            multiValueQueryStringParameters: {},
            path: '/hello',
            pathParameters: {},
            queryStringParameters: {},
            requestContext: {
                accountId: '123456789012',
                apiId: '1234',
                authorizer: {},
                httpMethod: 'get',
                identity: {
                    accessKey: '',
                    accountId: '',
                    apiKey: '',
                    apiKeyId: '',
                    caller: '',
                    clientCert: {
                        clientCertPem: '',
                        issuerDN: '',
                        serialNumber: '',
                        subjectDN: '',
                        validity: { notAfter: '', notBefore: '' },
                    },
                    cognitoAuthenticationProvider: '',
                    cognitoAuthenticationType: '',
                    cognitoIdentityId: '',
                    cognitoIdentityPoolId: '',
                    principalOrgId: '',
                    sourceIp: '',
                    user: '',
                    userAgent: '',
                    userArn: '',
                },
                path: '/hello',
                protocol: 'HTTP/1.1',
                requestId: 'c6af9ac6-7b61-11e6-9a41-93e8deadbeef',
                requestTimeEpoch: 1428582896000,
                resourceId: '123456',
                resourcePath: '/hello',
                stage: 'dev',
            },
            resource: '',
            stageVariables: {},
        };
        const result: APIGatewayProxyResult = await lambdaHandler(event);

        expect(result.statusCode).toEqual(200);
        expect(result.body).toEqual(
            JSON.stringify({
                message: 'hello world',
            }),
        );
    });
});
</file>

<file path="lambdas/cybrid/transfers/webhooks/transfer-processor.ts">
import { SQSEvent, SQSHandler } from 'aws-lambda';
import { DateUtil, logger } from 'commons';
import { getSecret } from 'commons';
import { getCybridToken, CybridConfig } from 'commons';
import { dynamoDB } from 'commons';
import { CybridCustomer } from '../../types';
import axios from 'axios';
import { AccountBankModel, TransferBankModel } from '@cybrid/cybrid-api-bank-typescript';
import { TransactWriteItemsInput } from '@aws-sdk/client-dynamodb';
import { UnifiedTransactionService } from '../../../shared/services/unified-transaction-service';
import { TransactionStatus, PaymentProvider } from '../../../shared/types/transaction.types';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../../utils/single-table-keys';

export const cybridTransferProcessor = async (event: SQSEvent): Promise<void> => {
    for (const record of event.Records) {
        try {
            logger.info('Processing SQS message', {
                messageId: record.messageId,
                body: record.body,
            });
            // Add validation before parsing
            if (!record.body) {
                logger.error('Empty SQS message body', { messageId: record.messageId });
                continue;
            }

            const message = JSON.parse(record.body);

            // Validate message.Message exists before parsing
            if (!message || !message.Message) {
                logger.error('Invalid SQS message format', {
                    messageId: record.messageId,
                    message,
                });
                continue;
            }

            const messageData = JSON.parse(message.Message);

            logger.info('MessageData', messageData);
            const eventSource = messageData.eventSource;
            const eventType = messageData.eventType;
            const transferGuid = messageData.transferGuid;

            logger.info('Processing SQS message', {
                messageId: record.messageId,
                eventSource,
                eventType,
                message,
                transferGuid,
            });

            const transferDetails = await getCybridTransferDetails(transferGuid);

            // Handle different transfer types
            logger.info('Transfer details type', { transferDetails: transferDetails.transfer_type });
            if (transferDetails.transfer_type === 'book') {
                logger.info('Processing book transfer');
                await processBookTransfer(transferDetails);
            } else {
                // Existing non-book transfer logic
                const transferDestinationAccountGuid = transferDetails.destination_account?.guid;
                const transferCustomerGuid = transferDetails.customer_guid;

                if (!transferDestinationAccountGuid || !transferCustomerGuid) {
                    logger.error('Transfer destination account guid or customer guid not found', {
                        transferDetails,
                    });
                    throw new Error('Transfer destination account guid or customer guid not found');
                }

                const platformBalance = await getCybridFiatAccount(transferDestinationAccountGuid);
                if (!platformBalance.platform_balance) {
                    throw new Error('Platform balance not found');
                }

                await updateFiatAccountBalance(transferCustomerGuid, platformBalance.platform_balance);
            }

            // After processing the transfer, update the transaction
            logger.info('Updating transaction from transfer', { transferDetails });
            await updateTransactionFromTransfer(transferDetails);
        } catch (error) {
            logger.error('Error processing SQS message', {
                error,
                messageId: record.messageId,
                body: record.body,
            });
            throw error;
        }
    }
};

//TODO: move to commons service
async function getCybridFiatAccount(accountGuid: string): Promise<AccountBankModel> {
    const cybridToken = await getCybridToken();
    const accountApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/accounts/${accountGuid}`;
    const headers = {
        Authorization: `Bearer ${cybridToken}`,
        'Content-Type': 'application/json',
    };

    try {
        const response = await axios.get(accountApiUrl, { headers });
        logger.info('Cybrid fiat account data:', { account: response.data });
        return response.data as AccountBankModel;
    } catch (error) {
        logger.error('Error fetching Cybrid fiat account data:', { error });
        throw error;
    }
}

async function getCybridTransferDetails(transferGuid: string): Promise<TransferBankModel> {
    const cybridToken = await getCybridToken();
    const transferApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/transfers/${transferGuid}`;
    const headers = {
        Authorization: `Bearer ${cybridToken}`,
        'Content-Type': 'application/json',
    };

    try {
        const response = await axios.get(transferApiUrl, { headers });
        logger.info('Cybrid transfer details:', { transfer: response.data });
        return response.data as TransferBankModel;
    } catch (error) {
        logger.error('Error fetching Cybrid transfer details:', { error });
        throw error;
    }
}

async function updateFiatAccountBalance(customerGuid: string, balance: number) {
    try {
        // First query to get the record using GSI
        const gsiKeys = SingleTableKeys.gsiKeys.fiatAccountByCustomerId(customerGuid);
        const queryParams = {
            TableName: SINGLE_TABLE_NAME,
            IndexName: 'EntityTypeIndex',
            KeyConditionExpression: 'EntityTypeKey = :etk AND begins_with(EntityStatusSortKey, :essk)',
            ExpressionAttributeValues: {
                ':etk': gsiKeys.EntityTypeKey,
                ':essk': gsiKeys.EntityStatusSortKey,
            },
            Limit: 1,
        };

        logger.info('Querying fiat account', { queryParams });

        const result = await dynamoDB.query(queryParams);

        logger.info('Fiat account query result', { result });
        const Items = result;

        logger.info('Fiat account query result items', { Items });

        //log type of items
        logger.info('Fiat account query result items type', { type: typeof Items });
        if (!result) {
            throw new Error(`No fiat account found for customerId: ${customerGuid}`);
        }

        const accountGuid = Items[0].accountId;
        const userId = Items[0].userId;

        logger.info('Updating fiat account', {
            userId,
            accountGuid,
            balance,
        });

        // Update using single table keys
        const updateKeys = SingleTableKeys.cybridFiatAccount(userId, accountGuid);
        const updateParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: updateKeys,
            UpdateExpression: 'SET #balance = :balance, #updatedAt = :updatedAt',
            ExpressionAttributeNames: {
                '#balance': 'balance',
                '#updatedAt': 'updatedAt',
            },
            ExpressionAttributeValues: {
                ':balance': balance,
                ':updatedAt': DateUtil.now(),
            },
        };
        logger.info('Update params', { updateParams });

        await dynamoDB.update(updateParams);
        logger.info('Successfully updated fiat account', {
            customerGuid,
            balance,
        });
    } catch (error) {
        logger.error('Error updating fiat account balance', { error, customerGuid, balance });
        throw error;
    }
}

async function processBookTransfer(transfer: TransferBankModel) {
    const sourceAccountGuid = transfer.source_account?.guid;
    const destAccountGuid = transfer.destination_account?.guid;

    if (!sourceAccountGuid || !destAccountGuid) {
        throw new Error('Invalid book transfer - missing account GUIDs');
    }

    // Get both account records and their current Cybrid balances
    const [sourceAccount, destAccount, sourceCybridAccount, destCybridAccount] = await Promise.all([
        getAccountByGuid(sourceAccountGuid),
        getAccountByGuid(destAccountGuid),
        getCybridFiatAccount(sourceAccountGuid),
        getCybridFiatAccount(destAccountGuid),
    ]);

    logger.info('Source account', { sourceAccount });
    logger.info('Dest account', { destAccount });
    logger.info('Source cybrid account', { sourceCybridAccount });
    logger.info('Dest cybrid account', { destCybridAccount });

    if (!sourceCybridAccount.platform_balance || !destCybridAccount.platform_balance) {
        throw new Error('Platform balances not found');
    }

    logger.info('Book transfer balances', {
        sourceBalance: sourceCybridAccount.platform_balance,
        destBalance: destCybridAccount.platform_balance,
    });

    const sourceKeys = SingleTableKeys.cybridFiatAccount(sourceAccount.userId, sourceAccount.accountId);
    const destKeys = SingleTableKeys.cybridFiatAccount(destAccount.userId, destAccount.accountId);
    
    const transactionParams: TransactWriteItemsInput = {
        TransactItems: [
            {
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: sourceKeys,
                    UpdateExpression: 'SET #balance = :balance, #updatedAt = :updatedAt',
                    ExpressionAttributeNames: {
                        '#balance': 'balance',
                        '#updatedAt': 'updatedAt',
                    },
                    ExpressionAttributeValues: {
                        ':balance': sourceCybridAccount.platform_balance,
                        ':updatedAt': DateUtil.now(),
                    },
                },
            },
            {
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: destKeys,
                    UpdateExpression: 'SET #balance = :balance, #updatedAt = :updatedAt',
                    ExpressionAttributeNames: {
                        '#balance': 'balance',
                        '#updatedAt': 'updatedAt',
                    },
                    ExpressionAttributeValues: {
                        ':balance': destCybridAccount.platform_balance,
                        ':updatedAt': DateUtil.now(),
                    },
                },
            },
        ],
    };

    logger.info('Transaction params', { transactionParams });

    try {
        await dynamoDB.transactWrite(transactionParams);

        // After updating account balances, update the transaction
        await updateTransactionFromTransfer(transfer);

        logger.info('Book transfer processed successfully', {
            transferGuid: transfer.guid,
            sourceAccount: sourceAccountGuid,
            destAccount: destAccountGuid,
        });
    } catch (error) {
        logger.error('Book transfer transaction failed', {
            error,
            transferGuid: transfer.guid,
            sourceAccount: sourceAccountGuid,
            destAccount: destAccountGuid,
        });
        throw error;
    }
}

async function getAccountByGuid(accountGuid: string) {
    // Query using a scan since we don't have the userId
    // In production, you might want to add a GSI for accountId lookups
    const params = {
        TableName: SINGLE_TABLE_NAME,
        FilterExpression: 'accountId = :aid AND begins_with(SK, :skPrefix)',
        ExpressionAttributeValues: {
            ':aid': accountGuid,
            ':skPrefix': 'CYBRID_FIAT#',
        },
        Limit: 1,
    };

    logger.info('Scanning account by GUID', { params });
    const result = await dynamoDB.scan(params);

    logger.info('Account query result', { result });

    if (!result || !result.length) {
        throw new Error(`Account not found for GUID: ${accountGuid}`);
    }

    // Return the first item directly since we already have all the data
    return result[0];
}

// Add this function to map Cybrid transfer states to our transaction statuses
function mapTransferStateToTransactionStatus(state: string): TransactionStatus {
    switch (state) {
        case 'completed':
        case 'transfer_completed':
            return TransactionStatus.COMPLETED;
        case 'failed':
        case 'rejected':
        case 'cancelled':
            return TransactionStatus.FAILED;
        case 'pending':
        case 'created':
        case 'processing':
            return TransactionStatus.PROCESSING;
        default:
            return TransactionStatus.PENDING;
    }
}

async function updateTransactionFromTransfer(transfer: TransferBankModel) {
    try {
        if (!transfer.guid) {
            logger.warn('Transfer has no GUID, cannot update transaction', { transfer });
            return;
        }

        // Find transaction by payment provider ID using unified service
        const transaction = await UnifiedTransactionService.getTransactionByProviderId(
            transfer.guid,
            PaymentProvider.CYBRID,
            'webhook-processor'
        );

        if (!transaction) {
            logger.warn('No transaction found for payment provider ID', { paymentProviderId: transfer.guid });
            return;
        }

        const newStatus = mapTransferStateToTransactionStatus(transfer.state);

        logger.info(`Transaction status updates: ${transaction.status} -> ${newStatus}`);

        // Build update with additional details
        const updateData: any = {
            transactionId: transaction.transactionId,
            status: newStatus,
        };

        // Add completion timestamp if transfer is completed
        if (newStatus === TransactionStatus.COMPLETED) {
            updateData.completedAt = new Date().toISOString();
        }

        // Add failure information if transfer failed
        if (newStatus === TransactionStatus.FAILED && transfer.state_details) {
            updateData.failureCode = transfer.state;
            updateData.failureReason = transfer.state_details;
        }

        // Only update if status has changed
        if (transaction.status !== newStatus) {
            logger.info('Updating transaction status', {
                transactionId: transaction.transactionId,
                oldStatus: transaction.status,
                newStatus,
                transferState: transfer.state,
            });

            await UnifiedTransactionService.updateTransaction(updateData, 'webhook-processor');
        }
    } catch (error) {
        logger.error('Error updating transaction from transfer', { error, transferGuid: transfer.guid });
        // Don't throw here - we don't want to fail the whole webhook processing
    }
}
</file>

<file path="lambdas/cybrid/transfers/app.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { Logger } from '@aws-lambda-powertools/logger';
import { responseBuilder } from '../../../commons';
import { CybridService } from './services/cybrid-service';
import { CreateTransferRequest, GetTransferRequest, ListTransfersRequest } from './types';
import { FeeService } from '../../services/feeService';
//TODO: Check if this is needed
const logger = new Logger({ serviceName: 'cybrid-transfers' });
const cybridService = new CybridService();

export const createTransfer = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    if (!event.body) {
        logger.error('No body provided');
        return responseBuilder(400, { message: 'No body provided' });
    }

    try {
        const request: CreateTransferRequest = JSON.parse(event.body);
        logger.info('Creating transfer', { request });

        const transfer = await cybridService.createTransfer(request);
        logger.info('Transfer created successfully', { transfer });

        return responseBuilder(201, transfer);
    } catch (error) {
        logger.error('Error creating transfer', { error });
        return responseBuilder(500, {
            message: error instanceof Error ? error.message : 'Internal server error',
        });
    }
};

export const getTransfer = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const transferGuid = event.pathParameters?.transferGuid;

    if (!transferGuid) {
        logger.error('No transferGuid provided');
        return responseBuilder(400, { message: 'No transferGuid provided' });
    }

    try {
        const request: GetTransferRequest = { transferGuid };
        logger.info('Getting transfer', { request });

        const transfer = await cybridService.getTransfer(request);
        logger.info('Transfer retrieved successfully', { transfer });

        return responseBuilder(200, transfer);
    } catch (error) {
        logger.error('Error getting transfer', { error });
        return responseBuilder(500, {
            message: error instanceof Error ? error.message : 'Internal server error',
        });
    }
};

export const listTransfers = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    try {
        const queryParams = event.queryStringParameters || {};
        const request: ListTransfersRequest = {
            page: queryParams.page ? parseInt(queryParams.page) : undefined,
            perPage: queryParams.perPage ? parseInt(queryParams.perPage) : undefined,
            guid: queryParams.guid,
            transferType: queryParams.transferType,
            bankGuid: queryParams.bankGuid,
            customerGuid: queryParams.customerGuid,
            accountGuid: queryParams.accountGuid,
            state: queryParams.state,
            side: queryParams.side,
            label: queryParams.label,
            txnHash: queryParams.txnHash,
            createdAtGte: queryParams.createdAtGte,
            createdAtLt: queryParams.createdAtLt,
            updatedAtGte: queryParams.updatedAtGte,
            updatedAtLt: queryParams.updatedAtLt,
        };
        logger.info('Listing transfers', { request });

        const transfers = await cybridService.listTransfers(request);
        logger.info('Transfers listed successfully', { transfers });

        return responseBuilder(200, transfers);
    } catch (error) {
        logger.error('Error listing transfers', { error });
        return responseBuilder(500, {
            message: error instanceof Error ? error.message : 'Internal server error',
        });
    }
};

export const processTransaction = async (transaction) => {
    try {
        // Initialize the fee service
        const feeService = new FeeService();

        // Check if this is a business payment
        const isBusinessPayment = await feeService.isBusinessEntity(transaction.recipientId);

        if (isBusinessPayment) {
            // Get business profile with fee structure
            const businessProfile = await feeService.getBusinessProfile(transaction.recipientId);

            if (!businessProfile) {
                throw new Error(`Business profile not found for recipient: ${transaction.recipientId}`);
            }

            // Process as business payment with fees
            const { mainTransaction, feeTransaction } = await feeService.processBusinessPayment(
                transaction,
                businessProfile,
            );

            logger.info('Business payment processed successfully', {
                mainTransaction,
                feeTransaction,
            });

            return { mainTransaction, feeTransaction };
        } else {
            // For non-business transfers, just save the transaction as is
            await saveTransaction(transaction);
            logger.info('Regular transaction processed', { transaction });
            return { mainTransaction: transaction };
        }
    } catch (error) {
        logger.error('Error processing transaction', { error, transaction });
        throw error;
    }
};
</file>

<file path="lambdas/cybrid/types/auth.ts">
export interface AuthUser {
    id: string;
    email: string;
    phoneNumber?: string | null; // Allow null as well
    firstName?: string | null;
    lastName?: string | null;
    username?: string | null;
    imageUrl?: string | null;
    profileImageUrl?: string | null;
    primaryEmailAddressId: string;
    primaryPhoneNumberId: string;
    emailAddresses: { id: string; emailAddress: string }[];
    phoneNumbers: { id: string; phoneNumber: string }[];
    createdAt: number;
    updatedAt: number;
    clerk: {
        userId: string;
        emailId?: string | null;
        phoneId?: string | null;
    };
}

export interface AuthWebhookEvent {
    type: string;
    data: AuthUser;
}

export interface AuthProvider {
    verifyWebhook(payload: string, headers: Record<string, string | undefined>): Promise<AuthWebhookEvent | null>;
    parseUser(data: any): AuthUser;
}
</file>

<file path="lambdas/cybrid/types/index.ts">
import { type IdentityVerificationStatus } from 'plaid';

// User Types
export type KYCVerifier = 'persona' | 'cybrid' | 'manual';

interface ComplianceCheck {
    type: string;
    outcome: string;
    failure_codes?: string[];
}

interface ComplianceDecision {
    type: string;
    state: string;
    failure_codes?: string[];
}

interface VerificationOutcome {
    state: string;
    outcome?: string;
    failure_codes?: string[];
    compliance_checks?: ComplianceCheck[];
    compliance_decisions?: ComplianceDecision[];
}
export interface KYCData {
    verifiedBy: KYCVerifier;
    timestamp: string;
    status: IdentityVerificationStatus;
    requester: string;
    verificationId?: string;
    expiresAt?: string;
    metadata?: {
        personaInquiryId?: string;
        personaUrl?: string;
        cybridVerificationGuid?: string;
    };
}

// Cybrid Types
export interface CybridCustomerName {
    first: string;
    middle?: string;
    last: string;
    full: string;
}

export interface CybridCustomerAddress {
    street: string;
    street2?: string;
    city: string;
    subdivision: string;
    postal_code: string;
    country_code: string;
}

export interface CybridCustomerAlias {
    first: string;
    middle?: string;
    last: string;
    full: string;
}

export interface CybridComplianceDecision {
    type: string;
    state: string;
    failure_codes?: string[];
}

export interface CybridIdentificationNumber {
    type: string;
    issuing_country_code: string;
    identification_number: string;
}

export interface CybridActivityLimit {
    type: string;
    name: string;
    asset: string;
    amount: number;
    interval: number;
    activities: string[];
    sides: string[];
}

export interface CybridCustomer {
    guid: string;
    bank_guid: string;
    type: string;
    created_at: string;
    updated_at: string;
    state: string;
    name?: CybridCustomerName;
    address?: CybridCustomerAddress;
    aliases?: CybridCustomerAlias[];
    website?: string;
    date_of_birth?: string;
    phone_number?: string;
    email_address?: string;
    labels?: string[];
    compliance_decisions?: CybridComplianceDecision[];
    identification_numbers?: CybridIdentificationNumber[];
    activity_limits?: CybridActivityLimit[];
}

export interface CybridWebhookEvent {
    guid: string;
    event_type: `identity_verification.${IdentityVerificationStatus}`;
    object_guid: string;
    organization_guid: string;
    environment: 'sandbox' | 'production';
    timestamp?: string;
}

// SQS Message Types
export interface SQSMessageAttributes {
    eventSource: {
        DataType: 'String';
        StringValue: string;
    };
    eventType: {
        DataType: 'String';
        StringValue: string;
    };
}

// Fiat Account Types
export interface FiatAccount {
    guid: string;
    type: string;
    status: string;
    // Add other fiat account fields as needed
}

// Response Types
export interface WebhookResponse {
    success: boolean;
    message: string;
    error?: ErrorDetails;
}

// DynamoDB Update Types
export interface DynamoDBUpdateParams {
    TableName: string;
    Key: {
        [key: string]: any;
    };
    UpdateExpression: string;
    ExpressionAttributeNames: {
        [key: string]: string;
    };
    ExpressionAttributeValues: {
        [key: string]: any;
    };
}

// Quote Types

// Constants
export const WEBHOOK_SOURCES = {
    CYBRID: 'cybrid-webhook',
} as const;

export const EVENT_TYPES = {
    IDENTITY_VERIFICATION: {
        COMPLETED: 'identity_verification.completed',
        EXPIRED: 'identity_verification.expired',
        PENDING: 'identity_verification.pending',
        REVIEWING: 'identity_verification.reviewing',
        STORING: 'identity_verification.storing',
        WAITING: 'identity_verification.waiting',
    },
} as const;

// clkk-aws/lambdas/cybrid/types.ts

// clkk-aws/lambdas/cybrid/types.ts
export interface CybridVerificationRequest {
    type: 'bank_account';
    method: 'attested_ownership';
    customer_guid: string;
    external_bank_account_guid: string;
    name: {
        // Change this line
        first: string;
        last: string;
        full: string;
    };
    address: {
        // Change this line
        street: string;
        city: string;
        subdivision: string;
        postal_code: string;
        country_code: string;
    };
    country_code: string;
    date_of_birth: string;
    phone_number: string;
    email_address: string;
    identification_numbers: {
        type: string;
        value: string;
    }[];
}

export interface AttestedOwnershipVerification extends CybridVerificationRequest {
    type: 'attested_ownership';
    method: 'attested_ownership';
    name: {
        first: string;
        last: string;
        full: string;
    };
    address: {
        street: string;
        city: string;
        subdivision: string;
        postal_code: string;
        country_code: string;
    };
    customer_guid: string;
    country_code: string;
    date_of_birth: string;
    phone_number: string;
    email_address: string;
    identification_numbers: {
        type: string;
        value: string;
    }[];
    external_bank_account_guid: string;
}

export interface IdentityVerificationResponse {
    guid: string;
    type: string;
    method: string;
    state: string;
    created_at: string;
    updated_at: string;
    customer_guid: string;
    external_bank_account_guid: string;
    outcome: string;
}

// clkk-aws/lambdas/cybrid/types.ts
export interface SQSMessageBody {
    type: 'bank_account';
    method: 'attested_ownership';
    customer_guid: string;
    external_bank_account_guid: string;
    userId: string;
    name?: {
        // Change this line
        first: string;
        last: string;
        full: string;
    };
    address?: {
        // Change this line
        street: string;
        city: string;
        subdivision: string;
        postal_code: string;
        country_code: string;
    };
    country_code?: string;
    date_of_birth?: string;
    phone_number?: string;
    email_address?: string;
    identification_numbers?: {
        type: string;
        value: string;
    }[];
    plaid_processor_token?: string;
}

export enum IdentityVerificationSource {
    PLAID = 'plaid',
    CYBRID = 'cybrid',
}
</file>

<file path="lambdas/cybrid/utils/constants.ts">
export const AWS_SECRETS = {
    CLERK: {
        SECRET_NAME: 'clerk-secrets',
        KEYS: {
            WEBHOOK_SECRET: 'webhookSecret',
        },
    },
    CYBRID: {
        SECRET_NAME: 'cybrid-secrets',
        KEYS: {
            SIGNING_KEY: 'signingKey',
        },
    },
    PLAID: {
        SECRET_NAME: 'plaid-secrets',
        KEYS: {
            CLIENT_ID: 'clientId',
            SECRET: 'secret',
        },
    },
} as const;

export const DYNAMO_TABLES = {
    ENTITIES: 'Entities',
    CYBRID_IDENTITY_VERIFICATIONS: 'CybridIdentityVerifications',
    CYBRID_FIAT_ACCOUNTS: 'CybridFiatAccounts',
    PLAID_ACCESS_TOKENS: 'PlaidAccessToken',
    CLKK_TRANSACTIONS: 'ClkkTransactions',
    CYBRID_CUSTOMERS: 'CybridCustomers',
    CHECKBOOK_USERS: 'CheckbookUsers',
    CYBRID_EXTERNAL_BANK_ACCOUNTS: 'CybridExternalBankAccounts',
} as const;

export const PERSONA = {
    BASE_URL: 'https://withpersona.com/verify?inquiry-id=',
} as const;

export const PLAID = {
    BASE_URL: 'https://sandbox.plaid.com',
} as const;
export const PLAID_IDENTITY_URL = `${PLAID.BASE_URL}/identity/get`;
export const PLAID_TOKEN_URL = `${PLAID.BASE_URL}/processor/token/create`;
</file>

<file path="lambdas/cybrid/utils/getSecret.ts">
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'secrets-manager' });
const secretsManager = new SecretsManagerClient({ region: process.env.AWS_REGION });

interface SecretError extends Error {
    code?: string;
}

export async function getSecret(secretName: string, key: string): Promise<string> {
    try {
        logger.debug('Fetching secret', { secretName, key });

        const command = new GetSecretValueCommand({
            SecretId: secretName,
            VersionStage: 'AWSCURRENT',
        });

        const response = await secretsManager.send(command);

        if (!response.SecretString) {
            throw new Error(`Secret ${secretName} not found`);
        }

        const secretObject = JSON.parse(response.SecretString);
        logger.debug('Secret fetched successfully', { secretObject });

        if (!(key in secretObject)) {
            throw new Error(`Key ${key} not found in secret ${secretName}`);
        }

        logger.debug('Secret fetched successfully');
        return secretObject[key];
    } catch (error) {
        const secretError = error as SecretError;

        // Handle specific AWS errors
        if (secretError.code === 'DecryptionFailureException') {
            logger.error('Could not decrypt the secret', { secretName, error: secretError });
            throw new Error('Secret decryption failed');
        }

        if (secretError.code === 'ResourceNotFoundException') {
            logger.error('Secret not found', { secretName, error: secretError });
            throw new Error(`Secret ${secretName} not found`);
        }

        if (secretError.code === 'InvalidParameterException') {
            logger.error('Invalid parameter provided', { secretName, error: secretError });
            throw new Error('Invalid parameter provided to Secrets Manager');
        }

        // Log any other unexpected errors
        logger.error('Error fetching secret', {
            secretName,
            errorMessage: secretError.message,
            errorCode: secretError.code,
        });

        throw new Error('Failed to fetch secret');
    }
}
</file>

<file path="lambdas/cybrid/utils/personaUrl.ts">
import { getSecret } from 'commons/utils/getSecret';
import { AWS_SECRETS, PERSONA } from 'commons/utils/constants';
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'persona-service' });

interface PersonaUrlResponse {
    personaInquiryId: string;
    personaUrl: string;
}

export async function getPersonaUrl(identityVerificationGuid: string): Promise<PersonaUrlResponse> {
    const cybridApiKey = await getSecret(AWS_SECRETS.CYBRID.SECRET_NAME, AWS_SECRETS.CYBRID.KEYS.SIGNING_KEY);

    if (!cybridApiKey) {
        logger.error('Cybrid API key not found');
        throw new Error('Cybrid API key not found');
    }

    try {
        const response = await fetch(
            `${process.env.CYBRID_URL_SCHEME}://${process.env.CYBRID_BASE_URL}/api/identity_verifications/${identityVerificationGuid}`,
            {
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${cybridApiKey}`,
                    'Content-Type': 'application/json',
                },
            },
        );

        if (!response.ok) {
            const errorBody = await response.json();
            logger.error('Error fetching identity verification', {
                error: errorBody,
                status: response.status,
                identityVerificationGuid,
            });
            throw new Error(`Error fetching identity verification: ${errorBody.message || 'Unknown error'}`);
        }

        const data = await response.json();
        logger.info('Successfully fetched identity verification', { data });

        const personaUrl = `${PERSONA.BASE_URL}${data.persona_inquiry_id}`;

        return {
            personaInquiryId: data.persona_inquiry_id,
            personaUrl,
        };
    } catch (error) {
        logger.error('Error fetching persona URL', { error });
        throw new Error(`Error fetching persona URL: ${error}`);
    }
}
</file>

<file path="lambdas/cybrid/utils/plaidService.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { IdentityGetResponse } from 'plaid';
import { plaidClient } from '../../plaid/utils/plaid';

const logger = new Logger({ serviceName: 'plaid-service' });

interface PlaidIdentityResponse {
    firstName: string;
    lastName: string;
    address: string;
    city: string;
    state: string;
    postalCode: string;
    countryCode: string;
    dateOfBirth: string;
    phoneNumber: string;
    emailAddress: string;
    identificationNumbers: {
        type: string;
        value: string;
    }[];
}

export class PlaidService {
    /**
     * Fetches Plaid identity data using the shared Plaid client.
     */
    async fetchPlaidIdentity(plaidProcessorToken: string): Promise<PlaidIdentityResponse> {
        logger.info('Fetching Plaid identity', { plaidProcessorToken });
        try {
            // Await the shared, preconfigured Plaid client
            const client = await plaidClient;
            const response: IdentityGetResponse = await client.identityGet({
                access_token: plaidProcessorToken,
            });
            logger.info('Plaid identity response', { response });

            if (!response.data || !response.data.accounts || response.data.accounts.length === 0) {
                logger.error('Error fetching Plaid identity: No accounts found', {
                    response: response.data,
                });
                throw new Error('Error fetching Plaid identity: No accounts found');
            }

            const account = response.data.accounts[0];
            const owner = account.owners[0];

            if (!owner) {
                logger.error('Error fetching Plaid identity: No owner data found', { account });
                throw new Error('Error fetching Plaid identity: No owner data found');
            }

            const address = owner.addresses?.[0];
            const phoneNumber = owner.phone_numbers?.[0];
            const emailAddress = owner.emails?.[0];
            const dob = owner.date_of_birth;
            const fullName = owner.names?.[0];
            const idNumber = owner.id_numbers?.[0] || { type: '', value: '' };

            // Check for required fields with proper structure
            if (!address?.data || !phoneNumber?.data || !emailAddress?.data || !fullName) {
                logger.error('Error fetching Plaid identity: Incomplete owner data', { owner });
                throw new Error('Error fetching Plaid identity: Incomplete owner data');
            }

            // Parse full name into first and last name
            const nameParts = fullName.split(' ');
            const firstName = nameParts[0] || '';
            const lastName = nameParts.slice(1).join(' ') || '';

            logger.info('Successfully fetched Plaid identity data', { owner });

            return {
                firstName: firstName,
                lastName: lastName,
                address: address.data.street,
                city: address.data.city,
                state: address.data.region,
                postalCode: address.data.postal_code,
                countryCode: address.data.country,
                dateOfBirth: dob?.date || '',
                phoneNumber: phoneNumber.data,
                emailAddress: emailAddress.data,
                identificationNumbers: [
                    {
                        type: idNumber.type || '',
                        value: idNumber.value || '',
                    },
                ],
            };
        } catch (error: any) {
            logger.error('Error fetching Plaid identity from service call', { error });
            throw new Error(`Error fetching Plaid identity from service call: ${error.message || error}`);
        }
    }
}
</file>

<file path="lambdas/cybrid/utils/plaidTokenService.ts">
import { DynamoDB } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { Logger } from '@aws-lambda-powertools/logger';
import { SingleTableKeys, SINGLE_TABLE_NAME } from './single-table-keys';

const logger = new Logger({ serviceName: 'plaid-token-service' });

export class PlaidTokenService {
    private dynamoDb: DynamoDBDocument;

    constructor() {
        this.dynamoDb = DynamoDBDocument.from(new DynamoDB({}));
    }

    async getProcessorToken(userId: string): Promise<string | null> {
        try {
            logger.info('Fetching processor token from DynamoDB', { userId });
            const keys = SingleTableKeys.plaidAccessToken(userId);
            const params = {
                TableName: SINGLE_TABLE_NAME,
                Key: keys,
            };

            const result = await this.dynamoDb.get(params);

            if (!result.Item) {
                logger.warn('Processor token not found in DynamoDB', { userId });
                return null;
            }

            logger.info('Successfully fetched processor token from DynamoDB', { userId });
            return result.Item.accessToken;
        } catch (error) {
            logger.error('Error fetching processor token from DynamoDB', { error, userId });
            throw error;
        }
    }
}
</file>

<file path="lambdas/cybrid/utils/single-table-keys.ts">
/**
 * Helper functions for generating keys for the single table design
 */

export const SingleTableKeys = {
    // User/Entity keys
    user: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PROFILE`,
    }),

    // Cybrid Fiat Account keys
    cybridFiatAccount: (userId: string, accountId: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_FIAT#${accountId}`,
    }),

    // Cybrid Identity Verification keys
    cybridIdentityVerification: (userId: string, verificationId: string, timestamp: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_KYC#${timestamp}#${verificationId}`,
    }),

    // Plaid Access Token keys
    plaidAccessToken: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PLAID_TOKEN`,
    }),

    // Transaction keys
    transaction: (userId: string, timestamp: string, transactionId: string) => ({
        PK: `USER#${userId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Transaction keys for business accounts
    businessTransaction: (businessId: string, timestamp: string, transactionId: string) => ({
        PK: `BUSINESS#${businessId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Query patterns for GSIs
    gsiKeys: {
        // For querying by Cybrid customer ID (using ExternalIdIndex)
        byCybridCustomerId: (customerId: string) => ({
            ExternalIdKey: `CYBRID_CUSTOMER#${customerId}`,
            ProviderIdKey: 'CYBRID',
        }),

        // For querying fiat accounts by customer ID
        fiatAccountByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_FIAT_ACCOUNT',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For KYC status queries
        byKycStatus: (status: string, userId: string) => ({
            KYCStatusKey: `STATUS#${status}`,
            EntityTypeIdKey: `USER#${userId}`,
        }),

        // For identity verifications by customer ID
        identityVerificationByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_IDENTITY_VERIFICATION',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For transaction lookups by ID
        transactionById: (transactionId: string) => ({
            TransactionIdKey: `TXN#${transactionId}`,
        }),

        // For querying transactions by sender
        transactionsBySender: (senderId: string) => ({
            SenderIdKey: `SENDER#${senderId}`,
        }),

        // For querying transactions by recipient
        transactionsByRecipient: (recipientId: string) => ({
            RecipientIdKey: `RECIPIENT#${recipientId}`,
        }),
    },
};

// Single table name constant
export const SINGLE_TABLE_NAME = process.env.SINGLE_TABLE_NAME || 'clkk-app-table-dev';
</file>

<file path="lambdas/cybrid/utils/verifySignature.ts">
import { Webhook } from 'svix';
import { WebhookEvent } from '@clerk/nextjs/server';
import { Logger } from '@aws-lambda-powertools/logger';
import { getSecret } from 'commons/utils/getSecret';
import { AWS_SECRETS } from 'commons/utils/constants';

const logger = new Logger({ serviceName: 'webhook-verification' });

export async function verifyWebhookSignature(
    payload: string,
    svixId: string,
    svixTimestamp: string,
    svixSignature: string,
): Promise<WebhookEvent | null> {
    try {
        const secret = await getSecret(AWS_SECRETS.CLERK.SECRET_NAME, AWS_SECRETS.CLERK.KEYS.WEBHOOK_SECRET);
        const webhook = new Webhook(secret);

        const evt = webhook.verify(payload, {
            'svix-id': svixId,
            'svix-timestamp': svixTimestamp,
            'svix-signature': svixSignature,
        }) as WebhookEvent;

        return evt;
    } catch (error) {
        logger.error('Error verifying webhook signature', {
            error: error instanceof Error ? error.message : 'Unknown error',
            svixId,
            timestamp: svixTimestamp,
        });
        return null;
    }
}
</file>

<file path="lambdas/cybrid/webhooks/types/auth.ts">
export interface AuthUser {
    id: string;
    email: string;
    phoneNumber?: string | null; // Allow null as well
    firstName?: string | null;
    lastName?: string | null;
    username?: string | null;
    imageUrl?: string | null;
    profileImageUrl?: string | null;
    primaryEmailAddressId: string;
    primaryPhoneNumberId: string;
    emailAddresses: { id: string; emailAddress: string }[];
    phoneNumbers: { id: string; phoneNumber: string }[];
    createdAt: number;
    updatedAt: number;
    clerk: {
        userId: string;
        emailId?: string | null;
        phoneId?: string | null;
    };
}

export interface AuthWebhookEvent {
    type: string;
    data: AuthUser;
}

export interface AuthProvider {
    verifyWebhook(payload: string, headers: Record<string, string | undefined>): Promise<AuthWebhookEvent | null>;
    parseUser(data: any): AuthUser;
}
</file>

<file path="lambdas/cybrid/webhooks/types/index.ts">
import { PostQuoteBankModelProductTypeEnum, PostQuoteBankModelSideEnum } from '@cybrid/cybrid-api-bank-typescript';

// User Types
export type KYCVerifier = 'persona' | 'cybrid' | 'manual';

interface ComplianceCheck {
    type: string;
    outcome: string;
    failure_codes?: string[];
}

interface ComplianceDecision {
    type: string;
    state: string;
    failure_codes?: string[];
}

interface VerificationOutcome {
    state: string;
    outcome?: string;
    failure_codes?: string[];
    compliance_checks?: ComplianceCheck[];
    compliance_decisions?: ComplianceDecision[];
}
export interface KYCData {
    verifiedBy: KYCVerifier;
    timestamp: string;
    status: IdentityVerificationStatus;
    requester: string;
    verificationId?: string;
    expiresAt?: string;
    metadata?: {
        personaInquiryId?: string;
        personaUrl?: string;
        cybridVerificationGuid?: string;
    };
}

// Cybrid Types
export interface CybridCustomer {
    guid: string;
    state: string;
    type: string;
    // Add other Cybrid customer fields as needed
}

export interface CybridWebhookEvent {
    guid: string;
    event_type: `identity_verification.${IdentityVerificationStatus}`;
    object_guid: string;
    organization_guid: string;
    environment: 'sandbox' | 'production';
    timestamp?: string;
}

// SQS Message Types
export interface SQSMessageAttributes {
    eventSource: {
        DataType: 'String';
        StringValue: string;
    };
    eventType: {
        DataType: 'String';
        StringValue: string;
    };
}

// Fiat Account Types
export interface FiatAccount {
    guid: string;
    type: string;
    status: string;
    // Add other fiat account fields as needed
}

// Response Types
export interface WebhookResponse {
    success: boolean;
    message: string;
    error?: ErrorDetails;
}

// DynamoDB Update Types
export interface DynamoDBUpdateParams {
    TableName: string;
    Key: {
        [key: string]: any;
    };
    UpdateExpression: string;
    ExpressionAttributeNames: {
        [key: string]: string;
    };
    ExpressionAttributeValues: {
        [key: string]: any;
    };
}

// Quote Types

// Constants
export const WEBHOOK_SOURCES = {
    CYBRID: 'cybrid-webhook',
} as const;

export const EVENT_TYPES = {
    IDENTITY_VERIFICATION: {
        COMPLETED: 'identity_verification.completed',
        EXPIRED: 'identity_verification.expired',
        PENDING: 'identity_verification.pending',
        REVIEWING: 'identity_verification.reviewing',
        STORING: 'identity_verification.storing',
        WAITING: 'identity_verification.waiting',
    },
} as const;

// clkk-aws/lambdas/cybrid/types.ts

// clkk-aws/lambdas/cybrid/types.ts
export interface CybridVerificationRequest {
    type: 'bank_account';
    method: 'attested_ownership';
    customer_guid: string;
    external_bank_account_guid: string;
    name: {
        // Change this line
        first: string;
        last: string;
        full: string;
    };
    address: {
        // Change this line
        street: string;
        city: string;
        subdivision: string;
        postal_code: string;
        country_code: string;
    };
    country_code: string;
    date_of_birth: string;
    phone_number: string;
    email_address: string;
    identification_numbers: {
        type: string;
        value: string;
    }[];
}

export interface AttestedOwnershipVerification extends CybridVerificationRequest {
    type: 'attested_ownership';
    method: 'attested_ownership';
    name: {
        first: string;
        last: string;
        full: string;
    };
    address: {
        street: string;
        city: string;
        subdivision: string;
        postal_code: string;
        country_code: string;
    };
    customer_guid: string;
    country_code: string;
    date_of_birth: string;
    phone_number: string;
    email_address: string;
    identification_numbers: {
        type: string;
        value: string;
    }[];
    external_bank_account_guid: string;
}

export interface IdentityVerificationResponse {
    guid: string;
    type: string;
    method: string;
    state: string;
    created_at: string;
    updated_at: string;
    customer_guid: string;
    external_bank_account_guid: string;
    outcome: string;
}

// clkk-aws/lambdas/cybrid/types.ts
export interface SQSMessageBody {
    type: 'bank_account';
    method: 'attested_ownership';
    customer_guid: string;
    external_bank_account_guid: string;
    userId: string;
    name?: {
        // Change this line
        first: string;
        last: string;
        full: string;
    };
    address?: {
        // Change this line
        street: string;
        city: string;
        subdivision: string;
        postal_code: string;
        country_code: string;
    };
    country_code?: string;
    date_of_birth?: string;
    phone_number?: string;
    email_address?: string;
    identification_numbers?: {
        type: string;
        value: string;
    }[];
    plaid_processor_token?: string;
}

export enum IdentityVerificationSource {
    PLAID = 'plaid',
    CYBRID = 'cybrid',
}

export interface IdentityVerificationRecord {
    identityVerificationId: string;
    customerId: string;
    userId: string;
    personaInquiryId: string;
    personaUrl: string;
    status: string;
    createdAt: string;
    source: IdentityVerificationSource;
    metadata?: {
        plaidAccessToken?: string;
        plaidAccountId?: string;
        plaidInstitutionId?: string;
        [key: string]: any;
    };
}
</file>

<file path="lambdas/cybrid/webhooks/webhook-handler.ts">
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { DateUtil, responseBuilder } from 'commons';
import { getSecret } from 'commons';
import { SNSService } from 'commons';
import { logger } from 'commons';
import crypto from 'crypto';
import { type IdentityVerificationStatus } from 'plaid';

import { type CybridWebhookEvent, type WebhookResponse } from '../types';

const snsService = new SNSService();

const ALGORITHM = 'sha256';
const SIGNATURE_HEADER = 'X-Cybrid-Signature';

const AWS_SECRETS = {
    CLERK: {
        SECRET_NAME: 'clerk-secrets',
        KEYS: {
            WEBHOOK_SECRET: 'webhookSecret',
        },
    },
    CYBRID: {
        SECRET_NAME: 'cybrid-secrets',
        KEYS: {
            SIGNING_KEY: 'signingKey',
        },
    },
    PLAID: {
        SECRET_NAME: 'plaid-secrets',
        KEYS: {
            CLIENT_ID: 'clientId',
            SECRET: 'secret',
        },
    },
    APPLE_PUSH_NOTIFICATION_KEY: {
        SECRET_NAME: 'apple-push-notification-key',
        KEYS: {
            KEY_ID: 'keyId',
            TEAM_ID: 'teamId',
            AUTH_KEY: 'authKey',
        },
    },
} as const;

export const cybridWebhookHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    logger.info('Received Cybrid Webhook Event', { event });

    try {
        // Validate request body
        if (!event.body) {
            return responseBuilder(
                {
                    success: false,
                    message: 'Empty request body',
                },
                400,
            );
        }

        // Validate signature
        const requestSignature = event.headers[SIGNATURE_HEADER];
        if (!requestSignature) {
            return responseBuilder(
                {
                    success: false,
                    message: 'Missing signature header',
                },
                400,
            );
        }

        //log last 4 digits of signature
        logger.info('Last 4 digits of signature', { last4: AWS_SECRETS.CYBRID.KEYS.SIGNING_KEY.slice(-4) });

        // Get signing key
        const SIGNING_KEY = await getSecret(AWS_SECRETS.CYBRID.SECRET_NAME, AWS_SECRETS.CYBRID.KEYS.SIGNING_KEY);

        // Verify webhook signature
        const verified = verifyCybridWebhook(event.body, requestSignature, SIGNING_KEY);
        logger.info('Verified webhook signature', { verified });
        if (!verified) {
            throw new Error('Invalid webhook signature');
        }

        logger.info('Webhook signature verified');

        // Parse and validate webhook event
        const webhookEvent = parseAndValidateWebhookEvent(event.body);

        // Process identity verification events
        if (webhookEvent.event_type.startsWith('identity_verification.')) {
            const status = webhookEvent.event_type.split('.')[1] as IdentityVerificationStatus;

            const message = {
                identityVerificationId: webhookEvent.object_guid,
                status: status,
                eventType: webhookEvent.event_type,
                timestamp: new Date().toISOString(),
                eventSource: 'cybrid-webhook',
            };

            // ENsure the topic_ARN is defined
            if (!process.env.CYBRID_WEBHOOK_TOPIC_ARN) {
                throw new Error('WEBHOOK_TOPIC_ARN is not defined');
            }

            await snsService.publishMessage(process.env.CYBRID_WEBHOOK_TOPIC_ARN, message, 'identity_verification');

            logger.info('Successfully published identity verification event', {
                status,
                identityVerificationId: webhookEvent.object_guid,
                eventType: webhookEvent.event_type,
            });

            return responseBuilder(
                {
                    success: true,
                    message: 'Webhook processed successfully',
                },
                200,
            );
        } else if (webhookEvent.event_type.startsWith('transfer.')) {
            logger.info('Processing transfer event', { event: webhookEvent });
            //TODO:Type check
            const message = {
                eventType: webhookEvent.event_type,
                transferGuid: webhookEvent.object_guid,
                timestamp: DateUtil.now(),
            };

            await snsService.publishMessage(process.env.CYBRID_TRANSFER_TOPIC_ARN!, message, 'transfer_event');
        } else {
            logger.info('Unhandled webhook event type', {
                type: webhookEvent.event_type,
            });
        }

        return responseBuilder(
            {
                success: true,
                message: 'Webhook acknowledged',
            },
            200,
        );
    } catch (error) {
        const errorDetails = {
            message: error instanceof Error ? error.message : 'Unknown error',
            event: event.body,
            headers: event.headers,
        };
        logger.error('Error processing webhook', errorDetails);

        return createResponse(
            {
                success: false,
                message: 'Error processing webhook',
                error: errorDetails,
            },
            500,
        );
    }
};

function verifyCybridWebhook(payload: string, requestSignature: string, signingKey: string): boolean {
    const expectedSignature = crypto.createHmac(ALGORITHM, signingKey).update(payload).digest('hex');
    return requestSignature === expectedSignature;
}

function parseAndValidateWebhookEvent(body: string): CybridWebhookEvent {
    const event = JSON.parse(body) as CybridWebhookEvent;

    if (!event.event_type || !event.object_guid || !event.guid) {
        logger.error('Invalid webhook event format', { event });
        throw new Error('Invalid webhook event format');
    }

    return event;
}

function createResponse(response: WebhookResponse, statusCode = 200): APIGatewayProxyResult {
    return {
        statusCode,
        body: JSON.stringify(response),
    };
}
</file>

<file path="lambdas/cybrid/webhooks/webhook-processor.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { DynamoDB } from '@aws-sdk/client-dynamodb';
import { Lambda } from '@aws-sdk/client-lambda';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { type SQSEvent } from 'aws-lambda';
import axios from 'axios';
import { CybridConfig, DateUtil, type IdentityVerificationDynamoItem } from 'commons';
import { type Entity } from 'commons/types/users/entities.i';
import { getCybridToken } from 'commons/utils/cybrid-auth';
import { createDynamoUpdateParams, type CybridMetadata } from 'commons/utils/dynamoUtils';
import { IdentityVerificationStatus } from 'plaid';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';
import { DYNAMO_TABLES } from '../utils/constants';

import { type FiatAccount, IdentityVerificationSource, type KYCData, type CybridCustomer } from '../types';

const logger = new Logger({ serviceName: 'cybrid-webhook-processor' });
const dynamoDb = DynamoDBDocument.from(new DynamoDB({}));
const lambda = new Lambda({});

// Define state progression hierarchy
const STATE_HIERARCHY: Record<string, number> = {
    'storing': 1,
    'pending': 2,
    'reviewing': 3,
    'waiting': 4,
    'expired': 5,
    'completed': 5,
};

// Check if a state transition is valid (only allow forward progression)
function isValidStateTransition(currentState: string, newState: string): boolean {
    const currentLevel = STATE_HIERARCHY[currentState] || 0;
    const newLevel = STATE_HIERARCHY[newState] || 0;
    return newLevel >= currentLevel;
}

export const cybridWebhookProcessor = async (event: SQSEvent): Promise<void> => {
    for (const record of event.Records) {
        try {
            const message = JSON.parse(record.body);
            // Parse the actual message content
            const messageData = JSON.parse(message.Message);
            
            // Extract event GUID for idempotency
            const eventGuid = message.MessageId || record.messageId;

            logger.info('MessageData', messageData);
            const eventSource = messageData.eventSource;
            const eventType = messageData.eventType;

            logger.info('Processing SQS message', {
                messageId: record.messageId,
                eventSource,
                eventType,
                message,
            });

            if (eventSource === 'cybrid-webhook' && eventType?.startsWith('identity_verification.')) {
                const { identityVerificationId, status } = messageData;

                logger.info('Processing identity verification', {
                    identityVerificationId,
                    status,
                    eventGuid,
                });

                if (!identityVerificationId || !status) {
                    logger.error('Invalid message format', { message });
                    continue;
                }
                
                // Check if we've already processed this event (idempotency)
                const processedEvent = await checkIfEventProcessed(eventGuid);
                if (processedEvent) {
                    logger.info('Event already processed, skipping', {
                        eventGuid,
                        identityVerificationId,
                        status,
                    });
                    continue;
                }

                // Fetch verification details from Cybrid API if status is completed
                let verificationData;
                if (status === 'completed') {
                    logger.info('Fetching Completed details', { status });
                    verificationData = await getIdentityVerificationDetails(identityVerificationId);
                    logger.info('Fetched verification details', { verificationData });
                }

                const updateResult = await updateIdentityVerificationAndUser(identityVerificationId, status, verificationData, eventGuid);
                
                if (updateResult.success) {
                    logger.info('Successfully processed update', {
                        messageId: record.messageId,
                        eventGuid,
                        status,
                        hasVerificationData: !!verificationData,
                        skipped: updateResult.skipped,
                        reason: updateResult.reason,
                    });
                } else {
                    logger.warn('Update skipped or failed', {
                        messageId: record.messageId,
                        eventGuid,
                        status,
                        reason: updateResult.reason,
                    });
                }
            }
        } catch (error) {
            logger.error('Error processing SQS message', {
                error,
                messageId: record.messageId,
                body: record.body,
            });
            throw error;
        }
    }
};

interface UpdateResult {
    success: boolean;
    skipped?: boolean;
    reason?: string;
}

async function updateIdentityVerificationAndUser(
    identityVerificationId: string,
    newStatus: 'completed' | 'expired' | 'waiting' | 'pending' | 'reviewing' | 'storing',
    verificationData: any,
    eventGuid: string,
): Promise<UpdateResult> {
    logger.info('Updating identity verification', {
        identityVerificationId,
        newStatus,
        hasVerificationData: !!verificationData,
    });

    try {
        const identityVerification = await getIdentityVerification(identityVerificationId);
        logger.info('Identity verification record:', { 
            identityVerification,
            hasRecord: !!identityVerification,
            recordKeys: identityVerification ? Object.keys(identityVerification) : [],
        });
        if (!identityVerification) {
            logger.warn('Identity verification record not found', {
                identityVerificationId,
                newStatus,
            });
            return { success: false, reason: 'Identity verification record not found' };
        }
        
        // Check if state transition is valid
        const currentStatus = identityVerification.status;
        if (!isValidStateTransition(currentStatus, newStatus)) {
            logger.info('Invalid state transition, skipping', {
                identityVerificationId,
                currentStatus,
                newStatus,
                eventGuid,
            });
            return { success: true, skipped: true, reason: `Invalid transition from ${currentStatus} to ${newStatus}` };
        }
        
        // Check timestamp to handle out-of-order events
        const eventTimestamp = verificationData?.timestamp || new Date().toISOString();
        const lastUpdateTimestamp = identityVerification.updatedAt || identityVerification.createdAt;
        
        if (lastUpdateTimestamp && new Date(eventTimestamp) < new Date(lastUpdateTimestamp)) {
            logger.info('Event timestamp is older than last update, skipping', {
                identityVerificationId,
                eventTimestamp,
                lastUpdateTimestamp,
                eventGuid,
            });
            return { success: true, skipped: true, reason: 'Event is older than last update' };
        }

        // Pass verification data and event GUID when updating status
        await updateIdentityVerificationStatus(
            identityVerificationId,
            newStatus as IdentityVerificationStatus,
            verificationData,
            eventGuid,
        );

        logger.info('Identity verification status updated and now on next step', {
            identityVerificationId,
            newStatus,
            verificationData,
        });

        // Only proceed with user updates if it's not a bank verification
        const verificationType = (identityVerification as any).verificationType || identityVerification.source;
        if (verificationType !== 'plaid' && verificationType !== IdentityVerificationSource.PLAID) {
            logger.info('Identity verification source is not plaid', {
                identityVerificationId,
                verificationType,
            });
            const userId = identityVerification.userId || identityVerification.entityId || (identityVerification as any).id;
            
            logger.info('Extracted userId from identity verification', {
                userId,
                hasUserId: !!identityVerification.userId,
                hasEntityId: !!identityVerification.entityId,
                hasId: !!(identityVerification as any).id,
                identityVerificationKeys: Object.keys(identityVerification),
            });
            const userRecord = await getUserRecord(userId);
            if (!userRecord) {
                throw new Error('User record not found');
            }

            switch (newStatus) {
                case 'completed':
                    logger.info('Handling completed status', {
                        outcome: verificationData?.outcome,
                        hasFailureCodes: !!verificationData?.failure_codes?.length,
                    });
                    // Only proceed with completed status handling if outcome is successful
                    if (verificationData?.outcome === 'passed') {
                        await handleCompletedStatus(userRecord);
                    } else {
                        logger.warn('Verification completed but failed', {
                            outcome: verificationData?.outcome,
                            failure_codes: verificationData?.failure_codes,
                        });
                    }
                    break;
                case 'expired':
                    logger.info('Handling expired status');
                    await handleExpiredStatus(userRecord);
                    break;
                default:
                    logger.info('Handling different status', { newStatus });
                    await updateIdentityVerificationStatusForUser(userId, newStatus as IdentityVerificationStatus);
            }
        } else {
            logger.info('Skipping user record update for bank verification', {
                identityVerificationId,
                verificationType: 'plaid',
            });
        }

        logger.info('Successfully processed status update', {
            identityVerificationId,
            newStatus,
            verificationType: (identityVerification as any).verificationType || identityVerification.source,
            outcome: verificationData?.outcome,
        });
        
        return { success: true };
    } catch (error) {
        logger.error('Error in updateIdentityVerificationAndUser', {
            error,
            identityVerificationId,
            newStatus,
            verificationData,
        });
        return { success: false, reason: error instanceof Error ? error.message : 'Unknown error' };
    }
}

async function getUserRecord(userId: string): Promise<Entity | null> {
    logger.info('Getting user record', { userId });
    
    const userKeys = SingleTableKeys.user(userId);
    const { Item } = await dynamoDb.get({
        TableName: SINGLE_TABLE_NAME,
        Key: userKeys,
    });

    logger.info('Retrieved user record:', { userId, userRecord: Item });
    return Item as Entity | null;
}

async function handleCompletedStatus(userRecord: Entity): Promise<void> {
    try {
        const customerGuid = (userRecord.metadata as CybridMetadata)?.cybrid?.customerId ||
                           (userRecord.metadata as any)?.cybrid?.customer?.guid;
        if (!customerGuid) {
            throw new Error('Cybrid customer GUID not found');
        }

        // Fetch customer details from Cybrid
        const cybridCustomer = await getCybridCustomer(customerGuid);
        
        logger.info('Fetched Cybrid customer details', {
            customerGuid,
            hasName: !!cybridCustomer.name,
            hasAddress: !!cybridCustomer.address,
            hasDateOfBirth: !!cybridCustomer.date_of_birth,
        });

        const kycData: KYCData = {
            verifiedBy: 'persona',
            timestamp: DateUtil.now(),
            status: IdentityVerificationStatus.Success,
            requester: (userRecord as any).id || userRecord.entityId || '',
            metadata: {
                cybridVerificationGuid: customerGuid,
            },
        };

        const userId = (userRecord as any).id || userRecord.entityId;
        
        // Prepare update data with Cybrid customer information
        const updateData: any = {
            kyc: kycData,
        };
        
        // Add Cybrid customer data to user profile
        if (cybridCustomer.name) {
            updateData.firstName = cybridCustomer.name.first;
            updateData.lastName = cybridCustomer.name.last;
            if (cybridCustomer.name.middle) {
                updateData.middleName = cybridCustomer.name.middle;
            }
        }
        
        if (cybridCustomer.date_of_birth) {
            updateData.dob = cybridCustomer.date_of_birth;
        }
        
        if (cybridCustomer.address) {
            updateData.address = {
                street: cybridCustomer.address.street,
                street2: cybridCustomer.address.street2,
                city: cybridCustomer.address.city,
                state: cybridCustomer.address.subdivision,
                postalCode: cybridCustomer.address.postal_code,
                countryCode: cybridCustomer.address.country_code,
            };
        }
        
        if (cybridCustomer.phone_number) {
            updateData.phoneNumber = cybridCustomer.phone_number;
        }
        
        if (cybridCustomer.email_address) {
            updateData.email = cybridCustomer.email_address;
        }
        
        // Store identification numbers if available
        if (cybridCustomer.identification_numbers && cybridCustomer.identification_numbers.length > 0) {
            updateData.identificationNumbers = cybridCustomer.identification_numbers;
        }
        
        logger.info('Updating user record with KYC and Cybrid customer data', { 
            userId,
            customerGuid,
            hasName: !!updateData.firstName,
            hasAddress: !!updateData.address,
            hasDob: !!updateData.dob,
        });

        await updateUserRecord(userId, updateData);

        logger.info('Creating fiat account for user', { userId });
        await createFiatAccountForUser(userId);
    } catch (error) {
        logger.error('Error handling completed status', { error, userId: (userRecord as any).id || userRecord.entityId });
        throw error;
    }
}

async function handleExpiredStatus(userRecord: Entity): Promise<void> {
    const userId = (userRecord as any).id || userRecord.entityId;
    const kycData: KYCData = {
        verifiedBy: 'persona',
        timestamp: new Date().toISOString(),
        status: IdentityVerificationStatus.Expired,
        requester: userId || '',
        expiresAt: new Date().toISOString(),
    };

    await updateUserRecord(userId, {
        kyc: kycData,
    });
}

// Database operations
async function getIdentityVerification(id: string): Promise<IdentityVerificationDynamoItem | null> {
    const maxAttempts = 3;
    const baseDelay = 1000; // 1 second

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
            logger.info('Getting identity verification record', {
                id,
                attempt,
                maxAttempts,
                tableName: SINGLE_TABLE_NAME,
            });

            // Query the single table for identity verification
            // We need to scan since we only have the verification ID
            // Exclude EVENT records which are for idempotency
            // Look specifically for USER# prefixed records with CYBRID_KYC# in SK
            const queryParams = {
                TableName: SINGLE_TABLE_NAME,
                FilterExpression: 'identityVerificationId = :id AND begins_with(PK, :userPrefix) AND contains(SK, :kycPrefix)',
                ExpressionAttributeValues: {
                    ':id': id,
                    ':userPrefix': 'USER#',
                    ':kycPrefix': 'CYBRID_KYC#',
                },
            };

            const result = await dynamoDb.scan(queryParams);

            logger.info('Scan result for identity verification', {
                id,
                itemCount: result.Items?.length || 0,
                items: result.Items?.map((item: any) => ({
                    PK: item.PK,
                    SK: item.SK,
                    identityVerificationId: item.identityVerificationId,
                    userId: item.userId,
                })),
            });

            // Check if any items were found
            if (!result.Items || result.Items.length === 0) {
                logger.warn('Identity verification record not found', {
                    id,
                    attempt,
                    maxAttempts,
                });

                // If it's the last attempt, return null
                if (attempt === maxAttempts) {
                    logger.error('Identity verification record not found after all attempts', {
                        id,
                        totalAttempts: maxAttempts,
                    });
                    return null;
                }

                // Calculate delay for next attempt
                const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), 5000) + Math.random() * 1000;

                logger.info('Retrying after delay', {
                    attempt,
                    delayMs: delay,
                });

                await new Promise((resolve) => setTimeout(resolve, delay));
                continue;
            }

            logger.info('Successfully retrieved identity verification record', {
                id,
                attempt,
                hasItem: true,
                itemsFound: result.Items.length,
            });

            // Return the first matching item
            return result.Items[0] as IdentityVerificationDynamoItem;
        } catch (error) {
            const isLastAttempt = attempt === maxAttempts;
            logger.error('Error getting identity verification record', {
                error,
                id,
                attempt,
                maxAttempts,
                isLastAttempt,
            });

            if (isLastAttempt) {
                throw new Error(
                    `Failed to get identity verification after ${maxAttempts} attempts: ${
                        error instanceof Error ? error.message : 'Unknown error'
                    }`,
                );
            }

            const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), 5000) + Math.random() * 1000;

            logger.info('Retrying after delay', {
                attempt,
                delayMs: delay,
            });

            await new Promise((resolve) => setTimeout(resolve, delay));
        }
    }

    return null;
}

async function updateIdentityVerificationStatus(
    id: string,
    status: IdentityVerificationStatus,
    verificationData: any,
    eventGuid?: string,
): Promise<void> {
    const maxAttempts = 3;
    const baseDelay = 1000;

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
            logger.info('Updating identity verification status', {
                id,
                status,
                verificationData,
                attempt,
                maxAttempts,
            });

            // First, get the verification to find its keys
            const verification = await getIdentityVerification(id);
            if (!verification) {
                throw new Error(`Identity verification not found: ${id}`);
            }

            const updateData: any = {
                status,
                updatedAt: new Date().toISOString(),
            };

            if (verificationData) {
                // Store additional verification data for any completed verification
                updateData.outcome = verificationData.outcome;
                updateData.failure_codes = verificationData.failure_codes;
                updateData.compliance_checks = verificationData.compliance_checks;
                updateData.compliance_decisions = verificationData.compliance_decisions;
            }

            // Update the verification record in single table
            const updateParams = {
                TableName: SINGLE_TABLE_NAME,
                Key: {
                    PK: (verification as any).PK,
                    SK: (verification as any).SK,
                },
                UpdateExpression: createUpdateExpression(updateData),
                ExpressionAttributeValues: createExpressionAttributeValues(updateData),
                ExpressionAttributeNames: createExpressionAttributeNames(updateData),
                ConditionExpression: 'attribute_exists(PK) AND attribute_exists(SK)',
            };

            await dynamoDb.update(updateParams);

            logger.info('Successfully updated identity verification status', {
                id,
                status,
                hasAdditionalData: !!verificationData,
                eventGuid,
                attempt,
            });
            
            // Store processed event GUID if provided
            if (eventGuid) {
                await storeProcessedEvent(eventGuid, id);
            }

            return;
        } catch (error) {
            const isLastAttempt = attempt === maxAttempts;
            logger.error('Error updating identity verification status', {
                error,
                id,
                status,
                verificationData,
                attempt,
                maxAttempts,
                isLastAttempt,
            });

            if (isLastAttempt) {
                throw new Error(
                    `Failed to update identity verification status after ${maxAttempts} attempts: ${
                        error instanceof Error ? error.message : 'Unknown error'
                    }`,
                );
            }

            const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), 5000) + Math.random() * 1000;

            logger.info('Retrying update after delay', {
                attempt,
                delayMs: delay,
            });

            await new Promise((resolve) => setTimeout(resolve, delay));
        }
    }
}

// Helper functions for DynamoDB update expressions
function createUpdateExpression(data: any): string {
    const keys = Object.keys(data);
    const setExpressions = keys.map((key, index) => `#field${index} = :value${index}`);
    return `SET ${setExpressions.join(', ')}`;
}

function createExpressionAttributeValues(data: any): any {
    const values: any = {};
    Object.keys(data).forEach((key, index) => {
        values[`:value${index}`] = data[key];
    });
    return values;
}

function createExpressionAttributeNames(data: any): any {
    const names: any = {};
    Object.keys(data).forEach((key, index) => {
        names[`#field${index}`] = key;
    });
    return names;
}

async function updateUserRecord(userId: string, updates: any): Promise<void> {
    logger.info('Updating user record', { userId, updates });
    try {
        const userKeys = SingleTableKeys.user(userId);
        const params: any = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
            UpdateExpression: 'SET updatedAt = :updatedAt',
            ExpressionAttributeValues: {
                ':updatedAt': DateUtil.now(),
            } as Record<string, unknown>,
        };

        // Only add ExpressionAttributeNames if needed
        const attributeNames: Record<string, string> = {};

        // Handle KYC updates
        if (updates.kyc) {
            params.UpdateExpression += ', kyc = :kyc';
            params.ExpressionAttributeValues[':kyc'] = updates.kyc;
        }
        
        // Handle name updates
        if (updates.firstName) {
            params.UpdateExpression += ', firstName = :firstName';
            params.ExpressionAttributeValues[':firstName'] = updates.firstName;
        }
        
        if (updates.lastName) {
            params.UpdateExpression += ', lastName = :lastName';
            params.ExpressionAttributeValues[':lastName'] = updates.lastName;
        }
        
        if (updates.middleName) {
            params.UpdateExpression += ', middleName = :middleName';
            params.ExpressionAttributeValues[':middleName'] = updates.middleName;
        }
        
        // Handle DOB update
        if (updates.dob) {
            params.UpdateExpression += ', dob = :dob';
            params.ExpressionAttributeValues[':dob'] = updates.dob;
        }
        
        // Handle address update
        if (updates.address) {
            params.UpdateExpression += ', #address = :address';
            params.ExpressionAttributeValues[':address'] = updates.address;
            attributeNames['#address'] = 'address';
        }
        
        // Handle phone number update
        if (updates.phoneNumber) {
            params.UpdateExpression += ', phoneNumber = :phoneNumber';
            params.ExpressionAttributeValues[':phoneNumber'] = updates.phoneNumber;
        }
        
        // Handle email update
        if (updates.email) {
            params.UpdateExpression += ', email = :email';
            params.ExpressionAttributeValues[':email'] = updates.email;
        }
        
        // Handle identification numbers update
        if (updates.identificationNumbers) {
            params.UpdateExpression += ', identificationNumbers = :identificationNumbers';
            params.ExpressionAttributeValues[':identificationNumbers'] = updates.identificationNumbers;
        }

        // Only add ExpressionAttributeNames if we have any
        if (Object.keys(attributeNames).length > 0) {
            params.ExpressionAttributeNames = attributeNames;
        }

        await dynamoDb.update(params);
        logger.info('Successfully updated user record', { userId, updates });
    } catch (error) {
        logger.error('Error updating user record', { error, userId, updates });
        throw error;
    }
}

async function updateIdentityVerificationStatusForUser(userId: string, status: IdentityVerificationStatus): Promise<void> {
    await updateUserRecord(userId, { kyc: { status, updatedAt: DateUtil.now() } });
}

async function createFiatAccountForUser(userId: string): Promise<FiatAccount> {
    logger.info('Creating Fiat Account for User', { userId });
    try {
        const payload = {
            body: JSON.stringify({ clerkUserId: userId }),
        };

        const response = await lambda.invoke({
            FunctionName: process.env.CREATE_ACCOUNT_FUNCTION_NAME!,
            InvocationType: 'RequestResponse',
            Payload: JSON.stringify(payload),
        });

        // Convert Uint8Array to string and parse JSON
        const payloadString = Buffer.from(response.Payload as Uint8Array).toString();
        const responsePayload = JSON.parse(payloadString);

        logger.info('Lambda response payload:', { responsePayload });

        if (response.StatusCode === 200) {
            // Parse the nested body string if it exists
            const body =
                typeof responsePayload.body === 'string' ? JSON.parse(responsePayload.body) : responsePayload.body;

            logger.info('Successfully created Fiat Account', { body });
            return body.fiatAccount;
        } else {
            logger.error('Error creating Fiat Account', {
                StatusCode: response.StatusCode,
                Payload: responsePayload,
            });
            throw new Error('Failed to create Fiat Account');
        }
    } catch (error) {
        logger.error('Error in createFiatAccountForUser', { error, userId });
        throw error;
    }
}

async function getCybridCustomer(customerGuid: string): Promise<CybridCustomer> {
    try {
        const cybridToken = await getCybridToken();
        const customerApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/customers/${customerGuid}?pii=true`;

        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        const response = await axios.get<CybridCustomer>(customerApiUrl, { headers });
        logger.info('Retrieved customer details from Cybrid', {
            customerGuid,
            hasName: !!response.data.name,
            hasAddress: !!response.data.address,
            hasDateOfBirth: !!response.data.date_of_birth,
        });

        return response.data;
    } catch (error) {
        if (axios.isAxiosError(error)) {
            logger.error('Error fetching customer details from Cybrid API:', {
                status: error.response?.status,
                statusText: error.response?.statusText,
                data: error.response?.data,
                customerGuid,
            });
        } else {
            logger.error('Unexpected error fetching customer details:', {
                error,
                customerGuid,
            });
        }
        throw error;
    }
}

async function getIdentityVerificationDetails(verificationId: string): Promise<any> {
    try {
        const cybridToken = await getCybridToken();
        const verificationApiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/identity_verifications/${verificationId}`;

        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        const response = await axios.get(verificationApiUrl, { headers });
        logger.info('Retrieved verification details from Cybrid', {
            verificationId,
            status: response.data.state,
            outcome: response.data.outcome,
        });

        return {
            state: response.data.state,
            outcome: response.data.outcome,
            failure_codes: response.data.failure_codes,
            compliance_checks: response.data.compliance_checks,
            compliance_decisions: response.data.compliance_decisions,
        };
    } catch (error) {
        if (axios.isAxiosError(error)) {
            logger.error('Error fetching verification details from Cybrid API:', {
                status: error.response?.status,
                statusText: error.response?.statusText,
                data: error.response?.data,
                verificationId,
            });
        } else {
            logger.error('Unexpected error fetching verification details:', {
                error,
                verificationId,
            });
        }
        throw error;
    }
}

// Check if event has been processed (for idempotency)
async function checkIfEventProcessed(eventGuid: string): Promise<boolean> {
    try {
        const params = {
            TableName: SINGLE_TABLE_NAME,
            Key: {
                PK: `EVENT#${eventGuid}`,
                SK: `EVENT#${eventGuid}`,
            },
        };
        
        const result = await dynamoDb.get(params);
        return !!result.Item;
    } catch (error) {
        logger.error('Error checking processed event', { error, eventGuid });
        return false;
    }
}

// Store processed event GUID
async function storeProcessedEvent(eventGuid: string, identityVerificationId: string): Promise<void> {
    try {
        const now = new Date().toISOString();
        const ttl = Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60); // 7 days TTL
        
        const params = {
            TableName: SINGLE_TABLE_NAME,
            Item: {
                PK: `EVENT#${eventGuid}`,
                SK: `EVENT#${eventGuid}`,
                eventGuid,
                identityVerificationId,
                processedAt: now,
                ttl, // DynamoDB will auto-delete after 7 days
            },
            ConditionExpression: 'attribute_not_exists(PK)',
        };
        
        await dynamoDb.put(params);
    } catch (error) {
        if ((error as any).name === 'ConditionalCheckFailedException') {
            logger.info('Event already stored', { eventGuid });
        } else {
            logger.error('Error storing processed event', { error, eventGuid });
        }
    }
}
</file>

<file path="lambdas/cybrid/app.ts">
import * as cybrid from '@cybrid/cybrid-api-bank-typescript';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { type CreateCyCustomerResponse, logger, responseBuilder } from 'commons';
import { CybridService } from 'commons';

// Updated interface to match Cybrid's models
interface CustomerRequest {
    name: {
        first: string;
        middle?: string;
        last: string;
    };
    address: {
        street: string;
        street2?: string;
        city: string;
        subdivision: string;
        postal_code: string;
        country_code: string;
    };
    date_of_birth: string;
    email_address: string;
    phone_number: string;
    identification_numbers: {
        type: cybrid.PostIdentificationNumberBankModelTypeEnum;
        issuing_country_code: string;
        identification_number: string;
    }[];
}

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    try {
        if (!event.body) {
            return responseBuilder('Request body is required', 400);
        }

        const customerRequest: CustomerRequest = JSON.parse(event.body);
        logger.info('Customer Request:', { customerRequest });

        // Create customer request model
        const postCustomerBankModel: cybrid.PostCustomerBankModel = {
            type: cybrid.PostCustomerBankModelTypeEnum.Individual,
            name: {
                first: customerRequest.name.first,
                middle: customerRequest.name.middle,
                last: customerRequest.name.last,
            },
            address: {
                street: customerRequest.address.street,
                street2: customerRequest.address.street2,
                city: customerRequest.address.city,
                subdivision: customerRequest.address.subdivision,
                postal_code: customerRequest.address.postal_code,
                country_code: customerRequest.address.country_code,
            },
            date_of_birth: customerRequest.date_of_birth,
            email_address: customerRequest.email_address,
            phone_number: customerRequest.phone_number,
            identification_numbers: customerRequest.identification_numbers.map((id) => ({
                type: id.type,
                issuing_country_code: id.issuing_country_code,
                identification_number: id.identification_number,
            })),
        };

        // Create customer using CybridService
        const cybridService = new CybridService();
        const customer = await cybridService.createCustomer(postCustomerBankModel);
        logger.info('Customer created successfully:', { customer });

        const response: CreateCyCustomerResponse = {
            success: true,
            message: 'Customer created successfully',
            guid: customer.guid,
            state: customer.state,
        };
        logger.info('Response from cybrid customer:', { response });

        return responseBuilder(response, 201);
    } catch (error: unknown) {
        logger.error('Error creating customer:', { error });

        if (error instanceof Error) {
            return responseBuilder(
                {
                    success: false,
                    message: 'Cybrid API error',
                    error: error,
                },
                500,
            );
        }

        return responseBuilder(error instanceof Error ? error.message : 'Internal server error', 500);
    }
};
</file>

<file path="lambdas/cybrid/package.json">
{
  "name": "cybrid",
  "version": "1.0.0",
  "description": "Cybrid Lambda Functions",
  "main": "app.js",
  "author": "CLKK",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^2.11.0",
    "@aws-sdk/client-lambda": "^3.716.0",
    "@aws-sdk/lib-dynamodb": "^3.705.0",
    "@cybrid/cybrid-api-bank-typescript": "^0.123.96",
    "aws-lambda": "^1.0.7",
    "axios": "^1.7.9",
    "esbuild": "^0.14.14",
    "jsonwebtoken": "^9.0.2",
    "plaid": "^30.0.0"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "@types/aws-lambda": "^8.10.146",
    "@types/jest": "^29.2.0",
    "@types/node": "^18.11.4",
    "@typescript-eslint/eslint-plugin": "^5.10.2",
    "@typescript-eslint/parser": "^5.10.2",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.2.1",
    "prettier": "^2.5.1",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
</file>

<file path="lambdas/cybrid/processPlatformFee.ts">

</file>

<file path="lambdas/cybrid/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/dynamo-stream-processor/index.ts">
import { Context, DynamoDBStreamEvent } from 'aws-lambda';
import { Logger } from '@aws-lambda-powertools/logger';
import { APIGateway } from 'aws-sdk';
import { unmarshall } from '@aws-sdk/util-dynamodb';
import fetch from 'node-fetch';
import { SignatureV4 } from '@aws-sdk/signature-v4';
import { HttpRequest } from '@aws-sdk/protocol-http';
import { defaultProvider } from '@aws-sdk/credential-provider-node';
import { Sha256 } from '@aws-crypto/sha256-js';
import { URL } from 'url';
import { AttributeValue } from '@aws-sdk/client-dynamodb';

// Constants for DynamoDB field names
const ENTITY_FIELDS = {
    FIELD_ID: 'id',
    FIELD_TYPE: 'type',
    FIELD_EMAIL: 'email',
    FIELD_STATUS: 'status',
    FIELD_USER_INFO: 'userInfo',
    FIELD_UPDATED_AT: 'updatedAt',
};

// Constants for Checkbook DynamoDB field names
const CHECKBOOK_FIELDS = {
    API_KEY: 'checkbookKey',
    API_SECRET: 'checkbookSecret',
    CHECKBOOK_ID: 'checkbookId',
    CARD_ID: 'cardId',
    CARD_NUMBER: 'lastFourDigits',
    EXPIRATION_DATE: 'expirationDate',
    IS_DEFAULT: 'isDefault',
    USER_DATA_SK: 'CHECKBOOK#DATA',
};

// Constants for wallet field names
const WALLET_FIELDS = {
    BALANCE: 'balance',
    CURRENCY: 'currency',
    PREVIOUS_BALANCE: 'previousBalance',
    TRANSACTION_ID: 'transactionId',
    WALLET_SK_PREFIX: 'WALLET#',
};

// Constant for entity key prefixes
const ENTITY_TYPE = {
    USER: 'USER',
    BUSINESS: 'BUSINESS',
};

// Constants for table prefixes and fields
const WALLET_TABLE_PREFIX = 'wallet-';
const CHECKBOOK_TABLE_PREFIX = 'checkbook-';
const USER_TABLE_PREFIX = 'user-';
const USER_ID_FIELD = 'userId';
const USER_STATUS_FIELD = 'status';
const USER_INFO_FIELD = 'userInfo';
const WALLET_BALANCE_FIELD = 'balance';
const WALLET_CURRENCY_FIELD = 'currency';
const WALLET_PREVIOUS_BALANCE_FIELD = 'previousBalance';
const WALLET_TRANSACTION_ID_FIELD = 'transactionId';
const CHECKBOOK_CARD_INFO_FIELD = 'cardInfo';
const CHECKBOOK_ID_FIELD = 'checkbookId';
const UPDATED_AT_FIELD = 'updatedAt';

// GraphQL mutations as strings
const PUBLISH_WALLET_UPDATE = `
  mutation PublishWalletUpdate($userId: ID!, $walletData: WalletBalanceUpdateInput!) {
    publishWalletUpdate(userId: $userId, walletData: $walletData) {
      userId
      balance
      currency
      previousBalance
      transactionId
      updatedAt
    }
  }
`;

const PUBLISH_USER_UPDATE = `
  mutation PublishUserUpdate($userId: ID!, $userData: UserDataUpdateInput!) {
    publishUserUpdate(userId: $userId, userData: $userData) {
      userId
      userInfo
      status
      updatedAt
    }
  }
`;

const PUBLISH_CHECKBOOK_UPDATE = `
  mutation PublishCheckbookUpdate($userId: ID!, $checkbookData: CheckbookDataUpdateInput!) {
    publishCheckbookUpdate(userId: $userId, checkbookData: $checkbookData) {
      userId
      checkbookId
      cardInfo
      updatedAt
    }
  }
`;

// Types for AppSync mutations
interface WalletBalanceUpdateInput {
    balance: number;
    currency: string;
    previousBalance?: number;
    transactionId?: string;
    updatedAt: string;
}

interface UserInfoInput {
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    profilePictureUrl?: string;
    preferredLanguage?: string;
}

interface UserDataUpdateInput {
    userInfo?: UserInfoInput;
    status?: string;
    updatedAt: string;
}

interface CardInfoInput {
    cardId: string;
    lastFourDigits?: string;
    expirationDate?: string;
    isDefault?: boolean;
}

interface CheckbookDataUpdateInput {
    checkbookId?: string;
    cardInfo?: CardInfoInput[];
    updatedAt: string;
}

const logger = new Logger({ serviceName: 'dynamo-stream-processor' });
const APPSYNC_ENDPOINT = process.env.APPSYNC_ENDPOINT || '';
const REGION = process.env.AWS_REGION || 'us-east-1';

// Function to sign requests using IAM credentials
async function signRequest(request: HttpRequest): Promise<HttpRequest> {
    const signer = new SignatureV4({
        credentials: defaultProvider(),
        region: REGION,
        service: 'appsync',
        sha256: Sha256,
    });

    return signer.sign(request);
}

// Function to execute GraphQL mutations with IAM authentication
async function executeGraphQLMutation(mutation: string, variables: any): Promise<any> {
    if (!APPSYNC_ENDPOINT) {
        throw new Error('AppSync endpoint not configured');
    }

    const url = new URL(APPSYNC_ENDPOINT);

    // Try IAM authentication first
    try {
        // Create HTTP request for IAM auth
        const iamRequest = new HttpRequest({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Host: url.host,
            },
            hostname: url.host,
            path: url.pathname,
            body: JSON.stringify({
                query: mutation,
                variables: variables,
            }),
        });

        // Sign the request with IAM credentials
        const signedRequest = await signRequest(iamRequest);

        // Execute the request with IAM authentication
        const iamResponse = await fetch(url.toString(), {
            method: signedRequest.method,
            headers: signedRequest.headers,
            body: signedRequest.body,
        });

        if (iamResponse.ok) {
            return await iamResponse.json();
        }

        // If IAM auth failed, log the error but don't throw - we'll try API key next
        const iamErrorText = await iamResponse.text();
        logger.warn('IAM authentication failed, trying API key', {
            status: iamResponse.status,
            body: iamErrorText,
        });
    } catch (iamError) {
        // Log IAM auth error but continue to API key auth
        logger.warn('Error during IAM authentication, falling back to API key', { error: iamError });
    }

    // Fall back to API key authentication
    const apiKey = process.env.APPSYNC_API_KEY;
    if (!apiKey) {
        throw new Error('AppSync API key not configured');
    }

    // Execute the request with API key authentication
    try {
        const apiKeyResponse = await fetch(url.toString(), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
            },
            body: JSON.stringify({
                query: mutation,
                variables: variables,
            }),
        });

        if (!apiKeyResponse.ok) {
            const errorText = await apiKeyResponse.text();
            logger.error('GraphQL error with API key auth', {
                status: apiKeyResponse.status,
                body: errorText,
            });
            throw new Error(`GraphQL request failed: ${apiKeyResponse.status} ${errorText}`);
        }

        return await apiKeyResponse.json();
    } catch (error) {
        logger.error('Failed to execute GraphQL mutation', { error });
        throw error;
    }
}

// Process wallet balance changes
async function processWalletChange(newImage: Record<string, AttributeValue>, userId: string): Promise<void> {
    if (!newImage) return;

    const unmarshalled = unmarshall(newImage);

    if (!unmarshalled.balance) {
        logger.info('No wallet balance found in the record', { userId });
        return;
    }

    const walletData: WalletBalanceUpdateInput = {
        balance: Number(unmarshalled.balance),
        currency: unmarshalled.currency || 'USD',
        updatedAt: unmarshalled.updatedAt || new Date().toISOString(),
    };

    if (unmarshalled.previousBalance) {
        walletData.previousBalance = Number(unmarshalled.previousBalance);
    }

    if (unmarshalled.transactionId) {
        walletData.transactionId = unmarshalled.transactionId;
    }

    logger.info('Publishing wallet update', { userId, walletData });

    const variables = {
        userId,
        walletData,
    };

    await executeGraphQLMutation(PUBLISH_WALLET_UPDATE, variables);
}

// Process user data changes
async function processUserChange(newImage: Record<string, AttributeValue>, userId: string): Promise<void> {
    if (!newImage) return;

    const unmarshalled = unmarshall(newImage);

    if (!unmarshalled[ENTITY_FIELDS.FIELD_ID] || !unmarshalled[ENTITY_FIELDS.FIELD_TYPE]) {
        logger.info('No valid user data found in the record', { userId });
        return;
    }

    // Only process user profile changes
    if (unmarshalled.SK !== 'PROFILE') {
        return;
    }

    const userData: UserDataUpdateInput = {
        status: unmarshalled[ENTITY_FIELDS.FIELD_STATUS],
        updatedAt: unmarshalled[ENTITY_FIELDS.FIELD_UPDATED_AT] || new Date().toISOString(),
    };

    if (unmarshalled[ENTITY_FIELDS.FIELD_USER_INFO]) {
        userData.userInfo = unmarshalled[ENTITY_FIELDS.FIELD_USER_INFO] as UserInfoInput;
    }

    logger.info('Publishing user data update', { userId, userData });

    const variables = {
        userId,
        userData,
    };

    await executeGraphQLMutation(PUBLISH_USER_UPDATE, variables);
}

// Process checkbook data changes
async function processCheckbookChange(newImage: Record<string, AttributeValue>, userId: string): Promise<void> {
    if (!newImage) return;

    const unmarshalled = unmarshall(newImage);

    // Ensure we have checkbook data
    if (!unmarshalled[CHECKBOOK_FIELDS.CHECKBOOK_ID]) {
        logger.info('No checkbook ID found in the record', { userId });
        return;
    }

    const checkbookData: CheckbookDataUpdateInput = {
        checkbookId: unmarshalled[CHECKBOOK_FIELDS.CHECKBOOK_ID],
        updatedAt: unmarshalled[ENTITY_FIELDS.FIELD_UPDATED_AT] || new Date().toISOString(),
    };

    // If this is a card record, extract card info
    if (unmarshalled.SK && unmarshalled.SK.toString().startsWith('CHECKBOOK#CARD#')) {
        const cardInfo: CardInfoInput = {
            cardId: unmarshalled[CHECKBOOK_FIELDS.CARD_ID],
            lastFourDigits: unmarshalled[CHECKBOOK_FIELDS.CARD_NUMBER],
            expirationDate: unmarshalled[CHECKBOOK_FIELDS.EXPIRATION_DATE],
            isDefault: unmarshalled[CHECKBOOK_FIELDS.IS_DEFAULT],
        };

        checkbookData.cardInfo = [cardInfo];
    }

    logger.info('Publishing checkbook data update', { userId, checkbookData });

    const variables = {
        userId,
        checkbookData,
    };

    await executeGraphQLMutation(PUBLISH_CHECKBOOK_UPDATE, variables);
}

// Extract entity ID from the PK
function extractEntityId(pk: string): string {
    // PK format is typically TYPE#ID (e.g., USER#123 or BUSINESS#456)
    const parts = pk.split('#');
    if (parts.length < 2) {
        return pk;
    }
    return parts[1];
}

// Process DynamoDB Stream events
export const handler = async (event: DynamoDBStreamEvent, context: Context): Promise<void> => {
    logger.addContext(context);
    logger.info('Processing DynamoDB Stream event', { recordCount: event.Records.length });

    for (const record of event.Records) {
        try {
            // Only process INSERT and MODIFY events
            if (record.eventName !== 'INSERT' && record.eventName !== 'MODIFY') {
                continue;
            }

            const newImage = record.dynamodb?.NewImage;
            if (!newImage) {
                continue;
            }

            const keys = record.dynamodb?.Keys;
            if (!keys || !keys.PK || !keys.SK) {
                continue;
            }

            const pk = keys.PK.S || '';
            const sk = keys.SK.S || '';

            // Extract entity ID from PK
            let entityId = '';
            if (pk.startsWith(`${ENTITY_TYPE.USER}#`) || pk.startsWith(`${ENTITY_TYPE.BUSINESS}#`)) {
                entityId = extractEntityId(pk);
            } else {
                // Not an entity record we're interested in
                continue;
            }

            // Process based on sort key pattern
            if (sk === 'PROFILE') {
                // User/Business profile update
                await processUserChange(newImage, entityId);
            } else if (sk.startsWith(WALLET_FIELDS.WALLET_SK_PREFIX)) {
                // Wallet update
                await processWalletChange(newImage, entityId);
            } else if (sk === CHECKBOOK_FIELDS.USER_DATA_SK || sk.startsWith('CHECKBOOK#CARD#')) {
                // Checkbook data or card update
                await processCheckbookChange(newImage, entityId);
            }
        } catch (error) {
            logger.error('Error processing record', { error, record });
            // Continue processing other records
        }
    }

    logger.info('Finished processing DynamoDB Stream event');
};

// Query handlers for direct AppSync resolvers
export const getWalletBalance = async (event: any): Promise<any> => {
    logger.info('GetWalletBalance query', { event });
    // Implement logic to fetch wallet balance from DynamoDB
    // This is a placeholder and would need to be implemented
    return {
        userId: event.userId,
        balance: 0,
        currency: 'USD',
        updatedAt: new Date().toISOString(),
    };
};

export const getUserData = async (event: any): Promise<any> => {
    logger.info('GetUserData query', { event });
    // Implement logic to fetch user data from DynamoDB
    // This is a placeholder and would need to be implemented
    return {
        userId: event.userId,
        status: 'ACTIVE',
        updatedAt: new Date().toISOString(),
    };
};

export const getCheckbookData = async (event: any): Promise<any> => {
    logger.info('GetCheckbookData query', { event });
    // Implement logic to fetch checkbook data from DynamoDB
    // This is a placeholder and would need to be implemented
    return {
        userId: event.userId,
        checkbookId: '',
        updatedAt: new Date().toISOString(),
    };
};
</file>

<file path="lambdas/dynamo-stream-processor/package.json">
{
  "name": "dynamo-stream-processor",
  "version": "1.0.0",
  "description": "Lambda function to process DynamoDB streams and publish to AppSync",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "@aws-crypto/sha256-js": "^4.0.0",
    "@aws-lambda-powertools/logger": "^1.5.1",
    "@aws-sdk/client-dynamodb": "^3.304.0",
    "@aws-sdk/credential-provider-node": "^3.304.0",
    "@aws-sdk/protocol-http": "^3.370.0",
    "@aws-sdk/signature-v4": "^3.370.0",
    "@aws-sdk/util-dynamodb": "^3.304.0",
    "aws-sdk": "^2.1348.0",
    "graphql": "^16.6.0",
    "graphql-tag": "^2.12.6",
    "node-fetch": "^2.6.9"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.114",
    "@types/jest": "^29.5.0",
    "@types/node": "^18.15.11",
    "jest": "^29.5.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.0.3"
  }
}
</file>

<file path="lambdas/dynamo-stream-processor/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "lib": ["es2018", "esnext.asynciterable"],
        "declaration": true,
        "strict": true,
        "noImplicitAny": true,
        "strictNullChecks": true,
        "noImplicitThis": true,
        "alwaysStrict": true,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noImplicitReturns": true,
        "noFallthroughCasesInSwitch": false,
        "inlineSourceMap": true,
        "inlineSources": true,
        "experimentalDecorators": true,
        "strictPropertyInitialization": false,
        "esModuleInterop": true,
        "typeRoots": ["./node_modules/@types"],
        "outDir": "dist"
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/dynamo-updater/dynamo-updater.ts">
import { type SQSEvent } from 'aws-lambda';
import { logger } from 'commons';

import { AuthService } from '../clerk-users/services/auth/auth-service';
import { ClerkAuthProvider } from '../clerk-users/services/auth/clerk-provider';

// Ensure environment variables are set
if (!process.env.TABLE_NAME) {
    logger.warn('TABLE_NAME environment variable is not set, using default');
    process.env.TABLE_NAME = 'clkk-app-table-dev';
}

const authService = new AuthService(new ClerkAuthProvider());

export const handler = async (event: SQSEvent): Promise<void> => {
    logger.info('Processing webhook event batch', {
        recordCount: event.Records.length,
    });

    // Track failed records for error reporting
    const failedRecords: { messageId: string; error: string }[] = [];

    for (const record of event.Records) {
        try {
            // Parse the SNS message from SQS
            let snsMessage;
            try {
                snsMessage = JSON.parse(record.body);
            } catch (parseError) {
                logger.error('Failed to parse SNS message from SQS', {
                    messageId: record.messageId,
                    body: record.body.substring(0, 100) + (record.body.length > 100 ? '...' : ''),
                    error: parseError instanceof Error ? parseError.message : 'Unknown error',
                });
                failedRecords.push({
                    messageId: record.messageId,
                    error: 'Invalid SQS message format',
                });
                continue;
            }

            // Parse the actual message content
            let messageData;
            try {
                messageData = JSON.parse(snsMessage.Message);
            } catch (parseError) {
                logger.error('Failed to parse webhook data from SNS message', {
                    messageId: record.messageId,
                    snsMessage:
                        typeof snsMessage.Message === 'string'
                            ? snsMessage.Message.substring(0, 100) + (snsMessage.Message.length > 100 ? '...' : '')
                            : 'Not a string',
                    error: parseError instanceof Error ? parseError.message : 'Unknown error',
                });
                failedRecords.push({
                    messageId: record.messageId,
                    error: 'Invalid SNS message format',
                });
                continue;
            }

            // Validate webhook message
            if (!messageData || !messageData.type || !messageData.data || !messageData.data.id) {
                logger.error('Invalid webhook data structure', {
                    messageId: record.messageId,
                    hasType: !!messageData?.type,
                    hasData: !!messageData?.data,
                    hasUserId: !!messageData?.data?.id,
                });
                failedRecords.push({
                    messageId: record.messageId,
                    error: 'Invalid webhook data structure',
                });
                continue;
            }

            logger.info('Processing webhook data', {
                messageId: record.messageId,
                type: messageData.type,
                userId: messageData.data.id,
            });

            // Process the webhook event
            const success = await authService.processWebhookEvent({
                type: messageData.type,
                data: messageData.data,
            });

            if (success) {
                logger.info('Successfully processed webhook', {
                    messageId: record.messageId,
                    userId: messageData.data.id,
                });
            } else {
                logger.error('Failed to process webhook', {
                    messageId: record.messageId,
                    userId: messageData.data.id,
                });
                failedRecords.push({
                    messageId: record.messageId,
                    error: 'Processing failed',
                });
            }
        } catch (error) {
            logger.error('Unhandled error processing webhook', {
                messageId: record.messageId,
                error: error instanceof Error ? error.message : 'Unknown error',
                stack: error instanceof Error ? error.stack : undefined,
            });
            failedRecords.push({
                messageId: record.messageId,
                error: error instanceof Error ? error.message : 'Unknown error',
            });
        }
    }

    // Summarize processing results
    if (failedRecords.length > 0) {
        logger.error('Some webhook events failed processing', {
            totalRecords: event.Records.length,
            failedCount: failedRecords.length,
            failedRecords: failedRecords.length <= 5 ? failedRecords : failedRecords.slice(0, 5),
            additionalFailures: failedRecords.length > 5 ? failedRecords.length - 5 : 0,
        });

        //TODO:
        // 1. Send these failed records to a dead-letter queue
        // 2. Store them in a persistent store for later retry
        // 3. Trigger an alert
    } else {
        logger.info('All webhook events processed successfully', {
            totalRecords: event.Records.length,
        });
    }
};
</file>

<file path="lambdas/dynamo-updater/package.json">
{
    "name": "dynamo-updater",
    "version": "1.0.0",
    "description": "DynamoDB Updater Lambda",
    "main": "dynamo-updater.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0",
        "@aws-sdk/client-dynamodb": "^3.782.0",
        "@aws-sdk/util-dynamodb": "^3.782.0"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="lambdas/graphql-business-transactions/currencyService.ts">
/**
 * Currency Service - Handles all currency conversions and calculations
 *
 * This service ensures consistent handling of monetary values throughout the application.
 * All amounts are stored and processed in the smallest currency unit (cents for USD)
 * to avoid floating point precision issues.
 */
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'currency-service' });

// Currency configuration
export interface CurrencyConfig {
    code: string; // Currency code (e.g., 'USD')
    decimals: number; // Number of decimal places (e.g., 2 for USD)
    symbol: string; // Currency symbol (e.g., '$')
}

// Supported currencies and their configurations
export const CURRENCIES: Record<string, CurrencyConfig> = {
    USD: { code: 'USD', decimals: 2, symbol: '$' },
    EUR: { code: 'EUR', decimals: 2, symbol: 'â‚¬' },
    // Add other currencies as needed
};

export class CurrencyService {
    /**
     * Convert a decimal amount (dollars) to the smallest unit (cents)
     * @param amount - Amount in decimal form (e.g., 10.99)
     * @param currencyCode - Currency code (defaults to USD)
     * @returns Amount in smallest units (e.g., 1099)
     */
    public static toSmallestUnit(amount: number, currencyCode = 'USD'): number {
        const currency = CURRENCIES[currencyCode] || CURRENCIES.USD;
        const factor = Math.pow(10, currency.decimals);

        // Use Math.round to handle potential floating point issues
        const result = Math.round(amount * factor);

        logger.debug('Converted to smallest unit', {
            from: amount,
            to: result,
            currency: currencyCode,
            operation: 'toSmallestUnit',
        });

        return result;
    }

    /**
     * Convert from smallest unit (cents) to decimal amount (dollars)
     * @param amount - Amount in smallest units (e.g., 1099)
     * @param currencyCode - Currency code (defaults to USD)
     * @returns Amount in decimal form (e.g., 10.99)
     */
    public static fromSmallestUnit(amount: number, currencyCode = 'USD'): number {
        const currency = CURRENCIES[currencyCode] || CURRENCIES.USD;
        const factor = Math.pow(10, currency.decimals);

        const result = amount / factor;

        logger.debug('Converted from smallest unit', {
            from: amount,
            to: result,
            currency: currencyCode,
            operation: 'fromSmallestUnit',
        });

        return result;
    }

    /**
     * Add two monetary amounts safely
     * @param a - First amount (in smallest units)
     * @param b - Second amount (in smallest units)
     * @returns Sum (in smallest units)
     */
    public static add(a: number, b: number): number {
        return a + b;
    }

    /**
     * Subtract one monetary amount from another safely
     * @param a - First amount (in smallest units)
     * @param b - Amount to subtract (in smallest units)
     * @returns Difference (in smallest units)
     */
    public static subtract(a: number, b: number): number {
        return a - b;
    }

    /**
     * Multiply a monetary amount by a factor
     * @param amount - Amount (in smallest units)
     * @param factor - Multiplication factor
     * @returns Product (in smallest units)
     */
    public static multiply(amount: number, factor: number): number {
        return Math.round(amount * factor);
    }

    /**
     * Calculate percentage of an amount
     * @param amount - Base amount (in smallest units)
     * @param percentage - Percentage as decimal (e.g., 0.01 for 1%)
     * @returns Percentage amount (in smallest units)
     */
    public static calculatePercentage(amount: number, percentage: number): number {
        const result = Math.round(amount * percentage);

        logger.debug('Calculated percentage', {
            amount,
            percentage: percentage * 100 + '%',
            result,
            operation: 'calculatePercentage',
        });

        return result;
    }

    /**
     * Format amount for display
     * @param amount - Amount (in smallest units)
     * @param currencyCode - Currency code
     * @returns Formatted string (e.g., "$10.99")
     */
    public static format(amount: number, currencyCode = 'USD'): string {
        const currency = CURRENCIES[currencyCode] || CURRENCIES.USD;
        const decimalAmount = this.fromSmallestUnit(amount, currencyCode);

        return `${currency.symbol}${decimalAmount.toFixed(currency.decimals)}`;
    }

    /**
     * Converts dollars to cents (integer)
     * @param dollars Amount in dollars (can be decimal)
     * @returns Amount in cents as integer
     */
    static dollarsToCents(dollars: number): number {
        return Math.round(dollars * 100);
    }

    /**
     * Converts cents to dollars
     * @param cents Amount in cents (integer)
     * @returns Amount in dollars (decimal)
     */
    static centsToDollars(cents: number): number {
        return cents / 100;
    }

    /**
     * Calculates fee amount based on percentage
     * @param amount Amount in cents
     * @param feePercentage Fee percentage (e.g., 0.01 for 1%)
     * @returns Fee amount in cents
     */
    static calculateFee(amount: number, feePercentage: number): number {
        return Math.round(amount * feePercentage);
    }

    /**
     * Formats amount for display with currency symbol
     * @param amount Amount in cents
     * @param currency Currency code
     * @returns Formatted currency string
     */
    static formatCurrency(amount: number, currency: string = 'USD'): string {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency,
        }).format(this.centsToDollars(amount));
    }
}
</file>

<file path="lambdas/graphql-business-transactions/getBusinessTransaction.ts">
import { DynamoDBClient, QueryCommand } from '@aws-sdk/client-dynamodb';
import { unmarshall } from '@aws-sdk/util-dynamodb';
import { SingleTableKeys, SINGLE_TABLE_NAME } from './single-table-keys';

const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });

/**
 * Transaction interface matching GraphQL schema
 */
interface Transaction {
    userId: string;
    transactionId: string;
    type: string;
    status: string;
    amount: number;
    asset: string;
    createdAt: string;
    updatedAt: string;
    fee_processed_at?: string;
    sourceAccountId?: string;
    destinationAccountId?: string;
    quoteGuid?: string;
    paymentProviderId?: string;
    recipientId?: string;
    memo?: string;
    senderName?: string;
    senderClkktag?: string;
    recipientName?: string;
    recipientClkktag?: string;
    transferState?: string;
    recipientEntityId?: string;
    senderEntityId?: string;
    sender_entity_type?: string;
    recipient_current_email?: string;
    sender_current_email?: string;
    source_account_guid?: string;
    destination_account_guid?: string;
    recipient_cy_guid?: string;
    sender_cy_guid?: string;
    sender_name?: string;
    recipient_name?: string;
    sender_clkktag?: string;
    recipient_clkktag?: string;
    fees?: Fee;
    fee_amount?: number;
    fee_pending?: boolean;
    fee_percentage?: number;
    net_amount?: number;
}

interface Fee {
    type: string;
    rate: number;
    spread_fee: number;
    fixed_fee: number;
}

/**
 * Handler for getting a business transaction by ID
 * @param event Lambda event from AppSync
 * @returns The business transaction or null if not found
 */
export const handler = async (event: any): Promise<Transaction | null> => {
    console.log('â­ï¸ GetBusinessTransaction event:', JSON.stringify(event));

    const transactionId = event.arguments.transactionId;
    const businessId = event.arguments.businessId; // Optional: used for verification

    try {
        // Get the transaction by ID using GSI
        const params = {
            TableName: SINGLE_TABLE_NAME,
            IndexName: 'TransactionIdIndex',
            KeyConditionExpression: 'TransactionIdKey = :tid',
            ExpressionAttributeValues: {
                ':tid': { S: SingleTableKeys.gsiKeys.transactionById(transactionId).TransactionIdKey },
            },
            Limit: 1,
        };

        console.log('ðŸ” Query params:', JSON.stringify(params));

        const result = await dynamoClient.send(new QueryCommand(params));

        if (!result.Items || result.Items.length === 0) {
            console.log('Transaction not found');
            return null;
        }

        // Transform the DynamoDB item to our schema format
        const transaction = transformTransaction(result.Items[0]);

        // Optionally verify that this transaction belongs to the business
        if (businessId && transaction.recipientEntityId !== businessId) {
            console.log('Transaction does not belong to the specified business');
            return null;
        }

        return transaction;
    } catch (error) {
        console.error('Error fetching business transaction:', error);
        throw new Error(
            `Failed to fetch business transaction: ${error instanceof Error ? error.message : 'Unknown error'}`,
        );
    }
};

/**
 * Transform DynamoDB item to Transaction object
 */
const transformTransaction = (item: any): Transaction => {
    const unmarshalled = unmarshall(item);
    
    // Remove single table keys
    const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = unmarshalled;

    return {
        // Required fields
        userId: unmarshalled.userId || '',
        transactionId: unmarshalled.transactionId || '',
        type: unmarshalled.type || 'p2p_transfer',
        status: unmarshalled.status || 'pending',
        amount: parseFloat(unmarshalled.amount?.toString() || '0'),
        asset: unmarshalled.asset || 'USD',
        createdAt: unmarshalled.createdAt || new Date().toISOString(),
        updatedAt: unmarshalled.updatedAt || new Date().toISOString(),
        recipientEntityId: unmarshalled.recipientEntityId || '',
        senderEntityId: unmarshalled.senderEntityId || '',

        // Optional fields
        sourceAccountId: unmarshalled.sourceAccountId,
        destinationAccountId: unmarshalled.destinationAccountId,
        quoteGuid: unmarshalled.quoteGuid,
        paymentProviderId: unmarshalled.paymentProviderId,
        recipientId: unmarshalled.recipientId,
        memo: unmarshalled.memo,
        senderName: unmarshalled.senderName,
        senderClkktag: unmarshalled.senderClkktag,
        recipientName: unmarshalled.recipientName,
        recipientClkktag: unmarshalled.recipientClkktag,
        transferState: unmarshalled.transferState,
        sender_entity_type: unmarshalled.sender_entity_type,
        recipient_current_email: unmarshalled.recipient_current_email,
        sender_current_email: unmarshalled.sender_current_email,
        source_account_guid: unmarshalled.source_account_guid,
        destination_account_guid: unmarshalled.destination_account_guid,
        recipient_cy_guid: unmarshalled.recipient_cy_guid,
        sender_cy_guid: unmarshalled.sender_cy_guid,
        sender_name: unmarshalled.sender_name,
        recipient_name: unmarshalled.recipient_name,
        sender_clkktag: unmarshalled.sender_clkktag,
        recipient_clkktag: unmarshalled.recipient_clkktag,
        fees: unmarshalled.fees
            ? {
                  type: unmarshalled.fees.type || '',
                  rate: parseFloat(unmarshalled.fees.rate?.toString() || '0'),
                  spread_fee: parseFloat(unmarshalled.fees.spread_fee?.toString() || '0'),
                  fixed_fee: parseFloat(unmarshalled.fees.fixed_fee?.toString() || '0'),
              }
            : undefined,
        fee_amount: parseFloat(unmarshalled.fee_amount?.toString() || '0'),
        fee_pending: unmarshalled.fee_pending || false,
        fee_percentage: parseFloat(unmarshalled.fee_percentage?.toString() || '0'),
        net_amount: parseFloat(unmarshalled.net_amount?.toString() || '0'),
        fee_processed_at: unmarshalled.fee_processed_at,
    };
};
</file>

<file path="lambdas/graphql-business-transactions/getBusinessTransactions.ts">
import { DynamoDBClient, QueryCommand } from '@aws-sdk/client-dynamodb';
import { unmarshall } from '@aws-sdk/util-dynamodb';
import { SingleTableKeys, SINGLE_TABLE_NAME } from './single-table-keys';
import { CurrencyService } from './currencyService';

const client = new DynamoDBClient({ region: process.env.AWS_REGION });

/**
 * Response interface for the GetBusinessTransactions API
 */
interface GetBusinessTransactionsResponse {
    transactions: Transaction[];
    nextToken?: string;
    totalCount?: number;
}

/**
 * Transaction interface matching GraphQL schema
 */
interface Transaction {
    userId: string;
    transactionId: string;
    type: string;
    status: string;
    amount: number;
    asset: string;
    createdAt: string;
    updatedAt: string;
    sourceAccountId?: string;
    destinationAccountId?: string;
    quoteGuid?: string;
    paymentProviderId?: string;
    recipientId?: string;
    memo?: string;
    senderName?: string;
    senderClkktag?: string;
    recipientName?: string;
    recipientClkktag?: string;
    transferState?: string;
    failureCode?: string;
    returnCode?: string;
    recipientEntityId: string;
    senderEntityId: string;
    recipient_entity_type?: string;
    sender_entity_type?: string;
    recipient_current_email?: string;
    sender_current_email?: string;
    source_account_guid?: string;
    destination_account_guid?: string;
    recipient_cy_guid?: string;
    sender_cy_guid?: string;
    sender_name?: string;
    recipient_name?: string;
    sender_clkktag?: string;
    recipient_clkktag?: string;
    fees?: Fee;
    fee_amount?: number;
    fee_pending?: boolean;
    fee_percentage?: number;
    net_amount?: number;
}

interface Fee {
    type: string;
    rate: number;
    spread_fee: number;
    fixed_fee: number;
}

interface BusinessTransactionFilter {
    senderClkktag?: string;
    senderEmail?: string;
    amountGreaterThan?: number;
    amountLessThan?: number;
    transactionId?: string;
    status?: string;
    dateFrom?: string;
    dateTo?: string;
}

/**
 * Fetches business transactions with optional filtering
 * @param {string} businessId - The business entity ID
 * @param {BusinessTransactionFilter} filter - Optional filter parameters
 * @param {number} limit - Maximum number of transactions to return
 * @param {string} nextToken - Token for pagination
 * @returns {Promise<Object>} - Business transactions and next token
 */
export const handler = async (event: any) => {
    try {
        console.log('â­ï¸ GetBusinessTransactions event:', JSON.stringify(event));

        const businessId = event.arguments.businessId;
        const filter = event.arguments.filter || {};
        const limit = event.arguments.limit || 20;
        const nextToken = event.arguments.nextToken ? JSON.parse(event.arguments.nextToken) : undefined;

        // Base query parameters - query business transactions from single table
        const queryParams: any = {
            TableName: SINGLE_TABLE_NAME,
            KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
            ExpressionAttributeValues: {
                ':pk': { S: `BUSINESS#${businessId}` },
                ':skPrefix': { S: 'TXN#' },
            },
            Limit: limit,
            ScanIndexForward: false, // Most recent first
        };

        // Also prepare to query using RecipientIdIndex GSI
        const recipientQueryParams: any = {
            TableName: SINGLE_TABLE_NAME,
            IndexName: 'RecipientIdIndex',
            KeyConditionExpression: 'RecipientIdKey = :rid',
            ExpressionAttributeValues: {
                ':rid': { S: `RECIPIENT#${businessId}` },
            },
            Limit: limit,
            ScanIndexForward: false,
        };

        // Date range filters - need to apply as filter expressions since SK includes timestamp
        if (filter.dateFrom || filter.dateTo) {
            const filterExpressions = [];
            if (filter.dateFrom) {
                filterExpressions.push('createdAt >= :dateFrom');
                queryParams.ExpressionAttributeValues[':dateFrom'] = { S: filter.dateFrom };
                recipientQueryParams.ExpressionAttributeValues[':dateFrom'] = { S: filter.dateFrom };
            }
            if (filter.dateTo) {
                filterExpressions.push('createdAt <= :dateTo');
                queryParams.ExpressionAttributeValues[':dateTo'] = { S: filter.dateTo };
                recipientQueryParams.ExpressionAttributeValues[':dateTo'] = { S: filter.dateTo };
            }
            if (filterExpressions.length > 0) {
                const dateFilter = filterExpressions.join(' AND ');
                queryParams.FilterExpression = dateFilter;
                recipientQueryParams.FilterExpression = dateFilter;
            }
        }

        // Build filter expression for additional filters (non-key attributes)
        let filterExpressions: string[] = [];

        // TransactionId filter
        if (filter.transactionId) {
            filterExpressions.push('transactionId = :transactionId');
            queryParams.ExpressionAttributeValues[':transactionId'] = { S: filter.transactionId };
        }

        // Sender clkktag filter
        if (filter.senderClkktag) {
            filterExpressions.push('contains(sender_clkktag, :senderClkktag)');
            queryParams.ExpressionAttributeValues[':senderClkktag'] = { S: filter.senderClkktag };
        }

        // Sender email filter
        if (filter.senderEmail) {
            filterExpressions.push('contains(sender_current_email, :senderEmail)');
            queryParams.ExpressionAttributeValues[':senderEmail'] = { S: filter.senderEmail };
        }

        // Amount range filters
        if (filter.amountGreaterThan !== undefined) {
            // Convert dollars to cents using the existing CurrencyService utility
            const minAmountCents = CurrencyService.toSmallestUnit(filter.amountGreaterThan, 'USD');
            filterExpressions.push('amount >= :minAmount');
            queryParams.ExpressionAttributeValues[':minAmount'] = { N: minAmountCents.toString() };
        }

        if (filter.amountLessThan !== undefined) {
            // Convert dollars to cents using the existing CurrencyService utility
            const maxAmountCents = CurrencyService.toSmallestUnit(filter.amountLessThan, 'USD');
            filterExpressions.push('amount <= :maxAmount');
            queryParams.ExpressionAttributeValues[':maxAmount'] = { N: maxAmountCents.toString() };
        }

        // Status filter
        if (filter.status) {
            filterExpressions.push('status = :status');
            queryParams.ExpressionAttributeValues[':status'] = { S: filter.status };
        }

        // Combine filter expressions if any exist
        if (filterExpressions.length > 0) {
            const additionalFilters = filterExpressions.join(' AND ');
            if (queryParams.FilterExpression) {
                queryParams.FilterExpression += ' AND ' + additionalFilters;
                recipientQueryParams.FilterExpression += ' AND ' + additionalFilters;
            } else {
                queryParams.FilterExpression = additionalFilters;
                recipientQueryParams.FilterExpression = additionalFilters;
            }
        }

        console.log('ðŸ” Query params:', JSON.stringify(queryParams));

        // Execute both queries in parallel
        const [directResults, recipientResults] = await Promise.all([
            client.send(new QueryCommand(queryParams)),
            client.send(new QueryCommand(recipientQueryParams))
        ]);

        // Combine and deduplicate results
        const transactionMap = new Map();
        
        [...(directResults.Items || []), ...(recipientResults.Items || [])].forEach(item => {
            const unmarshalledItem = unmarshall(item);
            // Remove single table keys before adding to map
            const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = unmarshalledItem;
            if (transaction.transactionId && !transactionMap.has(transaction.transactionId)) {
                transactionMap.set(transaction.transactionId, transaction);
            }
        });

        // Convert to array and sort by date
        const transactions = Array.from(transactionMap.values())
            .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
            .slice(0, limit);

        // Prepare pagination token if more results exist
        const responseNextToken = result.LastEvaluatedKey ? JSON.stringify(result.LastEvaluatedKey) : null;

        console.log('ðŸ” Transactions:', JSON.stringify(transactions));

        return {
            items: transactions,
            nextToken: responseNextToken,
        };
    } catch (error) {
        console.error('Error fetching business transactions:', error);
        throw new Error(
            `Failed to fetch business transactions: ${error instanceof Error ? error.message : 'Unknown error'}`,
        );
    }
};

/**
 * Transform DynamoDB item to Transaction object
 */
const transformTransaction = (item: any): Transaction => {
    const unmarshalled = unmarshall(item);

    return {
        // Required fields
        userId: unmarshalled.userId || '',
        transactionId: unmarshalled.transactionId || '',
        type: unmarshalled.type || 'p2p_transfer',
        status: unmarshalled.status || 'pending',
        amount: parseFloat(unmarshalled.amount?.toString() || '0'),
        asset: unmarshalled.asset || 'USD',
        createdAt: unmarshalled.createdAt || new Date().toISOString(),
        updatedAt: unmarshalled.updatedAt || new Date().toISOString(),
        recipientEntityId: unmarshalled.recipientEntityId || '',
        senderEntityId: unmarshalled.senderEntityId || '',

        // Optional fields
        sourceAccountId: unmarshalled.sourceAccountId,
        destinationAccountId: unmarshalled.destinationAccountId,
        quoteGuid: unmarshalled.quoteGuid,
        paymentProviderId: unmarshalled.paymentProviderId,
        recipientId: unmarshalled.recipientId,
        memo: unmarshalled.memo,
        senderName: unmarshalled.senderName,
        senderClkktag: unmarshalled.senderClkktag,
        recipientName: unmarshalled.recipientName,
        recipientClkktag: unmarshalled.recipientClkktag,
        transferState: unmarshalled.transferState,
        failureCode: unmarshalled.failureCode,
        returnCode: unmarshalled.returnCode,
        recipient_entity_type: unmarshalled.recipient_entity_type,
        sender_entity_type: unmarshalled.sender_entity_type,
        recipient_current_email: unmarshalled.recipient_current_email,
        sender_current_email: unmarshalled.sender_current_email,
        source_account_guid: unmarshalled.source_account_guid,
        destination_account_guid: unmarshalled.destination_account_guid,
        recipient_cy_guid: unmarshalled.recipient_cy_guid,
        sender_cy_guid: unmarshalled.sender_cy_guid,
        sender_name: unmarshalled.sender_name,
        recipient_name: unmarshalled.recipient_name,
        sender_clkktag: unmarshalled.sender_clkktag,
        recipient_clkktag: unmarshalled.recipient_clkktag,
        fees: unmarshalled.fees
            ? {
                  type: unmarshalled.fees.type || '',
                  rate: parseFloat(unmarshalled.fees.rate?.toString() || '0'),
                  spread_fee: parseFloat(unmarshalled.fees.spread_fee?.toString() || '0'),
                  fixed_fee: parseFloat(unmarshalled.fees.fixed_fee?.toString() || '0'),
              }
            : undefined,
        fee_amount: parseFloat(unmarshalled.fee_amount?.toString() || '0'),
        fee_pending: unmarshalled.fee_pending || false,
        fee_percentage: parseFloat(unmarshalled.fee_percentage?.toString() || '0'),
        net_amount: parseFloat(unmarshalled.net_amount?.toString() || '0'),
    };
};
</file>

<file path="lambdas/graphql-business-transactions/index.ts">
import { handler as getBusinessTransactionsHandler } from './getBusinessTransactions';
import { handler as getBusinessTransactionHandler } from './getBusinessTransaction';

/**
 * Main handler that routes requests based on field name
 */
export const handler = async (event: any) => {
    console.log('ðŸš€ Business API Event:', JSON.stringify(event));

    // Route based on the field name
    switch (event.field) {
        case 'getBusinessTransactions':
            return getBusinessTransactionsHandler(event);
        case 'getBusinessTransaction':
            return getBusinessTransactionHandler(event);
        default:
            throw new Error(`Unknown field: ${event.field}`);
    }
};
</file>

<file path="lambdas/graphql-business-transactions/package.json">
{
    "name": "user-notifications",
    "version": "1.0.0",
    "description": "User Notifications Lambda",
    "main": "user-notifications.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-sdk/client-dynamodb": "^3.755.0",
        "@aws-sdk/util-dynamodb": "^3.755.0",
        "@aws-lambda-powertools/logger": "^2.11.0"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "axios": "^1.7.9",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="lambdas/graphql-business-transactions/single-table-keys.ts">
/**
 * Helper functions for generating keys for the single table design
 */

export const SingleTableKeys = {
    // User/Entity keys
    user: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PROFILE`,
    }),

    // Cybrid Fiat Account keys
    cybridFiatAccount: (userId: string, accountId: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_FIAT#${accountId}`,
    }),

    // Cybrid Identity Verification keys
    cybridIdentityVerification: (userId: string, verificationId: string, timestamp: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_KYC#${timestamp}#${verificationId}`,
    }),

    // Plaid Access Token keys
    plaidAccessToken: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PLAID_TOKEN`,
    }),

    // Transaction keys
    transaction: (userId: string, timestamp: string, transactionId: string) => ({
        PK: `USER#${userId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Transaction keys for business accounts
    businessTransaction: (businessId: string, timestamp: string, transactionId: string) => ({
        PK: `BUSINESS#${businessId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Query patterns for GSIs
    gsiKeys: {
        // For querying by Cybrid customer ID (using ExternalIdIndex)
        byCybridCustomerId: (customerId: string) => ({
            ExternalIdKey: `CYBRID_CUSTOMER#${customerId}`,
            ProviderIdKey: 'CYBRID',
        }),

        // For querying fiat accounts by customer ID
        fiatAccountByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_FIAT_ACCOUNT',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For KYC status queries
        byKycStatus: (status: string, userId: string) => ({
            KYCStatusKey: `STATUS#${status}`,
            EntityTypeIdKey: `USER#${userId}`,
        }),

        // For identity verifications by customer ID
        identityVerificationByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_IDENTITY_VERIFICATION',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For transaction lookups by ID
        transactionById: (transactionId: string) => ({
            TransactionIdKey: `TXN#${transactionId}`,
        }),

        // For querying transactions by sender
        transactionsBySender: (senderId: string) => ({
            SenderIdKey: `SENDER#${senderId}`,
        }),

        // For querying transactions by recipient
        transactionsByRecipient: (recipientId: string) => ({
            RecipientIdKey: `RECIPIENT#${recipientId}`,
        }),
    },
};

// Single table name constant
export const SINGLE_TABLE_NAME = process.env.SINGLE_TABLE_NAME || 'clkk-app-table-dev';
</file>

<file path="lambdas/graphql-business-transactions/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/graphql-financial-data/index.ts">
import { DynamoDBClient, BatchGetItemCommand, QueryCommand, GetItemCommand } from '@aws-sdk/client-dynamodb';
import { DYNAMO_TABLES } from 'commons';
import { SingleTableKeys, SINGLE_TABLE_NAME } from './single-table-keys';
const client = new DynamoDBClient({ region: process.env.AWS_REGION });

interface FinancialDataResult {
    userProfile: UserProfile;
    cybridBalances: CybridBalance[];
    plaidAccounts: PlaidAccount[];
    recentTransactions: Transaction[];
    preferences: UserPreferences;
}

interface UserProfile {
    userId: string;
    name: string;
    email: string;
    kycStatus: string;
    accountState: string;
    createdAt: string;
    firstName: string;
    lastName: string;
    phoneNumber: string;
    profileImageUrl: string;
    clkkTag: string;
    updatedAt: string;
}

interface CybridBalance {
    accountId: string;
    balance: number;
    asset: string;
    name: string;
    customerId: string;
    state: string;
    createdAt: string;
    updatedAt: string;
}

interface PlaidAccount {
    id: string;
    mask: string;
    name: string;
    type: string;
    subtype: string;
    verificationStatus: string;
    institutionName: string;
}

interface Transaction {
    transactionId: string;
    senderId: string;
    requestType: string;
    senderName: string;
    senderClkktag: string;
    recipientId: string;
    recipientName: string;
    recipientClkktag: string;
    amount: number;
    asset: string;
    status: string;
    memo: string;
    createdAt: string;
    updatedAt: string;
}

interface UserPreferences {
    notificationSettings: NotificationSettings;
    displaySettings: DisplaySettings;
    deviceTokens: DeviceToken[];
}

interface NotificationSettings {
    emailEnabled: boolean;
    pushEnabled: boolean;
    smsEnabled: boolean;
}

interface DisplaySettings {
    theme: string;
    language: string;
    currency: string;
}

interface DeviceToken {
    token: string;
    platform: string;
    updatedAt: string;
}

const queryCybridAccounts = async (userId: string) => {
    // Query all Cybrid fiat accounts for this user using begins_with on SK
    const params = {
        TableName: SINGLE_TABLE_NAME,
        KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
        ExpressionAttributeValues: {
            ':pk': { S: `USER#${userId}` },
            ':skPrefix': { S: 'CYBRID_FIAT#' },
        },
    };

    const result = await client.send(new QueryCommand(params));
    console.log('cybridAccounts', result.Items);
    return result.Items || [];
};

const getEntity = async (userId: string) => {
    const keys = SingleTableKeys.user(userId);
    const params = {
        TableName: SINGLE_TABLE_NAME,
        Key: {
            PK: { S: keys.PK },
            SK: { S: keys.SK },
        },
    };

    const result = await client.send(new GetItemCommand(params));
    console.log('entity', result.Item);
    return result.Item;
};

const queryBankVerificationStatus = async (userId: string): Promise<string> => {
    try {
        console.log('Querying bank verification status for user:', userId);

        // Query for CYBRID_KYC records with source "plaid"
        const params = {
            TableName: SINGLE_TABLE_NAME,
            KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
            ExpressionAttributeValues: {
                ':pk': { S: `USER#${userId}` },
                ':skPrefix': { S: 'CYBRID_KYC#' },
            },
            ScanIndexForward: false, // Get most recent first
        };

        const response = await client.send(new QueryCommand(params));
        const verifications = response.Items || [];

        console.log('Found verification records:', verifications.length);

        // Find the most recent bank verification (source = "plaid")
        const bankVerification = verifications.find(item => 
            item.source?.S === 'plaid' && 
            item.status?.S === 'completed'
        );

        if (bankVerification) {
            console.log('Found bank verification:', {
                status: bankVerification.status?.S,
                outcome: bankVerification.outcome?.S,
                source: bankVerification.source?.S,
            });

            // Map the outcome to a user-friendly status
            if (bankVerification.outcome?.S === 'passed') {
                return 'verified';
            } else if (bankVerification.outcome?.S === 'failed') {
                return 'failed';
            } else if (bankVerification.status?.S === 'waiting' || bankVerification.status?.S === 'pending') {
                return 'pending';
            }
        }

        return 'unverified';
    } catch (error) {
        console.error('Error querying bank verification status:', error);
        return 'unknown';
    }
};

const queryRecentTransactions = async (userId: string, limit: number = 10) => {
    console.log('Querying transactions for userId:', userId);

    try {
        // Query all transactions for this user from single table
        const params = {
            TableName: SINGLE_TABLE_NAME,
            KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
            ExpressionAttributeValues: {
                ':pk': { S: `USER#${userId}` },
                ':skPrefix': { S: 'TXN#' },
            },
            ScanIndexForward: false, // Newest first
            Limit: limit,
        };

        const result = await client.send(new QueryCommand(params));
        console.log('User transactions from single table:', result.Items?.length || 0);
        
        // Also need to query transactions where user is involved using GSI
        const entityRoleParams = {
            TableName: SINGLE_TABLE_NAME,
            IndexName: 'EntityRoleTransactionIndex',
            KeyConditionExpression: 'EntityRoleKey = :erk',
            ExpressionAttributeValues: {
                ':erk': { S: `USER#${userId}` },
            },
            ScanIndexForward: false,
            Limit: limit,
        };

        const receiverRoleParams = {
            TableName: SINGLE_TABLE_NAME,
            IndexName: 'ReceiverRoleTransactionIndex',
            KeyConditionExpression: 'ReceiverRoleKey = :rrk',
            ExpressionAttributeValues: {
                ':rrk': { S: `USER#${userId}` },
            },
            ScanIndexForward: false,
            Limit: limit,
        };

        // Execute all queries in parallel
        const [userTxnResults, entityRoleResults, receiverRoleResults] = await Promise.all([
            client.send(new QueryCommand(params)),
            client.send(new QueryCommand(entityRoleParams)),
            client.send(new QueryCommand(receiverRoleParams)),
        ]);

        // Create a Map to deduplicate transactions by transactionId
        const transactionMap = new Map();

        // Process all transaction results and add to map (deduplicating by transactionId)
        [
            ...(userTxnResults.Items || []),
            ...(entityRoleResults.Items || []),
            ...(receiverRoleResults.Items || []),
        ].forEach((item) => {
            const transactionId = item.transactionId?.S;
            if (transactionId && !transactionMap.has(transactionId)) {
                transactionMap.set(transactionId, item);
            }
        });

        // Convert map values back to array and sort
        const uniqueTransactions = Array.from(transactionMap.values())
            .sort((a, b) => {
                const dateA = new Date(a.createdAt?.S || '').getTime();
                const dateB = new Date(b.createdAt?.S || '').getTime();
                return dateB - dateA; // Sort descending (newest first)
            })
            .slice(0, limit); // Limit to requested number

        console.log('Combined transactions count (after deduplication/sort/limit):', uniqueTransactions.length);
        return uniqueTransactions;
    } catch (error) {
        console.error('Error querying transactions:', error);
        return [];
    }
};

export const handler = async (event: any): Promise<FinancialDataResult> => {
    try {
        const userId = event.arguments.userId;
        const limit = event.arguments.limit || 10;

        console.log('â­ï¸ GraphQL request:', JSON.stringify(event));

        const [userEntity, cybridAccounts, recentTransactions, bankVerificationStatus] = await Promise.all([
            getEntity(userId),
            queryCybridAccounts(userId),
            queryRecentTransactions(userId, limit),
            queryBankVerificationStatus(userId),
        ]);

        console.log('â­ï¸ Raw user entity:', JSON.stringify(userEntity));
        console.log('â­ï¸ Bank verification status:', bankVerificationStatus);

        const result = {
            userProfile: transformUserProfile(userEntity),
            cybridBalances: transformCybridBalances(cybridAccounts),
            plaidAccounts: transformPlaidAccounts(userEntity?.plaid, bankVerificationStatus),
            recentTransactions: transformTransactions(recentTransactions, userId),
            preferences: transformPreferences(userEntity),
        };

        console.log('â­ï¸ Final result:', JSON.stringify(result));
        return result;
    } catch (error) {
        console.error('Error fetching financial data:', error);
        throw new Error('Failed to retrieve financial data');
    }
};

const transformUserProfile = (item: any): UserProfile => {
    if (!item) {
        return {
            userId: '',
            email: '',
            firstName: '',
            lastName: '',
            phoneNumber: '',
            kycStatus: 'pending',
            accountState: 'unknown',
            profileImageUrl: '',
            clkkTag: '',
            createdAt: '',
            updatedAt: '',
            name: '',
        };
    }
    return {
        userId: item.entityId?.S || '',
        email: item.email?.S || '',
        firstName: item.firstName?.S || '',
        lastName: item.lastName?.S || '',
        phoneNumber: item.phoneNumber?.S || '',
        kycStatus: item.kyc?.M?.status?.S || 'pending',
        accountState: item.metadata?.M?.cybrid?.M?.customerData?.M?.state?.S || 'unknown',
        profileImageUrl: item.profileImageUrl?.S || '',
        clkkTag: item.clkktag?.S || '',
        createdAt: item.createdAt?.S || '',
        updatedAt: item.updatedAt?.S || '',
        name: `${item.firstName?.S || ''} ${item.lastName?.S || ''}`.trim(),
    };
};

const transformCybridBalances = (items: any[]): CybridBalance[] =>
    items.map((item) => ({
        accountId: item.accountId?.S || '',
        name: item.name?.S || '',
        balance: parseFloat(item.balance?.N || '0'),
        asset: item.asset?.S || 'USD',
        state: item.state?.S || 'unknown',
        customerId: item.customerId?.S || '',
        createdAt: item.createdAt?.S || '',
        updatedAt: item.updatedAt?.S || '',
    }));

const transformPlaidAccounts = (plaidData: any, bankVerificationStatus: string): PlaidAccount[] => {
    if (!plaidData?.M?.metadata?.M?.accounts?.L) return [];

    return plaidData.M.metadata.M.accounts.L.map((account: any) => ({
        id: account.M.id?.S || '',
        mask: account.M.mask?.S || '',
        name: account.M.name?.S || '',
        type: account.M.type?.S || '',
        subtype: account.M.subtype?.S || '',
        verificationStatus: bankVerificationStatus,
        institutionName: plaidData.M.metadata.M.institution?.M?.name?.S || '',
    }));
};

const transformTransactions = (items: any[], userId: string): Transaction[] =>
    items.map((item) => {
        // Determine if current user is sender or recipient
        const isSender = item.sender_entity_guid?.S === userId || item.senderEntityId?.S === userId;
        const isDeposit = item.type?.S === 'deposit';
        const isWithdrawal = item.type?.S === 'withdrawal';

        // Handle memo with proper precedence
        let memo = item.memo?.S || '';
        if (memo === '' && isDeposit) {
            memo = 'Deposit from bank account';
        } else if (memo === '' && isWithdrawal) {
            memo = 'Withdrawal to bank account';
        }

        return {
            transactionId: item.transactionId?.S || '',
            senderId: item.sender_entity_guid?.S || item.senderEntityId?.S || '',
            recipientId: item.recipient_entity_guid?.S || '',
            // Set request type based on transaction type and user's role
            requestType: isDeposit ? 'deposit' : isWithdrawal ? 'withdrawal' : isSender ? 'sent' : 'received',
            amount: parseFloat(item.amount?.N || '0'),
            asset: item.asset?.S || 'USD',
            status: item.status?.S || '',
            recipientName: item.recipient_name?.S || '',
            recipientClkktag: item.recipient_clkktag?.S || '',
            senderName: item.sender_name?.S || '',
            senderClkktag: item.sender_clkktag?.S || '',
            memo: memo,
            createdAt: item.createdAt?.S || '',
            updatedAt: item.updatedAt?.S || '',
        };
    });

const transformPreferences = (item: any): UserPreferences => {
    console.log('â­ï¸ Begin transforming preferences');
    console.log('â­ï¸ Raw item:', JSON.stringify(item));
    console.log('â­ï¸ Raw preferences:', JSON.stringify(item?.preferences));

    // Set default preferences
    const defaultPreferences = {
        notificationSettings: {
            emailEnabled: true,
            pushEnabled: true,
            smsEnabled: false,
        },
        displaySettings: {
            theme: 'dark',
            language: 'en',
            currency: 'USD',
        },
        deviceTokens: [],
    };

    // If no preferences exist, return defaults
    if (!item?.preferences?.M) {
        console.log('â­ï¸ No preferences found, returning defaults');
        return defaultPreferences;
    }

    try {
        // Extract and transform device tokens
        const deviceTokensArray = [];
        if (item.preferences.M.deviceTokens?.L && Array.isArray(item.preferences.M.deviceTokens.L)) {
            console.log('â­ï¸ Found device tokens array with length:', item.preferences.M.deviceTokens.L.length);

            for (const tokenItem of item.preferences.M.deviceTokens.L) {
                console.log('â­ï¸ Processing token item:', JSON.stringify(tokenItem));

                if (tokenItem.M && tokenItem.M.token?.S) {
                    const token = {
                        token: tokenItem.M.token.S,
                        platform: tokenItem.M.platform?.S || 'unknown',
                        updatedAt: tokenItem.M.updatedAt?.S || new Date().toISOString(),
                    };
                    console.log('â­ï¸ Adding token:', JSON.stringify(token));
                    deviceTokensArray.push(token);
                }
            }
        } else {
            console.log('â­ï¸ No device tokens found in preferences');
        }

        console.log('â­ï¸ Transformed device tokens:', JSON.stringify(deviceTokensArray));

        // Extract notification settings with defaults
        const notificationSettings = {
            emailEnabled:
                item.preferences.M.notificationSettings?.M?.emailEnabled?.BOOL ??
                defaultPreferences.notificationSettings.emailEnabled,
            pushEnabled:
                item.preferences.M.notificationSettings?.M?.pushEnabled?.BOOL ??
                defaultPreferences.notificationSettings.pushEnabled,
            smsEnabled:
                item.preferences.M.notificationSettings?.M?.smsEnabled?.BOOL ??
                defaultPreferences.notificationSettings.smsEnabled,
        };
        console.log('â­ï¸ Transformed notification settings:', JSON.stringify(notificationSettings));

        // Extract display settings with defaults
        const displaySettings = {
            theme: item.preferences.M.displaySettings?.M?.theme?.S || defaultPreferences.displaySettings.theme,
            language: item.preferences.M.displaySettings?.M?.language?.S || defaultPreferences.displaySettings.language,
            currency: item.preferences.M.displaySettings?.M?.currency?.S || defaultPreferences.displaySettings.currency,
        };
        console.log('â­ï¸ Transformed display settings:', JSON.stringify(displaySettings));

        // Construct final preferences object
        const result = {
            notificationSettings: notificationSettings,
            displaySettings: displaySettings,
            deviceTokens: deviceTokensArray,
        };

        console.log('â­ï¸ Final preferences object:', JSON.stringify(result));
        return result;
    } catch (error) {
        console.error('â­ï¸ Error transforming preferences:', error);
        return defaultPreferences;
    }
};
</file>

<file path="lambdas/graphql-financial-data/package.json">
{
    "name": "user-notifications",
    "version": "1.0.0",
    "description": "User Notifications Lambda",
    "main": "user-notifications.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-sdk/client-dynamodb": "^3.755.0",
        "@aws-sdk/util-dynamodb": "^3.755.0",
        "@aws-lambda-powertools/logger": "^2.11.0"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "axios": "^1.7.9",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="lambdas/graphql-financial-data/single-table-keys.ts">
/**
 * Helper functions for generating keys for the single table design
 */

export const SingleTableKeys = {
    // User/Entity keys
    user: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PROFILE`,
    }),

    // Cybrid Fiat Account keys
    cybridFiatAccount: (userId: string, accountId: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_FIAT#${accountId}`,
    }),

    // Cybrid Identity Verification keys
    cybridIdentityVerification: (userId: string, verificationId: string, timestamp: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_KYC#${timestamp}#${verificationId}`,
    }),

    // Plaid Access Token keys
    plaidAccessToken: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PLAID_TOKEN`,
    }),

    // Transaction keys
    transaction: (userId: string, timestamp: string, transactionId: string) => ({
        PK: `USER#${userId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Transaction keys for business accounts
    businessTransaction: (businessId: string, timestamp: string, transactionId: string) => ({
        PK: `BUSINESS#${businessId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Query patterns for GSIs
    gsiKeys: {
        // For querying by Cybrid customer ID (using ExternalIdIndex)
        byCybridCustomerId: (customerId: string) => ({
            ExternalIdKey: `CYBRID_CUSTOMER#${customerId}`,
            ProviderIdKey: 'CYBRID',
        }),

        // For querying fiat accounts by customer ID
        fiatAccountByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_FIAT_ACCOUNT',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For KYC status queries
        byKycStatus: (status: string, userId: string) => ({
            KYCStatusKey: `STATUS#${status}`,
            EntityTypeIdKey: `USER#${userId}`,
        }),

        // For identity verifications by customer ID
        identityVerificationByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_IDENTITY_VERIFICATION',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For transaction lookups by ID
        transactionById: (transactionId: string) => ({
            TransactionIdKey: `TXN#${transactionId}`,
        }),

        // For querying transactions by sender
        transactionsBySender: (senderId: string) => ({
            SenderIdKey: `SENDER#${senderId}`,
        }),

        // For querying transactions by recipient
        transactionsByRecipient: (recipientId: string) => ({
            RecipientIdKey: `RECIPIENT#${recipientId}`,
        }),
    },
};

// Single table name constant
export const SINGLE_TABLE_NAME = process.env.SINGLE_TABLE_NAME || 'clkk-app-table-dev';
</file>

<file path="lambdas/graphql-financial-data/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/nmi/config/index.ts">
/**
 * NMI configuration exports
 */

export * from './paths';
export { default as nmiPaths } from './paths';
</file>

<file path="lambdas/nmi/config/paths.ts">
/**
 * NMI API path configurations
 * Centralizes all NMI endpoint paths for reuse across the application
 */

import { ENVIRONMENT } from '../../../layers/commons/utils/config';

/**
 * Base URLs for different NMI APIs
 */
export const NMI_BASE_URLS = {
    /** Main NMI Gateway API base URL */
    GATEWAY: process.env.NMI_API_URL || 'https://rytepay.transactiongateway.com/api',
    /** Card Type API base URL */
    CARD_TYPE: process.env.NMI_MAIN_API_URL || 'https://secure.nmi.com/api/v4',
};

/**
 * NMI API endpoint paths
 */
export const NMI_ENDPOINTS = {
    /** Transaction processing endpoint */
    TRANSACTION: 'transact.php',
    /** Query transactions endpoint */
    QUERY: 'query.php',
    /** Card type endpoint */
    CARD_TYPE: 'card_type',
};

/**
 * Complete API URLs with endpoints
 */
export const NMI_API_URLS = {
    /** Transaction processing full URL */
    TRANSACTION: `${NMI_BASE_URLS.GATEWAY}/${NMI_ENDPOINTS.TRANSACTION}`,
    /** Query transactions full URL */
    QUERY: `${NMI_BASE_URLS.GATEWAY}/${NMI_ENDPOINTS.QUERY}`,
    /** Card type check URL */
    CARD_TYPE: `${NMI_BASE_URLS.CARD_TYPE}/${NMI_ENDPOINTS.CARD_TYPE}`,
};

/**
 * Auth prefixes for different NMI API versions
 */
export const NMI_AUTH_PREFIXES = {
    /** V4 private API key prefix */
    V4_PRIVATE: 'v4_private_',
};

/**
 * Feature flags and configuration for NMI services
 */
export const NMI_FEATURES = {
    /** Card type validation configuration */
    CARD_TYPE_VALIDATION: {
        /** Whether card type validation is enabled */
        ENABLED: ENVIRONMENT !== 'dev', // Only enable in non-dev environments
        /** Card types allowed for transactions */
        ALLOWED_TYPES: ['debit'],
        /** Skip validation in case of errors */
        FAIL_OPEN: true,
    },
};

export default {
    NMI_BASE_URLS,
    NMI_ENDPOINTS,
    NMI_API_URLS,
    NMI_AUTH_PREFIXES,
    NMI_FEATURES,
};
</file>

<file path="lambdas/nmi/handlers/config/index.ts">
/**
 * NMI configuration exports
 */

export * from './paths';
export { default as nmiPaths } from './paths';
</file>

<file path="lambdas/nmi/handlers/config/paths.ts">
/**
 * NMI API path configurations
 * Centralizes all NMI endpoint paths for reuse across the application
 */

import { ENVIRONMENT } from 'commons/utils/config';

/**
 * Base URLs for different NMI APIs
 */
export const NMI_BASE_URLS = {
    /** Main NMI Gateway API base URL */
    GATEWAY: process.env.NMI_API_URL || 'https://rytepay.transactiongateway.com/api',
    /** Card Type API base URL */
    CARD_TYPE: process.env.NMI_MAIN_API_URL || 'https://secure.nmi.com/api/v4',
};

/**
 * NMI API endpoint paths
 */
export const NMI_ENDPOINTS = {
    /** Transaction processing endpoint */
    TRANSACTION: 'transact.php',
    /** Query transactions endpoint */
    QUERY: 'query.php',
    /** Card type endpoint */
    CARD_TYPE: 'card_type',
};

/**
 * Complete API URLs with endpoints
 */
export const NMI_API_URLS = {
    /** Transaction processing full URL */
    TRANSACTION: `${NMI_BASE_URLS.GATEWAY}/${NMI_ENDPOINTS.TRANSACTION}`,
    /** Query transactions full URL */
    QUERY: `${NMI_BASE_URLS.GATEWAY}/${NMI_ENDPOINTS.QUERY}`,
    /** Card type check URL */
    CARD_TYPE: `${NMI_BASE_URLS.CARD_TYPE}/${NMI_ENDPOINTS.CARD_TYPE}`,
};

/**
 * Auth prefixes for different NMI API versions
 */
export const NMI_AUTH_PREFIXES = {
    /** V4 private API key prefix */
    V4_PRIVATE: 'v4_private_',
};

/**
 * Feature flags and configuration for NMI services
 */
export const NMI_FEATURES = {
    /** Card type validation configuration */
    CARD_TYPE_VALIDATION: {
        /** Whether card type validation is enabled */
        ENABLED: ENVIRONMENT !== 'dev', // Only enable in non-dev environments
        /** Card types allowed for transactions */
        ALLOWED_TYPES: ['debit'],
        /** Skip validation in case of errors */
        FAIL_OPEN: true,
    },
};

export default {
    NMI_BASE_URLS,
    NMI_ENDPOINTS,
    NMI_API_URLS,
    NMI_AUTH_PREFIXES,
    NMI_FEATURES,
};
</file>

<file path="lambdas/nmi/handlers/services/nmi-service.ts">
import { createLogger } from 'commons/utils/logger_v2';
import { KmsService } from 'commons/services/KmsService';
import { XMLParser } from 'fast-xml-parser';
import { EntityTypeString } from 'commons/data/entities/entity';
import {
    NmiCustomer,
    createNmiCustomer,
    listNmiCustomersByEntity,
    getNmiCustomerByVaultId,
} from 'commons/services/nmi/nmi-customer';
import {
    AuthorizationRequest,
    CaptureRequest,
    TransactionResponse,
    PaymentResponse,
    TransactionRecord,
    ResponseCode,
    ResultCode,
    NmiTransactionType,
    QueryTransactionRequest,
    QueryTransactionResponse,
    CardTypeCheckResponse,
    CustomerVaultRequest,
    CustomerVaultResponse,
} from '../types/nmi';
import { URLSearchParams } from 'url';
import { TransactionType, TransactionStatus, TransactionService, Transaction } from 'commons/data/entities/transaction';
import { Money } from 'commons/data/entities/money';
import { WalletService, CurrencyCode } from 'commons/data/entities/wallet';
import { NMI_ENDPOINTS, NMI_API_URLS, NMI_AUTH_PREFIXES, NMI_FEATURES } from '../config';
import { UnifiedTransactionService } from '../../../webhooks/services/unified-transaction-service';
import { 
    CreateTransactionInput, 
    UnifiedTransaction, 
    EntityType, 
    PaymentProvider,
    TransactionType as UnifiedTransactionType,
    TransactionStatus as UnifiedTransactionStatus 
} from '../../../webhooks/types/transaction.types';

/**
 * Configuration for NMI payment gateway
 */
interface NmiConfig {
    /** API endpoint for NMI transactions */
    apiUrl: string;
    /** Security key for NMI authentication */
    securityKey: string;
    /** Timeout for API requests in milliseconds */
    timeout: number;
}

/**
 * Service class for handling NMI payment gateway operations
 */
export class NmiService {
    private logger = createLogger('NmiService');
    private kmsService: KmsService;
    private config: NmiConfig;

    /**
     * Initialize the NMI Service
     * @param kmsService - KMS service for data encryption
     * @param config - Configuration for NMI gateway
     */
    constructor(kmsService: KmsService, config: NmiConfig) {
        this.kmsService = kmsService;
        this.config = config;
    }

    /**
     * Health check endpoint
     * @returns Success response
     */
    async getEchoEndpoint(): Promise<{ message: string; success: boolean }> {
        this.logger.info('Executing NMI echo endpoint');
        return {
            message: 'ok',
            success: true,
        };
    }

    /**
     * Direct method to handle wallet-to-wallet transfers without going through NMI
     * @param entityId - Sender's ID
     * @param request - Transfer request parameters
     * @param transactionType - Must be P2P or P2B
     * @param options - Additional options for transaction processing
     * @returns Payment response
     */
    async handleWalletTransfer(
        entityId: string,
        request: { amount: string },
        transactionType: TransactionType.P2P | TransactionType.P2B,
        options: {
            recipientEntityId: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        },
    ): Promise<PaymentResponse> {
        if (!options.recipientEntityId) {
            return {
                success: false,
                message: 'Recipient ID is required for wallet transfers',
                status: 'failed',
                errorCode: 'INVALID_REQUEST',
            };
        }

        this.logger.info('Processing wallet-to-wallet transfer', {
            entityId,
            transactionType,
            amount: request.amount,
            recipientId: options.recipientEntityId,
        });

        try {
            // Create transaction record first (with useWalletBalance=true for wallet transfers)
            const transaction = await this.createTransactionRecord(
                entityId,
                request.amount,
                transactionType,
                true, // Always true for wallet transfers
                options,
            );

            // Process the wallet transfer
            return this.processWalletToWalletTransfer(
                transaction,
                entityId,
                options.recipientEntityId,
                request.amount,
                transactionType,
            );
        } catch (error) {
            this.logger.error('Error processing wallet transfer', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Authorize a card transaction through NMI payment provider
     * @param entityId - User's ID
     * @param request - Authorization request parameters
     * @param transactionType - Transaction type
     * @param options - Additional options for transaction processing
     * @returns Payment response
     */
    async authorizeTransaction(
        entityId: string,
        request: Omit<AuthorizationRequest, 'type' | 'security_key'>,
        transactionType: TransactionType,
        options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        } = {},
    ): Promise<PaymentResponse> {
        this.logger.info('Authorizing card transaction', {
            entityId,
            transactionType,
            amount: request.amount,
        });

        try {
            // Create transaction record first
            const transaction = await this.createTransactionRecord(
                entityId,
                request.amount,
                transactionType,
                false, // Always false for card payments
                options,
            );

            // Process as a card payment
            return this.processCardPayment(transaction, entityId, request, transactionType, options);
        } catch (error) {
            this.logger.error('Error authorizing card transaction', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Process a wallet-to-wallet transfer (no payment provider needed)
     * @param transaction - Transaction record
     * @param senderId - Sender's ID
     * @param recipientId - Recipient's ID
     * @param amount - Transaction amount
     * @param transactionType - Transaction type (P2P or P2B)
     * @returns Payment response
     */
    private async processWalletToWalletTransfer(
        transaction: Transaction,
        senderId: string,
        recipientId?: string,
        amount?: string,
        transactionType?: TransactionType,
    ): Promise<PaymentResponse> {
        this.logger.info(`Processing ${transactionType} wallet-to-wallet transfer`, {
            transactionId: transaction.transactionId,
            senderId,
            recipientId,
            amount,
        });

        try {
            // This will trigger the wallet update for the recipient
            await transaction.complete();

            this.logger.info(`${transactionType} wallet-to-wallet transfer completed successfully`, {
                transactionId: transaction.transactionId,
                senderId,
                recipientId,
                amount,
                status: transaction.status,
            });

            // Create a payment response without NMI details
            return {
                success: true,
                message: `${transactionType} transfer processed successfully`,
                status: 'captured', // Use 'captured' status for completed transfers
                internalTransactionId: transaction.transactionId,
            };
        } catch (error) {
            this.logger.error(`Error processing ${transactionType} wallet-to-wallet transfer`, {
                error: error instanceof Error ? error.message : 'Unknown error',
                transactionId: transaction.transactionId,
                senderId,
                recipientId,
            });

            // Mark transaction as failed
            transaction.status = TransactionStatus.FAILED;
            await transaction.update();

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
                internalTransactionId: transaction.transactionId,
            };
        }
    }

    /**
     * Process a card payment through NMI payment provider
     * @param transaction - Transaction record
     * @param entityId - User's ID
     * @param request - Authorization request parameters
     * @param transactionType - Transaction type
     * @param options - Additional options for transaction processing
     * @returns Payment response
     */
    private async processCardPayment(
        transaction: Transaction,
        entityId: string,
        request: Omit<AuthorizationRequest, 'type' | 'security_key'>,
        transactionType: TransactionType,
        options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        } = {},
    ): Promise<PaymentResponse> {
        // Determine the payment scenario based on request parameters
        const paymentScenario =
            request.customer_vault === 'add_customer'
                ? 'new_vault'
                : request.use_saved_card
                ? 'existing_vault'
                : 'direct_payment';

        this.logger.info('Processing card payment', {
            paymentScenario,
            transactionId: transaction.transactionId,
            entityId,
        });

        // Create the complete request with type and security key
        const fullRequest: AuthorizationRequest = {
            ...request,
            type: NmiTransactionType.AUTH,
            security_key: this.config.securityKey,
        };

        // If using an existing vault ID, fetch it from the database based on entityId
        if (paymentScenario === 'existing_vault') {
            try {
                // Get the customer vaults for this user - we only expect one per user
                const customerVaults = await listNmiCustomersByEntity(entityId);

                if (!customerVaults || customerVaults.length === 0) {
                    throw new Error(`No saved payment method found for user ${entityId}`);
                }

                // Just use the first vault since there should only be one
                const nmiCustomer = customerVaults[0];
                const customerVaultId = nmiCustomer.customerVaultId;

                this.logger.info('Using existing customer vault ID', {
                    customerVaultId,
                    ccType: nmiCustomer.ccType,
                });

                // Add the customer_vault_id to the request
                fullRequest.customer_vault_id = customerVaultId;
            } catch (vaultError) {
                this.logger.error('Error fetching customer vault for user', {
                    error: vaultError instanceof Error ? vaultError.message : 'Unknown error',
                    entityId,
                });
                throw new Error(
                    `Unable to use saved card: ${vaultError instanceof Error ? vaultError.message : 'Unknown error'}`,
                );
            }
        }

        this.logger.info('Sending payment request to NMI', {
            transactionId: transaction.transactionId,
        });

        // Process authorization through NMI
        const response: TransactionResponse = await this.processNmiRequest<AuthorizationRequest>(
            fullRequest,
            NMI_ENDPOINTS.TRANSACTION,
        );

        // log response
        this.logger.info('NMI payment response received back on method', {
            response,
        });

        this.logger.info('NMI payment response received', {
            providerTransactionId: response.transactionid,
            authCode: response.authcode,
            responseCode: response.response_code,
            responseText: response.responsetext,
            internalTransactionId: transaction.transactionId,
        });

        // Update the transaction with provider details
        const updatedTransaction = await this.updateTransactionWithProviderDetails(transaction.transactionId, response);

        // log vault and

        // If a customer vault ID was returned, store it for future use
        if (response.customer_vault_id && request.customer_vault === 'add_customer') {
            try {
                this.logger.info('Customer vault ID detected in response, storing for entity', {
                    entityId,
                    customerVaultId: response.customer_vault_id,
                    ccType: response.cc_type,
                });

                // Check if user already has a vault record and delete it first
                await this.deleteExistingVaultRecords(entityId);

                // Create NMI customer record for this user
                await createNmiCustomer(entityId, 'USER', response.customer_vault_id, {
                    ccType: response.cc_type,
                    ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
                });

                this.logger.info('Successfully stored NMI customer vault record', {
                    entityId,
                    customerVaultId: response.customer_vault_id,
                });
            } catch (vaultError) {
                // Log error but don't fail the transaction - the payment still succeeded
                this.logger.error('Error storing customer vault information', {
                    error: vaultError instanceof Error ? vaultError.message : 'Unknown error',
                    entityId,
                    customerVaultId: response.customer_vault_id,
                });
            }
        }

        // Create a payment response that includes both transaction IDs
        const paymentResponse = this.createPaymentResponse(response, updatedTransaction);

        // Add the internal transaction ID explicitly
        return {
            ...paymentResponse,
            internalTransactionId: transaction.transactionId,
        };
    }

    /**
     * Create a transaction record in the database
     * @param entityId - User's ID initiating the transaction
     * @param amount - Transaction amount
     * @param transactionType - Type of transaction
     * @param useWalletBalance - Whether to use wallet balance for payment (vs card)
     * @param options - Additional options for transaction creation
     * @returns Created transaction record
     */
    private async createTransactionRecord(
        entityId: string,
        amount: string,
        transactionType: TransactionType,
        useWalletBalance: boolean = false,
        options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        } = {},
    ): Promise<Transaction> {
        if (transactionType === TransactionType.DEPOSIT) {
            this.logger.info('Creating deposit transaction record', {
                entityId,
                amount,
            });

            // For a deposit, the user (entityId) is the recipient
            // Use UnifiedTransactionService to create transaction with proper structure
            const unifiedInput: CreateTransactionInput = {
                type: UnifiedTransactionType.DEPOSIT,
                provider: PaymentProvider.NMI,
                amount: parseFloat(amount) * 100, // Convert to cents
                asset: 'USD',
                sender: {
                    entityId: 'system',
                    entityType: EntityType.SYSTEM,
                    name: 'NMI Deposit',
                },
                recipient: {
                    entityId: entityId,
                    entityType: EntityType.USER,
                    name: options.senderClkkTag || entityId, // For deposits, the sender is the recipient
                    email: options.senderCurrentEmail, // For deposits, use sender email
                },
                memo: 'Card deposit',
                metadata: {
                    paymentMethod: 'card',
                },
            };

            const unifiedTransaction = await UnifiedTransactionService.createTransaction(
                unifiedInput,
                `nmi-deposit-${Date.now()}`
            );

            // Create a Transaction object for backward compatibility
            const transaction = new Transaction(
                TransactionType.DEPOSIT,
                amount,
                'USD',
                TransactionStatus.PENDING,
                {
                    transactionId: unifiedTransaction.transactionId,
                    sender: {
                        id: 'system',
                        type: 'SYSTEM',
                        name: 'NMI Deposit',
                    },
                    receiver: {
                        id: entityId,
                        type: 'USER',
                        name: options.recipientClkkTag || entityId,
                    },
                }
            );

            // Set the transaction ID to match the unified transaction
            (transaction as any).transactionId = unifiedTransaction.transactionId;

            this.logger.info('Deposit transaction created', {
                transactionId: transaction.transactionId,
                amount,
                entityId,
                unifiedTransactionId: unifiedTransaction.transactionId,
            });

            return transaction;
        } else if (transactionType === TransactionType.P2P) {
            const {
                recipientEntityId,
                recipientType,
                recipientClkkTag,
                senderClkkTag,
                recipientCurrentEmail,
                senderCurrentEmail,
            } = options;
            this.logger.info('Creating P2P transaction record at function', {
                entityId,
                recipientEntityId,
                amount,
                useWalletBalance,
                options,
            });

            if (!recipientEntityId) {
                throw new Error('Recipient entity ID is required for P2P transfers');
            }

            this.logger.info('Creating P2P transaction record', {
                entityId,
                recipientEntityId,
                amount,
                useWalletBalance,
                options,
            });

            // Create metadata with additional information
            const metadata: any = {
                description: `P2P transfer from ${senderClkkTag || entityId} to ${
                    recipientClkkTag || recipientEntityId
                }`,
                paymentMethod: useWalletBalance ? 'wallet' : 'card',
            };

            if (senderClkkTag) metadata.senderClkkTag = senderClkkTag;
            if (recipientClkkTag) metadata.recipientClkkTag = recipientClkkTag;
            if (recipientCurrentEmail) metadata.recipientCurrentEmail = recipientCurrentEmail;
            if (senderCurrentEmail) metadata.senderCurrentEmail = senderCurrentEmail;

            this.logger.info('Creating P2P transaction record after metadata', {
                entityId,
                recipientEntityId,
                amount,
                useWalletBalance,
                options,
                metadata,
            });

            // Create a single transaction for P2P transfer
            const transaction = new Transaction(TransactionType.P2P, amount, 'USD', TransactionStatus.PENDING, {
                sender: {
                    id: entityId,
                    type: 'USER',
                    name: senderClkkTag,
                },
                receiver: {
                    id: recipientEntityId,
                    type: recipientType || 'USER',
                    name: recipientClkkTag,
                },
                metadata,
            });

            // If using wallet balance, deduct from sender's wallet immediately
            if (useWalletBalance) {
                this.logger.info('Decided to deduct from sender wallet', {
                    entityId,
                    amount,
                    transactionId: transaction.transactionId,
                });
                try {
                    // Check if sender has sufficient funds
                    const wallet = await WalletService.getWallet(entityId, 'USER', 'USD');

                    this.logger.info('Got Wallet from DB', {
                        entityId,
                        wallet,
                    });

                    if (!wallet) {
                        throw new Error('Sender wallet not found');
                    }

                    const walletBalance = new Money(wallet.balance, 'USD');
                    const transferAmount = new Money(amount, 'USD');

                    if (walletBalance.lessThan(transferAmount)) {
                        throw new Error('Insufficient funds in wallet');
                    }

                    // Deduct from sender's wallet
                    await WalletService.withdraw(entityId, 'USER', transferAmount, transaction.transactionId, 'USD');

                    this.logger.info('Deducted amount from sender wallet', {
                        senderId: entityId,
                        amount: transferAmount.toString(),
                        transactionId: transaction.transactionId,
                    });

                    // Store the balance before and after in the transaction
                    transaction.balanceBefore = walletBalance.toString();
                    transaction.balanceAfter = walletBalance.subtract(transferAmount).toString();
                } catch (error) {
                    this.logger.error('Error deducting from sender wallet', {
                        error: error instanceof Error ? error.message : 'Unknown error',
                        senderId: entityId,
                        amount,
                    });
                    throw error;
                }
            }

            // Create the transaction record
            await transaction.create();

            this.logger.info('P2P transaction created', {
                transactionId: transaction.transactionId,
                senderId: entityId,
                receiverId: recipientEntityId,
                amount,
                useWalletBalance,
            });

            return transaction;
        } else if (transactionType === TransactionType.P2B) {
            const { recipientEntityId, recipientType, recipientClkkTag, senderClkkTag } = options;

            if (!recipientEntityId) {
                throw new Error('Business entity ID is required for P2B transfers');
            }

            this.logger.info('Creating P2B transaction record', {
                entityId,
                businessId: recipientEntityId,
                amount,
                useWalletBalance,
            });

            // Create metadata with additional information
            const metadata: any = {
                description: `Payment from ${senderClkkTag || entityId} to ${recipientClkkTag || recipientEntityId}`,
                paymentMethod: useWalletBalance ? 'wallet' : 'card',
            };

            if (senderClkkTag) metadata.senderClkkTag = senderClkkTag;
            if (recipientClkkTag) metadata.businessName = recipientClkkTag;

            // Create a single transaction for P2B transfer
            const transaction = new Transaction(TransactionType.P2B, amount, 'USD', TransactionStatus.PENDING, {
                sender: {
                    id: entityId,
                    type: 'USER',
                    name: senderClkkTag,
                },
                receiver: {
                    id: recipientEntityId,
                    type: recipientType || 'BUSINESS',
                    name: recipientClkkTag,
                },
                metadata,
            });

            // If using wallet balance, deduct from sender's wallet immediately
            if (useWalletBalance) {
                try {
                    // Check if sender has sufficient funds
                    const wallet = await WalletService.getWallet(entityId, 'USER', 'USD');
                    if (!wallet) {
                        throw new Error('Sender wallet not found');
                    }

                    const walletBalance = new Money(wallet.balance, 'USD');
                    const transferAmount = new Money(amount, 'USD');

                    if (walletBalance.lessThan(transferAmount)) {
                        throw new Error('Insufficient funds in wallet');
                    }

                    // Deduct from sender's wallet
                    await WalletService.withdraw(entityId, 'USER', transferAmount, transaction.transactionId, 'USD');

                    this.logger.info('Deducted amount from sender wallet', {
                        senderId: entityId,
                        amount: transferAmount.toString(),
                        transactionId: transaction.transactionId,
                    });

                    // Store the balance before and after in the transaction
                    transaction.balanceBefore = walletBalance.toString();
                    transaction.balanceAfter = walletBalance.subtract(transferAmount).toString();
                } catch (error) {
                    this.logger.error('Error deducting from sender wallet', {
                        error: error instanceof Error ? error.message : 'Unknown error',
                        senderId: entityId,
                        amount,
                    });
                    throw error;
                }
            }

            // Create the transaction record
            await transaction.create();

            this.logger.info('P2B transaction created', {
                transactionId: transaction.transactionId,
                senderId: entityId,
                businessId: recipientEntityId,
                amount,
                useWalletBalance,
            });

            return transaction;
        } else {
            throw new Error(`Unsupported transaction type: ${transactionType}`);
        }
    }

    /**
     * Validates if a card is acceptable for transactions based on its type
     * @param transactionId - Transaction ID to query for card information
     * @returns Validation result with reason if invalid
     */
    private async validateCardType(transactionId: string): Promise<{ isValid: boolean; reason?: string }> {
        this.logger.info('Validating card type for transaction', { transactionId });

        // Skip validation if not enabled
        if (!NMI_FEATURES.CARD_TYPE_VALIDATION.ENABLED) {
            this.logger.info('Card type validation skipped - feature disabled');
            return { isValid: true };
        }

        try {
            // Get the card BIN from the transaction
            const cardBin = await this.getCardBinFromTransaction(transactionId);

            if (!cardBin) {
                this.logger.warn('No card BIN found for transaction, skipping card type validation', { transactionId });
                return { isValid: true };
            }

            // Check the card type using the BIN
            const cardType = await this.getCardTypeFromBin(cardBin);

            if (!cardType) {
                this.logger.warn('Could not determine card type, skipping validation', { transactionId });
                return { isValid: true };
            }

            // Check if card type is in allowed types
            const allowedTypes = NMI_FEATURES.CARD_TYPE_VALIDATION.ALLOWED_TYPES;
            if (!allowedTypes.includes(cardType)) {
                this.logger.info('Transaction rejected - card type not allowed', {
                    transactionId,
                    cardType,
                    allowedTypes,
                });

                return {
                    isValid: false,
                    reason: `Only ${allowedTypes.join(', ')} cards are allowed. Card type: ${cardType}`,
                };
            }

            this.logger.info('Card type verified as allowed, proceeding with transaction', {
                transactionId,
                cardType,
            });
            return { isValid: true };
        } catch (error) {
            this.logger.error('Error validating card type', {
                transactionId,
                error: error instanceof Error ? error.message : 'Unknown error',
            });

            // If validation fails, check if we should fail open or closed
            if (NMI_FEATURES.CARD_TYPE_VALIDATION.FAIL_OPEN) {
                this.logger.info('Proceeding with transaction despite validation error (fail-open policy)');
                return { isValid: true };
            } else {
                this.logger.info('Rejecting transaction due to validation error (fail-closed policy)');
                return {
                    isValid: false,
                    reason: 'Card validation failed due to technical error',
                };
            }
        }
    }

    /**
     * Retrieves the card BIN (first 6 digits) from a transaction
     * @param transactionId - Transaction ID to query
     * @returns Card BIN if found, undefined otherwise
     */
    private async getCardBinFromTransaction(transactionId: string): Promise<string | undefined> {
        this.logger.info('Getting card BIN from transaction', { transactionId });

        try {
            // Query the transaction to get details including cc_bin
            const queryResponse = await this.queryTransactions({
                transaction_id: transactionId,
            });

            if (queryResponse.success && queryResponse.transactions && queryResponse.transactions.length > 0) {
                const cc_bin = queryResponse.transactions[0].cc_bin;

                if (cc_bin) {
                    this.logger.info('Retrieved card BIN from transaction', {
                        transactionId,
                        cc_bin: cc_bin.substring(0, 3) + '***',
                    });

                    return cc_bin;
                } else {
                    this.logger.warn('No card BIN found in transaction query response', { transactionId });
                }
            } else {
                this.logger.warn('Transaction query failed or returned no results', {
                    transactionId,
                    errorMessage: queryResponse.message,
                });
            }

            return undefined;
        } catch (error) {
            this.logger.error('Error retrieving card BIN from transaction', {
                transactionId,
                error: error instanceof Error ? error.message : 'Unknown error',
            });

            return undefined;
        }
    }

    /**
     * Determines the card type based on BIN
     * @param cardBin - Card BIN (first 6 digits)
     * @returns Card type if determined, undefined otherwise
     */
    private async getCardTypeFromBin(cardBin: string): Promise<string | undefined> {
        this.logger.info('Getting card type from BIN', {
            cardBin: cardBin.substring(0, 3) + '***',
        });

        try {
            // Check the card type using the BIN
            const cardTypeResponse = await this.checkCardType(cardBin);

            if (cardTypeResponse.success && cardTypeResponse.result) {
                this.logger.info('Card type determined', {
                    cardBin: cardBin.substring(0, 3) + '***',
                    cardType: cardTypeResponse.result,
                });

                return cardTypeResponse.result;
            } else {
                this.logger.warn('Unable to determine card type', {
                    cardBin: cardBin.substring(0, 3) + '***',
                    errorMessage: cardTypeResponse.message,
                });

                return undefined;
            }
        } catch (error) {
            this.logger.error('Error determining card type from BIN', {
                cardBin: cardBin.substring(0, 3) + '***',
                error: error instanceof Error ? error.message : 'Unknown error',
            });

            return undefined;
        }
    }

    /**
     * Capture a previously authorized transaction
     * @param userId - User's ID
     * @param transactionId - Original transaction ID to capture (from NMI)
     * @param amount - Amount to capture (can be less than original)
     * @returns Payment response
     */
    async captureTransaction(userId: string, transactionId: string, amount?: string): Promise<PaymentResponse> {
        this.logger.info('Capturing transaction', {
            userId,
            providerTransactionId: transactionId,
            amount,
        });

        try {
            // Create the capture request
            const captureRequest: CaptureRequest = {
                type: NmiTransactionType.CAPTURE,
                transactionid: transactionId,
                amount,
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest<CaptureRequest>(captureRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Capture response', { response });

            this.logger.info('Transaction captured', {
                transactionId: response.transactionid,
                authCode: response.authcode,
                responseCode: response.response_code,
                responseText: response.responsetext,
            });

            // Keep transaction in PENDING status for webhook updates later
            // The webhook handler will update to COMPLETED when final settlement occurs
            const status =
                response.response === ResponseCode.APPROVED ? TransactionStatus.PENDING : TransactionStatus.FAILED;

            // First, find the internal transaction by provider transaction ID
            try {
                this.logger.info('Finding transaction by provider transaction ID', {
                    providerTransactionId: transactionId,
                });

                // Try to find transactions with this provider transaction ID
                const transactions = await TransactionService.getTransactionsByProviderTransactionId(transactionId);

                if (!transactions || transactions.length === 0) {
                    this.logger.warn('No transaction found with provider transaction ID', {
                        providerTransactionId: transactionId,
                    });

                    // Return a basic response if no transaction is found
                    return {
                        success: response.response === ResponseCode.APPROVED,
                        transactionId: response.transactionid,
                        message: response.responsetext || '',
                        status: 'pending',
                        errorCode: response.response !== ResponseCode.APPROVED ? response.response_code : undefined,
                    };
                }

                // Use the first transaction found (should be only one)
                const internalTransaction = transactions[0];
                const internalTransactionId = internalTransaction.transactionId;

                this.logger.info('Found internal transaction', {
                    internalTransactionId,
                    providerTransactionId: transactionId,
                });

                // Update transaction record with our internal transaction ID
                const updatedTransaction = await TransactionService.updateTransaction(internalTransactionId, {
                    status: status,
                    metadata: {
                        ...((await TransactionService.getTransaction(internalTransactionId))?.metadata || {}),
                        statusReason: response.responsetext,
                        authCode: response.authcode,
                        responseCode: response.response_code,
                        responseText: response.responsetext,
                    },
                    updatedAt: new Date().toISOString(),
                });

                this.logger.info('Internal transaction updated successfully', {
                    transaction: updatedTransaction,
                    internalTransactionId: updatedTransaction.transactionId,
                });

                // Create and return the payment response
                this.logger.info('Creating payment response for updated transaction');
                const paymentResponse = this.createPaymentResponse(response, updatedTransaction);
                return paymentResponse;
            } catch (findError) {
                this.logger.error('Error finding or updating transaction after capture', {
                    error: findError,
                    providerTransactionId: transactionId,
                    responseCode: response.response_code,
                });

                // Even if update fails, still return a valid response
                return {
                    success: response.response === ResponseCode.APPROVED,
                    transactionId: response.transactionid,
                    message: response.responsetext || '',
                    status: 'pending',
                    errorCode: response.response !== ResponseCode.APPROVED ? response.response_code : undefined,
                };
            }
        } catch (error) {
            this.logger.error('Error capturing transaction', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Process a request to the NMI API
     * @param requestData - Request data to send to NMI
     * @param apiUrlPath - NMI API URL path
     * @returns NMI API response
     */
    private async processNmiRequest<T extends Record<string, any>>(
        requestData: T,
        apiUrlPath: string,
    ): Promise<TransactionResponse> {
        this.logger.info('Processing NMI request', {
            requestData,
        });
        try {
            this.logger.info('Sending request to NMI API', {
                type: requestData.type,
                endpointUrl: this.config.apiUrl,
            });

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

            const options = {
                method: 'POST',
                headers: {
                    accept: 'application/x-www-form-urlencoded',
                    'content-type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams(requestData as Record<string, string>),
                signal: controller.signal,
            };

            const response = await fetch(`${this.config.apiUrl}/${apiUrlPath}`, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NMI API responded with status ${response.status}: ${errorText}`);
            }

            // Read the response text only once
            const responseText = await response.text();

            this.logger.info('Full NMI API response', {
                status: response.status,
                statusText: response.statusText,
                response: responseText,
            });

            this.logger.info('response text', {
                responseText,
            });

            // Parse the response from x-www-form-urlencoded format
            const parsedResponse = this.parseResponseText(responseText);

            this.logger.info('Full parsed response from NMI API', {
                parsedResponse,
            });

            this.logger.info('Received response from NMI API', {
                response: parsedResponse.response,
                responsetext: parsedResponse.responsetext,
                transactionid: parsedResponse.transactionid,
            });

            // Handle rate limit separately
            if (
                parsedResponse.response === ResponseCode.ERROR &&
                parsedResponse.response_code === ResultCode.RATE_LIMIT_EXCEEDED
            ) {
                throw new Error('Rate limit exceeded. Please try again later.');
            }

            // Special case for duplicate transactions
            if (
                parsedResponse.response === ResponseCode.ERROR &&
                parsedResponse.response_code === ResultCode.GATEWAY_REJECTED &&
                parsedResponse.responsetext &&
                parsedResponse.responsetext.includes('Duplicate transaction')
            ) {
                this.logger.warn('Duplicate transaction detected', {
                    responseCode: parsedResponse.response_code,
                    responseText: parsedResponse.responsetext,
                });
            }

            return parsedResponse;
        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('NMI API request timed out');
            }

            this.logger.error('Error processing NMI request', error);
            throw error;
        }
    }

    /**
     * Parse response text from x-www-form-urlencoded format
     * @param responseText - Raw response text from NMI API
     * @returns Parsed transaction response
     */
    private parseResponseText(responseText: string): TransactionResponse {
        this.logger.info('Parsing response text', {
            responseText,
        });
        const result: Record<string, string> = {};
        const params = new URLSearchParams(responseText);

        params.forEach((value, key) => {
            result[key] = value;
        });

        return result as unknown as TransactionResponse;
    }

    /**
     * Create a standardized payment response from NMI response
     * @param nmiResponse - Response from NMI API
     * @param transaction - Transaction record from database
     * @returns Standardized payment response
     */
    private createPaymentResponse(
        nmiResponse: TransactionResponse,
        transaction: Transaction | TransactionRecord,
    ): PaymentResponse {
        this.logger.info('Creating payment response', {
            nmiResponse,
            transaction,
        });
        const success = nmiResponse.response === ResponseCode.APPROVED;

        try {
            this.logger.info('Creating payment response', {
                transaction: typeof transaction === 'object' ? 'transaction_object_exists' : 'transaction_missing',
                transactionType: transaction ? typeof transaction : 'undefined',
            });

            // Safely handle the transaction record conversion
            let transactionRecord: TransactionRecord;

            if (this.isTransactionRecord(transaction)) {
                transactionRecord = transaction;
            } else if (transaction) {
                transactionRecord = {
                    userId: transaction.senderId || transaction.senderEntityId || '',
                    transactionId: transaction.transactionId || '',
                    type: transaction.type || TransactionType.DEPOSIT,
                    amount: typeof transaction.amount === 'number' ? transaction.amount.toString() : '0',
                    status: this.mapTransactionStatus(transaction.status || TransactionStatus.PENDING),
                    createdAt: new Date(transaction.createdAt || Date.now()),
                    updatedAt: new Date(transaction.updatedAt || Date.now()),
                };
            } else {
                transactionRecord = {
                    userId: '',
                    transactionId: nmiResponse.transactionid || '',
                    type: TransactionType.DEPOSIT,
                    amount: '0',
                    status: 'pending',
                    createdAt: new Date(),
                    updatedAt: new Date(),
                };
            }

            return {
                success,
                transactionId: nmiResponse.transactionid,
                internalTransactionId: transaction?.transactionId || '',
                // NMI might return customer_vault_id in some responses
                customerVaultId: (nmiResponse as any).customer_vault_id,
                message: nmiResponse.responsetext || '',
                orderReference: transactionRecord.orderReference,
                status: transactionRecord.status || 'pending',
                errorCode: !success ? nmiResponse.response_code : undefined,
                transactionRecord,
            };
        } catch (error) {
            // If anything fails in processing, return a minimal valid response
            this.logger.error('Error creating payment response', { error });
            return {
                success,
                transactionId: nmiResponse.transactionid,
                message: nmiResponse.responsetext || 'Error processing response',
                status: 'pending',
                errorCode: !success ? nmiResponse.response_code : undefined,
            };
        }
    }

    private isTransactionRecord(obj: any): obj is TransactionRecord {
        return 'userId' in obj && typeof obj.userId === 'string';
    }

    /**
     * Maps internal transaction status to NMI-compatible status
     */
    private mapTransactionStatus(status: TransactionStatus): TransactionRecord['status'] {
        const statusMap: Record<TransactionStatus, TransactionRecord['status']> = {
            [TransactionStatus.PENDING]: 'pending',
            [TransactionStatus.COMPLETED]: 'captured',
            [TransactionStatus.FAILED]: 'failed',
            [TransactionStatus.CANCELLED]: 'failed',
            [TransactionStatus.REVERSED]: 'refunded',
        };
        return statusMap[status] || 'pending';
    }

    /**
     * Determine transaction status from NMI response
     * @param response - NMI API response
     * @returns Transaction status
     */
    /**
     * Maps NMI response codes to appropriate transaction statuses based on the response
     * and adjusts based on the transaction type when needed
     *
     * @param response - NMI API response
     * @param transactionType - Optional transaction type for specialized status mapping
     * @returns Appropriate transaction status based on response code and transaction type
     */
    private getTransactionStatus(
        response: TransactionResponse,
        transactionType?: TransactionType,
    ): TransactionRecord['status'] {
        // First, determine basic status from response code
        if (response.response === ResponseCode.APPROVED) {
            // For capture operations, set to captured
            if (transactionType === undefined && response.authcode) {
                // When capturing, we usually have an auth code and no transaction type specified
                return 'captured';
            }

            // Different success statuses based on transaction type
            if (transactionType) {
                switch (transactionType) {
                    case TransactionType.DEPOSIT:
                        // Deposits typically just need authorization
                        return 'pending';
                    case TransactionType.P2P:
                    case TransactionType.P2B:
                        // P2P and P2B transfers are usually fully captured immediately
                        return 'captured';
                    default:
                        return 'pending';
                }
            }
            // Default for APPROVED if no transaction type specified
            return 'pending';
        } else if (response.response === ResponseCode.DECLINED) {
            return 'failed';
        } else if (response.response === ResponseCode.ERROR) {
            return 'failed';
        } else {
            return 'pending';
        }
    }

    /**
     * Query transactions from NMI API
     * @param request - Query request parameters
     * @returns Query transaction response
     */
    async queryTransactions(request: Omit<QueryTransactionRequest, 'security_key'>): Promise<QueryTransactionResponse> {
        this.logger.info('Querying transactions', {
            transactionId: request.transaction_id,
            condition: request.condition,
        });

        try {
            // Create the complete request with security key
            const fullRequest: QueryTransactionRequest = {
                ...request,
                security_key: this.config.securityKey,
            };

            // NMI query API base endpoint
            const baseUrl = NMI_API_URLS.QUERY;

            // Convert request to URL parameters
            const params = new URLSearchParams();
            Object.entries(fullRequest).forEach(([key, value]) => {
                if (value !== undefined) {
                    params.append(key, String(value));
                }
            });

            // Build the full URL with query parameters
            const queryUrl = `${baseUrl}?${params.toString()}`;

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

            const options = {
                method: 'POST',
                headers: {
                    accept: 'application/xml',
                },
                signal: controller.signal,
            };

            this.logger.info('Sending POST request to NMI Query API', {
                url: queryUrl,
            });

            const response = await fetch(queryUrl, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NMI Query API responded with status ${response.status}: ${errorText}`);
            }

            const responseText = await response.text();
            this.logger.info('Received response from NMI Query API');

            // Check if response is XML or plain text
            if (responseText.trim().startsWith('<?xml')) {
                // Handle XML response
                const parser = new XMLParser({
                    ignoreAttributes: false,
                    parseAttributeValue: true,
                });

                const parsedXml = parser.parse(responseText);

                if (!parsedXml.nm_response || !parsedXml.nm_response.transaction) {
                    return {
                        success: false,
                        message: 'No transactions found',
                    };
                }

                const transactions = Array.isArray(parsedXml.nm_response.transaction)
                    ? parsedXml.nm_response.transaction
                    : [parsedXml.nm_response.transaction];

                // Extract required fields from each transaction
                const parsedTransactions = transactions.map((tx: any) => ({
                    transaction_id: tx.transaction_id || '',
                    cc_bin: tx.cc_bin || '',
                    cc_type: tx.cc_type || '',
                    condition: tx.condition || '',
                    customerid: tx.customerid || '',
                    // Extract other fields if needed
                    amount: tx.action && tx.action.amount ? tx.action.amount : '',
                    action_type: tx.action && tx.action.action_type ? tx.action.action_type : '',
                    date: tx.action && tx.action.date ? tx.action.date : '',
                }));

                return {
                    success: true,
                    message: 'Transactions retrieved successfully',
                    transactions: parsedTransactions,
                };
            } else {
                this.logger.info('Received plain text response, parsing manually');

                if (responseText.trim() === '') {
                    return {
                        success: false,
                        message: 'No transactions found',
                    };
                }

                const fields = responseText.trim().split(' ');
                if (fields.length >= 5) {
                    // Map the fields based on the expected order
                    const transaction = {
                        transaction_id: fields[0] || '',
                        cc_type: fields[1] || '',
                        condition: fields[2] || '',
                        customerid: fields[4] || '',
                        cc_bin: fields.length > 15 ? fields[15] || '' : '',
                    };

                    return {
                        success: true,
                        message: 'Transaction retrieved successfully',
                        transactions: [transaction],
                    };
                } else {
                    return {
                        success: false,
                        message: 'Invalid response format',
                    };
                }
            }
        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('NMI Query API request timed out');
            }

            this.logger.error('Error querying transactions', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Check card type based on the card number (IIN/BIN)
     * @param ccnumber - Card IIN (first 6 digits)
     * @returns Card type information
     */
    async checkCardType(ccnumber: string): Promise<CardTypeCheckResponse> {
        this.logger.info('Checking card type', {
            ccnumber: ccnumber.substring(0, 3) + '***',
        });

        try {
            // Card type check API endpoint (v4 API)
            const cardTypeApiUrl = NMI_API_URLS.CARD_TYPE;
            const v4ApiKey = this.config.securityKey;

            if (!v4ApiKey) {
                throw new Error('NMI API key is not configured');
            }

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

            // Create request options
            const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `${NMI_AUTH_PREFIXES.V4_PRIVATE}${v4ApiKey}`,
                },
                body: JSON.stringify({ ccnumber }),
                signal: controller.signal,
            };

            this.logger.info('Sending request to NMI Card Type API', {
                url: cardTypeApiUrl,
            });

            const response = await fetch(cardTypeApiUrl, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NMI Card Type API responded with status ${response.status}: ${errorText}`);
            }

            const responseData = await response.json();

            this.logger.info('Received response from NMI Card Type API', {
                result: responseData.result,
            });

            return {
                success: true,
                result: responseData.result,
            };
        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                this.logger.error('NMI Card Type API request timed out');
                return {
                    success: false,
                    result: 'unavailable',
                    message: 'Request timed out',
                    errorCode: 'TIMEOUT_ERROR',
                };
            }

            this.logger.error('Error checking card type', error);
            return {
                success: false,
                result: 'unavailable',
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Update transaction record with provider details
     * @param transactionId - Internal transaction ID
     * @param nmiResponse - Response from NMI
     * @returns Updated transaction
     */
    private async updateTransactionWithProviderDetails(
        transactionId: string,
        nmiResponse: TransactionResponse,
    ): Promise<Transaction> {
        // Update with provider details
        const success = nmiResponse.response === ResponseCode.APPROVED;
        const status = success ? TransactionStatus.PENDING : TransactionStatus.FAILED;

        this.logger.info('Updating transaction with provider details', {
            internalTransactionId: transactionId,
            providerTransactionId: nmiResponse.transactionid,
            status,
        });

        const updateData = {
            status,
            providerTransactionId: nmiResponse.transactionid, // This should match the GSI key name
            authCode: nmiResponse.authcode,
            responseCode: nmiResponse.response_code,
            responseText: nmiResponse.responsetext,
            updatedAt: new Date().toISOString(),
        };

        return TransactionService.updateTransaction(transactionId, updateData);
    }

    /**
     * Add a customer to the NMI vault
     * @param entityId - Entity ID (user or business)
     * @param entityType - Entity type (USER or BUSINESS)
     * @param request - Customer vault request
     * @returns Customer vault response with vault ID
     */
    async addCustomerToVault(
        entityId: string,
        entityType: EntityTypeString,
        request: Omit<CustomerVaultRequest, 'customer_vault' | 'security_key'>,
    ): Promise<CustomerVaultResponse> {
        try {
            this.logger.info('Adding customer to NMI vault', {
                entityId,
                entityType,
            });

            // Add customer_vault action to the request
            const vaultRequest: CustomerVaultRequest = {
                ...request,
                customer_vault: 'add_customer',
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest(vaultRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Customer vault response received', {
                response_code: response.response_code,
                responsetext: response.responsetext,
                customer_vault_id: response.customer_vault_id,
            });

            if (response.response !== '1') {
                throw new Error(`Failed to add customer to vault: ${response.responsetext}`);
            }

            // Store the customer vault data in DynamoDB
            const customerVaultId = response.customer_vault_id;
            if (!customerVaultId) {
                throw new Error('No customer_vault_id returned from NMI');
            }

            // Create NMI customer record
            await createNmiCustomer(entityId, entityType, customerVaultId, {
                ccType: response.cc_type,
                ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
            });

            return {
                success: true,
                customerVaultId: customerVaultId,
                message: response.responsetext || 'Customer added to vault successfully',
                ccType: response.cc_type,
                ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
            };
        } catch (error) {
            this.logger.error('Error adding customer to vault', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
                entityType,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }

    /**
     * Update a customer in the NMI vault
     * @param entityId - Entity ID (user or business)
     * @param customerVaultId - NMI customer vault ID
     * @param request - Customer vault update request
     * @returns Customer vault response
     */
    async updateCustomerInVault(
        entityId: string,
        customerVaultId: string,
        request: Omit<CustomerVaultRequest, 'customer_vault' | 'security_key' | 'customer_vault_id'>,
    ): Promise<CustomerVaultResponse> {
        try {
            this.logger.info('Updating customer in NMI vault', {
                entityId,
                customerVaultId,
            });

            // First verify that this customer vault ID belongs to the user
            const nmiCustomers = await listNmiCustomersByEntity(entityId);
            const matchingCustomer = nmiCustomers.find((c) => c.customerVaultId === customerVaultId);

            if (!matchingCustomer) {
                throw new Error('Customer vault ID not found for this user');
            }

            // Add customer_vault update action to the request
            const vaultRequest: CustomerVaultRequest = {
                ...request,
                customer_vault: 'update_customer',
                customer_vault_id: customerVaultId,
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest(vaultRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Customer vault update response received', {
                response_code: response.response_code,
                responsetext: response.responsetext,
            });

            if (response.response !== '1') {
                throw new Error(`Failed to update customer in vault: ${response.responsetext}`);
            }

            // Update the NMI customer record if card details changed
            if (response.cc_type || response.cc_number) {
                matchingCustomer.ccType = response.cc_type || matchingCustomer.ccType;
                matchingCustomer.ccNumber = response.cc_number
                    ? response.cc_number.slice(-4)
                    : matchingCustomer.ccNumber;
                matchingCustomer.updatedAt = new Date().toISOString();
                await matchingCustomer.update();
            }

            return {
                success: true,
                customerVaultId: customerVaultId,
                message: response.responsetext || 'Customer updated in vault successfully',
                ccType: response.cc_type,
                ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
            };
        } catch (error) {
            this.logger.error('Error updating customer in vault', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
                customerVaultId,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }

    /**
     * Delete a customer from the NMI vault
     * @param entityId - Entity ID (user or business)
     * @param customerVaultId - NMI customer vault ID to delete
     * @returns Success response
     */
    async deleteCustomerFromVault(
        entityId: string,
        customerVaultId: string,
    ): Promise<{ success: boolean; message: string }> {
        try {
            this.logger.info('Deleting customer from NMI vault', {
                entityId,
                customerVaultId,
            });

            // First verify that this customer vault ID belongs to the user
            const nmiCustomers = await listNmiCustomersByEntity(entityId);
            const matchingCustomer = nmiCustomers.find((c) => c.customerVaultId === customerVaultId);

            if (!matchingCustomer) {
                throw new Error('Customer vault ID not found for this user');
            }

            // Create delete request
            const vaultRequest = {
                customer_vault: 'delete_customer',
                customer_vault_id: customerVaultId,
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest(vaultRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Customer vault delete response received', {
                response_code: response.response_code,
                responsetext: response.responsetext,
            });

            if (response.response !== '1') {
                throw new Error(`Failed to delete customer from vault: ${response.responsetext}`);
            }

            // Delete the NMI customer record from our database
            await matchingCustomer.delete();

            return {
                success: true,
                message: response.responsetext || 'Customer deleted from vault successfully',
            };
        } catch (error) {
            this.logger.error('Error deleting customer from vault', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
                customerVaultId,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }

    /**
     * Get all stored customer vault records for an entity
     * @param entityId - Entity ID (user or business)
     * @returns List of customer vault records
     */
    async getStoredCustomerVaults(entityId: string): Promise<NmiCustomer[]> {
        try {
            return await listNmiCustomersByEntity(entityId);
        } catch (error) {
            this.logger.error('Error getting stored customer vaults', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
            });
            throw error;
        }
    }

    /**
     * Delete all vault records for an entity
     * This is a public method that can be called directly from API endpoints
     * @param entityId - Entity ID (user or business)
     * @returns Result of the deletion operation
     */
    async deleteAllCustomerVaultRecords(entityId: string): Promise<{ success: boolean; message: string }> {
        return this.deleteExistingVaultRecords(entityId);
    }

    /**
     * Delete all existing vault records for an entity from both NMI and DynamoDB
     * This is used when a user is adding a new payment method to replace existing ones
     * @param entityId - Entity ID (user or business)
     * @returns Result of the deletion operation
     */
    private async deleteExistingVaultRecords(entityId: string): Promise<{ success: boolean; message: string }> {
        try {
            this.logger.info('Checking for existing vault records to delete', { entityId });

            // Get all existing vault records for this entity
            const existingVaults = await listNmiCustomersByEntity(entityId);

            if (!existingVaults || existingVaults.length === 0) {
                this.logger.info('No existing vault records found for entity', { entityId });
                return { success: true, message: 'No existing vault records to delete' };
            }

            this.logger.info('Found existing vault records to delete', {
                entityId,
                count: existingVaults.length,
                vaultIds: existingVaults.map((v) => v.customerVaultId),
            });

            // Delete each vault record from NMI and DynamoDB
            for (const vault of existingVaults) {
                const result = await this.deleteCustomerFromVault(entityId, vault.customerVaultId);

                if (!result.success) {
                    this.logger.warn('Failed to delete vault record', {
                        entityId,
                        customerVaultId: vault.customerVaultId,
                        error: result.message,
                    });
                    // Continue with other deletions even if one fails
                }
            }

            return {
                success: true,
                message: `Successfully deleted ${existingVaults.length} existing vault record(s)`,
            };
        } catch (error) {
            this.logger.error('Error deleting existing vault records', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }
}
</file>

<file path="lambdas/nmi/handlers/services/secrets-service.ts">
import { getSecret } from '../../../layers/commons/utils/getSecret';
import { createLogger } from '../../../layers/commons/utils/logger_v2';

/**
 * Logger for the secrets service
 */
const logger = createLogger('NmiSecretsService');

/**
 * Default secret name for NMI
 */
const DEFAULT_SECRET_NAME = 'nmi/credentials';

/**
 * NMI secret keys
 */
export enum NmiSecretKeys {
    WEBHOOK_SIGNING_KEY = 'NMI_WEBHOOK_SIGNING_KEY',
    PRIVATE_KEY = 'NMI_PRIVATE_KEY',
}

/**
 * Cache for secrets to avoid repeated calls to Secrets Manager
 */
const secretsCache: Record<string, string> = {};

/**
 * Get NMI secret from AWS Secrets Manager
 * @param key - The key of the secret to retrieve
 * @param secretName - The name of the secret in Secrets Manager (optional)
 * @returns The secret value
 */
export async function getNmiSecret(key: NmiSecretKeys, secretName?: string): Promise<string> {
    const name = secretName || process.env.NMI_SECRET_NAME || DEFAULT_SECRET_NAME;
    const cacheKey = `${name}:${key}`;

    // Return from cache if available
    if (secretsCache[cacheKey]) {
        logger.info(`Using cached secret for ${key}`);
        return secretsCache[cacheKey];
    }

    try {
        logger.info(`Retrieving NMI secret: ${key}`, { secretName: name });

        // Get the secret using the common utility
        const secretValue = await getSecret(name, key);

        if (!secretValue) {
            throw new Error(`Secret ${key} not found in ${name}`);
        }

        // Cache the secret
        secretsCache[cacheKey] = secretValue;

        logger.info(`Successfully retrieved NMI secret: ${key}`);
        return secretValue;
    } catch (error) {
        logger.error(`Error retrieving NMI secret: ${key}`, error);
        throw error;
    }
}

/**
 * Get NMI webhook signing key
 * @param secretName - Optional secret name override
 * @returns The webhook signing key
 */
export async function getNmiWebhookSigningKey(secretName?: string): Promise<string> {
    return getNmiSecret(NmiSecretKeys.WEBHOOK_SIGNING_KEY, secretName);
}

/**
 * Get NMI private key
 * @param secretName - Optional secret name override
 * @returns The private key
 */
export async function getNmiPrivateKey(secretName?: string): Promise<string> {
    return getNmiSecret(NmiSecretKeys.PRIVATE_KEY, secretName);
}
</file>

<file path="lambdas/nmi/handlers/services/webhook-service.ts">
import { createHmac } from 'crypto';
import { createLogger } from '../../../layers/commons/utils/logger_v2';
import {
    NmiWebhookEvent,
    NmiWebhookEventType,
    WebhookVerificationRequest,
    WebhookVerificationResult,
    WebhookProcessingResult,
} from '../types/webhook';
import { TransactionService, TransactionStatus } from '../../../layers/commons/data/entities/transaction';
import { Transaction, TransactionType, EntityType } from '../../../layers/commons/data/entities/transaction';

/**
 * Transaction update data interface
 */
interface TransactionUpdateData {
    status: TransactionStatus;
    updatedAt: string;
    responseCode?: string;
    responseText?: string;
    authCode?: string;
    [key: string]: any; // For any additional fields
}

/**
 * Service for handling NMI webhooks
 */
export class WebhookService {
    private logger = createLogger('WebhookService');
    private signingKey: string;

    /**
     * Initialize the webhook service
     * @param signingKey - NMI webhook signing key for validation
     */
    constructor(signingKey: string) {
        this.signingKey = signingKey;
    }

    /**
     * Verify webhook signature using HMAC with SHA-256
     * @param request - Webhook verification request data
     * @returns Verification result with parsed webhook if valid
     */
    verifyWebhook(request: WebhookVerificationRequest): WebhookVerificationResult {
        try {
            this.logger.info('Verifying webhook signature');

            const { webhookBody, signingKey, nonce, signature } = request;

            // Generate expected signature using the same algorithm as NMI
            const expectedSignature = createHmac('sha256', signingKey).update(`${nonce}.${webhookBody}`).digest('hex');

            // Compare the signatures
            const isValid = expectedSignature === signature;

            if (!isValid) {
                this.logger.warn('Invalid webhook signature', {
                    expectedSignature: expectedSignature.substring(0, 10) + '...',
                    receivedSignature: signature.substring(0, 10) + '...',
                });

                return {
                    isValid: false,
                    message: 'Invalid webhook signature',
                };
            }

            // Parse webhook body to JSON
            try {
                const webhook = JSON.parse(webhookBody) as NmiWebhookEvent;

                this.logger.info('Webhook signature verified successfully', {
                    event_id: webhook.event_id,
                    event_type: webhook.event_type,
                });

                return {
                    isValid: true,
                    webhook,
                };
            } catch (parseError) {
                this.logger.error('Error parsing webhook body', parseError);

                return {
                    isValid: false,
                    message: 'Error parsing webhook body',
                };
            }
        } catch (error) {
            this.logger.error('Error verifying webhook', error);

            return {
                isValid: false,
                message: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }

    /**
     * Process an NMI webhook event
     * @param webhook - Verified webhook event
     * @returns Processing result
     */
    async processWebhook(webhook: NmiWebhookEvent): Promise<WebhookProcessingResult> {
        try {
            this.logger.info('Processing webhook', {
                event_id: webhook.event_id,
                event_type: webhook.event_type,
                transaction_id: webhook.event_body.transaction_id,
            });

            // Extract transaction ID from the webhook
            const { transaction_id } = webhook.event_body;
            this.logger.info('Detected Transaction ID', { transaction_id });

            if (!transaction_id) {
                this.logger.warn('Missing transaction ID in webhook');
                return {
                    success: false,
                    message: 'Missing transaction ID in webhook',
                };
            }

            // Find the transaction by provider ID
            const transactions = await TransactionService.getTransactionsByProviderTransactionId(transaction_id);
            if (!transactions || transactions.length === 0) {
                this.logger.warn('No transaction found with provider ID', { providerTransactionId: transaction_id });
                return {
                    success: false,
                    message: `No transaction found with provider ID: ${transaction_id}`,
                    transactionId: transaction_id,
                };
            }

            // Use the first transaction found
            const transaction = transactions[0];
            const transactionId = transaction.transactionId;

            this.logger.info('Found transaction', {
                internalTransactionId: transactionId,
                providerTransactionId: transaction_id,
                currentStatus: transaction.status,
            });

            // Determine the new status based on webhook event type
            const status = this.determineTransactionStatus(webhook.event_type, webhook.event_body);

            this.logger.info('Determined transaction status', {
                status,
            });

            if (!status) {
                this.logger.warn('Unable to determine transaction status from webhook', {
                    event_type: webhook.event_type,
                });
                return {
                    success: false,
                    message: 'Unable to determine transaction status from webhook',
                    transactionId,
                };
            }

            // Check if this is a completion event
            const isCompletionEvent = status === TransactionStatus.COMPLETED;
            this.logger.info('Is completion event', {
                isCompletionEvent,
                status,
            });

            // Prepare update data
            const updateData: TransactionUpdateData = {
                status,
                updatedAt: new Date().toISOString(),
            };

            // Add any additional data from the webhook
            if (webhook.event_body.action) {
                if (webhook.event_body.action.response_code) {
                    updateData.responseCode = webhook.event_body.action.response_code;
                }
                if (webhook.event_body.action.response_text) {
                    updateData.responseText = webhook.event_body.action.response_text;
                }
            }

            if (webhook.event_body.authorization_code) {
                updateData.authCode = webhook.event_body.authorization_code;
            }

            // If this is a completion event for a DEPOSIT or WITHDRAWAL,update the wallet balance
            if (isCompletionEvent) {
                this.logger.info('Processing completion event before wallet update', { transactionId });
                try {
                    // Get the Transaction object to access its methods
                    const fullTransaction = await TransactionService.getTransaction(transactionId);

                    this.logger.info('Full transaction before wallet update', {
                        fullTransaction,
                    });

                    if (fullTransaction) {
                        // Create a Transaction instance with all properties
                        const transactionInstance = new Transaction(
                            fullTransaction.type as TransactionType,
                            parseFloat(fullTransaction.amount.toString()),
                            fullTransaction.currency || 'USD',
                            fullTransaction.status as TransactionStatus,
                            {
                                transactionId: fullTransaction.transactionId,
                                sender:
                                    fullTransaction.senderId && fullTransaction.senderType
                                        ? {
                                              id: fullTransaction.senderId,
                                              type: fullTransaction.senderType as EntityType,
                                              name: fullTransaction.senderName,
                                          }
                                        : undefined,
                                receiver:
                                    fullTransaction.receiverId && fullTransaction.receiverType
                                        ? {
                                              id: fullTransaction.receiverId,
                                              type: fullTransaction.receiverType as EntityType,
                                              name: fullTransaction.receiverName,
                                          }
                                        : undefined,
                                providerType: fullTransaction.providerType,
                                providerId: fullTransaction.providerId,
                                providerTransactionId: fullTransaction.providerTransactionId,
                                providerReference: fullTransaction.providerReference,
                                metadata: fullTransaction.metadata,
                                balanceBefore: fullTransaction.balanceBefore,
                                balanceAfter: fullTransaction.balanceAfter,
                                completedAt: fullTransaction.completedAt,
                                createdAt: fullTransaction.createdAt,
                                updatedAt: fullTransaction.updatedAt,
                            },
                        );

                        // Complete the transaction (this will update wallet balances)
                        await transactionInstance.complete();

                        this.logger.info('Transaction completed and wallet balance updated', {
                            transactionId,
                            type: fullTransaction.type,
                            amount: fullTransaction.amount,
                        });

                        // Return successful result
                        return {
                            success: true,
                            message: 'Transaction updated and wallet balance updated',
                            transactionId,
                            updatedStatus: status,
                        };
                    }
                } catch (balanceError) {
                    this.logger.error('Error updating wallet balance', {
                        transactionId,
                        error: balanceError instanceof Error ? balanceError.message : 'Unknown error',
                    });

                    // Continue with the basic transaction update
                }
            }

            // Standard update
            this.logger.info('Updating standard transaction', { transactionId, updateData });
            const updatedTransaction = await TransactionService.updateTransaction(transactionId, updateData);

            this.logger.info('Updated transaction successfully', {
                updatedTransaction,
            });

            return {
                success: true,
                message: 'Transaction updated successfully',
                transactionId,
                updatedStatus: status,
            };
        } catch (error) {
            this.logger.error('Error processing webhook', error);

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }

    /**
     * Determine the transaction status based on the webhook event type and body
     * @param eventType - The type of NMI webhook event
     * @param eventBody - The body of the webhook event
     * @returns The determined transaction status or null if unable to determine
     */
    private determineTransactionStatus(eventType: string, eventBody: any): TransactionStatus | null {
        switch (eventType) {
            case 'transaction.sale.success':
            case 'transaction.capture.success':
                return TransactionStatus.COMPLETED;

            case 'transaction.sale.failure':
            case 'transaction.capture.failure':
            case 'transaction.auth.failure':
                return TransactionStatus.FAILED;

            case 'transaction.auth.success':
                return TransactionStatus.PENDING;

            case 'transaction.void.success':
                return TransactionStatus.CANCELLED;

            case 'transaction.refund.success':
                return TransactionStatus.REVERSED;

            default:
                // Check event body for status clues if event type isn't definitive
                if (eventBody && eventBody.status) {
                    if (eventBody.status.toLowerCase() === 'approved') {
                        return TransactionStatus.COMPLETED;
                    } else if (eventBody.status.toLowerCase() === 'declined') {
                        return TransactionStatus.FAILED;
                    }
                }

                // Unable to determine status
                return null;
        }
    }
}
</file>

<file path="lambdas/nmi/handlers/types/nmi.ts">
/**
 * NMI API Response and Request Type Definitions
 */

import { TransactionType } from '../../../layers/commons/data/entities/transaction';

// Transaction types
export enum NmiTransactionType {
    AUTH = 'auth',
    CAPTURE = 'capture',
    SALE = 'sale',
    REFUND = 'refund',
    VOID = 'void',
    CREDIT = 'credit',
    VALIDATE = 'validate',
    UPDATE = 'update',
}

// Response codes
export enum ResponseCode {
    APPROVED = '1',
    DECLINED = '2',
    ERROR = '3',
}

// Result codes
export enum ResultCode {
    APPROVED = '100',
    DECLINED = '200',
    DO_NOT_HONOR = '201',
    INSUFFICIENT_FUNDS = '202',
    OVER_LIMIT = '203',
    TRANSACTION_NOT_ALLOWED = '204',
    INCORRECT_PAYMENT_INFO = '220',
    NO_CARD_ISSUER = '221',
    NO_CARD_NUMBER = '222',
    EXPIRED_CARD = '223',
    INVALID_EXPIRATION_DATE = '224',
    INVALID_CVV = '225',
    INVALID_PIN = '226',
    CALL_ISSUER = '240',
    PICK_UP_CARD = '250',
    LOST_CARD = '251',
    STOLEN_CARD = '252',
    FRAUDULENT_CARD = '253',
    DECLINED_WITH_INSTRUCTIONS = '260',
    DECLINED_RECURRING_STOP_ALL = '261',
    DECLINED_RECURRING_STOP_THIS = '262',
    UPDATE_CARDHOLDER_DATA = '263',
    RETRY_LATER = '264',
    GATEWAY_REJECTED = '300',
    PROCESSOR_ERROR = '400',
    INVALID_MERCHANT_CONFIG = '410',
    MERCHANT_ACCOUNT_INACTIVE = '411',
    COMMUNICATION_ERROR = '420',
    ISSUER_COMMUNICATION_ERROR = '421',
    DUPLICATE_TRANSACTION = '430',
    PROCESSOR_FORMAT_ERROR = '440',
    INVALID_TRANSACTION_INFO = '441',
    PROCESSOR_FEATURE_UNAVAILABLE = '460',
    UNSUPPORTED_CARD_TYPE = '461',
    RATE_LIMIT_EXCEEDED = '301',
}

// Base authorization request parameters
export interface AuthorizationRequest {
    type: NmiTransactionType.AUTH;
    payment_token?: string;
    amount: string;
    customer_vault?: 'add_customer';
    customer_vault_id?: string;
    use_saved_card?: boolean; // Flag to indicate if we should use the user's saved card
    security_key: string;
    orderid?: string;
    // Customer information
    first_name?: string;
    last_name?: string;
    email?: string;
    phone?: string;
    // Address information
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
    country?: string;
}

// Capture request parameters
export interface CaptureRequest {
    type: NmiTransactionType.CAPTURE;
    transactionid: string; // Original transaction ID to capture
    amount?: string; // Can be equal to or less than the original amount
    security_key: string;
}

// Transaction response interface
export interface TransactionResponse {
    response: string; // 1=Approved, 2=Declined, 3=Error
    responsetext: string;
    authcode?: string;
    transactionid?: string;
    cvvresponse?: string;
    avsresponse?: string;
    orderid?: string;
    response_code?: string;
    // Customer vault related fields
    customer_vault_id?: string;
    customer_vault?: string;  // For identifying if this was an add_customer, update_customer, etc.
    cc_type?: string;
    cc_number?: string;
}

// Database transaction record
export interface TransactionRecord {
    id?: string; // UUID for the transaction record
    userId: string; // User who made the transaction
    transactionId?: string; // NMI transaction ID
    customerVaultId?: string; // NMI customer vault ID
    type: TransactionType;
    amount: string;
    status: 'pending' | 'authorized' | 'captured' | 'failed' | 'voided' | 'refunded';
    statusReason?: string;
    authCode?: string;
    responseCode?: string;
    responseText?: string;
    orderReference?: string;
    createdAt: Date;
    updatedAt: Date;
}

// Client-facing payment response
export interface PaymentResponse {
    success: boolean;
    transactionId?: string; // Provider's transaction ID
    internalTransactionId?: string; // Our internal transaction ID
    customerVaultId?: string;
    message: string;
    orderReference?: string;
    status: 'pending' | 'authorized' | 'captured' | 'failed' | 'voided' | 'refunded';
    errorCode?: string;
    transactionRecord?: TransactionRecord;
}

/**
 * Query transaction interface for NMI API
 */
export interface QueryTransactionRequest {
    security_key: string;
    transaction_id?: string;
    condition?: string;
    transaction_type?: string;
    action_type?: string;
    source?: string;
    start_date?: string;
    end_date?: string;
    result_limit?: string;
    page_number?: string;
    order_id?: string;
    email?: string;
    result_order?: 'standard' | 'reverse';
}

/**
 * Query transaction response interface for the specific fields
 * Extracting from the XML response
 */
export interface QueryTransactionResponse {
    success: boolean;
    message: string;
    transactions?: Array<{
        transaction_id: string;
        cc_bin: string;
        cc_type: string;
        condition: string;
        customerid: string;
        amount?: string;
        action_type?: string;
        date?: string;
    }>;
    errorCode?: string;
}

/**
 * Card Type Check Response from NMI API
 */
export interface CardTypeCheckResponse {
    success: boolean;
    result?: 'debit' | 'credit' | 'prepaid' | 'charge' | 'deferred_debit' | 'unknown' | 'unavailable';
    message?: string;
    errorCode?: string;
}

/**
 * Customer Vault Request for NMI API
 */
export interface CustomerVaultRequest {
    customer_vault: 'add_customer' | 'update_customer' | 'delete_customer';
    customer_vault_id?: string;
    security_key: string;
    payment_token?: string;
    first_name?: string;
    last_name?: string;
    email?: string;
    phone?: string;
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
    country?: string;
    company?: string;
    orderid?: string;
}

/**
 * Customer Vault Response from NMI API
 */
export interface CustomerVaultResponse {
    success: boolean;
    customerVaultId?: string;
    message: string;
    ccType?: string;
    ccNumber?: string;
    errorCode?: string;
}
</file>

<file path="lambdas/nmi/handlers/types/request-types.ts">
/**
 * TypeScript interfaces for NMI API request bodies
 */

/**
 * Base transaction request interface with common properties
 */
export interface BaseTransactionRequest {
    amount?: string;
    orderid?: string;
}

/**
 * Customer information interface for payment requests
 */
export interface CustomerInfo {
    first_name?: string;
    last_name?: string;
    email?: string;
    phone?: string;
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
    country?: string;
}

/**
 * Interface for the authorize transaction request
 */
export interface AuthorizeRequest extends BaseTransactionRequest, CustomerInfo {
    payment_token: string;
    customer_vault?: 'add_customer';
    use_saved_card?: boolean; // Flag to indicate if we should use the user's saved card
    use_wallet_balance?: boolean; // Flag to indicate if we should use wallet balance instead of card
    type: 'deposit' | 'p2p' | 'p2b';
    amount: string; // Making amount required to match NMI service expectations
    captureImmediately?: boolean; // Whether to capture the transaction immediately after authorization

    // Additional fields for P2P and P2B transactions
    recipient_entity_id?: string; // ID of the recipient (user or business)
    recipient_type?: string; // Type of recipient (USER or BUSINESS)
    recipient_clkk_tag?: string; // Username of the recipient
    sender_clkk_tag?: string; // Username of the sender
    recipient_current_email?: string; // Email of the recipient
    sender_current_email?: string; // Email of the sender
}

/**
 * Interface for the capture transaction request
 */
export interface CaptureRequest extends BaseTransactionRequest {
    transactionId: string;
}

/**
 * Interface for query transaction request
 */
export interface QueryTransactionRequest extends BaseTransactionRequest {
    transaction_id?: string;
    condition?: string;
    transaction_type?: string;
    action_type?: string;
    source?: string;
    start_date?: string;
    end_date?: string;
    result_limit?: string;
    page_number?: string;
    email?: string;
    result_order?: 'standard' | 'reverse';
}

/**
 * Interface for the card type check request
 */
export interface CardTypeCheckRequest {
    ccnumber: string;
}
</file>

<file path="lambdas/nmi/handlers/types/webhook.ts">
/**
 * NMI Webhook Types
 * Defines types for NMI webhook events and processing
 */

/**
 * NMI Webhook Event Types
 */
export enum NmiWebhookEventType {
    AUTH_SUCCESS = 'transaction.auth.success',
    AUTH_FAILURE = 'transaction.auth.failure',
    CAPTURE_SUCCESS = 'transaction.capture.success',
    CAPTURE_FAILURE = 'transaction.capture.failure',
    SALE_SUCCESS = 'transaction.sale.success',
    SALE_FAILURE = 'transaction.sale.failure',
    REFUND_SUCCESS = 'transaction.refund.success',
    REFUND_FAILURE = 'transaction.refund.failure',
    VOID_SUCCESS = 'transaction.void.success',
    VOID_FAILURE = 'transaction.void.failure',
}

/**
 * NMI Webhook Event Payload
 */
export interface NmiWebhookEvent {
    event_id: string;
    event_type: NmiWebhookEventType | string;
    event_body: NmiWebhookEventBody;
}

/**
 * NMI Webhook Event Body
 */
export interface NmiWebhookEventBody {
    merchant: {
        id: string;
        name: string;
    };
    features: {
        is_test_mode: boolean;
    };
    transaction_id: string;
    transaction_type: string;
    condition: string;
    processor_id: string;
    ponumber: string;
    order_description: string;
    order_id: string;
    customerid: string;
    customertaxid: string;
    website: string;
    shipping: string;
    currency: string;
    tax: string;
    surcharge: string;
    convenience_fee: string;
    misc_fee: string;
    misc_fee_name: string;
    cash_discount: string;
    tip: string;
    requested_amount: string;
    shipping_carrier: string;
    tracking_number: string;
    shipping_date: string;
    partial_payment_id: string;
    partial_payment_balance: string;
    platform_id: string;
    authorization_code: string;
    social_security_number: string;
    drivers_license_number: string;
    drivers_license_state: string;
    drivers_license_dob: string;
    duty_amount: string;
    discount_amount: string;
    national_tax_amount: string;
    summary_commodity_code: string;
    alternate_tax_amount: string;
    vat_tax_amount: string;
    vat_tax_rate: string;
    merchant_advice_code: string;
    merchant_advice_code_description: string;
    association_response_code: string;
    association_response_code_description: string;
    additional_processor_responses: string;
    additional_processor_response_descriptions: string;
    billing_address: {
        first_name: string;
        last_name: string;
        address_1: string;
        address_2: string;
        company: string;
        city: string;
        state: string;
        postal_code: string;
        country: string;
        email: string;
        phone: string;
        cell_phone: string;
        fax: string;
    };
    shipping_address: {
        first_name: string;
        last_name: string;
        address_1: string;
        address_2: string;
        company: string;
        city: string;
        state: string;
        postal_code: string;
        country: string;
        email: string;
        phone: string;
        fax: string;
    };
    card: {
        cc_number: string;
        cc_exp: string;
        cavv: string;
        cavv_result: string;
        xid: string;
        eci: string;
        avs_response: string;
        csc_response: string;
        cardholder_auth: string;
        cc_start_date: string;
        cc_issue_number: string;
        card_balance: string;
        card_available_balance: string;
        entry_mode: string;
        cc_bin: string;
        cc_type: string;
        feature_token: string;
    };
    merchant_defined_fields: Record<string, string>;
    action: {
        amount: string;
        action_type: string;
        date: string;
        success: string;
        ip_address: string;
        source: string;
        api_method: string;
        username: string;
        response_text: string;
        response_code: string;
        processor_response_text: string;
        tap_to_mobile: boolean;
        network_token_used: boolean;
        processor_response_code: string;
        processor_response_description: string;
        device_license_number: string;
        device_nickname: string;
    };
}

/**
 * NMI Webhook Verification Request
 */
export interface WebhookVerificationRequest {
    webhookBody: string;
    signingKey: string;
    nonce: string;
    signature: string;
}

/**
 * NMI Webhook Verification Result
 */
export interface WebhookVerificationResult {
    isValid: boolean;
    message?: string;
    webhook?: NmiWebhookEvent;
}

/**
 * NMI Webhook Handler Response
 */
export interface WebhookHandlerResponse {
    statusCode: number;
    headers?: Record<string, string>;
    body: string;
}

/**
 * NMI Webhook Processing Result
 */
export interface WebhookProcessingResult {
    success: boolean;
    message: string;
    transactionId?: string;
    updatedStatus?: string;
}
</file>

<file path="lambdas/nmi/handlers/validators/request-validator.ts">
/**
 * Request validation utility
 */

import { createLogger } from 'commons/utils/logger_v2';

const logger = createLogger('NmiRequestValidator');

/**
 * Validate request against JSON schema
 * @param data - Request data to validate
 * @param schema - JSON schema to validate against
 * @returns Validation result with errors if any
 */
export const validateRequest = (data: any, schema: any): { isValid: boolean; errors: string[] } => {
    logger.info('Validating request', { schemaType: schema.title || 'unknown' });

    const errors: string[] = [];

    // Check required fields
    if (schema.required && Array.isArray(schema.required)) {
        schema.required.forEach((field: string) => {
            if (data[field] === undefined || data[field] === null || data[field] === '') {
                errors.push(`Field '${field}' is required`);
            }
        });
    }

    // Validate field types and formats
    if (schema.properties && Object.keys(schema.properties).length > 0) {
        Object.entries(schema.properties).forEach(([field, fieldSchema]: [string, any]) => {
            if (data[field] !== undefined && data[field] !== null) {
                // Type validation
                if (fieldSchema.type === 'string' && typeof data[field] !== 'string') {
                    errors.push(`Field '${field}' must be a string`);
                } else if (fieldSchema.type === 'number' && typeof data[field] !== 'number') {
                    errors.push(`Field '${field}' must be a number`);
                } else if (fieldSchema.type === 'boolean' && typeof data[field] !== 'boolean') {
                    errors.push(`Field '${field}' must be a boolean`);
                } else if (fieldSchema.type === 'object' && typeof data[field] !== 'object') {
                    errors.push(`Field '${field}' must be an object`);
                } else if (fieldSchema.type === 'array' && !Array.isArray(data[field])) {
                    errors.push(`Field '${field}' must be an array`);
                }

                // Pattern validation for strings
                if (fieldSchema.pattern && typeof data[field] === 'string') {
                    const regex = new RegExp(fieldSchema.pattern);
                    if (!regex.test(data[field])) {
                        errors.push(`Field '${field}' does not match required pattern`);
                    }
                }

                // Enum validation
                if (fieldSchema.enum && Array.isArray(fieldSchema.enum) && !fieldSchema.enum.includes(data[field])) {
                    errors.push(`Field '${field}' must be one of: ${fieldSchema.enum.join(', ')}`);
                }

                // Email format validation (simple regex)
                if (fieldSchema.format === 'email' && typeof data[field] === 'string') {
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    if (!emailRegex.test(data[field])) {
                        errors.push(`Field '${field}' must be a valid email address`);
                    }
                }
            }
        });
    }

    // Check for additional properties if not allowed
    if (schema.additionalProperties === false) {
        const allowedProps = Object.keys(schema.properties || {});
        Object.keys(data).forEach((prop) => {
            if (!allowedProps.includes(prop)) {
                errors.push(`Property '${prop}' is not allowed`);
            }
        });
    }

    const isValid = errors.length === 0;
    logger.info('Request validation completed', { isValid, errorCount: errors.length });

    return { isValid, errors };
};
</file>

<file path="lambdas/nmi/handlers/validators/schemas.ts">
/**
 * NMI request validation schemas
 */

export const authorizeRequestSchema = {
    type: 'object',
    required: ['amount'],
    properties: {
        amount: {
            type: 'string',
            pattern: '^[0-9]+(.[0-9]{1,2})?$', // Validates amount format (e.g., 10.99)
            description: 'Transaction amount in decimal format',
        },
        type: {
            type: 'string',
            enum: ['deposit', 'p2p', 'p2b'],
            description: 'Type of transaction',
        },
        payment_token: {
            type: 'string',
            description: 'Payment token from Collect.js',
        },
        customer_vault: {
            type: 'string',
            enum: ['add_customer'],
            description: 'Add customer to vault',
        },
        customer_vault_id: {
            type: 'string',
            description: 'Customer vault ID for returning customers',
        },
        use_saved_card: {
            type: 'boolean',
            description: 'Flag to indicate if the user wants to use their saved card',
        },
        orderid: {
            type: 'string',
            description: 'Order reference ID',
        },
        first_name: {
            type: 'string',
            description: 'Customer first name',
        },
        last_name: {
            type: 'string',
            description: 'Customer last name',
        },
        email: {
            type: 'string',
            format: 'email',
            description: 'Customer email address',
        },
        phone: {
            type: 'string',
            description: 'Customer phone number',
        },
        address1: {
            type: 'string',
            description: 'Customer address line 1',
        },
        address2: {
            type: 'string',
            description: 'Customer address line 2',
        },
        city: {
            type: 'string',
            description: 'Customer city',
        },
        state: {
            type: 'string',
            description: 'Customer state or province',
        },
        zip: {
            type: 'string',
            description: 'Customer postal code',
        },
        country: {
            type: 'string',
            description: 'Customer country',
        },
        captureImmediately: {
            type: 'boolean',
            description: 'Whether to capture the transaction immediately after authorization',
        },
        use_wallet_balance: {
            type: 'boolean',
            description: 'Flag to indicate if the user wants to use their wallet balance',
        },
        recipient_entity_id: {
            type: 'string',
            description: 'ID of the recipient entity',
        },
        recipient_type: {
            type: 'string',
            description: 'Type of recipient (user, business, etc.)',
        },
        recipient_clkk_tag: {
            type: 'string',
            description: 'Clkk tag of the recipient',
        },
        sender_clkk_tag: {
            type: 'string',
            description: 'Clkk tag of the sender',
        },
        recipient_current_email: {
            type: 'string',
            format: 'email',
            description: 'Current email of the recipient',
        },
        sender_current_email: {
            type: 'string',
            format: 'email',
            description: 'Current email of the sender',
        },
    },
    additionalProperties: false,
};

export const captureRequestSchema = {
    type: 'object',
    required: ['transactionId'],
    properties: {
        transactionId: {
            type: 'string',
            description: 'Original transaction ID to capture',
        },
        amount: {
            type: 'string',
            pattern: '^[0-9]+(.[0-9]{1,2})?$',
            description: 'Amount to capture, can be equal to or less than original amount',
        },
    },
    additionalProperties: false,
};

export const queryTransactionSchema = {
    type: 'object',
    properties: {
        transaction_id: {
            type: 'string',
            description: 'Transaction ID to query',
        },
        condition: {
            type: 'string',
            description: 'Transaction condition (pending, pendingsettlement, complete, etc.)',
        },
        transaction_type: {
            type: 'string',
            description: 'Transaction type (cc, ck)',
        },
        action_type: {
            type: 'string',
            description: 'Action type (sale, refund, credit, auth, capture, void, return)',
        },
        source: {
            type: 'string',
            description: 'Transaction source (api, batch_upload, mobile, etc.)',
        },
        start_date: {
            type: 'string',
            description: 'Start date for transaction search (YYYYMMDDhhmmss)',
        },
        end_date: {
            type: 'string',
            description: 'End date for transaction search (YYYYMMDDhhmmss)',
        },
        result_limit: {
            type: 'string',
            description: 'Maximum number of results to return',
        },
        page_number: {
            type: 'string',
            description: 'Page number for paginated results',
        },
        order_id: {
            type: 'string',
            description: 'Order ID to search for',
        },
        email: {
            type: 'string',
            description: 'Customer email to search for',
        },
        result_order: {
            type: 'string',
            enum: ['standard', 'reverse'],
            description: 'Sort order for results (standard=oldest to newest, reverse=newest to oldest)',
        },
    },
    additionalProperties: false,
};

export const cardTypeCheckSchema = {
    type: 'object',
    required: ['ccnumber'],
    properties: {
        ccnumber: {
            type: 'string',
            minLength: 6,
            maxLength: 16,
            pattern: '^[0-9]+$',
            description: 'Credit card Issuer Identification Number (IIN) - at least first 6 digits',
        },
    },
    additionalProperties: false,
};
</file>

<file path="lambdas/nmi/handlers/nmi.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { NmiService } from './services/nmi-service';
import { KmsService } from 'commons/services/KmsService';
import { createLogger } from 'commons/utils/logger_v2';
import { kmsKeyId } from 'commons/utils/variables';
import { validateRequest } from './validators/request-validator';
import {
    authorizeRequestSchema,
    captureRequestSchema,
    queryTransactionSchema,
    cardTypeCheckSchema,
} from './validators/schemas';
import {
    AuthorizeRequest,
    CaptureRequest,
    QueryTransactionRequest,
    CardTypeCheckRequest,
} from '../types/request-types';
import { PaymentResponse } from './types/nmi';
import { TransactionType } from 'commons/data/entities/transaction';
import { EntityTypeString } from 'commons/data/entities/entity';
import { NMI_BASE_URLS } from './config';

// HTTP Status Codes
enum StatusCodes {
    OK = 200,
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    INTERNAL_SERVER_ERROR = 500,
}

const logger = createLogger('NmiHandlers');

// NMI Configuration - in a real environment, these would come from environment variables or secrets
const nmiConfig = {
    apiUrl: NMI_BASE_URLS.GATEWAY,
    securityKey: process.env.NMI_PRIVATE_KEY || '',
    timeout: parseInt(process.env.NMI_API_TIMEOUT || '10000', 10),
};

// Initialize services
const kmsService = new KmsService(kmsKeyId);
const nmiService = new NmiService(kmsService, nmiConfig);

/**
 * Parse JSON body with error handling and type checking
 * @param body - Request body as string
 * @returns Parsed body object or null if invalid
 */
const parseBody = <T>(body: string | null): T | null => {
    if (!body) return null;

    try {
        return JSON.parse(body) as T;
    } catch (error) {
        logger.error('Error parsing request body', error);
        return null;
    }
};

/**
 * Build a standardized Lambda response
 * @param statusCode - HTTP status code
 * @param body - Response body object
 * @returns Formatted API Gateway response
 */
const buildResponse = (statusCode: number, body: any): APIGatewayProxyResult => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type,Authorization',
            'Access-Control-Allow-Methods': 'OPTIONS,POST,GET',
        },
        body: JSON.stringify(body),
    };
};

/**
 * Echo endpoint handler for health checks
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const echoHandler = async (event: APIGatewayProxyEvent, context: Context): Promise<APIGatewayProxyResult> => {
    logger.info('Echo endpoint called', { requestId: context.awsRequestId });

    const entityId = event.requestContext.authorizer?.userId;

    logger.info('Entity ID', { entityId });
    //show ip address
    const ip = event.requestContext.identity.sourceIp;
    logger.info('IP address', { ip });
    // Check outbound IP
    let outboundIp = null;
    try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        outboundIp = data.ip;
        logger.info('Outbound IP address', { outboundIp });
    } catch (error) {
        logger.error('Error checking outbound IP', error);
    }

    try {
        const result = await nmiService.getEchoEndpoint();
        return buildResponse(StatusCodes.OK, { ...result, ip, outboundIp, entityId });
    } catch (error) {
        logger.error('Error in echo endpoint', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, { error: 'Internal server error' });
    }
};

/**
 * Deposit Authorize transaction handler
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const authorizeHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Authorize transaction called', { requestId: context.awsRequestId });

    const entityId = event.requestContext.authorizer?.userId;

    if (!entityId) {
        return buildResponse(StatusCodes.UNAUTHORIZED, { success: false, error: 'User authentication required' });
    }

    try {
        // Parse and validate body
        const body = parseBody<AuthorizeRequest>(event.body);
        if (!body) {
            return buildResponse(StatusCodes.BAD_REQUEST, { success: false, error: 'Invalid request body' });
        }

        //log request body
        logger.info('Request body', { body });

        // Validate request
        const { errors, isValid } = validateRequest(body, authorizeRequestSchema);
        if (!isValid) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error_type: 'ValidationError',
                errors,
            });
        }

        //Get Transaction type from user
        // Map the request type to the actual TransactionType enum
        let transactionType: TransactionType;
        switch (body.type) {
            case 'p2p':
                transactionType = TransactionType.P2P;
                break;
            case 'p2b':
                transactionType = TransactionType.P2B;
                break;
            default:
                transactionType = TransactionType.DEPOSIT; // Default to deposit
        }

        // Process authorization
        logger.info('Processing payment authorization', {
            entityId,
            amount: body.amount,
            transactionType,
            customer_vault: body.customer_vault,
            use_saved_card: body.use_saved_card,
        });

        // Log the payment scenario - help with debugging
        const paymentScenario =
            body.customer_vault === 'add_customer'
                ? 'new_vault'
                : body.use_saved_card
                ? 'existing_vault'
                : 'direct_payment';
        logger.info('Payment scenario', { paymentScenario });

        // Extract additional parameters for P2P and P2B transactions
        const useWalletBalance = body.use_wallet_balance === true;
        const options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientClkkTag?: string;
            senderClkkTag?: string;
            recipientCurrentEmail?: string;
            senderCurrentEmail?: string;
        } = {
            recipientEntityId: body.recipient_entity_id,
            recipientType: body.recipient_type as EntityTypeString,
            recipientClkkTag: body.recipient_clkk_tag,
            senderClkkTag: body.sender_clkk_tag,
            recipientCurrentEmail: body.recipient_current_email,
            senderCurrentEmail: body.sender_current_email,
        };

        logger.info('Transaction options', {
            useWalletBalance,
            options,
        });

        // Make the routing decision at the handler level
        let response: PaymentResponse;

        if (useWalletBalance && (transactionType === TransactionType.P2P || transactionType === TransactionType.P2B)) {
            logger.info('Handler detected wallet transfer, calling wallet transfer method directly', {
                entityId,
                recipientId: options.recipientEntityId,
                amount: body.amount,
                transactionType,
            });

            response = await nmiService.handleWalletTransfer(
                entityId,
                body,
                transactionType as TransactionType.P2P | TransactionType.P2B,
                options as { recipientEntityId: string; [key: string]: any },
            );
        } else {
            logger.info('Processing as card payment', {
                entityId,
                amount: body.amount,
                transactionType,
            });

            response = await nmiService.authorizeTransaction(entityId, body, transactionType, options);
        }
        logger.info('Authorization response', { response });

        // For wallet transfers, we don't need to capture as they're already completed
        // Only capture for card payments that have a provider transaction ID
        if (response.success && response.transactionId && !useWalletBalance) {
            logger.info('Card payment authorization successful, proceeding with immediate capture', {
                providerTransactionId: response.transactionId,
                internalTransactionId: response.transactionRecord?.transactionId,
                amount: body.amount,
            });

            try {
                // Pass the provider's transaction ID (from NMI) to the capture method
                const captureResponse = await nmiService.captureTransaction(
                    entityId,
                    response.transactionId,
                    body.amount,
                );

                return buildResponse(StatusCodes.OK, captureResponse);
            } catch (captureError) {
                logger.error('Error during capture after authorization', {
                    error: captureError,
                    providerTransactionId: response.transactionId,
                    internalTransactionId: response.transactionRecord?.transactionId,
                    originalResponse: response,
                });

                // Return the original auth response if capture fails
                return buildResponse(StatusCodes.OK, {
                    ...response,
                    captureStatus: 'failed',
                    captureError: captureError instanceof Error ? captureError.message : 'Unknown capture error',
                });
            }
        } else if (response.success && useWalletBalance) {
            // For wallet transfers, the transaction is already complete - no capture needed
            logger.info('Wallet transfer completed successfully, no capture needed', {
                internalTransactionId: response.internalTransactionId || response.transactionRecord?.transactionId,
                status: response.status,
            });
        }

        return buildResponse(StatusCodes.OK, response);
    } catch (error) {
        logger.error('Error in authorize transaction', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: 'Internal server error',
            message: error instanceof Error ? error.message : 'Unknown error occurred',
        });
    }
};

/**
 * Capture transaction handler
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const captureHandler = async (event: APIGatewayProxyEvent, context: Context): Promise<APIGatewayProxyResult> => {
    logger.info('Capture transaction called', { requestId: context.awsRequestId });

    try {
        // Parse and validate body
        const body = parseBody<CaptureRequest>(event.body);
        if (!body) {
            return buildResponse(StatusCodes.BAD_REQUEST, { error: 'Invalid request body' });
        }

        // Extract user ID from authorizer
        const userId = event.requestContext.authorizer?.userId;
        if (!userId) {
            return buildResponse(StatusCodes.UNAUTHORIZED, { error: 'User authentication required' });
        }

        // Validate request
        const { errors, isValid } = validateRequest(body, captureRequestSchema);
        if (!isValid) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error_type: 'ValidationError',
                errors,
            });
        }

        // Process capture
        logger.info('Processing payment capture', {
            userId,
            transactionId: body.transactionId,
            amount: body.amount,
        });

        const response = await nmiService.captureTransaction(userId, body.transactionId, body.amount);

        return buildResponse(StatusCodes.OK, response);
    } catch (error) {
        logger.error('Error in capture transaction', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: 'Internal server error',
            message: error instanceof Error ? error.message : 'Unknown error occurred',
        });
    }
};

/**
 * Query transactions handler
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const queryTransactionsHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Query transactions called', { requestId: context.awsRequestId });

    try {
        // Parse and validate body
        const body = parseBody<QueryTransactionRequest>(event.body);
        if (!body) {
            return buildResponse(StatusCodes.BAD_REQUEST, { error: 'Invalid request body' });
        }

        // Extract user ID from authorizer
        const userId = event.requestContext.authorizer?.userId;
        if (!userId) {
            return buildResponse(StatusCodes.UNAUTHORIZED, { error: 'User authentication required' });
        }

        // Validate request
        const { errors, isValid } = validateRequest(body, queryTransactionSchema);
        if (!isValid) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error_type: 'ValidationError',
                errors,
            });
        }

        // Process query
        logger.info('Processing transaction query', {
            userId,
            transactionId: body.transaction_id,
            condition: body.condition,
        });

        const response = await nmiService.queryTransactions(body);

        return buildResponse(StatusCodes.OK, response);
    } catch (error) {
        logger.error('Error in query transactions', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            error: 'Internal server error',
            message: error instanceof Error ? error.message : 'Unknown error occurred',
        });
    }
};

/**
 * Card type check handler
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const cardTypeCheckHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Card type check called', { requestId: context.awsRequestId });

    try {
        // Parse and validate body
        const body = parseBody<CardTypeCheckRequest>(event.body);
        if (!body) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error: 'Invalid request body',
            });
        }

        // Validate request
        const { errors, isValid } = validateRequest(body, cardTypeCheckSchema);
        if (!isValid) {
            return buildResponse(StatusCodes.BAD_REQUEST, {
                success: false,
                error_type: 'ValidationError',
                errors,
            });
        }

        // Process card type check
        logger.info('Processing card type check', {
            ccnumber: body.ccnumber.substring(0, 3) + '***', // Log only first 3 digits for security
        });

        const response = await nmiService.checkCardType(body.ccnumber);
        return buildResponse(StatusCodes.OK, response);
    } catch (error) {
        logger.error('Error in card type check', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, {
            success: false,
            result: 'unavailable',
            error: 'Internal server error',
            message: error instanceof Error ? error.message : 'Unknown error occurred',
        });
    }
};
</file>

<file path="lambdas/nmi/handlers/package.json">
{
    "name": "nmi-handlers",
    "version": "1.0.0",
    "description": "NMI Payment Handlers",
    "main": "nmi.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0",
        "@aws-sdk/client-secrets-manager": "^3.716.0",
        "@aws-sdk/client-sns": "^3.716.0",
        "@aws-sdk/client-sqs": "^3.716.0",
        "fast-xml-parser": "^5.2.0"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="lambdas/nmi/handlers/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/nmi/services/nmi-service.ts">
import { createLogger } from '../../../layers/commons/utils/logger_v2';
import { KmsService } from '../../../layers/commons/services/KmsService';
import { XMLParser } from 'fast-xml-parser';
import { EntityTypeString } from '../../../layers/commons/data/entities/entity';
import {
    NmiCustomer,
    createNmiCustomer,
    listNmiCustomersByEntity,
    getNmiCustomerByVaultId,
} from '../../../layers/commons/services/nmi/nmi-customer';
import {
    AuthorizationRequest,
    CaptureRequest,
    TransactionResponse,
    PaymentResponse,
    TransactionRecord,
    ResponseCode,
    ResultCode,
    NmiTransactionType,
    QueryTransactionRequest,
    QueryTransactionResponse,
    CardTypeCheckResponse,
    CustomerVaultRequest,
    CustomerVaultResponse,
} from '../types/nmi';
import { URLSearchParams } from 'url';
import {
    TransactionType,
    TransactionStatus,
    TransactionService,
    Transaction,
} from '../../../layers/commons/data/entities/transaction';
import { Money } from '../../../layers/commons/data/entities/money';
import { WalletService, CurrencyCode } from '../../../layers/commons/data/entities/wallet';
import { NMI_ENDPOINTS, NMI_API_URLS, NMI_AUTH_PREFIXES, NMI_FEATURES } from '../config';

/**
 * Configuration for NMI payment gateway
 */
interface NmiConfig {
    /** API endpoint for NMI transactions */
    apiUrl: string;
    /** Security key for NMI authentication */
    securityKey: string;
    /** Timeout for API requests in milliseconds */
    timeout: number;
}

/**
 * Service class for handling NMI payment gateway operations
 */
export class NmiService {
    private logger = createLogger('NmiService');
    private kmsService: KmsService;
    private config: NmiConfig;

    /**
     * Initialize the NMI Service
     * @param kmsService - KMS service for data encryption
     * @param config - Configuration for NMI gateway
     */
    constructor(kmsService: KmsService, config: NmiConfig) {
        this.kmsService = kmsService;
        this.config = config;
    }

    /**
     * Health check endpoint
     * @returns Success response
     */
    async getEchoEndpoint(): Promise<{ message: string; success: boolean }> {
        this.logger.info('Executing NMI echo endpoint');
        return {
            message: 'ok',
            success: true,
        };
    }

    /**
     * Direct method to handle wallet-to-wallet transfers without going through NMI
     * @param entityId - Sender's ID
     * @param request - Transfer request parameters
     * @param transactionType - Must be P2P or P2B
     * @param options - Additional options for transaction processing
     * @returns Payment response
     */
    async handleWalletTransfer(
        entityId: string,
        request: { amount: string },
        transactionType: TransactionType.P2P | TransactionType.P2B,
        options: {
            recipientEntityId: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        },
    ): Promise<PaymentResponse> {
        if (!options.recipientEntityId) {
            return {
                success: false,
                message: 'Recipient ID is required for wallet transfers',
                status: 'failed',
                errorCode: 'INVALID_REQUEST',
            };
        }

        this.logger.info('Processing wallet-to-wallet transfer', {
            entityId,
            transactionType,
            amount: request.amount,
            recipientId: options.recipientEntityId,
        });

        try {
            // Create transaction record first (with useWalletBalance=true for wallet transfers)
            const transaction = await this.createTransactionRecord(
                entityId,
                request.amount,
                transactionType,
                true, // Always true for wallet transfers
                options,
            );

            // Process the wallet transfer
            return this.processWalletToWalletTransfer(
                transaction,
                entityId,
                options.recipientEntityId,
                request.amount,
                transactionType,
            );
        } catch (error) {
            this.logger.error('Error processing wallet transfer', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Authorize a card transaction through NMI payment provider
     * @param entityId - User's ID
     * @param request - Authorization request parameters
     * @param transactionType - Transaction type
     * @param options - Additional options for transaction processing
     * @returns Payment response
     */
    async authorizeTransaction(
        entityId: string,
        request: Omit<AuthorizationRequest, 'type' | 'security_key'>,
        transactionType: TransactionType,
        options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        } = {},
    ): Promise<PaymentResponse> {
        this.logger.info('Authorizing card transaction', {
            entityId,
            transactionType,
            amount: request.amount,
        });

        try {
            // Create transaction record first
            const transaction = await this.createTransactionRecord(
                entityId,
                request.amount,
                transactionType,
                false, // Always false for card payments
                options,
            );

            // Process as a card payment
            return this.processCardPayment(transaction, entityId, request, transactionType, options);
        } catch (error) {
            this.logger.error('Error authorizing card transaction', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Process a wallet-to-wallet transfer (no payment provider needed)
     * @param transaction - Transaction record
     * @param senderId - Sender's ID
     * @param recipientId - Recipient's ID
     * @param amount - Transaction amount
     * @param transactionType - Transaction type (P2P or P2B)
     * @returns Payment response
     */
    private async processWalletToWalletTransfer(
        transaction: Transaction,
        senderId: string,
        recipientId?: string,
        amount?: string,
        transactionType?: TransactionType,
    ): Promise<PaymentResponse> {
        this.logger.info(`Processing ${transactionType} wallet-to-wallet transfer`, {
            transactionId: transaction.transactionId,
            senderId,
            recipientId,
            amount,
        });

        try {
            // This will trigger the wallet update for the recipient
            await transaction.complete();

            this.logger.info(`${transactionType} wallet-to-wallet transfer completed successfully`, {
                transactionId: transaction.transactionId,
                senderId,
                recipientId,
                amount,
                status: transaction.status,
            });

            // Create a payment response without NMI details
            return {
                success: true,
                message: `${transactionType} transfer processed successfully`,
                status: 'captured', // Use 'captured' status for completed transfers
                internalTransactionId: transaction.transactionId,
            };
        } catch (error) {
            this.logger.error(`Error processing ${transactionType} wallet-to-wallet transfer`, {
                error: error instanceof Error ? error.message : 'Unknown error',
                transactionId: transaction.transactionId,
                senderId,
                recipientId,
            });

            // Mark transaction as failed
            transaction.status = TransactionStatus.FAILED;
            await transaction.update();

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
                internalTransactionId: transaction.transactionId,
            };
        }
    }

    /**
     * Process a card payment through NMI payment provider
     * @param transaction - Transaction record
     * @param entityId - User's ID
     * @param request - Authorization request parameters
     * @param transactionType - Transaction type
     * @param options - Additional options for transaction processing
     * @returns Payment response
     */
    private async processCardPayment(
        transaction: Transaction,
        entityId: string,
        request: Omit<AuthorizationRequest, 'type' | 'security_key'>,
        transactionType: TransactionType,
        options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        } = {},
    ): Promise<PaymentResponse> {
        // Determine the payment scenario based on request parameters
        const paymentScenario =
            request.customer_vault === 'add_customer'
                ? 'new_vault'
                : request.use_saved_card
                ? 'existing_vault'
                : 'direct_payment';

        this.logger.info('Processing card payment', {
            paymentScenario,
            transactionId: transaction.transactionId,
            entityId,
        });

        // Create the complete request with type and security key
        const fullRequest: AuthorizationRequest = {
            ...request,
            type: NmiTransactionType.AUTH,
            security_key: this.config.securityKey,
        };

        // If using an existing vault ID, fetch it from the database based on entityId
        if (paymentScenario === 'existing_vault') {
            try {
                // Get the customer vaults for this user - we only expect one per user
                const customerVaults = await listNmiCustomersByEntity(entityId);

                if (!customerVaults || customerVaults.length === 0) {
                    throw new Error(`No saved payment method found for user ${entityId}`);
                }

                // Just use the first vault since there should only be one
                const nmiCustomer = customerVaults[0];
                const customerVaultId = nmiCustomer.customerVaultId;

                this.logger.info('Using existing customer vault ID', {
                    customerVaultId,
                    ccType: nmiCustomer.ccType,
                });

                // Add the customer_vault_id to the request
                fullRequest.customer_vault_id = customerVaultId;
            } catch (vaultError) {
                this.logger.error('Error fetching customer vault for user', {
                    error: vaultError instanceof Error ? vaultError.message : 'Unknown error',
                    entityId,
                });
                throw new Error(
                    `Unable to use saved card: ${vaultError instanceof Error ? vaultError.message : 'Unknown error'}`,
                );
            }
        }

        this.logger.info('Sending payment request to NMI', {
            transactionId: transaction.transactionId,
        });

        // Process authorization through NMI
        const response: TransactionResponse = await this.processNmiRequest<AuthorizationRequest>(
            fullRequest,
            NMI_ENDPOINTS.TRANSACTION,
        );

        // log response
        this.logger.info('NMI payment response received back on method', {
            response,
        });

        this.logger.info('NMI payment response received', {
            providerTransactionId: response.transactionid,
            authCode: response.authcode,
            responseCode: response.response_code,
            responseText: response.responsetext,
            internalTransactionId: transaction.transactionId,
        });

        // Update the transaction with provider details
        const updatedTransaction = await this.updateTransactionWithProviderDetails(transaction.transactionId, response);

        // log vault and

        // If a customer vault ID was returned, store it for future use
        if (response.customer_vault_id && request.customer_vault === 'add_customer') {
            try {
                this.logger.info('Customer vault ID detected in response, storing for entity', {
                    entityId,
                    customerVaultId: response.customer_vault_id,
                    ccType: response.cc_type,
                });

                // Check if user already has a vault record and delete it first
                await this.deleteExistingVaultRecords(entityId);

                // Create NMI customer record for this user
                await createNmiCustomer(entityId, 'USER', response.customer_vault_id, {
                    ccType: response.cc_type,
                    ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
                });

                this.logger.info('Successfully stored NMI customer vault record', {
                    entityId,
                    customerVaultId: response.customer_vault_id,
                });
            } catch (vaultError) {
                // Log error but don't fail the transaction - the payment still succeeded
                this.logger.error('Error storing customer vault information', {
                    error: vaultError instanceof Error ? vaultError.message : 'Unknown error',
                    entityId,
                    customerVaultId: response.customer_vault_id,
                });
            }
        }

        // Create a payment response that includes both transaction IDs
        const paymentResponse = this.createPaymentResponse(response, updatedTransaction);

        // Add the internal transaction ID explicitly
        return {
            ...paymentResponse,
            internalTransactionId: transaction.transactionId,
        };
    }

    /**
     * Create a transaction record in the database
     * @param entityId - User's ID initiating the transaction
     * @param amount - Transaction amount
     * @param transactionType - Type of transaction
     * @param useWalletBalance - Whether to use wallet balance for payment (vs card)
     * @param options - Additional options for transaction creation
     * @returns Created transaction record
     */
    private async createTransactionRecord(
        entityId: string,
        amount: string,
        transactionType: TransactionType,
        useWalletBalance: boolean = false,
        options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        } = {},
    ): Promise<Transaction> {
        if (transactionType === TransactionType.DEPOSIT) {
            this.logger.info('Creating deposit transaction record', {
                entityId,
                amount,
            });

            // For a deposit, the user (entityId) is the recipient
            const transaction = await TransactionService.createDeposit(
                entityId, // recipientId (the user receiving funds)
                'USER', // recipientType
                TransactionStatus.PENDING,
                amount,
                '', // senderId (empty for card deposit)
            );

            this.logger.info('Deposit transaction created', {
                transactionId: transaction.transactionId,
                amount,
                entityId,
            });

            return transaction;
        } else if (transactionType === TransactionType.P2P) {
            const {
                recipientEntityId,
                recipientType,
                recipientClkkTag,
                senderClkkTag,
                recipientCurrentEmail,
                senderCurrentEmail,
            } = options;
            this.logger.info('Creating P2P transaction record at function', {
                entityId,
                recipientEntityId,
                amount,
                useWalletBalance,
                options,
            });

            if (!recipientEntityId) {
                throw new Error('Recipient entity ID is required for P2P transfers');
            }

            this.logger.info('Creating P2P transaction record', {
                entityId,
                recipientEntityId,
                amount,
                useWalletBalance,
                options,
            });

            // Create metadata with additional information
            const metadata: any = {
                description: `P2P transfer from ${senderClkkTag || entityId} to ${
                    recipientClkkTag || recipientEntityId
                }`,
                paymentMethod: useWalletBalance ? 'wallet' : 'card',
            };

            if (senderClkkTag) metadata.senderClkkTag = senderClkkTag;
            if (recipientClkkTag) metadata.recipientClkkTag = recipientClkkTag;
            if (recipientCurrentEmail) metadata.recipientCurrentEmail = recipientCurrentEmail;
            if (senderCurrentEmail) metadata.senderCurrentEmail = senderCurrentEmail;

            this.logger.info('Creating P2P transaction record after metadata', {
                entityId,
                recipientEntityId,
                amount,
                useWalletBalance,
                options,
                metadata,
            });

            // Create a single transaction for P2P transfer
            const transaction = new Transaction(TransactionType.P2P, amount, 'USD', TransactionStatus.PENDING, {
                sender: {
                    id: entityId,
                    type: 'USER',
                    name: senderClkkTag,
                },
                receiver: {
                    id: recipientEntityId,
                    type: recipientType || 'USER',
                    name: recipientClkkTag,
                },
                metadata,
            });

            // If using wallet balance, deduct from sender's wallet immediately
            if (useWalletBalance) {
                this.logger.info('Decided to deduct from sender wallet', {
                    entityId,
                    amount,
                    transactionId: transaction.transactionId,
                });
                try {
                    // Check if sender has sufficient funds
                    const wallet = await WalletService.getWallet(entityId, 'USER', 'USD');

                    this.logger.info('Got Wallet from DB', {
                        entityId,
                        wallet,
                    });

                    if (!wallet) {
                        throw new Error('Sender wallet not found');
                    }

                    const walletBalance = new Money(wallet.balance, 'USD');
                    const transferAmount = new Money(amount, 'USD');

                    if (walletBalance.lessThan(transferAmount)) {
                        throw new Error('Insufficient funds in wallet');
                    }

                    // Deduct from sender's wallet
                    await WalletService.withdraw(entityId, 'USER', transferAmount, transaction.transactionId, 'USD');

                    this.logger.info('Deducted amount from sender wallet', {
                        senderId: entityId,
                        amount: transferAmount.toString(),
                        transactionId: transaction.transactionId,
                    });

                    // Store the balance before and after in the transaction
                    transaction.balanceBefore = walletBalance.toString();
                    transaction.balanceAfter = walletBalance.subtract(transferAmount).toString();
                } catch (error) {
                    this.logger.error('Error deducting from sender wallet', {
                        error: error instanceof Error ? error.message : 'Unknown error',
                        senderId: entityId,
                        amount,
                    });
                    throw error;
                }
            }

            // Create the transaction record
            await transaction.create();

            this.logger.info('P2P transaction created', {
                transactionId: transaction.transactionId,
                senderId: entityId,
                receiverId: recipientEntityId,
                amount,
                useWalletBalance,
            });

            return transaction;
        } else if (transactionType === TransactionType.P2B) {
            const { recipientEntityId, recipientType, recipientClkkTag, senderClkkTag } = options;

            if (!recipientEntityId) {
                throw new Error('Business entity ID is required for P2B transfers');
            }

            this.logger.info('Creating P2B transaction record', {
                entityId,
                businessId: recipientEntityId,
                amount,
                useWalletBalance,
            });

            // Create metadata with additional information
            const metadata: any = {
                description: `Payment from ${senderClkkTag || entityId} to ${recipientClkkTag || recipientEntityId}`,
                paymentMethod: useWalletBalance ? 'wallet' : 'card',
            };

            if (senderClkkTag) metadata.senderClkkTag = senderClkkTag;
            if (recipientClkkTag) metadata.businessName = recipientClkkTag;

            // Create a single transaction for P2B transfer
            const transaction = new Transaction(TransactionType.P2B, amount, 'USD', TransactionStatus.PENDING, {
                sender: {
                    id: entityId,
                    type: 'USER',
                    name: senderClkkTag,
                },
                receiver: {
                    id: recipientEntityId,
                    type: recipientType || 'BUSINESS',
                    name: recipientClkkTag,
                },
                metadata,
            });

            // If using wallet balance, deduct from sender's wallet immediately
            if (useWalletBalance) {
                try {
                    // Check if sender has sufficient funds
                    const wallet = await WalletService.getWallet(entityId, 'USER', 'USD');
                    if (!wallet) {
                        throw new Error('Sender wallet not found');
                    }

                    const walletBalance = new Money(wallet.balance, 'USD');
                    const transferAmount = new Money(amount, 'USD');

                    if (walletBalance.lessThan(transferAmount)) {
                        throw new Error('Insufficient funds in wallet');
                    }

                    // Deduct from sender's wallet
                    await WalletService.withdraw(entityId, 'USER', transferAmount, transaction.transactionId, 'USD');

                    this.logger.info('Deducted amount from sender wallet', {
                        senderId: entityId,
                        amount: transferAmount.toString(),
                        transactionId: transaction.transactionId,
                    });

                    // Store the balance before and after in the transaction
                    transaction.balanceBefore = walletBalance.toString();
                    transaction.balanceAfter = walletBalance.subtract(transferAmount).toString();
                } catch (error) {
                    this.logger.error('Error deducting from sender wallet', {
                        error: error instanceof Error ? error.message : 'Unknown error',
                        senderId: entityId,
                        amount,
                    });
                    throw error;
                }
            }

            // Create the transaction record
            await transaction.create();

            this.logger.info('P2B transaction created', {
                transactionId: transaction.transactionId,
                senderId: entityId,
                businessId: recipientEntityId,
                amount,
                useWalletBalance,
            });

            return transaction;
        } else {
            throw new Error(`Unsupported transaction type: ${transactionType}`);
        }
    }

    /**
     * Validates if a card is acceptable for transactions based on its type
     * @param transactionId - Transaction ID to query for card information
     * @returns Validation result with reason if invalid
     */
    private async validateCardType(transactionId: string): Promise<{ isValid: boolean; reason?: string }> {
        this.logger.info('Validating card type for transaction', { transactionId });

        // Skip validation if not enabled
        if (!NMI_FEATURES.CARD_TYPE_VALIDATION.ENABLED) {
            this.logger.info('Card type validation skipped - feature disabled');
            return { isValid: true };
        }

        try {
            // Get the card BIN from the transaction
            const cardBin = await this.getCardBinFromTransaction(transactionId);

            if (!cardBin) {
                this.logger.warn('No card BIN found for transaction, skipping card type validation', { transactionId });
                return { isValid: true };
            }

            // Check the card type using the BIN
            const cardType = await this.getCardTypeFromBin(cardBin);

            if (!cardType) {
                this.logger.warn('Could not determine card type, skipping validation', { transactionId });
                return { isValid: true };
            }

            // Check if card type is in allowed types
            const allowedTypes = NMI_FEATURES.CARD_TYPE_VALIDATION.ALLOWED_TYPES;
            if (!allowedTypes.includes(cardType)) {
                this.logger.info('Transaction rejected - card type not allowed', {
                    transactionId,
                    cardType,
                    allowedTypes,
                });

                return {
                    isValid: false,
                    reason: `Only ${allowedTypes.join(', ')} cards are allowed. Card type: ${cardType}`,
                };
            }

            this.logger.info('Card type verified as allowed, proceeding with transaction', {
                transactionId,
                cardType,
            });
            return { isValid: true };
        } catch (error) {
            this.logger.error('Error validating card type', {
                transactionId,
                error: error instanceof Error ? error.message : 'Unknown error',
            });

            // If validation fails, check if we should fail open or closed
            if (NMI_FEATURES.CARD_TYPE_VALIDATION.FAIL_OPEN) {
                this.logger.info('Proceeding with transaction despite validation error (fail-open policy)');
                return { isValid: true };
            } else {
                this.logger.info('Rejecting transaction due to validation error (fail-closed policy)');
                return {
                    isValid: false,
                    reason: 'Card validation failed due to technical error',
                };
            }
        }
    }

    /**
     * Retrieves the card BIN (first 6 digits) from a transaction
     * @param transactionId - Transaction ID to query
     * @returns Card BIN if found, undefined otherwise
     */
    private async getCardBinFromTransaction(transactionId: string): Promise<string | undefined> {
        this.logger.info('Getting card BIN from transaction', { transactionId });

        try {
            // Query the transaction to get details including cc_bin
            const queryResponse = await this.queryTransactions({
                transaction_id: transactionId,
            });

            if (queryResponse.success && queryResponse.transactions && queryResponse.transactions.length > 0) {
                const cc_bin = queryResponse.transactions[0].cc_bin;

                if (cc_bin) {
                    this.logger.info('Retrieved card BIN from transaction', {
                        transactionId,
                        cc_bin: cc_bin.substring(0, 3) + '***',
                    });

                    return cc_bin;
                } else {
                    this.logger.warn('No card BIN found in transaction query response', { transactionId });
                }
            } else {
                this.logger.warn('Transaction query failed or returned no results', {
                    transactionId,
                    errorMessage: queryResponse.message,
                });
            }

            return undefined;
        } catch (error) {
            this.logger.error('Error retrieving card BIN from transaction', {
                transactionId,
                error: error instanceof Error ? error.message : 'Unknown error',
            });

            return undefined;
        }
    }

    /**
     * Determines the card type based on BIN
     * @param cardBin - Card BIN (first 6 digits)
     * @returns Card type if determined, undefined otherwise
     */
    private async getCardTypeFromBin(cardBin: string): Promise<string | undefined> {
        this.logger.info('Getting card type from BIN', {
            cardBin: cardBin.substring(0, 3) + '***',
        });

        try {
            // Check the card type using the BIN
            const cardTypeResponse = await this.checkCardType(cardBin);

            if (cardTypeResponse.success && cardTypeResponse.result) {
                this.logger.info('Card type determined', {
                    cardBin: cardBin.substring(0, 3) + '***',
                    cardType: cardTypeResponse.result,
                });

                return cardTypeResponse.result;
            } else {
                this.logger.warn('Unable to determine card type', {
                    cardBin: cardBin.substring(0, 3) + '***',
                    errorMessage: cardTypeResponse.message,
                });

                return undefined;
            }
        } catch (error) {
            this.logger.error('Error determining card type from BIN', {
                cardBin: cardBin.substring(0, 3) + '***',
                error: error instanceof Error ? error.message : 'Unknown error',
            });

            return undefined;
        }
    }

    /**
     * Capture a previously authorized transaction
     * @param userId - User's ID
     * @param transactionId - Original transaction ID to capture (from NMI)
     * @param amount - Amount to capture (can be less than original)
     * @returns Payment response
     */
    async captureTransaction(userId: string, transactionId: string, amount?: string): Promise<PaymentResponse> {
        this.logger.info('Capturing transaction', {
            userId,
            providerTransactionId: transactionId,
            amount,
        });

        try {
            // Create the capture request
            const captureRequest: CaptureRequest = {
                type: NmiTransactionType.CAPTURE,
                transactionid: transactionId,
                amount,
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest<CaptureRequest>(captureRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Capture response', { response });

            this.logger.info('Transaction captured', {
                transactionId: response.transactionid,
                authCode: response.authcode,
                responseCode: response.response_code,
                responseText: response.responsetext,
            });

            // Keep transaction in PENDING status for webhook updates later
            // The webhook handler will update to COMPLETED when final settlement occurs
            const status =
                response.response === ResponseCode.APPROVED ? TransactionStatus.PENDING : TransactionStatus.FAILED;

            // First, find the internal transaction by provider transaction ID
            try {
                this.logger.info('Finding transaction by provider transaction ID', {
                    providerTransactionId: transactionId,
                });

                // Try to find transactions with this provider transaction ID
                const transactions = await TransactionService.getTransactionsByProviderTransactionId(transactionId);

                if (!transactions || transactions.length === 0) {
                    this.logger.warn('No transaction found with provider transaction ID', {
                        providerTransactionId: transactionId,
                    });

                    // Return a basic response if no transaction is found
                    return {
                        success: response.response === ResponseCode.APPROVED,
                        transactionId: response.transactionid,
                        message: response.responsetext || '',
                        status: 'pending',
                        errorCode: response.response !== ResponseCode.APPROVED ? response.response_code : undefined,
                    };
                }

                // Use the first transaction found (should be only one)
                const internalTransaction = transactions[0];
                const internalTransactionId = internalTransaction.transactionId;

                this.logger.info('Found internal transaction', {
                    internalTransactionId,
                    providerTransactionId: transactionId,
                });

                // Update transaction record with our internal transaction ID
                const updatedTransaction = await TransactionService.updateTransaction(internalTransactionId, {
                    status: status,
                    metadata: {
                        ...((await TransactionService.getTransaction(internalTransactionId))?.metadata || {}),
                        statusReason: response.responsetext,
                        authCode: response.authcode,
                        responseCode: response.response_code,
                        responseText: response.responsetext,
                    },
                    updatedAt: new Date().toISOString(),
                });

                this.logger.info('Internal transaction updated successfully', {
                    transaction: updatedTransaction,
                    internalTransactionId: updatedTransaction.transactionId,
                });

                // Create and return the payment response
                this.logger.info('Creating payment response for updated transaction');
                const paymentResponse = this.createPaymentResponse(response, updatedTransaction);
                return paymentResponse;
            } catch (findError) {
                this.logger.error('Error finding or updating transaction after capture', {
                    error: findError,
                    providerTransactionId: transactionId,
                    responseCode: response.response_code,
                });

                // Even if update fails, still return a valid response
                return {
                    success: response.response === ResponseCode.APPROVED,
                    transactionId: response.transactionid,
                    message: response.responsetext || '',
                    status: 'pending',
                    errorCode: response.response !== ResponseCode.APPROVED ? response.response_code : undefined,
                };
            }
        } catch (error) {
            this.logger.error('Error capturing transaction', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Process a request to the NMI API
     * @param requestData - Request data to send to NMI
     * @param apiUrlPath - NMI API URL path
     * @returns NMI API response
     */
    private async processNmiRequest<T extends Record<string, any>>(
        requestData: T,
        apiUrlPath: string,
    ): Promise<TransactionResponse> {
        this.logger.info('Processing NMI request', {
            requestData,
        });
        try {
            this.logger.info('Sending request to NMI API', {
                type: requestData.type,
                endpointUrl: this.config.apiUrl,
            });

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

            const options = {
                method: 'POST',
                headers: {
                    accept: 'application/x-www-form-urlencoded',
                    'content-type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams(requestData as Record<string, string>),
                signal: controller.signal,
            };

            const response = await fetch(`${this.config.apiUrl}/${apiUrlPath}`, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NMI API responded with status ${response.status}: ${errorText}`);
            }

            // Read the response text only once
            const responseText = await response.text();

            this.logger.info('Full NMI API response', {
                status: response.status,
                statusText: response.statusText,
                response: responseText,
            });

            this.logger.info('response text', {
                responseText,
            });

            // Parse the response from x-www-form-urlencoded format
            const parsedResponse = this.parseResponseText(responseText);

            this.logger.info('Full parsed response from NMI API', {
                parsedResponse,
            });

            this.logger.info('Received response from NMI API', {
                response: parsedResponse.response,
                responsetext: parsedResponse.responsetext,
                transactionid: parsedResponse.transactionid,
            });

            // Handle rate limit separately
            if (
                parsedResponse.response === ResponseCode.ERROR &&
                parsedResponse.response_code === ResultCode.RATE_LIMIT_EXCEEDED
            ) {
                throw new Error('Rate limit exceeded. Please try again later.');
            }

            // Special case for duplicate transactions
            if (
                parsedResponse.response === ResponseCode.ERROR &&
                parsedResponse.response_code === ResultCode.GATEWAY_REJECTED &&
                parsedResponse.responsetext &&
                parsedResponse.responsetext.includes('Duplicate transaction')
            ) {
                this.logger.warn('Duplicate transaction detected', {
                    responseCode: parsedResponse.response_code,
                    responseText: parsedResponse.responsetext,
                });
            }

            return parsedResponse;
        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('NMI API request timed out');
            }

            this.logger.error('Error processing NMI request', error);
            throw error;
        }
    }

    /**
     * Parse response text from x-www-form-urlencoded format
     * @param responseText - Raw response text from NMI API
     * @returns Parsed transaction response
     */
    private parseResponseText(responseText: string): TransactionResponse {
        this.logger.info('Parsing response text', {
            responseText,
        });
        const result: Record<string, string> = {};
        const params = new URLSearchParams(responseText);

        params.forEach((value, key) => {
            result[key] = value;
        });

        return result as unknown as TransactionResponse;
    }

    /**
     * Create a standardized payment response from NMI response
     * @param nmiResponse - Response from NMI API
     * @param transaction - Transaction record from database
     * @returns Standardized payment response
     */
    private createPaymentResponse(
        nmiResponse: TransactionResponse,
        transaction: Transaction | TransactionRecord,
    ): PaymentResponse {
        this.logger.info('Creating payment response', {
            nmiResponse,
            transaction,
        });
        const success = nmiResponse.response === ResponseCode.APPROVED;

        try {
            this.logger.info('Creating payment response', {
                transaction: typeof transaction === 'object' ? 'transaction_object_exists' : 'transaction_missing',
                transactionType: transaction ? typeof transaction : 'undefined',
            });

            // Safely handle the transaction record conversion
            let transactionRecord: TransactionRecord;

            if (this.isTransactionRecord(transaction)) {
                transactionRecord = transaction;
            } else if (transaction) {
                transactionRecord = {
                    userId: transaction.senderId || transaction.senderEntityId || '',
                    transactionId: transaction.transactionId || '',
                    type: transaction.type || TransactionType.DEPOSIT,
                    amount: typeof transaction.amount === 'number' ? transaction.amount.toString() : '0',
                    status: this.mapTransactionStatus(transaction.status || TransactionStatus.PENDING),
                    createdAt: new Date(transaction.createdAt || Date.now()),
                    updatedAt: new Date(transaction.updatedAt || Date.now()),
                };
            } else {
                transactionRecord = {
                    userId: '',
                    transactionId: nmiResponse.transactionid || '',
                    type: TransactionType.DEPOSIT,
                    amount: '0',
                    status: 'pending',
                    createdAt: new Date(),
                    updatedAt: new Date(),
                };
            }

            return {
                success,
                transactionId: nmiResponse.transactionid,
                internalTransactionId: transaction?.transactionId || '',
                // NMI might return customer_vault_id in some responses
                customerVaultId: (nmiResponse as any).customer_vault_id,
                message: nmiResponse.responsetext || '',
                orderReference: transactionRecord.orderReference,
                status: transactionRecord.status || 'pending',
                errorCode: !success ? nmiResponse.response_code : undefined,
                transactionRecord,
            };
        } catch (error) {
            // If anything fails in processing, return a minimal valid response
            this.logger.error('Error creating payment response', { error });
            return {
                success,
                transactionId: nmiResponse.transactionid,
                message: nmiResponse.responsetext || 'Error processing response',
                status: 'pending',
                errorCode: !success ? nmiResponse.response_code : undefined,
            };
        }
    }

    private isTransactionRecord(obj: any): obj is TransactionRecord {
        return 'userId' in obj && typeof obj.userId === 'string';
    }

    /**
     * Maps internal transaction status to NMI-compatible status
     */
    private mapTransactionStatus(status: TransactionStatus): TransactionRecord['status'] {
        const statusMap: Record<TransactionStatus, TransactionRecord['status']> = {
            [TransactionStatus.PENDING]: 'pending',
            [TransactionStatus.COMPLETED]: 'captured',
            [TransactionStatus.FAILED]: 'failed',
            [TransactionStatus.CANCELLED]: 'failed',
            [TransactionStatus.REVERSED]: 'refunded',
        };
        return statusMap[status] || 'pending';
    }

    /**
     * Determine transaction status from NMI response
     * @param response - NMI API response
     * @returns Transaction status
     */
    /**
     * Maps NMI response codes to appropriate transaction statuses based on the response
     * and adjusts based on the transaction type when needed
     *
     * @param response - NMI API response
     * @param transactionType - Optional transaction type for specialized status mapping
     * @returns Appropriate transaction status based on response code and transaction type
     */
    private getTransactionStatus(
        response: TransactionResponse,
        transactionType?: TransactionType,
    ): TransactionRecord['status'] {
        // First, determine basic status from response code
        if (response.response === ResponseCode.APPROVED) {
            // For capture operations, set to captured
            if (transactionType === undefined && response.authcode) {
                // When capturing, we usually have an auth code and no transaction type specified
                return 'captured';
            }

            // Different success statuses based on transaction type
            if (transactionType) {
                switch (transactionType) {
                    case TransactionType.DEPOSIT:
                        // Deposits typically just need authorization
                        return 'pending';
                    case TransactionType.P2P:
                    case TransactionType.P2B:
                        // P2P and P2B transfers are usually fully captured immediately
                        return 'captured';
                    default:
                        return 'pending';
                }
            }
            // Default for APPROVED if no transaction type specified
            return 'pending';
        } else if (response.response === ResponseCode.DECLINED) {
            return 'failed';
        } else if (response.response === ResponseCode.ERROR) {
            return 'failed';
        } else {
            return 'pending';
        }
    }

    /**
     * Query transactions from NMI API
     * @param request - Query request parameters
     * @returns Query transaction response
     */
    async queryTransactions(request: Omit<QueryTransactionRequest, 'security_key'>): Promise<QueryTransactionResponse> {
        this.logger.info('Querying transactions', {
            transactionId: request.transaction_id,
            condition: request.condition,
        });

        try {
            // Create the complete request with security key
            const fullRequest: QueryTransactionRequest = {
                ...request,
                security_key: this.config.securityKey,
            };

            // NMI query API base endpoint
            const baseUrl = NMI_API_URLS.QUERY;

            // Convert request to URL parameters
            const params = new URLSearchParams();
            Object.entries(fullRequest).forEach(([key, value]) => {
                if (value !== undefined) {
                    params.append(key, String(value));
                }
            });

            // Build the full URL with query parameters
            const queryUrl = `${baseUrl}?${params.toString()}`;

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

            const options = {
                method: 'POST',
                headers: {
                    accept: 'application/xml',
                },
                signal: controller.signal,
            };

            this.logger.info('Sending POST request to NMI Query API', {
                url: queryUrl,
            });

            const response = await fetch(queryUrl, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NMI Query API responded with status ${response.status}: ${errorText}`);
            }

            const responseText = await response.text();
            this.logger.info('Received response from NMI Query API');

            // Check if response is XML or plain text
            if (responseText.trim().startsWith('<?xml')) {
                // Handle XML response
                const parser = new XMLParser({
                    ignoreAttributes: false,
                    parseAttributeValue: true,
                });

                const parsedXml = parser.parse(responseText);

                if (!parsedXml.nm_response || !parsedXml.nm_response.transaction) {
                    return {
                        success: false,
                        message: 'No transactions found',
                    };
                }

                const transactions = Array.isArray(parsedXml.nm_response.transaction)
                    ? parsedXml.nm_response.transaction
                    : [parsedXml.nm_response.transaction];

                // Extract required fields from each transaction
                const parsedTransactions = transactions.map((tx: any) => ({
                    transaction_id: tx.transaction_id || '',
                    cc_bin: tx.cc_bin || '',
                    cc_type: tx.cc_type || '',
                    condition: tx.condition || '',
                    customerid: tx.customerid || '',
                    // Extract other fields if needed
                    amount: tx.action && tx.action.amount ? tx.action.amount : '',
                    action_type: tx.action && tx.action.action_type ? tx.action.action_type : '',
                    date: tx.action && tx.action.date ? tx.action.date : '',
                }));

                return {
                    success: true,
                    message: 'Transactions retrieved successfully',
                    transactions: parsedTransactions,
                };
            } else {
                this.logger.info('Received plain text response, parsing manually');

                if (responseText.trim() === '') {
                    return {
                        success: false,
                        message: 'No transactions found',
                    };
                }

                const fields = responseText.trim().split(' ');
                if (fields.length >= 5) {
                    // Map the fields based on the expected order
                    const transaction = {
                        transaction_id: fields[0] || '',
                        cc_type: fields[1] || '',
                        condition: fields[2] || '',
                        customerid: fields[4] || '',
                        cc_bin: fields.length > 15 ? fields[15] || '' : '',
                    };

                    return {
                        success: true,
                        message: 'Transaction retrieved successfully',
                        transactions: [transaction],
                    };
                } else {
                    return {
                        success: false,
                        message: 'Invalid response format',
                    };
                }
            }
        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('NMI Query API request timed out');
            }

            this.logger.error('Error querying transactions', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Check card type based on the card number (IIN/BIN)
     * @param ccnumber - Card IIN (first 6 digits)
     * @returns Card type information
     */
    async checkCardType(ccnumber: string): Promise<CardTypeCheckResponse> {
        this.logger.info('Checking card type', {
            ccnumber: ccnumber.substring(0, 3) + '***',
        });

        try {
            // Card type check API endpoint (v4 API)
            const cardTypeApiUrl = NMI_API_URLS.CARD_TYPE;
            const v4ApiKey = this.config.securityKey;

            if (!v4ApiKey) {
                throw new Error('NMI API key is not configured');
            }

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

            // Create request options
            const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `${NMI_AUTH_PREFIXES.V4_PRIVATE}${v4ApiKey}`,
                },
                body: JSON.stringify({ ccnumber }),
                signal: controller.signal,
            };

            this.logger.info('Sending request to NMI Card Type API', {
                url: cardTypeApiUrl,
            });

            const response = await fetch(cardTypeApiUrl, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NMI Card Type API responded with status ${response.status}: ${errorText}`);
            }

            const responseData = await response.json();

            this.logger.info('Received response from NMI Card Type API', {
                result: responseData.result,
            });

            return {
                success: true,
                result: responseData.result,
            };
        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                this.logger.error('NMI Card Type API request timed out');
                return {
                    success: false,
                    result: 'unavailable',
                    message: 'Request timed out',
                    errorCode: 'TIMEOUT_ERROR',
                };
            }

            this.logger.error('Error checking card type', error);
            return {
                success: false,
                result: 'unavailable',
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Update transaction record with provider details
     * @param transactionId - Internal transaction ID
     * @param nmiResponse - Response from NMI
     * @returns Updated transaction
     */
    private async updateTransactionWithProviderDetails(
        transactionId: string,
        nmiResponse: TransactionResponse,
    ): Promise<Transaction> {
        // Update with provider details
        const success = nmiResponse.response === ResponseCode.APPROVED;
        const status = success ? TransactionStatus.PENDING : TransactionStatus.FAILED;

        this.logger.info('Updating transaction with provider details', {
            internalTransactionId: transactionId,
            providerTransactionId: nmiResponse.transactionid,
            status,
        });

        const updateData = {
            status,
            providerTransactionId: nmiResponse.transactionid, // This should match the GSI key name
            authCode: nmiResponse.authcode,
            responseCode: nmiResponse.response_code,
            responseText: nmiResponse.responsetext,
            updatedAt: new Date().toISOString(),
        };

        return TransactionService.updateTransaction(transactionId, updateData);
    }

    /**
     * Add a customer to the NMI vault
     * @param entityId - Entity ID (user or business)
     * @param entityType - Entity type (USER or BUSINESS)
     * @param request - Customer vault request
     * @returns Customer vault response with vault ID
     */
    async addCustomerToVault(
        entityId: string,
        entityType: EntityTypeString,
        request: Omit<CustomerVaultRequest, 'customer_vault' | 'security_key'>,
    ): Promise<CustomerVaultResponse> {
        try {
            this.logger.info('Adding customer to NMI vault', {
                entityId,
                entityType,
            });

            // Add customer_vault action to the request
            const vaultRequest: CustomerVaultRequest = {
                ...request,
                customer_vault: 'add_customer',
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest(vaultRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Customer vault response received', {
                response_code: response.response_code,
                responsetext: response.responsetext,
                customer_vault_id: response.customer_vault_id,
            });

            if (response.response !== '1') {
                throw new Error(`Failed to add customer to vault: ${response.responsetext}`);
            }

            // Store the customer vault data in DynamoDB
            const customerVaultId = response.customer_vault_id;
            if (!customerVaultId) {
                throw new Error('No customer_vault_id returned from NMI');
            }

            // Create NMI customer record
            await createNmiCustomer(entityId, entityType, customerVaultId, {
                ccType: response.cc_type,
                ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
            });

            return {
                success: true,
                customerVaultId: customerVaultId,
                message: response.responsetext || 'Customer added to vault successfully',
                ccType: response.cc_type,
                ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
            };
        } catch (error) {
            this.logger.error('Error adding customer to vault', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
                entityType,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }

    /**
     * Update a customer in the NMI vault
     * @param entityId - Entity ID (user or business)
     * @param customerVaultId - NMI customer vault ID
     * @param request - Customer vault update request
     * @returns Customer vault response
     */
    async updateCustomerInVault(
        entityId: string,
        customerVaultId: string,
        request: Omit<CustomerVaultRequest, 'customer_vault' | 'security_key' | 'customer_vault_id'>,
    ): Promise<CustomerVaultResponse> {
        try {
            this.logger.info('Updating customer in NMI vault', {
                entityId,
                customerVaultId,
            });

            // First verify that this customer vault ID belongs to the user
            const nmiCustomers = await listNmiCustomersByEntity(entityId);
            const matchingCustomer = nmiCustomers.find((c) => c.customerVaultId === customerVaultId);

            if (!matchingCustomer) {
                throw new Error('Customer vault ID not found for this user');
            }

            // Add customer_vault update action to the request
            const vaultRequest: CustomerVaultRequest = {
                ...request,
                customer_vault: 'update_customer',
                customer_vault_id: customerVaultId,
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest(vaultRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Customer vault update response received', {
                response_code: response.response_code,
                responsetext: response.responsetext,
            });

            if (response.response !== '1') {
                throw new Error(`Failed to update customer in vault: ${response.responsetext}`);
            }

            // Update the NMI customer record if card details changed
            if (response.cc_type || response.cc_number) {
                matchingCustomer.ccType = response.cc_type || matchingCustomer.ccType;
                matchingCustomer.ccNumber = response.cc_number
                    ? response.cc_number.slice(-4)
                    : matchingCustomer.ccNumber;
                matchingCustomer.updatedAt = new Date().toISOString();
                await matchingCustomer.update();
            }

            return {
                success: true,
                customerVaultId: customerVaultId,
                message: response.responsetext || 'Customer updated in vault successfully',
                ccType: response.cc_type,
                ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
            };
        } catch (error) {
            this.logger.error('Error updating customer in vault', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
                customerVaultId,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }

    /**
     * Delete a customer from the NMI vault
     * @param entityId - Entity ID (user or business)
     * @param customerVaultId - NMI customer vault ID to delete
     * @returns Success response
     */
    async deleteCustomerFromVault(
        entityId: string,
        customerVaultId: string,
    ): Promise<{ success: boolean; message: string }> {
        try {
            this.logger.info('Deleting customer from NMI vault', {
                entityId,
                customerVaultId,
            });

            // First verify that this customer vault ID belongs to the user
            const nmiCustomers = await listNmiCustomersByEntity(entityId);
            const matchingCustomer = nmiCustomers.find((c) => c.customerVaultId === customerVaultId);

            if (!matchingCustomer) {
                throw new Error('Customer vault ID not found for this user');
            }

            // Create delete request
            const vaultRequest = {
                customer_vault: 'delete_customer',
                customer_vault_id: customerVaultId,
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest(vaultRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Customer vault delete response received', {
                response_code: response.response_code,
                responsetext: response.responsetext,
            });

            if (response.response !== '1') {
                throw new Error(`Failed to delete customer from vault: ${response.responsetext}`);
            }

            // Delete the NMI customer record from our database
            await matchingCustomer.delete();

            return {
                success: true,
                message: response.responsetext || 'Customer deleted from vault successfully',
            };
        } catch (error) {
            this.logger.error('Error deleting customer from vault', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
                customerVaultId,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }

    /**
     * Get all stored customer vault records for an entity
     * @param entityId - Entity ID (user or business)
     * @returns List of customer vault records
     */
    async getStoredCustomerVaults(entityId: string): Promise<NmiCustomer[]> {
        try {
            return await listNmiCustomersByEntity(entityId);
        } catch (error) {
            this.logger.error('Error getting stored customer vaults', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
            });
            throw error;
        }
    }

    /**
     * Delete all vault records for an entity
     * This is a public method that can be called directly from API endpoints
     * @param entityId - Entity ID (user or business)
     * @returns Result of the deletion operation
     */
    async deleteAllCustomerVaultRecords(entityId: string): Promise<{ success: boolean; message: string }> {
        return this.deleteExistingVaultRecords(entityId);
    }

    /**
     * Delete all existing vault records for an entity from both NMI and DynamoDB
     * This is used when a user is adding a new payment method to replace existing ones
     * @param entityId - Entity ID (user or business)
     * @returns Result of the deletion operation
     */
    private async deleteExistingVaultRecords(entityId: string): Promise<{ success: boolean; message: string }> {
        try {
            this.logger.info('Checking for existing vault records to delete', { entityId });

            // Get all existing vault records for this entity
            const existingVaults = await listNmiCustomersByEntity(entityId);

            if (!existingVaults || existingVaults.length === 0) {
                this.logger.info('No existing vault records found for entity', { entityId });
                return { success: true, message: 'No existing vault records to delete' };
            }

            this.logger.info('Found existing vault records to delete', {
                entityId,
                count: existingVaults.length,
                vaultIds: existingVaults.map((v) => v.customerVaultId),
            });

            // Delete each vault record from NMI and DynamoDB
            for (const vault of existingVaults) {
                const result = await this.deleteCustomerFromVault(entityId, vault.customerVaultId);

                if (!result.success) {
                    this.logger.warn('Failed to delete vault record', {
                        entityId,
                        customerVaultId: vault.customerVaultId,
                        error: result.message,
                    });
                    // Continue with other deletions even if one fails
                }
            }

            return {
                success: true,
                message: `Successfully deleted ${existingVaults.length} existing vault record(s)`,
            };
        } catch (error) {
            this.logger.error('Error deleting existing vault records', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }
}
</file>

<file path="lambdas/nmi/services/secrets-service.ts">
import { getSecret } from '../../../layers/commons/utils/getSecret';
import { createLogger } from '../../../layers/commons/utils/logger_v2';

/**
 * Logger for the secrets service
 */
const logger = createLogger('NmiSecretsService');

/**
 * Default secret name for NMI
 */
const DEFAULT_SECRET_NAME = 'nmi/credentials';

/**
 * NMI secret keys
 */
export enum NmiSecretKeys {
    WEBHOOK_SIGNING_KEY = 'NMI_WEBHOOK_SIGNING_KEY',
    PRIVATE_KEY = 'NMI_PRIVATE_KEY',
}

/**
 * Cache for secrets to avoid repeated calls to Secrets Manager
 */
const secretsCache: Record<string, string> = {};

/**
 * Get NMI secret from AWS Secrets Manager
 * @param key - The key of the secret to retrieve
 * @param secretName - The name of the secret in Secrets Manager (optional)
 * @returns The secret value
 */
export async function getNmiSecret(key: NmiSecretKeys, secretName?: string): Promise<string> {
    const name = secretName || process.env.NMI_SECRET_NAME || DEFAULT_SECRET_NAME;
    const cacheKey = `${name}:${key}`;

    // Return from cache if available
    if (secretsCache[cacheKey]) {
        logger.info(`Using cached secret for ${key}`);
        return secretsCache[cacheKey];
    }

    try {
        logger.info(`Retrieving NMI secret: ${key}`, { secretName: name });

        // Get the secret using the common utility
        const secretValue = await getSecret(name, key);

        if (!secretValue) {
            throw new Error(`Secret ${key} not found in ${name}`);
        }

        // Cache the secret
        secretsCache[cacheKey] = secretValue;

        logger.info(`Successfully retrieved NMI secret: ${key}`);
        return secretValue;
    } catch (error) {
        logger.error(`Error retrieving NMI secret: ${key}`, error);
        throw error;
    }
}

/**
 * Get NMI webhook signing key
 * @param secretName - Optional secret name override
 * @returns The webhook signing key
 */
export async function getNmiWebhookSigningKey(secretName?: string): Promise<string> {
    return getNmiSecret(NmiSecretKeys.WEBHOOK_SIGNING_KEY, secretName);
}

/**
 * Get NMI private key
 * @param secretName - Optional secret name override
 * @returns The private key
 */
export async function getNmiPrivateKey(secretName?: string): Promise<string> {
    return getNmiSecret(NmiSecretKeys.PRIVATE_KEY, secretName);
}
</file>

<file path="lambdas/nmi/services/webhook-service.ts">
import { createHmac } from 'crypto';
import { createLogger } from '../../../layers/commons/utils/logger_v2';
import {
    NmiWebhookEvent,
    NmiWebhookEventType,
    WebhookVerificationRequest,
    WebhookVerificationResult,
    WebhookProcessingResult,
} from '../types/webhook';
import { TransactionService, TransactionStatus } from '../../../layers/commons/data/entities/transaction';
import { Transaction, TransactionType, EntityType } from '../../../layers/commons/data/entities/transaction';

/**
 * Transaction update data interface
 */
interface TransactionUpdateData {
    status: TransactionStatus;
    updatedAt: string;
    responseCode?: string;
    responseText?: string;
    authCode?: string;
    [key: string]: any; // For any additional fields
}

/**
 * Service for handling NMI webhooks
 */
export class WebhookService {
    private logger = createLogger('WebhookService');
    private signingKey: string;

    /**
     * Initialize the webhook service
     * @param signingKey - NMI webhook signing key for validation
     */
    constructor(signingKey: string) {
        this.signingKey = signingKey;
    }

    /**
     * Verify webhook signature using HMAC with SHA-256
     * @param request - Webhook verification request data
     * @returns Verification result with parsed webhook if valid
     */
    verifyWebhook(request: WebhookVerificationRequest): WebhookVerificationResult {
        try {
            this.logger.info('Verifying webhook signature');

            const { webhookBody, signingKey, nonce, signature } = request;

            // Generate expected signature using the same algorithm as NMI
            const expectedSignature = createHmac('sha256', signingKey).update(`${nonce}.${webhookBody}`).digest('hex');

            // Compare the signatures
            const isValid = expectedSignature === signature;

            if (!isValid) {
                this.logger.warn('Invalid webhook signature', {
                    expectedSignature: expectedSignature.substring(0, 10) + '...',
                    receivedSignature: signature.substring(0, 10) + '...',
                });

                return {
                    isValid: false,
                    message: 'Invalid webhook signature',
                };
            }

            // Parse webhook body to JSON
            try {
                const webhook = JSON.parse(webhookBody) as NmiWebhookEvent;

                this.logger.info('Webhook signature verified successfully', {
                    event_id: webhook.event_id,
                    event_type: webhook.event_type,
                });

                return {
                    isValid: true,
                    webhook,
                };
            } catch (parseError) {
                this.logger.error('Error parsing webhook body', parseError);

                return {
                    isValid: false,
                    message: 'Error parsing webhook body',
                };
            }
        } catch (error) {
            this.logger.error('Error verifying webhook', error);

            return {
                isValid: false,
                message: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }

    /**
     * Process an NMI webhook event
     * @param webhook - Verified webhook event
     * @returns Processing result
     */
    async processWebhook(webhook: NmiWebhookEvent): Promise<WebhookProcessingResult> {
        try {
            this.logger.info('Processing webhook', {
                event_id: webhook.event_id,
                event_type: webhook.event_type,
                transaction_id: webhook.event_body.transaction_id,
            });

            // Extract transaction ID from the webhook
            const { transaction_id } = webhook.event_body;
            this.logger.info('Detected Transaction ID', { transaction_id });

            if (!transaction_id) {
                this.logger.warn('Missing transaction ID in webhook');
                return {
                    success: false,
                    message: 'Missing transaction ID in webhook',
                };
            }

            // Find the transaction by provider ID
            const transactions = await TransactionService.getTransactionsByProviderTransactionId(transaction_id);
            if (!transactions || transactions.length === 0) {
                this.logger.warn('No transaction found with provider ID', { providerTransactionId: transaction_id });
                return {
                    success: false,
                    message: `No transaction found with provider ID: ${transaction_id}`,
                    transactionId: transaction_id,
                };
            }

            // Use the first transaction found
            const transaction = transactions[0];
            const transactionId = transaction.transactionId;

            this.logger.info('Found transaction', {
                internalTransactionId: transactionId,
                providerTransactionId: transaction_id,
                currentStatus: transaction.status,
            });

            // Determine the new status based on webhook event type
            const status = this.determineTransactionStatus(webhook.event_type, webhook.event_body);

            this.logger.info('Determined transaction status', {
                status,
            });

            if (!status) {
                this.logger.warn('Unable to determine transaction status from webhook', {
                    event_type: webhook.event_type,
                });
                return {
                    success: false,
                    message: 'Unable to determine transaction status from webhook',
                    transactionId,
                };
            }

            // Check if this is a completion event
            const isCompletionEvent = status === TransactionStatus.COMPLETED;
            this.logger.info('Is completion event', {
                isCompletionEvent,
                status,
            });

            // Prepare update data
            const updateData: TransactionUpdateData = {
                status,
                updatedAt: new Date().toISOString(),
            };

            // Add any additional data from the webhook
            if (webhook.event_body.action) {
                if (webhook.event_body.action.response_code) {
                    updateData.responseCode = webhook.event_body.action.response_code;
                }
                if (webhook.event_body.action.response_text) {
                    updateData.responseText = webhook.event_body.action.response_text;
                }
            }

            if (webhook.event_body.authorization_code) {
                updateData.authCode = webhook.event_body.authorization_code;
            }

            // If this is a completion event for a DEPOSIT or WITHDRAWAL,update the wallet balance
            if (isCompletionEvent) {
                this.logger.info('Processing completion event before wallet update', { transactionId });
                try {
                    // Get the Transaction object to access its methods
                    const fullTransaction = await TransactionService.getTransaction(transactionId);

                    this.logger.info('Full transaction before wallet update', {
                        fullTransaction,
                    });

                    if (fullTransaction) {
                        // Create a Transaction instance with all properties
                        const transactionInstance = new Transaction(
                            fullTransaction.type as TransactionType,
                            parseFloat(fullTransaction.amount.toString()),
                            fullTransaction.currency || 'USD',
                            fullTransaction.status as TransactionStatus,
                            {
                                transactionId: fullTransaction.transactionId,
                                sender:
                                    fullTransaction.senderId && fullTransaction.senderType
                                        ? {
                                              id: fullTransaction.senderId,
                                              type: fullTransaction.senderType as EntityType,
                                              name: fullTransaction.senderName,
                                          }
                                        : undefined,
                                receiver:
                                    fullTransaction.receiverId && fullTransaction.receiverType
                                        ? {
                                              id: fullTransaction.receiverId,
                                              type: fullTransaction.receiverType as EntityType,
                                              name: fullTransaction.receiverName,
                                          }
                                        : undefined,
                                providerType: fullTransaction.providerType,
                                providerId: fullTransaction.providerId,
                                providerTransactionId: fullTransaction.providerTransactionId,
                                providerReference: fullTransaction.providerReference,
                                metadata: fullTransaction.metadata,
                                balanceBefore: fullTransaction.balanceBefore,
                                balanceAfter: fullTransaction.balanceAfter,
                                completedAt: fullTransaction.completedAt,
                                createdAt: fullTransaction.createdAt,
                                updatedAt: fullTransaction.updatedAt,
                            },
                        );

                        // Complete the transaction (this will update wallet balances)
                        await transactionInstance.complete();

                        this.logger.info('Transaction completed and wallet balance updated', {
                            transactionId,
                            type: fullTransaction.type,
                            amount: fullTransaction.amount,
                        });

                        // Return successful result
                        return {
                            success: true,
                            message: 'Transaction updated and wallet balance updated',
                            transactionId,
                            updatedStatus: status,
                        };
                    }
                } catch (balanceError) {
                    this.logger.error('Error updating wallet balance', {
                        transactionId,
                        error: balanceError instanceof Error ? balanceError.message : 'Unknown error',
                    });

                    // Continue with the basic transaction update
                }
            }

            // Standard update
            this.logger.info('Updating standard transaction', { transactionId, updateData });
            const updatedTransaction = await TransactionService.updateTransaction(transactionId, updateData);

            this.logger.info('Updated transaction successfully', {
                updatedTransaction,
            });

            return {
                success: true,
                message: 'Transaction updated successfully',
                transactionId,
                updatedStatus: status,
            };
        } catch (error) {
            this.logger.error('Error processing webhook', error);

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }

    /**
     * Determine the transaction status based on the webhook event type and body
     * @param eventType - The type of NMI webhook event
     * @param eventBody - The body of the webhook event
     * @returns The determined transaction status or null if unable to determine
     */
    private determineTransactionStatus(eventType: string, eventBody: any): TransactionStatus | null {
        switch (eventType) {
            case 'transaction.sale.success':
            case 'transaction.capture.success':
                return TransactionStatus.COMPLETED;

            case 'transaction.sale.failure':
            case 'transaction.capture.failure':
            case 'transaction.auth.failure':
                return TransactionStatus.FAILED;

            case 'transaction.auth.success':
                return TransactionStatus.PENDING;

            case 'transaction.void.success':
                return TransactionStatus.CANCELLED;

            case 'transaction.refund.success':
                return TransactionStatus.REVERSED;

            default:
                // Check event body for status clues if event type isn't definitive
                if (eventBody && eventBody.status) {
                    if (eventBody.status.toLowerCase() === 'approved') {
                        return TransactionStatus.COMPLETED;
                    } else if (eventBody.status.toLowerCase() === 'declined') {
                        return TransactionStatus.FAILED;
                    }
                }

                // Unable to determine status
                return null;
        }
    }
}
</file>

<file path="lambdas/nmi/types/nmi.ts">
/**
 * NMI API Response and Request Type Definitions
 */

import { TransactionType } from '../../../layers/commons/data/entities/transaction';

// Transaction types
export enum NmiTransactionType {
    AUTH = 'auth',
    CAPTURE = 'capture',
    SALE = 'sale',
    REFUND = 'refund',
    VOID = 'void',
    CREDIT = 'credit',
    VALIDATE = 'validate',
    UPDATE = 'update',
}

// Response codes
export enum ResponseCode {
    APPROVED = '1',
    DECLINED = '2',
    ERROR = '3',
}

// Result codes
export enum ResultCode {
    APPROVED = '100',
    DECLINED = '200',
    DO_NOT_HONOR = '201',
    INSUFFICIENT_FUNDS = '202',
    OVER_LIMIT = '203',
    TRANSACTION_NOT_ALLOWED = '204',
    INCORRECT_PAYMENT_INFO = '220',
    NO_CARD_ISSUER = '221',
    NO_CARD_NUMBER = '222',
    EXPIRED_CARD = '223',
    INVALID_EXPIRATION_DATE = '224',
    INVALID_CVV = '225',
    INVALID_PIN = '226',
    CALL_ISSUER = '240',
    PICK_UP_CARD = '250',
    LOST_CARD = '251',
    STOLEN_CARD = '252',
    FRAUDULENT_CARD = '253',
    DECLINED_WITH_INSTRUCTIONS = '260',
    DECLINED_RECURRING_STOP_ALL = '261',
    DECLINED_RECURRING_STOP_THIS = '262',
    UPDATE_CARDHOLDER_DATA = '263',
    RETRY_LATER = '264',
    GATEWAY_REJECTED = '300',
    PROCESSOR_ERROR = '400',
    INVALID_MERCHANT_CONFIG = '410',
    MERCHANT_ACCOUNT_INACTIVE = '411',
    COMMUNICATION_ERROR = '420',
    ISSUER_COMMUNICATION_ERROR = '421',
    DUPLICATE_TRANSACTION = '430',
    PROCESSOR_FORMAT_ERROR = '440',
    INVALID_TRANSACTION_INFO = '441',
    PROCESSOR_FEATURE_UNAVAILABLE = '460',
    UNSUPPORTED_CARD_TYPE = '461',
    RATE_LIMIT_EXCEEDED = '301',
}

// Base authorization request parameters
export interface AuthorizationRequest {
    type: NmiTransactionType.AUTH;
    payment_token?: string;
    amount: string;
    customer_vault?: 'add_customer';
    customer_vault_id?: string;
    use_saved_card?: boolean; // Flag to indicate if we should use the user's saved card
    security_key: string;
    orderid?: string;
    // Customer information
    first_name?: string;
    last_name?: string;
    email?: string;
    phone?: string;
    // Address information
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
    country?: string;
}

// Capture request parameters
export interface CaptureRequest {
    type: NmiTransactionType.CAPTURE;
    transactionid: string; // Original transaction ID to capture
    amount?: string; // Can be equal to or less than the original amount
    security_key: string;
}

// Transaction response interface
export interface TransactionResponse {
    response: string; // 1=Approved, 2=Declined, 3=Error
    responsetext: string;
    authcode?: string;
    transactionid?: string;
    cvvresponse?: string;
    avsresponse?: string;
    orderid?: string;
    response_code?: string;
    // Customer vault related fields
    customer_vault_id?: string;
    customer_vault?: string;  // For identifying if this was an add_customer, update_customer, etc.
    cc_type?: string;
    cc_number?: string;
}

// Database transaction record
export interface TransactionRecord {
    id?: string; // UUID for the transaction record
    userId: string; // User who made the transaction
    transactionId?: string; // NMI transaction ID
    customerVaultId?: string; // NMI customer vault ID
    type: TransactionType;
    amount: string;
    status: 'pending' | 'authorized' | 'captured' | 'failed' | 'voided' | 'refunded';
    statusReason?: string;
    authCode?: string;
    responseCode?: string;
    responseText?: string;
    orderReference?: string;
    createdAt: Date;
    updatedAt: Date;
}

// Client-facing payment response
export interface PaymentResponse {
    success: boolean;
    transactionId?: string; // Provider's transaction ID
    internalTransactionId?: string; // Our internal transaction ID
    customerVaultId?: string;
    message: string;
    orderReference?: string;
    status: 'pending' | 'authorized' | 'captured' | 'failed' | 'voided' | 'refunded';
    errorCode?: string;
    transactionRecord?: TransactionRecord;
}

/**
 * Query transaction interface for NMI API
 */
export interface QueryTransactionRequest {
    security_key: string;
    transaction_id?: string;
    condition?: string;
    transaction_type?: string;
    action_type?: string;
    source?: string;
    start_date?: string;
    end_date?: string;
    result_limit?: string;
    page_number?: string;
    order_id?: string;
    email?: string;
    result_order?: 'standard' | 'reverse';
}

/**
 * Query transaction response interface for the specific fields
 * Extracting from the XML response
 */
export interface QueryTransactionResponse {
    success: boolean;
    message: string;
    transactions?: Array<{
        transaction_id: string;
        cc_bin: string;
        cc_type: string;
        condition: string;
        customerid: string;
        amount?: string;
        action_type?: string;
        date?: string;
    }>;
    errorCode?: string;
}

/**
 * Card Type Check Response from NMI API
 */
export interface CardTypeCheckResponse {
    success: boolean;
    result?: 'debit' | 'credit' | 'prepaid' | 'charge' | 'deferred_debit' | 'unknown' | 'unavailable';
    message?: string;
    errorCode?: string;
}

/**
 * Customer Vault Request for NMI API
 */
export interface CustomerVaultRequest {
    customer_vault: 'add_customer' | 'update_customer' | 'delete_customer';
    customer_vault_id?: string;
    security_key: string;
    payment_token?: string;
    first_name?: string;
    last_name?: string;
    email?: string;
    phone?: string;
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
    country?: string;
    company?: string;
    orderid?: string;
}

/**
 * Customer Vault Response from NMI API
 */
export interface CustomerVaultResponse {
    success: boolean;
    customerVaultId?: string;
    message: string;
    ccType?: string;
    ccNumber?: string;
    errorCode?: string;
}
</file>

<file path="lambdas/nmi/types/request-types.ts">
/**
 * TypeScript interfaces for NMI API request bodies
 */

/**
 * Base transaction request interface with common properties
 */
export interface BaseTransactionRequest {
    amount?: string;
    orderid?: string;
}

/**
 * Customer information interface for payment requests
 */
export interface CustomerInfo {
    first_name?: string;
    last_name?: string;
    email?: string;
    phone?: string;
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
    country?: string;
}

/**
 * Interface for the authorize transaction request
 */
export interface AuthorizeRequest extends BaseTransactionRequest, CustomerInfo {
    payment_token: string;
    customer_vault?: 'add_customer';
    use_saved_card?: boolean; // Flag to indicate if we should use the user's saved card
    use_wallet_balance?: boolean; // Flag to indicate if we should use wallet balance instead of card
    type: 'deposit' | 'p2p' | 'p2b';
    amount: string; // Making amount required to match NMI service expectations
    captureImmediately?: boolean; // Whether to capture the transaction immediately after authorization

    // Additional fields for P2P and P2B transactions
    recipient_entity_id?: string; // ID of the recipient (user or business)
    recipient_type?: string; // Type of recipient (USER or BUSINESS)
    recipient_clkk_tag?: string; // Username of the recipient
    sender_clkk_tag?: string; // Username of the sender
    recipient_current_email?: string; // Email of the recipient
    sender_current_email?: string; // Email of the sender
}

/**
 * Interface for the capture transaction request
 */
export interface CaptureRequest extends BaseTransactionRequest {
    transactionId: string;
}

/**
 * Interface for query transaction request
 */
export interface QueryTransactionRequest extends BaseTransactionRequest {
    transaction_id?: string;
    condition?: string;
    transaction_type?: string;
    action_type?: string;
    source?: string;
    start_date?: string;
    end_date?: string;
    result_limit?: string;
    page_number?: string;
    email?: string;
    result_order?: 'standard' | 'reverse';
}

/**
 * Interface for the card type check request
 */
export interface CardTypeCheckRequest {
    ccnumber: string;
}
</file>

<file path="lambdas/nmi/types/webhook.ts">
/**
 * NMI Webhook Types
 * Defines types for NMI webhook events and processing
 */

/**
 * NMI Webhook Event Types
 */
export enum NmiWebhookEventType {
    AUTH_SUCCESS = 'transaction.auth.success',
    AUTH_FAILURE = 'transaction.auth.failure',
    CAPTURE_SUCCESS = 'transaction.capture.success',
    CAPTURE_FAILURE = 'transaction.capture.failure',
    SALE_SUCCESS = 'transaction.sale.success',
    SALE_FAILURE = 'transaction.sale.failure',
    REFUND_SUCCESS = 'transaction.refund.success',
    REFUND_FAILURE = 'transaction.refund.failure',
    VOID_SUCCESS = 'transaction.void.success',
    VOID_FAILURE = 'transaction.void.failure',
}

/**
 * NMI Webhook Event Payload
 */
export interface NmiWebhookEvent {
    event_id: string;
    event_type: NmiWebhookEventType | string;
    event_body: NmiWebhookEventBody;
}

/**
 * NMI Webhook Event Body
 */
export interface NmiWebhookEventBody {
    merchant: {
        id: string;
        name: string;
    };
    features: {
        is_test_mode: boolean;
    };
    transaction_id: string;
    transaction_type: string;
    condition: string;
    processor_id: string;
    ponumber: string;
    order_description: string;
    order_id: string;
    customerid: string;
    customertaxid: string;
    website: string;
    shipping: string;
    currency: string;
    tax: string;
    surcharge: string;
    convenience_fee: string;
    misc_fee: string;
    misc_fee_name: string;
    cash_discount: string;
    tip: string;
    requested_amount: string;
    shipping_carrier: string;
    tracking_number: string;
    shipping_date: string;
    partial_payment_id: string;
    partial_payment_balance: string;
    platform_id: string;
    authorization_code: string;
    social_security_number: string;
    drivers_license_number: string;
    drivers_license_state: string;
    drivers_license_dob: string;
    duty_amount: string;
    discount_amount: string;
    national_tax_amount: string;
    summary_commodity_code: string;
    alternate_tax_amount: string;
    vat_tax_amount: string;
    vat_tax_rate: string;
    merchant_advice_code: string;
    merchant_advice_code_description: string;
    association_response_code: string;
    association_response_code_description: string;
    additional_processor_responses: string;
    additional_processor_response_descriptions: string;
    billing_address: {
        first_name: string;
        last_name: string;
        address_1: string;
        address_2: string;
        company: string;
        city: string;
        state: string;
        postal_code: string;
        country: string;
        email: string;
        phone: string;
        cell_phone: string;
        fax: string;
    };
    shipping_address: {
        first_name: string;
        last_name: string;
        address_1: string;
        address_2: string;
        company: string;
        city: string;
        state: string;
        postal_code: string;
        country: string;
        email: string;
        phone: string;
        fax: string;
    };
    card: {
        cc_number: string;
        cc_exp: string;
        cavv: string;
        cavv_result: string;
        xid: string;
        eci: string;
        avs_response: string;
        csc_response: string;
        cardholder_auth: string;
        cc_start_date: string;
        cc_issue_number: string;
        card_balance: string;
        card_available_balance: string;
        entry_mode: string;
        cc_bin: string;
        cc_type: string;
        feature_token: string;
    };
    merchant_defined_fields: Record<string, string>;
    action: {
        amount: string;
        action_type: string;
        date: string;
        success: string;
        ip_address: string;
        source: string;
        api_method: string;
        username: string;
        response_text: string;
        response_code: string;
        processor_response_text: string;
        tap_to_mobile: boolean;
        network_token_used: boolean;
        processor_response_code: string;
        processor_response_description: string;
        device_license_number: string;
        device_nickname: string;
    };
}

/**
 * NMI Webhook Verification Request
 */
export interface WebhookVerificationRequest {
    webhookBody: string;
    signingKey: string;
    nonce: string;
    signature: string;
}

/**
 * NMI Webhook Verification Result
 */
export interface WebhookVerificationResult {
    isValid: boolean;
    message?: string;
    webhook?: NmiWebhookEvent;
}

/**
 * NMI Webhook Handler Response
 */
export interface WebhookHandlerResponse {
    statusCode: number;
    headers?: Record<string, string>;
    body: string;
}

/**
 * NMI Webhook Processing Result
 */
export interface WebhookProcessingResult {
    success: boolean;
    message: string;
    transactionId?: string;
    updatedStatus?: string;
}
</file>

<file path="lambdas/nmi/validators/request-validator.ts">
/**
 * Request validation utility
 */

import { createLogger } from '../../../layers/commons/utils/logger_v2';

const logger = createLogger('NmiRequestValidator');

/**
 * Validate request against JSON schema
 * @param data - Request data to validate
 * @param schema - JSON schema to validate against
 * @returns Validation result with errors if any
 */
export const validateRequest = (data: any, schema: any): { isValid: boolean; errors: string[] } => {
    logger.info('Validating request', { schemaType: schema.title || 'unknown' });

    const errors: string[] = [];

    // Check required fields
    if (schema.required && Array.isArray(schema.required)) {
        schema.required.forEach((field: string) => {
            if (data[field] === undefined || data[field] === null || data[field] === '') {
                errors.push(`Field '${field}' is required`);
            }
        });
    }

    // Validate field types and formats
    if (schema.properties && Object.keys(schema.properties).length > 0) {
        Object.entries(schema.properties).forEach(([field, fieldSchema]: [string, any]) => {
            if (data[field] !== undefined && data[field] !== null) {
                // Type validation
                if (fieldSchema.type === 'string' && typeof data[field] !== 'string') {
                    errors.push(`Field '${field}' must be a string`);
                } else if (fieldSchema.type === 'number' && typeof data[field] !== 'number') {
                    errors.push(`Field '${field}' must be a number`);
                } else if (fieldSchema.type === 'boolean' && typeof data[field] !== 'boolean') {
                    errors.push(`Field '${field}' must be a boolean`);
                } else if (fieldSchema.type === 'object' && typeof data[field] !== 'object') {
                    errors.push(`Field '${field}' must be an object`);
                } else if (fieldSchema.type === 'array' && !Array.isArray(data[field])) {
                    errors.push(`Field '${field}' must be an array`);
                }

                // Pattern validation for strings
                if (fieldSchema.pattern && typeof data[field] === 'string') {
                    const regex = new RegExp(fieldSchema.pattern);
                    if (!regex.test(data[field])) {
                        errors.push(`Field '${field}' does not match required pattern`);
                    }
                }

                // Enum validation
                if (fieldSchema.enum && Array.isArray(fieldSchema.enum) && !fieldSchema.enum.includes(data[field])) {
                    errors.push(`Field '${field}' must be one of: ${fieldSchema.enum.join(', ')}`);
                }

                // Email format validation (simple regex)
                if (fieldSchema.format === 'email' && typeof data[field] === 'string') {
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    if (!emailRegex.test(data[field])) {
                        errors.push(`Field '${field}' must be a valid email address`);
                    }
                }
            }
        });
    }

    // Check for additional properties if not allowed
    if (schema.additionalProperties === false) {
        const allowedProps = Object.keys(schema.properties || {});
        Object.keys(data).forEach((prop) => {
            if (!allowedProps.includes(prop)) {
                errors.push(`Property '${prop}' is not allowed`);
            }
        });
    }

    const isValid = errors.length === 0;
    logger.info('Request validation completed', { isValid, errorCount: errors.length });

    return { isValid, errors };
};
</file>

<file path="lambdas/nmi/validators/schemas.ts">
/**
 * NMI request validation schemas
 */

export const authorizeRequestSchema = {
    type: 'object',
    required: ['amount'],
    properties: {
        amount: {
            type: 'string',
            pattern: '^[0-9]+(.[0-9]{1,2})?$', // Validates amount format (e.g., 10.99)
            description: 'Transaction amount in decimal format',
        },
        type: {
            type: 'string',
            enum: ['deposit', 'p2p', 'p2b'],
            description: 'Type of transaction',
        },
        payment_token: {
            type: 'string',
            description: 'Payment token from Collect.js',
        },
        customer_vault: {
            type: 'string',
            enum: ['add_customer'],
            description: 'Add customer to vault',
        },
        customer_vault_id: {
            type: 'string',
            description: 'Customer vault ID for returning customers',
        },
        use_saved_card: {
            type: 'boolean',
            description: 'Flag to indicate if the user wants to use their saved card',
        },
        orderid: {
            type: 'string',
            description: 'Order reference ID',
        },
        first_name: {
            type: 'string',
            description: 'Customer first name',
        },
        last_name: {
            type: 'string',
            description: 'Customer last name',
        },
        email: {
            type: 'string',
            format: 'email',
            description: 'Customer email address',
        },
        phone: {
            type: 'string',
            description: 'Customer phone number',
        },
        address1: {
            type: 'string',
            description: 'Customer address line 1',
        },
        address2: {
            type: 'string',
            description: 'Customer address line 2',
        },
        city: {
            type: 'string',
            description: 'Customer city',
        },
        state: {
            type: 'string',
            description: 'Customer state or province',
        },
        zip: {
            type: 'string',
            description: 'Customer postal code',
        },
        country: {
            type: 'string',
            description: 'Customer country',
        },
        captureImmediately: {
            type: 'boolean',
            description: 'Whether to capture the transaction immediately after authorization',
        },
        use_wallet_balance: {
            type: 'boolean',
            description: 'Flag to indicate if the user wants to use their wallet balance',
        },
        recipient_entity_id: {
            type: 'string',
            description: 'ID of the recipient entity',
        },
        recipient_type: {
            type: 'string',
            description: 'Type of recipient (user, business, etc.)',
        },
        recipient_clkk_tag: {
            type: 'string',
            description: 'Clkk tag of the recipient',
        },
        sender_clkk_tag: {
            type: 'string',
            description: 'Clkk tag of the sender',
        },
        recipient_current_email: {
            type: 'string',
            format: 'email',
            description: 'Current email of the recipient',
        },
        sender_current_email: {
            type: 'string',
            format: 'email',
            description: 'Current email of the sender',
        },
    },
    additionalProperties: false,
};

export const captureRequestSchema = {
    type: 'object',
    required: ['transactionId'],
    properties: {
        transactionId: {
            type: 'string',
            description: 'Original transaction ID to capture',
        },
        amount: {
            type: 'string',
            pattern: '^[0-9]+(.[0-9]{1,2})?$',
            description: 'Amount to capture, can be equal to or less than original amount',
        },
    },
    additionalProperties: false,
};

export const queryTransactionSchema = {
    type: 'object',
    properties: {
        transaction_id: {
            type: 'string',
            description: 'Transaction ID to query',
        },
        condition: {
            type: 'string',
            description: 'Transaction condition (pending, pendingsettlement, complete, etc.)',
        },
        transaction_type: {
            type: 'string',
            description: 'Transaction type (cc, ck)',
        },
        action_type: {
            type: 'string',
            description: 'Action type (sale, refund, credit, auth, capture, void, return)',
        },
        source: {
            type: 'string',
            description: 'Transaction source (api, batch_upload, mobile, etc.)',
        },
        start_date: {
            type: 'string',
            description: 'Start date for transaction search (YYYYMMDDhhmmss)',
        },
        end_date: {
            type: 'string',
            description: 'End date for transaction search (YYYYMMDDhhmmss)',
        },
        result_limit: {
            type: 'string',
            description: 'Maximum number of results to return',
        },
        page_number: {
            type: 'string',
            description: 'Page number for paginated results',
        },
        order_id: {
            type: 'string',
            description: 'Order ID to search for',
        },
        email: {
            type: 'string',
            description: 'Customer email to search for',
        },
        result_order: {
            type: 'string',
            enum: ['standard', 'reverse'],
            description: 'Sort order for results (standard=oldest to newest, reverse=newest to oldest)',
        },
    },
    additionalProperties: false,
};

export const cardTypeCheckSchema = {
    type: 'object',
    required: ['ccnumber'],
    properties: {
        ccnumber: {
            type: 'string',
            minLength: 6,
            maxLength: 16,
            pattern: '^[0-9]+$',
            description: 'Credit card Issuer Identification Number (IIN) - at least first 6 digits',
        },
    },
    additionalProperties: false,
};
</file>

<file path="lambdas/nmi/webhooks/config/index.ts">
/**
 * NMI configuration exports
 */

export * from './paths';
export { default as nmiPaths } from './paths';
</file>

<file path="lambdas/nmi/webhooks/config/paths.ts">
/**
 * NMI API path configurations
 * Centralizes all NMI endpoint paths for reuse across the application
 */

import { ENVIRONMENT } from '../../../layers/commons/utils/config';

/**
 * Base URLs for different NMI APIs
 */
export const NMI_BASE_URLS = {
    /** Main NMI Gateway API base URL */
    GATEWAY: process.env.NMI_API_URL || 'https://rytepay.transactiongateway.com/api',
    /** Card Type API base URL */
    CARD_TYPE: process.env.NMI_MAIN_API_URL || 'https://secure.nmi.com/api/v4',
};

/**
 * NMI API endpoint paths
 */
export const NMI_ENDPOINTS = {
    /** Transaction processing endpoint */
    TRANSACTION: 'transact.php',
    /** Query transactions endpoint */
    QUERY: 'query.php',
    /** Card type endpoint */
    CARD_TYPE: 'card_type',
};

/**
 * Complete API URLs with endpoints
 */
export const NMI_API_URLS = {
    /** Transaction processing full URL */
    TRANSACTION: `${NMI_BASE_URLS.GATEWAY}/${NMI_ENDPOINTS.TRANSACTION}`,
    /** Query transactions full URL */
    QUERY: `${NMI_BASE_URLS.GATEWAY}/${NMI_ENDPOINTS.QUERY}`,
    /** Card type check URL */
    CARD_TYPE: `${NMI_BASE_URLS.CARD_TYPE}/${NMI_ENDPOINTS.CARD_TYPE}`,
};

/**
 * Auth prefixes for different NMI API versions
 */
export const NMI_AUTH_PREFIXES = {
    /** V4 private API key prefix */
    V4_PRIVATE: 'v4_private_',
};

/**
 * Feature flags and configuration for NMI services
 */
export const NMI_FEATURES = {
    /** Card type validation configuration */
    CARD_TYPE_VALIDATION: {
        /** Whether card type validation is enabled */
        ENABLED: ENVIRONMENT !== 'dev', // Only enable in non-dev environments
        /** Card types allowed for transactions */
        ALLOWED_TYPES: ['debit'],
        /** Skip validation in case of errors */
        FAIL_OPEN: true,
    },
};

export default {
    NMI_BASE_URLS,
    NMI_ENDPOINTS,
    NMI_API_URLS,
    NMI_AUTH_PREFIXES,
    NMI_FEATURES,
};
</file>

<file path="lambdas/nmi/webhooks/services/book-transfer-service.ts">
/**
 * Book transfer service for handling Cybrid book transfers
 * Used for internal money movement between accounts
 */

import { Logger } from '@aws-lambda-powertools/logger';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'book-transfer-service',
});

const secretsClient = new SecretsManagerClient({ region: process.env.AWS_REGION });

// Helper functions
const getCybridToken = async (): Promise<string> => {
    const secretName = process.env.CYBRID_SECRET_NAME || '/cybrid/api-keys/dev';
    
    try {
        const command = new GetSecretValueCommand({ SecretId: secretName });
        const data = await secretsClient.send(command);
        
        if (!data.SecretString) {
            throw new Error('Failed to get Cybrid client credentials');
        }
        
        const secret = JSON.parse(data.SecretString);
        
        const authUrl = `${process.env.CYBRID_URL_SCHEME || 'https'}://id.${process.env.CYBRID_BASE_URL || 'sandbox.cybrid.app'}/oauth/token`;
        const scopes = [
            'quotes:read',
            'quotes:execute',
            'transfers:read',
            'transfers:execute',
        ];
        
        const requestData = {
            grant_type: 'client_credentials',
            client_id: secret.client_id,
            client_secret: secret.client_secret,
            scope: scopes.join(' '),
        };
        
        const response = await axios.post(authUrl, requestData, {
            headers: { 'Content-Type': 'application/json' },
        });
        
        return response.data.access_token;
    } catch (error) {
        logger.error('Error retrieving Cybrid token', { error });
        throw new Error('Failed to get Cybrid authentication token');
    }
};

const getCybridUrl = {
    quotes: () => `${process.env.CYBRID_URL_SCHEME || 'https'}://bank.${process.env.CYBRID_BASE_URL || 'sandbox.cybrid.app'}/api/quotes`,
    transfers: () => `${process.env.CYBRID_URL_SCHEME || 'https'}://bank.${process.env.CYBRID_BASE_URL || 'sandbox.cybrid.app'}/api/transfers`,
};

export interface BookTransferRequest {
    sourceAccountId: string;
    destinationAccountId: string;
    amount: number; // Amount in cents
    asset: string;
    memo?: string;
    metadata?: Record<string, any>;
    // Source participant details
    sourceParticipantType: 'bank' | 'customer';
    sourceParticipantGuid: string;
    // Destination participant details
    destinationParticipantType: 'bank' | 'customer';
    destinationParticipantGuid: string;
}

export interface BookTransferResponse {
    transferGuid: string;
    quoteGuid: string;
    state: string;
    amount: number;
    asset: string;
    sourceAccountGuid: string;
    destinationAccountGuid: string;
    createdAt: string;
}

export interface CybridQuoteRequest {
    product_type: string;
    customer_guid: string;
    asset: string;
    side: string;
    receive_amount?: number;
    deliver_amount?: number;
}

export interface CybridTransferRequest {
    quote_guid: string;
    transfer_type: string;
    source_account_guid: string;
    destination_account_guid: string;
    source_participants: Array<{
        type: string;
        amount: number;
        guid: string;
    }>;
    destination_participants: Array<{
        type: string;
        amount: number;
        guid: string;
    }>;
}

export class BookTransferService {
    /**
     * Creates a book transfer between two Cybrid accounts
     * This is a two-step process: create a quote, then create a transfer
     * Can handle both bank-to-customer and customer-to-customer transfers
     */
    static async createBookTransfer(request: BookTransferRequest, requestId: string): Promise<BookTransferResponse> {
        const functionName = 'createBookTransfer';

        logger.info(`[${functionName}] Creating book transfer`, {
            requestId,
            sourceAccountId: request.sourceAccountId,
            destinationAccountId: request.destinationAccountId,
            amount: request.amount,
            asset: request.asset,
        });

        try {
            // Step 1: Create a quote for the book transfer
            // Use the appropriate customer GUID based on participant type
            const customerGuid =
                request.sourceParticipantType === 'customer'
                    ? request.sourceParticipantGuid
                    : request.destinationParticipantGuid;

            const quote = await this.createBookTransferQuote(customerGuid, request.amount, request.asset, requestId);

            logger.info(`[${functionName}] Quote created successfully`, {
                requestId,
                quoteGuid: quote.guid,
                receiveAmount: quote.receive_amount,
                deliverAmount: quote.deliver_amount,
            });

            // Step 2: Create the transfer using the quote
            const transfer = await this.createTransferFromQuote(quote.guid, request, requestId);

            logger.info(`[${functionName}] Book transfer created successfully`, {
                requestId,
                transferGuid: transfer.guid,
                state: transfer.state,
            });

            return {
                transferGuid: transfer.guid || '',
                quoteGuid: quote.guid || '',
                state: transfer.state || 'pending',
                amount: request.amount,
                asset: request.asset,
                sourceAccountGuid: request.sourceAccountId,
                destinationAccountGuid: request.destinationAccountId,
                createdAt: transfer.created_at || new Date().toISOString(),
            };
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to create book transfer`, {
                requestId,
                error: error.message,
                errorResponse: error.response?.data,
                errorStatus: error.response?.status,
            });
            throw new Error(`Failed to create book transfer: ${error.message}`);
        }
    }

    /**
     * Creates a quote for a book transfer
     */
    private static async createBookTransferQuote(
        customerGuid: string,
        amount: number,
        asset: string,
        requestId: string,
    ): Promise<any> {
        const functionName = 'createBookTransferQuote';

        logger.info(`[${functionName}] Creating book transfer quote`, {
            requestId,
            customerGuid,
            amount,
            asset,
        });

        const cybridToken = await getCybridToken();
        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        const quoteRequest: CybridQuoteRequest = {
            product_type: 'book_transfer',
            customer_guid: customerGuid,
            asset: asset,
            side: 'deposit',
            receive_amount: amount, // Amount in cents (both NMI and Cybrid use cents for USD)
        };

        try {
            const startTime = Date.now();
            const response = await axios.post(getCybridUrl.quotes(), quoteRequest, { headers });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Quote created`, {
                requestId,
                quoteGuid: response.data.guid,
                latencyMs: latency,
            });

            return response.data;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to create quote`, {
                requestId,
                error: error.message,
                errorResponse: error.response?.data,
            });
            throw error;
        }
    }

    /**
     * Creates a transfer from a quote
     */
    private static async createTransferFromQuote(
        quoteGuid: string,
        request: BookTransferRequest,
        requestId: string,
    ): Promise<any> {
        const functionName = 'createTransferFromQuote';

        logger.info(`[${functionName}] Creating transfer from quote`, {
            requestId,
            quoteGuid,
            sourceAccountGuid: request.sourceAccountId,
            destinationAccountGuid: request.destinationAccountId,
        });

        const cybridToken = await getCybridToken();
        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        const transferRequest: CybridTransferRequest = {
            quote_guid: quoteGuid,
            transfer_type: 'book',
            source_account_guid: request.sourceAccountId,
            destination_account_guid: request.destinationAccountId,
            source_participants: [
                {
                    type: request.sourceParticipantType,
                    amount: request.amount,
                    guid: request.sourceParticipantGuid,
                },
            ],
            destination_participants: [
                {
                    type: request.destinationParticipantType,
                    amount: request.amount,
                    guid: request.destinationParticipantGuid,
                },
            ],
        };

        try {
            const startTime = Date.now();
            const response = await axios.post(getCybridUrl.transfers(), transferRequest, { headers });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Transfer created`, {
                requestId,
                transferGuid: response.data.guid,
                state: response.data.state,
                latencyMs: latency,
            });

            return response.data;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to create transfer`, {
                requestId,
                error: error.message,
                errorResponse: error.response?.data,
            });
            throw error;
        }
    }

    /**
     * Gets the status of a transfer
     */
    static async getTransferStatus(transferGuid: string, requestId: string): Promise<any> {
        const functionName = 'getTransferStatus';

        logger.info(`[${functionName}] Getting transfer status`, {
            requestId,
            transferGuid,
        });

        const cybridToken = await getCybridToken();
        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        try {
            const startTime = Date.now();
            const response = await axios.get(`${getCybridUrl.transfers()}/${transferGuid}`, { headers });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Transfer status retrieved`, {
                requestId,
                transferGuid,
                state: response.data.state,
                latencyMs: latency,
            });

            return response.data;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to get transfer status`, {
                requestId,
                transferGuid,
                error: error.message,
                errorResponse: error.response?.data,
            });
            throw error;
        }
    }
}
</file>

<file path="lambdas/nmi/webhooks/services/nmi-service.ts">
import { createLogger } from 'commons/utils/logger_v2';
import { KmsService } from 'commons/services/KmsService';
import { XMLParser } from 'fast-xml-parser';
import { EntityTypeString } from 'commons/data/entities/entity';
import {
    NmiCustomer,
    createNmiCustomer,
    listNmiCustomersByEntity,
    getNmiCustomerByVaultId,
} from 'commons/services/nmi/nmi-customer';
import {
    AuthorizationRequest,
    CaptureRequest,
    TransactionResponse,
    PaymentResponse,
    TransactionRecord,
    ResponseCode,
    ResultCode,
    NmiTransactionType,
    QueryTransactionRequest,
    QueryTransactionResponse,
    CardTypeCheckResponse,
    CustomerVaultRequest,
    CustomerVaultResponse,
} from '../types/nmi';
import { URLSearchParams } from 'url';
import { TransactionType, TransactionStatus, TransactionService, Transaction } from 'commons/data/entities/transaction';
import { Money } from 'commons/data/entities/money';
import { WalletService, CurrencyCode } from 'commons/data/entities/wallet';
import { NMI_ENDPOINTS, NMI_API_URLS, NMI_AUTH_PREFIXES, NMI_FEATURES } from '../config';

/**
 * Configuration for NMI payment gateway
 */
interface NmiConfig {
    /** API endpoint for NMI transactions */
    apiUrl: string;
    /** Security key for NMI authentication */
    securityKey: string;
    /** Timeout for API requests in milliseconds */
    timeout: number;
}

/**
 * Service class for handling NMI payment gateway operations
 */
export class NmiService {
    private logger = createLogger('NmiService');
    private kmsService: KmsService;
    private config: NmiConfig;

    /**
     * Initialize the NMI Service
     * @param kmsService - KMS service for data encryption
     * @param config - Configuration for NMI gateway
     */
    constructor(kmsService: KmsService, config: NmiConfig) {
        this.kmsService = kmsService;
        this.config = config;
    }

    /**
     * Health check endpoint
     * @returns Success response
     */
    async getEchoEndpoint(): Promise<{ message: string; success: boolean }> {
        this.logger.info('Executing NMI echo endpoint');
        return {
            message: 'ok',
            success: true,
        };
    }

    /**
     * Direct method to handle wallet-to-wallet transfers without going through NMI
     * @param entityId - Sender's ID
     * @param request - Transfer request parameters
     * @param transactionType - Must be P2P or P2B
     * @param options - Additional options for transaction processing
     * @returns Payment response
     */
    async handleWalletTransfer(
        entityId: string,
        request: { amount: string },
        transactionType: TransactionType.P2P | TransactionType.P2B,
        options: {
            recipientEntityId: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        },
    ): Promise<PaymentResponse> {
        if (!options.recipientEntityId) {
            return {
                success: false,
                message: 'Recipient ID is required for wallet transfers',
                status: 'failed',
                errorCode: 'INVALID_REQUEST',
            };
        }

        this.logger.info('Processing wallet-to-wallet transfer', {
            entityId,
            transactionType,
            amount: request.amount,
            recipientId: options.recipientEntityId,
        });

        try {
            // Create transaction record first (with useWalletBalance=true for wallet transfers)
            const transaction = await this.createTransactionRecord(
                entityId,
                request.amount,
                transactionType,
                true, // Always true for wallet transfers
                options,
            );

            // Process the wallet transfer
            return this.processWalletToWalletTransfer(
                transaction,
                entityId,
                options.recipientEntityId,
                request.amount,
                transactionType,
            );
        } catch (error) {
            this.logger.error('Error processing wallet transfer', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Authorize a card transaction through NMI payment provider
     * @param entityId - User's ID
     * @param request - Authorization request parameters
     * @param transactionType - Transaction type
     * @param options - Additional options for transaction processing
     * @returns Payment response
     */
    async authorizeTransaction(
        entityId: string,
        request: Omit<AuthorizationRequest, 'type' | 'security_key'>,
        transactionType: TransactionType,
        options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        } = {},
    ): Promise<PaymentResponse> {
        this.logger.info('Authorizing card transaction', {
            entityId,
            transactionType,
            amount: request.amount,
        });

        try {
            // Create transaction record first
            const transaction = await this.createTransactionRecord(
                entityId,
                request.amount,
                transactionType,
                false, // Always false for card payments
                options,
            );

            // Process as a card payment
            return this.processCardPayment(transaction, entityId, request, transactionType, options);
        } catch (error) {
            this.logger.error('Error authorizing card transaction', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Process a wallet-to-wallet transfer (no payment provider needed)
     * @param transaction - Transaction record
     * @param senderId - Sender's ID
     * @param recipientId - Recipient's ID
     * @param amount - Transaction amount
     * @param transactionType - Transaction type (P2P or P2B)
     * @returns Payment response
     */
    private async processWalletToWalletTransfer(
        transaction: Transaction,
        senderId: string,
        recipientId?: string,
        amount?: string,
        transactionType?: TransactionType,
    ): Promise<PaymentResponse> {
        this.logger.info(`Processing ${transactionType} wallet-to-wallet transfer`, {
            transactionId: transaction.transactionId,
            senderId,
            recipientId,
            amount,
        });

        try {
            // This will trigger the wallet update for the recipient
            await transaction.complete();

            this.logger.info(`${transactionType} wallet-to-wallet transfer completed successfully`, {
                transactionId: transaction.transactionId,
                senderId,
                recipientId,
                amount,
                status: transaction.status,
            });

            // Create a payment response without NMI details
            return {
                success: true,
                message: `${transactionType} transfer processed successfully`,
                status: 'captured', // Use 'captured' status for completed transfers
                internalTransactionId: transaction.transactionId,
            };
        } catch (error) {
            this.logger.error(`Error processing ${transactionType} wallet-to-wallet transfer`, {
                error: error instanceof Error ? error.message : 'Unknown error',
                transactionId: transaction.transactionId,
                senderId,
                recipientId,
            });

            // Mark transaction as failed
            transaction.status = TransactionStatus.FAILED;
            await transaction.update();

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
                internalTransactionId: transaction.transactionId,
            };
        }
    }

    /**
     * Process a card payment through NMI payment provider
     * @param transaction - Transaction record
     * @param entityId - User's ID
     * @param request - Authorization request parameters
     * @param transactionType - Transaction type
     * @param options - Additional options for transaction processing
     * @returns Payment response
     */
    private async processCardPayment(
        transaction: Transaction,
        entityId: string,
        request: Omit<AuthorizationRequest, 'type' | 'security_key'>,
        transactionType: TransactionType,
        options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        } = {},
    ): Promise<PaymentResponse> {
        // Determine the payment scenario based on request parameters
        const paymentScenario =
            request.customer_vault === 'add_customer'
                ? 'new_vault'
                : request.use_saved_card
                ? 'existing_vault'
                : 'direct_payment';

        this.logger.info('Processing card payment', {
            paymentScenario,
            transactionId: transaction.transactionId,
            entityId,
        });

        // Create the complete request with type and security key
        const fullRequest: AuthorizationRequest = {
            ...request,
            type: NmiTransactionType.AUTH,
            security_key: this.config.securityKey,
        };

        // If using an existing vault ID, fetch it from the database based on entityId
        if (paymentScenario === 'existing_vault') {
            try {
                // Get the customer vaults for this user - we only expect one per user
                const customerVaults = await listNmiCustomersByEntity(entityId);

                if (!customerVaults || customerVaults.length === 0) {
                    throw new Error(`No saved payment method found for user ${entityId}`);
                }

                // Just use the first vault since there should only be one
                const nmiCustomer = customerVaults[0];
                const customerVaultId = nmiCustomer.customerVaultId;

                this.logger.info('Using existing customer vault ID', {
                    customerVaultId,
                    ccType: nmiCustomer.ccType,
                });

                // Add the customer_vault_id to the request
                fullRequest.customer_vault_id = customerVaultId;
            } catch (vaultError) {
                this.logger.error('Error fetching customer vault for user', {
                    error: vaultError instanceof Error ? vaultError.message : 'Unknown error',
                    entityId,
                });
                throw new Error(
                    `Unable to use saved card: ${vaultError instanceof Error ? vaultError.message : 'Unknown error'}`,
                );
            }
        }

        this.logger.info('Sending payment request to NMI', {
            transactionId: transaction.transactionId,
        });

        // Process authorization through NMI
        const response: TransactionResponse = await this.processNmiRequest<AuthorizationRequest>(
            fullRequest,
            NMI_ENDPOINTS.TRANSACTION,
        );

        // log response
        this.logger.info('NMI payment response received back on method', {
            response,
        });

        this.logger.info('NMI payment response received', {
            providerTransactionId: response.transactionid,
            authCode: response.authcode,
            responseCode: response.response_code,
            responseText: response.responsetext,
            internalTransactionId: transaction.transactionId,
        });

        // Update the transaction with provider details
        const updatedTransaction = await this.updateTransactionWithProviderDetails(transaction.transactionId, response);

        // log vault and

        // If a customer vault ID was returned, store it for future use
        if (response.customer_vault_id && request.customer_vault === 'add_customer') {
            try {
                this.logger.info('Customer vault ID detected in response, storing for entity', {
                    entityId,
                    customerVaultId: response.customer_vault_id,
                    ccType: response.cc_type,
                });

                // Check if user already has a vault record and delete it first
                await this.deleteExistingVaultRecords(entityId);

                // Create NMI customer record for this user
                await createNmiCustomer(entityId, 'USER', response.customer_vault_id, {
                    ccType: response.cc_type,
                    ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
                });

                this.logger.info('Successfully stored NMI customer vault record', {
                    entityId,
                    customerVaultId: response.customer_vault_id,
                });
            } catch (vaultError) {
                // Log error but don't fail the transaction - the payment still succeeded
                this.logger.error('Error storing customer vault information', {
                    error: vaultError instanceof Error ? vaultError.message : 'Unknown error',
                    entityId,
                    customerVaultId: response.customer_vault_id,
                });
            }
        }

        // Create a payment response that includes both transaction IDs
        const paymentResponse = this.createPaymentResponse(response, updatedTransaction);

        // Add the internal transaction ID explicitly
        return {
            ...paymentResponse,
            internalTransactionId: transaction.transactionId,
        };
    }

    /**
     * Create a transaction record in the database
     * @param entityId - User's ID initiating the transaction
     * @param amount - Transaction amount
     * @param transactionType - Type of transaction
     * @param useWalletBalance - Whether to use wallet balance for payment (vs card)
     * @param options - Additional options for transaction creation
     * @returns Created transaction record
     */
    private async createTransactionRecord(
        entityId: string,
        amount: string,
        transactionType: TransactionType,
        useWalletBalance: boolean = false,
        options: {
            recipientEntityId?: string;
            recipientType?: EntityTypeString;
            recipientCurrentEmail?: string;
            senderId?: string;
            senderType?: EntityTypeString;
            senderClkkTag?: string;
            senderEntityId?: string;
            senderCurrentEmail?: string;
            recipientClkkTag?: string;
        } = {},
    ): Promise<Transaction> {
        if (transactionType === TransactionType.DEPOSIT) {
            this.logger.info('Creating deposit transaction record', {
                entityId,
                amount,
            });

            // For a deposit, the user (entityId) is the recipient
            const transaction = await TransactionService.createDeposit(
                entityId, // recipientId (the user receiving funds)
                'USER', // recipientType
                TransactionStatus.PENDING,
                amount,
                '', // senderId (empty for card deposit)
            );

            this.logger.info('Deposit transaction created', {
                transactionId: transaction.transactionId,
                amount,
                entityId,
            });

            return transaction;
        } else if (transactionType === TransactionType.P2P) {
            const {
                recipientEntityId,
                recipientType,
                recipientClkkTag,
                senderClkkTag,
                recipientCurrentEmail,
                senderCurrentEmail,
            } = options;
            this.logger.info('Creating P2P transaction record at function', {
                entityId,
                recipientEntityId,
                amount,
                useWalletBalance,
                options,
            });

            if (!recipientEntityId) {
                throw new Error('Recipient entity ID is required for P2P transfers');
            }

            this.logger.info('Creating P2P transaction record', {
                entityId,
                recipientEntityId,
                amount,
                useWalletBalance,
                options,
            });

            // Create metadata with additional information
            const metadata: any = {
                description: `P2P transfer from ${senderClkkTag || entityId} to ${
                    recipientClkkTag || recipientEntityId
                }`,
                paymentMethod: useWalletBalance ? 'wallet' : 'card',
            };

            if (senderClkkTag) metadata.senderClkkTag = senderClkkTag;
            if (recipientClkkTag) metadata.recipientClkkTag = recipientClkkTag;
            if (recipientCurrentEmail) metadata.recipientCurrentEmail = recipientCurrentEmail;
            if (senderCurrentEmail) metadata.senderCurrentEmail = senderCurrentEmail;

            this.logger.info('Creating P2P transaction record after metadata', {
                entityId,
                recipientEntityId,
                amount,
                useWalletBalance,
                options,
                metadata,
            });

            // Create a single transaction for P2P transfer
            const transaction = new Transaction(TransactionType.P2P, amount, 'USD', TransactionStatus.PENDING, {
                sender: {
                    id: entityId,
                    type: 'USER',
                    name: senderClkkTag,
                },
                receiver: {
                    id: recipientEntityId,
                    type: recipientType || 'USER',
                    name: recipientClkkTag,
                },
                metadata,
            });

            // If using wallet balance, deduct from sender's wallet immediately
            if (useWalletBalance) {
                this.logger.info('Decided to deduct from sender wallet', {
                    entityId,
                    amount,
                    transactionId: transaction.transactionId,
                });
                try {
                    // Check if sender has sufficient funds
                    const wallet = await WalletService.getWallet(entityId, 'USER', 'USD');

                    this.logger.info('Got Wallet from DB', {
                        entityId,
                        wallet,
                    });

                    if (!wallet) {
                        throw new Error('Sender wallet not found');
                    }

                    const walletBalance = new Money(wallet.balance, 'USD');
                    const transferAmount = new Money(amount, 'USD');

                    if (walletBalance.lessThan(transferAmount)) {
                        throw new Error('Insufficient funds in wallet');
                    }

                    // Deduct from sender's wallet
                    await WalletService.withdraw(entityId, 'USER', transferAmount, transaction.transactionId, 'USD');

                    this.logger.info('Deducted amount from sender wallet', {
                        senderId: entityId,
                        amount: transferAmount.toString(),
                        transactionId: transaction.transactionId,
                    });

                    // Store the balance before and after in the transaction
                    transaction.balanceBefore = walletBalance.toString();
                    transaction.balanceAfter = walletBalance.subtract(transferAmount).toString();
                } catch (error) {
                    this.logger.error('Error deducting from sender wallet', {
                        error: error instanceof Error ? error.message : 'Unknown error',
                        senderId: entityId,
                        amount,
                    });
                    throw error;
                }
            }

            // Create the transaction record
            await transaction.create();

            this.logger.info('P2P transaction created', {
                transactionId: transaction.transactionId,
                senderId: entityId,
                receiverId: recipientEntityId,
                amount,
                useWalletBalance,
            });

            return transaction;
        } else if (transactionType === TransactionType.P2B) {
            const { recipientEntityId, recipientType, recipientClkkTag, senderClkkTag } = options;

            if (!recipientEntityId) {
                throw new Error('Business entity ID is required for P2B transfers');
            }

            this.logger.info('Creating P2B transaction record', {
                entityId,
                businessId: recipientEntityId,
                amount,
                useWalletBalance,
            });

            // Create metadata with additional information
            const metadata: any = {
                description: `Payment from ${senderClkkTag || entityId} to ${recipientClkkTag || recipientEntityId}`,
                paymentMethod: useWalletBalance ? 'wallet' : 'card',
            };

            if (senderClkkTag) metadata.senderClkkTag = senderClkkTag;
            if (recipientClkkTag) metadata.businessName = recipientClkkTag;

            // Create a single transaction for P2B transfer
            const transaction = new Transaction(TransactionType.P2B, amount, 'USD', TransactionStatus.PENDING, {
                sender: {
                    id: entityId,
                    type: 'USER',
                    name: senderClkkTag,
                },
                receiver: {
                    id: recipientEntityId,
                    type: recipientType || 'BUSINESS',
                    name: recipientClkkTag,
                },
                metadata,
            });

            // If using wallet balance, deduct from sender's wallet immediately
            if (useWalletBalance) {
                try {
                    // Check if sender has sufficient funds
                    const wallet = await WalletService.getWallet(entityId, 'USER', 'USD');
                    if (!wallet) {
                        throw new Error('Sender wallet not found');
                    }

                    const walletBalance = new Money(wallet.balance, 'USD');
                    const transferAmount = new Money(amount, 'USD');

                    if (walletBalance.lessThan(transferAmount)) {
                        throw new Error('Insufficient funds in wallet');
                    }

                    // Deduct from sender's wallet
                    await WalletService.withdraw(entityId, 'USER', transferAmount, transaction.transactionId, 'USD');

                    this.logger.info('Deducted amount from sender wallet', {
                        senderId: entityId,
                        amount: transferAmount.toString(),
                        transactionId: transaction.transactionId,
                    });

                    // Store the balance before and after in the transaction
                    transaction.balanceBefore = walletBalance.toString();
                    transaction.balanceAfter = walletBalance.subtract(transferAmount).toString();
                } catch (error) {
                    this.logger.error('Error deducting from sender wallet', {
                        error: error instanceof Error ? error.message : 'Unknown error',
                        senderId: entityId,
                        amount,
                    });
                    throw error;
                }
            }

            // Create the transaction record
            await transaction.create();

            this.logger.info('P2B transaction created', {
                transactionId: transaction.transactionId,
                senderId: entityId,
                businessId: recipientEntityId,
                amount,
                useWalletBalance,
            });

            return transaction;
        } else {
            throw new Error(`Unsupported transaction type: ${transactionType}`);
        }
    }

    /**
     * Validates if a card is acceptable for transactions based on its type
     * @param transactionId - Transaction ID to query for card information
     * @returns Validation result with reason if invalid
     */
    private async validateCardType(transactionId: string): Promise<{ isValid: boolean; reason?: string }> {
        this.logger.info('Validating card type for transaction', { transactionId });

        // Skip validation if not enabled
        if (!NMI_FEATURES.CARD_TYPE_VALIDATION.ENABLED) {
            this.logger.info('Card type validation skipped - feature disabled');
            return { isValid: true };
        }

        try {
            // Get the card BIN from the transaction
            const cardBin = await this.getCardBinFromTransaction(transactionId);

            if (!cardBin) {
                this.logger.warn('No card BIN found for transaction, skipping card type validation', { transactionId });
                return { isValid: true };
            }

            // Check the card type using the BIN
            const cardType = await this.getCardTypeFromBin(cardBin);

            if (!cardType) {
                this.logger.warn('Could not determine card type, skipping validation', { transactionId });
                return { isValid: true };
            }

            // Check if card type is in allowed types
            const allowedTypes = NMI_FEATURES.CARD_TYPE_VALIDATION.ALLOWED_TYPES;
            if (!allowedTypes.includes(cardType)) {
                this.logger.info('Transaction rejected - card type not allowed', {
                    transactionId,
                    cardType,
                    allowedTypes,
                });

                return {
                    isValid: false,
                    reason: `Only ${allowedTypes.join(', ')} cards are allowed. Card type: ${cardType}`,
                };
            }

            this.logger.info('Card type verified as allowed, proceeding with transaction', {
                transactionId,
                cardType,
            });
            return { isValid: true };
        } catch (error) {
            this.logger.error('Error validating card type', {
                transactionId,
                error: error instanceof Error ? error.message : 'Unknown error',
            });

            // If validation fails, check if we should fail open or closed
            if (NMI_FEATURES.CARD_TYPE_VALIDATION.FAIL_OPEN) {
                this.logger.info('Proceeding with transaction despite validation error (fail-open policy)');
                return { isValid: true };
            } else {
                this.logger.info('Rejecting transaction due to validation error (fail-closed policy)');
                return {
                    isValid: false,
                    reason: 'Card validation failed due to technical error',
                };
            }
        }
    }

    /**
     * Retrieves the card BIN (first 6 digits) from a transaction
     * @param transactionId - Transaction ID to query
     * @returns Card BIN if found, undefined otherwise
     */
    private async getCardBinFromTransaction(transactionId: string): Promise<string | undefined> {
        this.logger.info('Getting card BIN from transaction', { transactionId });

        try {
            // Query the transaction to get details including cc_bin
            const queryResponse = await this.queryTransactions({
                transaction_id: transactionId,
            });

            if (queryResponse.success && queryResponse.transactions && queryResponse.transactions.length > 0) {
                const cc_bin = queryResponse.transactions[0].cc_bin;

                if (cc_bin) {
                    this.logger.info('Retrieved card BIN from transaction', {
                        transactionId,
                        cc_bin: cc_bin.substring(0, 3) + '***',
                    });

                    return cc_bin;
                } else {
                    this.logger.warn('No card BIN found in transaction query response', { transactionId });
                }
            } else {
                this.logger.warn('Transaction query failed or returned no results', {
                    transactionId,
                    errorMessage: queryResponse.message,
                });
            }

            return undefined;
        } catch (error) {
            this.logger.error('Error retrieving card BIN from transaction', {
                transactionId,
                error: error instanceof Error ? error.message : 'Unknown error',
            });

            return undefined;
        }
    }

    /**
     * Determines the card type based on BIN
     * @param cardBin - Card BIN (first 6 digits)
     * @returns Card type if determined, undefined otherwise
     */
    private async getCardTypeFromBin(cardBin: string): Promise<string | undefined> {
        this.logger.info('Getting card type from BIN', {
            cardBin: cardBin.substring(0, 3) + '***',
        });

        try {
            // Check the card type using the BIN
            const cardTypeResponse = await this.checkCardType(cardBin);

            if (cardTypeResponse.success && cardTypeResponse.result) {
                this.logger.info('Card type determined', {
                    cardBin: cardBin.substring(0, 3) + '***',
                    cardType: cardTypeResponse.result,
                });

                return cardTypeResponse.result;
            } else {
                this.logger.warn('Unable to determine card type', {
                    cardBin: cardBin.substring(0, 3) + '***',
                    errorMessage: cardTypeResponse.message,
                });

                return undefined;
            }
        } catch (error) {
            this.logger.error('Error determining card type from BIN', {
                cardBin: cardBin.substring(0, 3) + '***',
                error: error instanceof Error ? error.message : 'Unknown error',
            });

            return undefined;
        }
    }

    /**
     * Capture a previously authorized transaction
     * @param userId - User's ID
     * @param transactionId - Original transaction ID to capture (from NMI)
     * @param amount - Amount to capture (can be less than original)
     * @returns Payment response
     */
    async captureTransaction(userId: string, transactionId: string, amount?: string): Promise<PaymentResponse> {
        this.logger.info('Capturing transaction', {
            userId,
            providerTransactionId: transactionId,
            amount,
        });

        try {
            // Create the capture request
            const captureRequest: CaptureRequest = {
                type: NmiTransactionType.CAPTURE,
                transactionid: transactionId,
                amount,
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest<CaptureRequest>(captureRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Capture response', { response });

            this.logger.info('Transaction captured', {
                transactionId: response.transactionid,
                authCode: response.authcode,
                responseCode: response.response_code,
                responseText: response.responsetext,
            });

            // Keep transaction in PENDING status for webhook updates later
            // The webhook handler will update to COMPLETED when final settlement occurs
            const status =
                response.response === ResponseCode.APPROVED ? TransactionStatus.PENDING : TransactionStatus.FAILED;

            // First, find the internal transaction by provider transaction ID
            try {
                this.logger.info('Finding transaction by provider transaction ID', {
                    providerTransactionId: transactionId,
                });

                // Try to find transactions with this provider transaction ID
                const transactions = await TransactionService.getTransactionsByProviderTransactionId(transactionId);

                if (!transactions || transactions.length === 0) {
                    this.logger.warn('No transaction found with provider transaction ID', {
                        providerTransactionId: transactionId,
                    });

                    // Return a basic response if no transaction is found
                    return {
                        success: response.response === ResponseCode.APPROVED,
                        transactionId: response.transactionid,
                        message: response.responsetext || '',
                        status: 'pending',
                        errorCode: response.response !== ResponseCode.APPROVED ? response.response_code : undefined,
                    };
                }

                // Use the first transaction found (should be only one)
                const internalTransaction = transactions[0];
                const internalTransactionId = internalTransaction.transactionId;

                this.logger.info('Found internal transaction', {
                    internalTransactionId,
                    providerTransactionId: transactionId,
                });

                // Update transaction record with our internal transaction ID
                const updatedTransaction = await TransactionService.updateTransaction(internalTransactionId, {
                    status: status,
                    metadata: {
                        ...((await TransactionService.getTransaction(internalTransactionId))?.metadata || {}),
                        statusReason: response.responsetext,
                        authCode: response.authcode,
                        responseCode: response.response_code,
                        responseText: response.responsetext,
                    },
                    updatedAt: new Date().toISOString(),
                });

                this.logger.info('Internal transaction updated successfully', {
                    transaction: updatedTransaction,
                    internalTransactionId: updatedTransaction.transactionId,
                });

                // Create and return the payment response
                this.logger.info('Creating payment response for updated transaction');
                const paymentResponse = this.createPaymentResponse(response, updatedTransaction);
                return paymentResponse;
            } catch (findError) {
                this.logger.error('Error finding or updating transaction after capture', {
                    error: findError,
                    providerTransactionId: transactionId,
                    responseCode: response.response_code,
                });

                // Even if update fails, still return a valid response
                return {
                    success: response.response === ResponseCode.APPROVED,
                    transactionId: response.transactionid,
                    message: response.responsetext || '',
                    status: 'pending',
                    errorCode: response.response !== ResponseCode.APPROVED ? response.response_code : undefined,
                };
            }
        } catch (error) {
            this.logger.error('Error capturing transaction', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                status: 'failed',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Process a request to the NMI API
     * @param requestData - Request data to send to NMI
     * @param apiUrlPath - NMI API URL path
     * @returns NMI API response
     */
    private async processNmiRequest<T extends Record<string, any>>(
        requestData: T,
        apiUrlPath: string,
    ): Promise<TransactionResponse> {
        this.logger.info('Processing NMI request', {
            requestData,
        });
        try {
            this.logger.info('Sending request to NMI API', {
                type: requestData.type,
                endpointUrl: this.config.apiUrl,
            });

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

            const options = {
                method: 'POST',
                headers: {
                    accept: 'application/x-www-form-urlencoded',
                    'content-type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams(requestData as Record<string, string>),
                signal: controller.signal,
            };

            const response = await fetch(`${this.config.apiUrl}/${apiUrlPath}`, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NMI API responded with status ${response.status}: ${errorText}`);
            }

            // Read the response text only once
            const responseText = await response.text();

            this.logger.info('Full NMI API response', {
                status: response.status,
                statusText: response.statusText,
                response: responseText,
            });

            this.logger.info('response text', {
                responseText,
            });

            // Parse the response from x-www-form-urlencoded format
            const parsedResponse = this.parseResponseText(responseText);

            this.logger.info('Full parsed response from NMI API', {
                parsedResponse,
            });

            this.logger.info('Received response from NMI API', {
                response: parsedResponse.response,
                responsetext: parsedResponse.responsetext,
                transactionid: parsedResponse.transactionid,
            });

            // Handle rate limit separately
            if (
                parsedResponse.response === ResponseCode.ERROR &&
                parsedResponse.response_code === ResultCode.RATE_LIMIT_EXCEEDED
            ) {
                throw new Error('Rate limit exceeded. Please try again later.');
            }

            // Special case for duplicate transactions
            if (
                parsedResponse.response === ResponseCode.ERROR &&
                parsedResponse.response_code === ResultCode.GATEWAY_REJECTED &&
                parsedResponse.responsetext &&
                parsedResponse.responsetext.includes('Duplicate transaction')
            ) {
                this.logger.warn('Duplicate transaction detected', {
                    responseCode: parsedResponse.response_code,
                    responseText: parsedResponse.responsetext,
                });
            }

            return parsedResponse;
        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('NMI API request timed out');
            }

            this.logger.error('Error processing NMI request', error);
            throw error;
        }
    }

    /**
     * Parse response text from x-www-form-urlencoded format
     * @param responseText - Raw response text from NMI API
     * @returns Parsed transaction response
     */
    private parseResponseText(responseText: string): TransactionResponse {
        this.logger.info('Parsing response text', {
            responseText,
        });
        const result: Record<string, string> = {};
        const params = new URLSearchParams(responseText);

        params.forEach((value, key) => {
            result[key] = value;
        });

        return result as unknown as TransactionResponse;
    }

    /**
     * Create a standardized payment response from NMI response
     * @param nmiResponse - Response from NMI API
     * @param transaction - Transaction record from database
     * @returns Standardized payment response
     */
    private createPaymentResponse(
        nmiResponse: TransactionResponse,
        transaction: Transaction | TransactionRecord,
    ): PaymentResponse {
        this.logger.info('Creating payment response', {
            nmiResponse,
            transaction,
        });
        const success = nmiResponse.response === ResponseCode.APPROVED;

        try {
            this.logger.info('Creating payment response', {
                transaction: typeof transaction === 'object' ? 'transaction_object_exists' : 'transaction_missing',
                transactionType: transaction ? typeof transaction : 'undefined',
            });

            // Safely handle the transaction record conversion
            let transactionRecord: TransactionRecord;

            if (this.isTransactionRecord(transaction)) {
                transactionRecord = transaction;
            } else if (transaction) {
                transactionRecord = {
                    userId: transaction.senderId || transaction.senderEntityId || '',
                    transactionId: transaction.transactionId || '',
                    type: transaction.type || TransactionType.DEPOSIT,
                    amount: typeof transaction.amount === 'number' ? transaction.amount.toString() : '0',
                    status: this.mapTransactionStatus(transaction.status || TransactionStatus.PENDING),
                    createdAt: new Date(transaction.createdAt || Date.now()),
                    updatedAt: new Date(transaction.updatedAt || Date.now()),
                };
            } else {
                transactionRecord = {
                    userId: '',
                    transactionId: nmiResponse.transactionid || '',
                    type: TransactionType.DEPOSIT,
                    amount: '0',
                    status: 'pending',
                    createdAt: new Date(),
                    updatedAt: new Date(),
                };
            }

            return {
                success,
                transactionId: nmiResponse.transactionid,
                internalTransactionId: transaction?.transactionId || '',
                // NMI might return customer_vault_id in some responses
                customerVaultId: (nmiResponse as any).customer_vault_id,
                message: nmiResponse.responsetext || '',
                orderReference: transactionRecord.orderReference,
                status: transactionRecord.status || 'pending',
                errorCode: !success ? nmiResponse.response_code : undefined,
                transactionRecord,
            };
        } catch (error) {
            // If anything fails in processing, return a minimal valid response
            this.logger.error('Error creating payment response', { error });
            return {
                success,
                transactionId: nmiResponse.transactionid,
                message: nmiResponse.responsetext || 'Error processing response',
                status: 'pending',
                errorCode: !success ? nmiResponse.response_code : undefined,
            };
        }
    }

    private isTransactionRecord(obj: any): obj is TransactionRecord {
        return 'userId' in obj && typeof obj.userId === 'string';
    }

    /**
     * Maps internal transaction status to NMI-compatible status
     */
    private mapTransactionStatus(status: TransactionStatus): TransactionRecord['status'] {
        const statusMap: Record<TransactionStatus, TransactionRecord['status']> = {
            [TransactionStatus.PENDING]: 'pending',
            [TransactionStatus.COMPLETED]: 'captured',
            [TransactionStatus.FAILED]: 'failed',
            [TransactionStatus.CANCELLED]: 'failed',
            [TransactionStatus.REVERSED]: 'refunded',
        };
        return statusMap[status] || 'pending';
    }

    /**
     * Determine transaction status from NMI response
     * @param response - NMI API response
     * @returns Transaction status
     */
    /**
     * Maps NMI response codes to appropriate transaction statuses based on the response
     * and adjusts based on the transaction type when needed
     *
     * @param response - NMI API response
     * @param transactionType - Optional transaction type for specialized status mapping
     * @returns Appropriate transaction status based on response code and transaction type
     */
    private getTransactionStatus(
        response: TransactionResponse,
        transactionType?: TransactionType,
    ): TransactionRecord['status'] {
        // First, determine basic status from response code
        if (response.response === ResponseCode.APPROVED) {
            // For capture operations, set to captured
            if (transactionType === undefined && response.authcode) {
                // When capturing, we usually have an auth code and no transaction type specified
                return 'captured';
            }

            // Different success statuses based on transaction type
            if (transactionType) {
                switch (transactionType) {
                    case TransactionType.DEPOSIT:
                        // Deposits typically just need authorization
                        return 'pending';
                    case TransactionType.P2P:
                    case TransactionType.P2B:
                        // P2P and P2B transfers are usually fully captured immediately
                        return 'captured';
                    default:
                        return 'pending';
                }
            }
            // Default for APPROVED if no transaction type specified
            return 'pending';
        } else if (response.response === ResponseCode.DECLINED) {
            return 'failed';
        } else if (response.response === ResponseCode.ERROR) {
            return 'failed';
        } else {
            return 'pending';
        }
    }

    /**
     * Query transactions from NMI API
     * @param request - Query request parameters
     * @returns Query transaction response
     */
    async queryTransactions(request: Omit<QueryTransactionRequest, 'security_key'>): Promise<QueryTransactionResponse> {
        this.logger.info('Querying transactions', {
            transactionId: request.transaction_id,
            condition: request.condition,
        });

        try {
            // Create the complete request with security key
            const fullRequest: QueryTransactionRequest = {
                ...request,
                security_key: this.config.securityKey,
            };

            // NMI query API base endpoint
            const baseUrl = NMI_API_URLS.QUERY;

            // Convert request to URL parameters
            const params = new URLSearchParams();
            Object.entries(fullRequest).forEach(([key, value]) => {
                if (value !== undefined) {
                    params.append(key, String(value));
                }
            });

            // Build the full URL with query parameters
            const queryUrl = `${baseUrl}?${params.toString()}`;

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

            const options = {
                method: 'POST',
                headers: {
                    accept: 'application/xml',
                },
                signal: controller.signal,
            };

            this.logger.info('Sending POST request to NMI Query API', {
                url: queryUrl,
            });

            const response = await fetch(queryUrl, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NMI Query API responded with status ${response.status}: ${errorText}`);
            }

            const responseText = await response.text();
            this.logger.info('Received response from NMI Query API');

            // Check if response is XML or plain text
            if (responseText.trim().startsWith('<?xml')) {
                // Handle XML response
                const parser = new XMLParser({
                    ignoreAttributes: false,
                    parseAttributeValue: true,
                });

                const parsedXml = parser.parse(responseText);

                if (!parsedXml.nm_response || !parsedXml.nm_response.transaction) {
                    return {
                        success: false,
                        message: 'No transactions found',
                    };
                }

                const transactions = Array.isArray(parsedXml.nm_response.transaction)
                    ? parsedXml.nm_response.transaction
                    : [parsedXml.nm_response.transaction];

                // Extract required fields from each transaction
                const parsedTransactions = transactions.map((tx: any) => ({
                    transaction_id: tx.transaction_id || '',
                    cc_bin: tx.cc_bin || '',
                    cc_type: tx.cc_type || '',
                    condition: tx.condition || '',
                    customerid: tx.customerid || '',
                    // Extract other fields if needed
                    amount: tx.action && tx.action.amount ? tx.action.amount : '',
                    action_type: tx.action && tx.action.action_type ? tx.action.action_type : '',
                    date: tx.action && tx.action.date ? tx.action.date : '',
                }));

                return {
                    success: true,
                    message: 'Transactions retrieved successfully',
                    transactions: parsedTransactions,
                };
            } else {
                this.logger.info('Received plain text response, parsing manually');

                if (responseText.trim() === '') {
                    return {
                        success: false,
                        message: 'No transactions found',
                    };
                }

                const fields = responseText.trim().split(' ');
                if (fields.length >= 5) {
                    // Map the fields based on the expected order
                    const transaction = {
                        transaction_id: fields[0] || '',
                        cc_type: fields[1] || '',
                        condition: fields[2] || '',
                        customerid: fields[4] || '',
                        cc_bin: fields.length > 15 ? fields[15] || '' : '',
                    };

                    return {
                        success: true,
                        message: 'Transaction retrieved successfully',
                        transactions: [transaction],
                    };
                } else {
                    return {
                        success: false,
                        message: 'Invalid response format',
                    };
                }
            }
        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('NMI Query API request timed out');
            }

            this.logger.error('Error querying transactions', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Check card type based on the card number (IIN/BIN)
     * @param ccnumber - Card IIN (first 6 digits)
     * @returns Card type information
     */
    async checkCardType(ccnumber: string): Promise<CardTypeCheckResponse> {
        this.logger.info('Checking card type', {
            ccnumber: ccnumber.substring(0, 3) + '***',
        });

        try {
            // Card type check API endpoint (v4 API)
            const cardTypeApiUrl = NMI_API_URLS.CARD_TYPE;
            const v4ApiKey = this.config.securityKey;

            if (!v4ApiKey) {
                throw new Error('NMI API key is not configured');
            }

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

            // Create request options
            const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `${NMI_AUTH_PREFIXES.V4_PRIVATE}${v4ApiKey}`,
                },
                body: JSON.stringify({ ccnumber }),
                signal: controller.signal,
            };

            this.logger.info('Sending request to NMI Card Type API', {
                url: cardTypeApiUrl,
            });

            const response = await fetch(cardTypeApiUrl, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NMI Card Type API responded with status ${response.status}: ${errorText}`);
            }

            const responseData = await response.json();

            this.logger.info('Received response from NMI Card Type API', {
                result: responseData.result,
            });

            return {
                success: true,
                result: responseData.result,
            };
        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                this.logger.error('NMI Card Type API request timed out');
                return {
                    success: false,
                    result: 'unavailable',
                    message: 'Request timed out',
                    errorCode: 'TIMEOUT_ERROR',
                };
            }

            this.logger.error('Error checking card type', error);
            return {
                success: false,
                result: 'unavailable',
                message: error instanceof Error ? error.message : 'Unknown error occurred',
                errorCode: 'PROCESSING_ERROR',
            };
        }
    }

    /**
     * Update transaction record with provider details
     * @param transactionId - Internal transaction ID
     * @param nmiResponse - Response from NMI
     * @returns Updated transaction
     */
    private async updateTransactionWithProviderDetails(
        transactionId: string,
        nmiResponse: TransactionResponse,
    ): Promise<Transaction> {
        // Update with provider details
        const success = nmiResponse.response === ResponseCode.APPROVED;
        const status = success ? TransactionStatus.PENDING : TransactionStatus.FAILED;

        this.logger.info('Updating transaction with provider details', {
            internalTransactionId: transactionId,
            providerTransactionId: nmiResponse.transactionid,
            status,
        });

        const updateData = {
            status,
            providerTransactionId: nmiResponse.transactionid, // This should match the GSI key name
            authCode: nmiResponse.authcode,
            responseCode: nmiResponse.response_code,
            responseText: nmiResponse.responsetext,
            updatedAt: new Date().toISOString(),
        };

        return TransactionService.updateTransaction(transactionId, updateData);
    }

    /**
     * Add a customer to the NMI vault
     * @param entityId - Entity ID (user or business)
     * @param entityType - Entity type (USER or BUSINESS)
     * @param request - Customer vault request
     * @returns Customer vault response with vault ID
     */
    async addCustomerToVault(
        entityId: string,
        entityType: EntityTypeString,
        request: Omit<CustomerVaultRequest, 'customer_vault' | 'security_key'>,
    ): Promise<CustomerVaultResponse> {
        try {
            this.logger.info('Adding customer to NMI vault', {
                entityId,
                entityType,
            });

            // Add customer_vault action to the request
            const vaultRequest: CustomerVaultRequest = {
                ...request,
                customer_vault: 'add_customer',
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest(vaultRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Customer vault response received', {
                response_code: response.response_code,
                responsetext: response.responsetext,
                customer_vault_id: response.customer_vault_id,
            });

            if (response.response !== '1') {
                throw new Error(`Failed to add customer to vault: ${response.responsetext}`);
            }

            // Store the customer vault data in DynamoDB
            const customerVaultId = response.customer_vault_id;
            if (!customerVaultId) {
                throw new Error('No customer_vault_id returned from NMI');
            }

            // Create NMI customer record
            await createNmiCustomer(entityId, entityType, customerVaultId, {
                ccType: response.cc_type,
                ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
            });

            return {
                success: true,
                customerVaultId: customerVaultId,
                message: response.responsetext || 'Customer added to vault successfully',
                ccType: response.cc_type,
                ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
            };
        } catch (error) {
            this.logger.error('Error adding customer to vault', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
                entityType,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }

    /**
     * Update a customer in the NMI vault
     * @param entityId - Entity ID (user or business)
     * @param customerVaultId - NMI customer vault ID
     * @param request - Customer vault update request
     * @returns Customer vault response
     */
    async updateCustomerInVault(
        entityId: string,
        customerVaultId: string,
        request: Omit<CustomerVaultRequest, 'customer_vault' | 'security_key' | 'customer_vault_id'>,
    ): Promise<CustomerVaultResponse> {
        try {
            this.logger.info('Updating customer in NMI vault', {
                entityId,
                customerVaultId,
            });

            // First verify that this customer vault ID belongs to the user
            const nmiCustomers = await listNmiCustomersByEntity(entityId);
            const matchingCustomer = nmiCustomers.find((c) => c.customerVaultId === customerVaultId);

            if (!matchingCustomer) {
                throw new Error('Customer vault ID not found for this user');
            }

            // Add customer_vault update action to the request
            const vaultRequest: CustomerVaultRequest = {
                ...request,
                customer_vault: 'update_customer',
                customer_vault_id: customerVaultId,
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest(vaultRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Customer vault update response received', {
                response_code: response.response_code,
                responsetext: response.responsetext,
            });

            if (response.response !== '1') {
                throw new Error(`Failed to update customer in vault: ${response.responsetext}`);
            }

            // Update the NMI customer record if card details changed
            if (response.cc_type || response.cc_number) {
                matchingCustomer.ccType = response.cc_type || matchingCustomer.ccType;
                matchingCustomer.ccNumber = response.cc_number
                    ? response.cc_number.slice(-4)
                    : matchingCustomer.ccNumber;
                matchingCustomer.updatedAt = new Date().toISOString();
                await matchingCustomer.update();
            }

            return {
                success: true,
                customerVaultId: customerVaultId,
                message: response.responsetext || 'Customer updated in vault successfully',
                ccType: response.cc_type,
                ccNumber: response.cc_number ? response.cc_number.slice(-4) : undefined,
            };
        } catch (error) {
            this.logger.error('Error updating customer in vault', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
                customerVaultId,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }

    /**
     * Delete a customer from the NMI vault
     * @param entityId - Entity ID (user or business)
     * @param customerVaultId - NMI customer vault ID to delete
     * @returns Success response
     */
    async deleteCustomerFromVault(
        entityId: string,
        customerVaultId: string,
    ): Promise<{ success: boolean; message: string }> {
        try {
            this.logger.info('Deleting customer from NMI vault', {
                entityId,
                customerVaultId,
            });

            // First verify that this customer vault ID belongs to the user
            const nmiCustomers = await listNmiCustomersByEntity(entityId);
            const matchingCustomer = nmiCustomers.find((c) => c.customerVaultId === customerVaultId);

            if (!matchingCustomer) {
                throw new Error('Customer vault ID not found for this user');
            }

            // Create delete request
            const vaultRequest = {
                customer_vault: 'delete_customer',
                customer_vault_id: customerVaultId,
                security_key: this.config.securityKey,
            };

            // Process the request
            const response = await this.processNmiRequest(vaultRequest, NMI_ENDPOINTS.TRANSACTION);

            this.logger.info('Customer vault delete response received', {
                response_code: response.response_code,
                responsetext: response.responsetext,
            });

            if (response.response !== '1') {
                throw new Error(`Failed to delete customer from vault: ${response.responsetext}`);
            }

            // Delete the NMI customer record from our database
            await matchingCustomer.delete();

            return {
                success: true,
                message: response.responsetext || 'Customer deleted from vault successfully',
            };
        } catch (error) {
            this.logger.error('Error deleting customer from vault', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
                customerVaultId,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }

    /**
     * Get all stored customer vault records for an entity
     * @param entityId - Entity ID (user or business)
     * @returns List of customer vault records
     */
    async getStoredCustomerVaults(entityId: string): Promise<NmiCustomer[]> {
        try {
            return await listNmiCustomersByEntity(entityId);
        } catch (error) {
            this.logger.error('Error getting stored customer vaults', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
            });
            throw error;
        }
    }

    /**
     * Delete all vault records for an entity
     * This is a public method that can be called directly from API endpoints
     * @param entityId - Entity ID (user or business)
     * @returns Result of the deletion operation
     */
    async deleteAllCustomerVaultRecords(entityId: string): Promise<{ success: boolean; message: string }> {
        return this.deleteExistingVaultRecords(entityId);
    }

    /**
     * Delete all existing vault records for an entity from both NMI and DynamoDB
     * This is used when a user is adding a new payment method to replace existing ones
     * @param entityId - Entity ID (user or business)
     * @returns Result of the deletion operation
     */
    private async deleteExistingVaultRecords(entityId: string): Promise<{ success: boolean; message: string }> {
        try {
            this.logger.info('Checking for existing vault records to delete', { entityId });

            // Get all existing vault records for this entity
            const existingVaults = await listNmiCustomersByEntity(entityId);

            if (!existingVaults || existingVaults.length === 0) {
                this.logger.info('No existing vault records found for entity', { entityId });
                return { success: true, message: 'No existing vault records to delete' };
            }

            this.logger.info('Found existing vault records to delete', {
                entityId,
                count: existingVaults.length,
                vaultIds: existingVaults.map((v) => v.customerVaultId),
            });

            // Delete each vault record from NMI and DynamoDB
            for (const vault of existingVaults) {
                const result = await this.deleteCustomerFromVault(entityId, vault.customerVaultId);

                if (!result.success) {
                    this.logger.warn('Failed to delete vault record', {
                        entityId,
                        customerVaultId: vault.customerVaultId,
                        error: result.message,
                    });
                    // Continue with other deletions even if one fails
                }
            }

            return {
                success: true,
                message: `Successfully deleted ${existingVaults.length} existing vault record(s)`,
            };
        } catch (error) {
            this.logger.error('Error deleting existing vault records', {
                error: error instanceof Error ? error.message : 'Unknown error',
                entityId,
            });

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    }
}
</file>

<file path="lambdas/nmi/webhooks/services/secrets-service.ts">
import { getSecret } from 'commons/utils/getSecret';
import { createLogger } from 'commons/utils/logger_v2';

/**
 * Logger for the secrets service
 */
const logger = createLogger('NmiSecretsService');

/**
 * Default secret name for NMI
 */
const DEFAULT_SECRET_NAME = 'nmi/credentials';

/**
 * NMI secret keys
 */
export enum NmiSecretKeys {
    WEBHOOK_SIGNING_KEY = 'NMI_WEBHOOK_SIGNING_KEY',
    PRIVATE_KEY = 'NMI_PRIVATE_KEY',
}

/**
 * Cache for secrets to avoid repeated calls to Secrets Manager
 */
const secretsCache: Record<string, string> = {};

/**
 * Get NMI secret from AWS Secrets Manager
 * @param key - The key of the secret to retrieve
 * @param secretName - The name of the secret in Secrets Manager (optional)
 * @returns The secret value
 */
export async function getNmiSecret(key: NmiSecretKeys, secretName?: string): Promise<string> {
    const name = secretName || process.env.NMI_SECRET_NAME || DEFAULT_SECRET_NAME;
    const cacheKey = `${name}:${key}`;

    // Return from cache if available
    if (secretsCache[cacheKey]) {
        logger.info(`Using cached secret for ${key}`);
        return secretsCache[cacheKey];
    }

    try {
        logger.info(`Retrieving NMI secret: ${key}`, { secretName: name });

        // Get the secret using the common utility
        const secretValue = await getSecret(name, key);

        if (!secretValue) {
            throw new Error(`Secret ${key} not found in ${name}`);
        }

        // Cache the secret
        secretsCache[cacheKey] = secretValue;

        logger.info(`Successfully retrieved NMI secret: ${key}`);
        return secretValue;
    } catch (error) {
        logger.error(`Error retrieving NMI secret: ${key}`, error);
        throw error;
    }
}

/**
 * Get NMI webhook signing key
 * @param secretName - Optional secret name override
 * @returns The webhook signing key
 */
export async function getNmiWebhookSigningKey(secretName?: string): Promise<string> {
    return getNmiSecret(NmiSecretKeys.WEBHOOK_SIGNING_KEY, secretName);
}

/**
 * Get NMI private key
 * @param secretName - Optional secret name override
 * @returns The private key
 */
export async function getNmiPrivateKey(secretName?: string): Promise<string> {
    return getNmiSecret(NmiSecretKeys.PRIVATE_KEY, secretName);
}
</file>

<file path="lambdas/nmi/webhooks/services/unified-transaction-service.ts">
/**
 * Unified transaction service for all payment providers
 */

import { Logger } from '@aws-lambda-powertools/logger';
import { v4 as uuidv4 } from 'uuid';
import { DateUtil } from '../utils/date-util';
import { dynamoDB } from '../utils/dynamodb';
import {
    UnifiedTransaction,
    CreateTransactionInput,
    UpdateTransactionInput,
    TransactionStatus,
    TransactionType,
    EntityType,
    PaymentProvider,
    TransactionQueryOptions,
} from '../types/transaction.types';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'unified-transaction-service',
});

export class UnifiedTransactionService {
    /**
     * Creates a new transaction in the database
     * Creates records for both sender and recipient entities
     */
    static async createTransaction(input: CreateTransactionInput, requestId: string): Promise<UnifiedTransaction> {
        const functionName = 'createTransaction';
        const transactionId = uuidv4();
        const timestamp = DateUtil.now();

        logger.info(`[${functionName}] Creating new transaction`, {
            requestId,
            transactionId,
            type: input.type,
            provider: input.provider,
            amount: input.amount,
            senderEntityId: input.sender.entityId,
            recipientEntityId: input.recipient.entityId,
        });

        // Build the base transaction object
        const transaction: UnifiedTransaction = {
            // Identifiers
            userId: input.sender.entityType === EntityType.USER ? input.sender.entityId : '',
            transactionId,

            // Type and status
            type: input.type,
            status: TransactionStatus.PENDING,
            provider: input.provider,

            // Amounts
            amount: input.amount,
            asset: input.asset,
            fees: input.fees
                ? {
                      amount: input.fees.amount || 0,
                      percentage: input.fees.percentage || 0,
                      isPending: input.fees.isPending ?? true,
                  }
                : undefined,
            netAmount: input.amount - (input.fees?.amount || 0),

            // Entities
            sender: input.sender,
            recipient: input.recipient,

            // Account references
            sourceAccountId: input.sourceAccountId,
            destinationAccountId: input.destinationAccountId,

            // Metadata
            memo: input.memo,
            metadata: input.metadata,

            // Timestamps
            createdAt: timestamp,
            updatedAt: timestamp,
        };

        // Prepare DynamoDB items
        const transactionItems = [];

        // 1. Create sender's transaction record
        if (input.sender.entityType === EntityType.USER) {
            const senderKeys = SingleTableKeys.transaction(input.sender.entityId, timestamp, transactionId);
            const senderRecord = {
                ...senderKeys,
                ...transaction,
                entityType: 'TRANSACTION',
                // GSI keys for efficient querying
                TransactionIdKey: `TXN#${transactionId}`,
                SenderIdKey: `SENDER#${input.sender.entityId}`,
                RecipientIdKey: `RECIPIENT#${input.recipient.entityId}`,
                // Additional fields for queries
                senderEntityId: input.sender.entityId,
                senderEntityType: input.sender.entityType,
                senderName: input.sender.name,
                senderClkktag: input.sender.clkktag,
                senderEmail: input.sender.email,
                recipientEntityId: input.recipient.entityId,
                recipientEntityType: input.recipient.entityType,
                recipientName: input.recipient.name,
                recipientClkktag: input.recipient.clkktag,
                recipientEmail: input.recipient.email,
            };

            transactionItems.push({
                Put: {
                    TableName: SINGLE_TABLE_NAME,
                    Item: senderRecord,
                },
            });
        }

        // 2. Create recipient's transaction record (if user or business)
        if (input.recipient.entityType !== EntityType.SYSTEM) {
            const recipientUserId =
                input.recipient.entityType === EntityType.USER
                    ? input.recipient.entityId
                    : `BUSINESS#${input.recipient.entityId}`;

            const recipientKeys = SingleTableKeys.transaction(recipientUserId, timestamp, transactionId);
            const recipientRecord = {
                ...recipientKeys,
                ...transaction,
                entityType: 'TRANSACTION',
                userId: input.recipient.entityType === EntityType.USER ? input.recipient.entityId : '',
                // GSI keys
                TransactionIdKey: `TXN#${transactionId}`,
                SenderIdKey: `SENDER#${input.sender.entityId}`,
                RecipientIdKey: `RECIPIENT#${input.recipient.entityId}`,
                // Additional fields
                senderEntityId: input.sender.entityId,
                senderEntityType: input.sender.entityType,
                senderName: input.sender.name,
                senderClkktag: input.sender.clkktag,
                senderEmail: input.sender.email,
                recipientEntityId: input.recipient.entityId,
                recipientEntityType: input.recipient.entityType,
                recipientName: input.recipient.name,
                recipientClkktag: input.recipient.clkktag,
                recipientEmail: input.recipient.email,
            };

            transactionItems.push({
                Put: {
                    TableName: SINGLE_TABLE_NAME,
                    Item: recipientRecord,
                },
            });
        }

        // 3. Create a transaction index record for quick lookups
        const indexKeys = {
            PK: `TXN#${transactionId}`,
            SK: `TXN#${transactionId}`,
        };

        const indexRecord = {
            ...indexKeys,
            ...transaction,
            entityType: 'TRANSACTION_INDEX',
            // Store entity details for quick access
            senderEntityId: input.sender.entityId,
            senderEntityType: input.sender.entityType,
            recipientEntityId: input.recipient.entityId,
            recipientEntityType: input.recipient.entityType,
            // Add timestamp for reference when updating user records
            transactionTimestamp: timestamp,
        };

        transactionItems.push({
            Put: {
                TableName: SINGLE_TABLE_NAME,
                Item: indexRecord,
            },
        });

        logger.debug(`[${functionName}] Transaction items prepared`, {
            requestId,
            transactionId,
            itemCount: transactionItems.length,
        });

        // Execute the transaction
        try {
            const startTime = Date.now();
            await dynamoDB.transactWrite({ TransactItems: transactionItems });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Transaction created successfully`, {
                requestId,
                transactionId,
                latencyMs: latency,
                recordsCreated: transactionItems.length,
            });

            return transaction;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to create transaction`, {
                requestId,
                transactionId,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to create transaction: ${error.message}`);
        }
    }

    /**
     * Updates an existing transaction
     */
    static async updateTransaction(input: UpdateTransactionInput, requestId: string): Promise<void> {
        const functionName = 'updateTransaction';
        const timestamp = DateUtil.now();

        logger.info(`[${functionName}] Updating transaction`, {
            requestId,
            transactionId: input.transactionId,
            updates: Object.keys(input).filter((k) => k !== 'transactionId'),
        });

        // First, get the transaction index to find all related records
        const indexKeys = {
            PK: `TXN#${input.transactionId}`,
            SK: `TXN#${input.transactionId}`,
        };

        const indexResult = await dynamoDB.get({
            TableName: SINGLE_TABLE_NAME,
            Key: indexKeys,
        });

        if (!indexResult) {
            logger.error(`[${functionName}] Transaction not found`, {
                requestId,
                transactionId: input.transactionId,
            });
            throw new Error(`Transaction ${input.transactionId} not found`);
        }

        const transactionIndex = indexResult as any;

        // Build update expression
        const updateExpressions: string[] = ['SET #updatedAt = :updatedAt'];
        const expressionAttributeNames: any = {
            '#updatedAt': 'updatedAt',
        };
        const expressionAttributeValues: any = {
            ':updatedAt': timestamp,
        };

        if (input.status !== undefined) {
            updateExpressions.push('#status = :status');
            expressionAttributeNames['#status'] = 'status';
            expressionAttributeValues[':status'] = input.status;
        }

        if (input.paymentProviderId !== undefined) {
            updateExpressions.push('paymentProviderId = :paymentProviderId');
            updateExpressions.push('ProviderTransactionIdKey = :providerTransactionIdKey');
            expressionAttributeValues[':paymentProviderId'] = input.paymentProviderId;
            expressionAttributeValues[':providerTransactionIdKey'] = input.paymentProviderId;
        }

        if (input.quoteGuid !== undefined) {
            updateExpressions.push('quoteGuid = :quoteGuid');
            expressionAttributeValues[':quoteGuid'] = input.quoteGuid;
        }

        if (input.completedAt !== undefined) {
            updateExpressions.push('completedAt = :completedAt');
            expressionAttributeValues[':completedAt'] = input.completedAt;
        }

        if (input.failureCode !== undefined) {
            updateExpressions.push('failureCode = :failureCode');
            expressionAttributeValues[':failureCode'] = input.failureCode;
        }

        if (input.failureReason !== undefined) {
            updateExpressions.push('failureReason = :failureReason');
            expressionAttributeValues[':failureReason'] = input.failureReason;
        }

        if (input.metadata !== undefined) {
            updateExpressions.push('metadata = :metadata');
            expressionAttributeValues[':metadata'] = input.metadata;
        }

        const updateExpression = updateExpressions.join(', ');

        // Prepare update items for all transaction records
        const updateItems = [];

        // Get the transaction timestamp from the index record
        const transactionTimestamp = transactionIndex.transactionTimestamp || transactionIndex.createdAt;

        // Update sender's record if exists
        if (transactionIndex.senderEntityType === EntityType.USER) {
            const senderKeys = SingleTableKeys.transaction(transactionIndex.senderEntityId, transactionTimestamp, input.transactionId);
            updateItems.push({
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: senderKeys,
                    UpdateExpression: updateExpression,
                    ExpressionAttributeNames: expressionAttributeNames,
                    ExpressionAttributeValues: expressionAttributeValues,
                },
            });
        }

        // Update recipient's record if exists
        if (transactionIndex.recipientEntityType !== EntityType.SYSTEM) {
            const recipientUserId =
                transactionIndex.recipientEntityType === EntityType.USER
                    ? transactionIndex.recipientEntityId
                    : `BUSINESS#${transactionIndex.recipientEntityId}`;

            const recipientKeys = SingleTableKeys.transaction(recipientUserId, transactionTimestamp, input.transactionId);
            updateItems.push({
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: recipientKeys,
                    UpdateExpression: updateExpression,
                    ExpressionAttributeNames: expressionAttributeNames,
                    ExpressionAttributeValues: expressionAttributeValues,
                },
            });
        }

        // Update the index record
        updateItems.push({
            Update: {
                TableName: SINGLE_TABLE_NAME,
                Key: indexKeys,
                UpdateExpression: updateExpression,
                ExpressionAttributeNames: expressionAttributeNames,
                ExpressionAttributeValues: expressionAttributeValues,
            },
        });

        logger.debug(`[${functionName}] Update items prepared`, {
            requestId,
            transactionId: input.transactionId,
            itemCount: updateItems.length,
            updateExpression,
        });

        // Execute the updates
        try {
            const startTime = Date.now();
            await dynamoDB.transactWrite({ TransactItems: updateItems });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Transaction updated successfully`, {
                requestId,
                transactionId: input.transactionId,
                latencyMs: latency,
                recordsUpdated: updateItems.length,
            });
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to update transaction`, {
                requestId,
                transactionId: input.transactionId,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to update transaction: ${error.message}`);
        }
    }

    /**
     * Helper function to transform raw transaction data to UnifiedTransaction format
     */
    private static transformToUnifiedTransaction(rawTransaction: any): UnifiedTransaction {
        // For deposits, the userId should be the receiverId (the person receiving the deposit)
        let userId = rawTransaction.userId || '';
        if (!userId && rawTransaction.type === 'DEPOSIT' && rawTransaction.receiverId) {
            userId = rawTransaction.receiverId;
        } else if (!userId && rawTransaction.senderId) {
            userId = rawTransaction.senderId;
        }

        return {
            userId,
            transactionId: rawTransaction.transactionId,
            type: rawTransaction.type,
            status: rawTransaction.status,
            provider: rawTransaction.provider || PaymentProvider.NMI,
            amount: typeof rawTransaction.amount === 'string' ? parseFloat(rawTransaction.amount) * 100 : rawTransaction.amount,
            asset: rawTransaction.currency || rawTransaction.asset || 'USD',
            sender: rawTransaction.sender || {
                entityId: rawTransaction.senderId || 'system',
                entityType: rawTransaction.senderType || EntityType.SYSTEM,
                name: rawTransaction.senderName || 'System',
            },
            recipient: rawTransaction.recipient || {
                entityId: rawTransaction.receiverId || rawTransaction.recipientEntityId || userId || '',
                entityType: rawTransaction.receiverType || rawTransaction.recipientType || EntityType.USER,
                name: rawTransaction.recipientName || rawTransaction.receiverName || '',
                email: rawTransaction.recipientEmail || rawTransaction.receiverEmail,
            },
            paymentProviderId: rawTransaction.paymentProviderId || rawTransaction.providerTransactionId,
            quoteGuid: rawTransaction.quoteGuid,
            sourceAccountId: rawTransaction.sourceAccountId,
            destinationAccountId: rawTransaction.destinationAccountId,
            memo: rawTransaction.memo,
            metadata: rawTransaction.metadata,
            createdAt: rawTransaction.createdAt || rawTransaction.CreatedAt,
            updatedAt: rawTransaction.updatedAt || rawTransaction.UpdatedAt,
            completedAt: rawTransaction.completedAt,
            failureCode: rawTransaction.failureCode,
            failureReason: rawTransaction.failureReason,
        };
    }

    /**
     * Retrieves a transaction by ID
     */
    static async getTransactionById(transactionId: string, requestId: string): Promise<UnifiedTransaction | null> {
        const functionName = 'getTransactionById';

        logger.info(`[${functionName}] Retrieving transaction`, {
            requestId,
            transactionId,
        });

        const keys = {
            PK: `TXN#${transactionId}`,
            SK: `TXN#${transactionId}`,
        };

        try {
            const startTime = Date.now();
            const result = await dynamoDB.get({
                TableName: SINGLE_TABLE_NAME,
                Key: keys,
            });
            const latency = Date.now() - startTime;

            if (!result) {
                logger.info(`[${functionName}] Transaction not found`, {
                    requestId,
                    transactionId,
                    latencyMs: latency,
                });
                return null;
            }

            logger.info(`[${functionName}] Transaction retrieved successfully`, {
                requestId,
                transactionId,
                latencyMs: latency,
            });

            // Remove DynamoDB specific fields and transform to UnifiedTransaction format
            const { PK, SK, ...rawTransaction } = result as any;
            
            return this.transformToUnifiedTransaction(rawTransaction);
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to retrieve transaction`, {
                requestId,
                transactionId,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to retrieve transaction: ${error.message}`);
        }
    }

    /**
     * Retrieves a transaction by payment provider ID
     */
    static async getTransactionByProviderId(
        providerId: string,
        provider: PaymentProvider,
        requestId: string,
    ): Promise<UnifiedTransaction | null> {
        const functionName = 'getTransactionByProviderId';

        logger.info(`[${functionName}] Retrieving transaction by provider ID`, {
            requestId,
            providerId,
            provider,
        });

        try {
            const startTime = Date.now();

            // Use the ProviderTransactionIndex GSI for efficient lookup
            const params = {
                TableName: SINGLE_TABLE_NAME,
                IndexName: 'ProviderTransactionIndex',
                KeyConditionExpression: 'ProviderTransactionIdKey = :providerId',
                ExpressionAttributeValues: {
                    ':providerId': providerId,
                },
                Limit: 1,
            };

            const result = await dynamoDB.query(params);
            const latency = Date.now() - startTime;

            if (!result.Items || result.Items.length === 0) {
                logger.info(`[${functionName}] Transaction not found by provider ID`, {
                    requestId,
                    providerId,
                    provider,
                    latencyMs: latency,
                });
                return null;
            }

            logger.info(`[${functionName}] Transaction retrieved successfully`, {
                requestId,
                providerId,
                provider,
                latencyMs: latency,
            });

            // Remove DynamoDB specific fields and transform to UnifiedTransaction format
            const { PK, SK, ...rawTransaction } = result.Items[0] as any;
            
            return this.transformToUnifiedTransaction(rawTransaction);
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to retrieve transaction by provider ID`, {
                requestId,
                providerId,
                provider,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to retrieve transaction by provider ID: ${error.message}`);
        }
    }

    /**
     * Queries transactions based on various criteria
     */
    static async queryTransactions(options: TransactionQueryOptions, requestId: string): Promise<UnifiedTransaction[]> {
        const functionName = 'queryTransactions';

        logger.info(`[${functionName}] Querying transactions`, {
            requestId,
            options,
        });

        try {
            const transactions: UnifiedTransaction[] = [];
            const limit = options.limit || 20;

            // Determine the best query strategy based on provided options
            if (options.transactionId) {
                // Direct lookup by transaction ID
                const transaction = await this.getTransactionById(options.transactionId, requestId);
                if (transaction) {
                    transactions.push(transaction);
                }
            } else if (options.userId) {
                // Query by user ID
                const params: any = {
                    TableName: SINGLE_TABLE_NAME,
                    KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
                    ExpressionAttributeValues: {
                        ':pk': `USER#${options.userId}`,
                        ':skPrefix': 'TXN#',
                    },
                    Limit: limit,
                    ScanIndexForward: false, // Most recent first
                };

                // Add filters
                const filterExpressions = [];
                const expressionAttributeNames: any = {};

                if (options.status) {
                    filterExpressions.push('#status = :status');
                    expressionAttributeNames['#status'] = 'status';
                    params.ExpressionAttributeValues[':status'] = options.status;
                }

                if (options.type) {
                    filterExpressions.push('#type = :type');
                    expressionAttributeNames['#type'] = 'type';
                    params.ExpressionAttributeValues[':type'] = options.type;
                }

                if (options.provider) {
                    filterExpressions.push('#provider = :provider');
                    expressionAttributeNames['#provider'] = 'provider';
                    params.ExpressionAttributeValues[':provider'] = options.provider;
                }

                if (options.startDate) {
                    filterExpressions.push('#createdAt >= :startDate');
                    expressionAttributeNames['#createdAt'] = 'createdAt';
                    params.ExpressionAttributeValues[':startDate'] = options.startDate;
                }

                if (options.endDate) {
                    filterExpressions.push('#createdAt <= :endDate');
                    expressionAttributeNames['#createdAt'] = 'createdAt';
                    params.ExpressionAttributeValues[':endDate'] = options.endDate;
                }

                if (filterExpressions.length > 0) {
                    params.FilterExpression = filterExpressions.join(' AND ');
                }

                if (Object.keys(expressionAttributeNames).length > 0) {
                    params.ExpressionAttributeNames = expressionAttributeNames;
                }

                const result = await dynamoDB.query(params);

                if (result.Items) {
                    result.Items.forEach((item) => {
                        const { PK, SK, ...rawTransaction } = item as any;
                        transactions.push(this.transformToUnifiedTransaction(rawTransaction));
                    });
                }
            } else if (options.businessId) {
                // Query by business ID
                const params: any = {
                    TableName: SINGLE_TABLE_NAME,
                    KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
                    ExpressionAttributeValues: {
                        ':pk': `BUSINESS#${options.businessId}`,
                        ':skPrefix': 'TXN#',
                    },
                    Limit: limit,
                    ScanIndexForward: false,
                };

                const result = await dynamoDB.query(params);

                if (result.Items) {
                    result.Items.forEach((item) => {
                        const { PK, SK, ...rawTransaction } = item as any;
                        transactions.push(this.transformToUnifiedTransaction(rawTransaction));
                    });
                }
            }

            logger.info(`[${functionName}] Query completed`, {
                requestId,
                transactionsFound: transactions.length,
            });

            return transactions;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to query transactions`, {
                requestId,
                options,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to query transactions: ${error.message}`);
        }
    }
}
</file>

<file path="lambdas/nmi/webhooks/services/webhook-service.ts">
import { createHmac } from 'crypto';
import { createLogger } from 'commons/utils/logger_v2';
import {
    NmiWebhookEvent,
    NmiWebhookEventType,
    WebhookVerificationRequest,
    WebhookVerificationResult,
    WebhookProcessingResult,
} from '../types/webhook';
import { TransactionStatus } from '../types/transaction.types';
import { UnifiedTransactionService } from './unified-transaction-service';
import { BookTransferService } from './book-transfer-service';
import { PaymentProvider } from '../types/transaction.types';
import { dynamoDB } from 'commons';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';

// Platform bank GUID for source of funds
const PLATFORM_BANK_GUID = '59d6b3a8cd8274024cde9e1cba94af28';
const PLATFORM_FEE_ACCOUNT_GUID = '9ca294342049188799998df4d86655f0';

/**
 * Service for handling NMI webhooks
 */
export class WebhookService {
    private logger = createLogger('WebhookService');
    private signingKey: string;

    /**
     * Initialize the webhook service
     * @param signingKey - NMI webhook signing key for validation
     */
    constructor(signingKey: string) {
        this.signingKey = signingKey;
    }

    /**
     * Verify webhook signature using HMAC with SHA-256
     * @param request - Webhook verification request data
     * @returns Verification result with parsed webhook if valid
     */
    verifyWebhook(request: WebhookVerificationRequest): WebhookVerificationResult {
        try {
            this.logger.info('Verifying webhook signature');

            const { webhookBody, signingKey, nonce, signature } = request;

            // Generate expected signature using the same algorithm as NMI
            const expectedSignature = createHmac('sha256', signingKey).update(`${nonce}.${webhookBody}`).digest('hex');

            // Compare the signatures
            const isValid = expectedSignature === signature;

            if (!isValid) {
                this.logger.warn('Invalid webhook signature', {
                    expectedSignature: expectedSignature.substring(0, 10) + '...',
                    receivedSignature: signature.substring(0, 10) + '...',
                });

                return {
                    isValid: false,
                    message: 'Invalid webhook signature',
                };
            }

            // Parse webhook body to JSON
            try {
                const webhook = JSON.parse(webhookBody) as NmiWebhookEvent;

                this.logger.info('Webhook signature verified successfully', {
                    event_id: webhook.event_id,
                    event_type: webhook.event_type,
                });

                return {
                    isValid: true,
                    webhook,
                };
            } catch (parseError) {
                this.logger.error('Error parsing webhook body', parseError);

                return {
                    isValid: false,
                    message: 'Error parsing webhook body',
                };
            }
        } catch (error) {
            this.logger.error('Error verifying webhook', error);

            return {
                isValid: false,
                message: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }

    /**
     * Process an NMI webhook event
     * @param webhook - Verified webhook event
     * @returns Processing result
     */
    async processWebhook(webhook: NmiWebhookEvent): Promise<WebhookProcessingResult> {
        try {
            this.logger.info('Processing webhook', {
                event_id: webhook.event_id,
                event_type: webhook.event_type,
                transaction_id: webhook.event_body.transaction_id,
            });

            // Extract transaction ID from the webhook
            const { transaction_id } = webhook.event_body;
            this.logger.info('Detected Transaction ID', { transaction_id });

            if (!transaction_id) {
                this.logger.warn('Missing transaction ID in webhook');
                return {
                    success: false,
                    message: 'Missing transaction ID in webhook',
                };
            }

            // Find the transaction by provider ID using unified service
            const transaction = await UnifiedTransactionService.getTransactionByProviderId(
                transaction_id,
                PaymentProvider.NMI,
                `webhook-${webhook.event_id}`,
            );

            if (!transaction) {
                this.logger.warn('No transaction found with provider ID', { providerTransactionId: transaction_id });
                return {
                    success: false,
                    message: `No transaction found with provider ID: ${transaction_id}`,
                    transactionId: transaction_id,
                };
            }

            const transactionId = transaction.transactionId;

            this.logger.info('Found transaction', {
                internalTransactionId: transactionId,
                providerTransactionId: transaction_id,
                currentStatus: transaction.status,
            });

            // Determine the new status based on webhook event type
            const status = this.determineTransactionStatus(webhook.event_type, webhook.event_body);

            this.logger.info('Determined transaction status', {
                status,
            });

            if (!status) {
                this.logger.warn('Unable to determine transaction status from webhook', {
                    event_type: webhook.event_type,
                });
                return {
                    success: false,
                    message: 'Unable to determine transaction status from webhook',
                    transactionId,
                };
            }

            // Check if this is a completion event
            const isCompletionEvent = status === TransactionStatus.COMPLETED;
            this.logger.info('Is completion event', {
                isCompletionEvent,
                status,
            });

            // Prepare update data
            const updateData: any = {
                status,
                updatedAt: new Date().toISOString(),
            };

            // Add any additional data from the webhook
            if (webhook.event_body.action) {
                if (webhook.event_body.action.response_code) {
                    updateData.responseCode = webhook.event_body.action.response_code;
                }
                if (webhook.event_body.action.response_text) {
                    updateData.responseText = webhook.event_body.action.response_text;
                }
            }

            if (webhook.event_body.authorization_code) {
                updateData.authCode = webhook.event_body.authorization_code;
            }

            // If this is a completion event, process book transfer instead of manual wallet update
            if (isCompletionEvent && status === TransactionStatus.COMPLETED) {
                this.logger.info('Processing completion event with book transfer', { transactionId });
                try {
                    // Get the unified transaction to access recipient details
                    const unifiedTransaction = await UnifiedTransactionService.getTransactionById(
                        transactionId,
                        `webhook-${webhook.event_id}`,
                    );

                    if (unifiedTransaction) {
                        await this.processBookTransferForCompletedPayment(
                            unifiedTransaction,
                            `webhook-${webhook.event_id}`,
                        );

                        this.logger.info('Successfully processed book transfer for completed payment', {
                            transactionId,
                            amount: unifiedTransaction.amount,
                        });

                        // Return successful result
                        return {
                            success: true,
                            message: 'Transaction updated and book transfer initiated',
                            transactionId,
                            updatedStatus: status,
                        };
                    }
                } catch (transferError) {
                    this.logger.error('Failed to process book transfer', {
                        transactionId,
                        error: transferError instanceof Error ? transferError.message : 'Unknown error',
                    });

                    // Update transaction to indicate transfer failure but continue
                    try {
                        await UnifiedTransactionService.updateTransaction(
                            {
                                transactionId,
                                metadata: {
                                    ...transaction.metadata,
                                    bookTransferError:
                                        transferError instanceof Error ? transferError.message : 'Unknown error',
                                    bookTransferFailedAt: new Date().toISOString(),
                                },
                            },
                            `webhook-${webhook.event_id}`,
                        );
                    } catch (updateError) {
                        this.logger.error('Failed to update transaction with transfer error', updateError);
                    }
                }
            }

            // Standard update using unified service
            this.logger.info('Updating standard transaction', { transactionId, updateData });

            // Convert the update data to UnifiedTransactionService format
            await UnifiedTransactionService.updateTransaction(
                {
                    transactionId,
                    status: updateData.status,
                    metadata: {
                        ...transaction.metadata,
                        responseCode: updateData.responseCode,
                        responseText: updateData.responseText,
                        authCode: updateData.authCode,
                        webhookUpdatedAt: updateData.updatedAt,
                    },
                },
                `webhook-${webhook.event_id}`,
            );

            this.logger.info('Updated transaction successfully', {
                transactionId,
                newStatus: updateData.status,
            });

            return {
                success: true,
                message: 'Transaction updated successfully',
                transactionId,
                updatedStatus: status,
            };
        } catch (error) {
            this.logger.error('Error processing webhook', error);

            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }

    /**
     * Determine the transaction status based on the webhook event type and body
     * @param eventType - The type of NMI webhook event
     * @param eventBody - The body of the webhook event
     * @returns The determined transaction status or null if unable to determine
     */
    private determineTransactionStatus(eventType: string, eventBody: any): TransactionStatus | null {
        switch (eventType) {
            case 'transaction.sale.success':
            case 'transaction.capture.success':
                return TransactionStatus.COMPLETED;

            case 'transaction.sale.failure':
            case 'transaction.capture.failure':
            case 'transaction.auth.failure':
                return TransactionStatus.FAILED;

            case 'transaction.auth.success':
                return TransactionStatus.PENDING;

            case 'transaction.void.success':
                return TransactionStatus.CANCELLED;

            case 'transaction.refund.success':
                return TransactionStatus.REVERSED;

            default:
                // Check event body for status clues if event type isn't definitive
                if (eventBody && eventBody.status) {
                    if (eventBody.status.toLowerCase() === 'approved') {
                        return TransactionStatus.COMPLETED;
                    } else if (eventBody.status.toLowerCase() === 'declined') {
                        return TransactionStatus.FAILED;
                    }
                }

                // Unable to determine status
                return null;
        }
    }

    /**
     * Process a book transfer for a completed NMI payment
     */
    private async processBookTransferForCompletedPayment(transaction: any, requestId: string): Promise<void> {
        const functionName = 'processBookTransferForCompletedPayment';

        this.logger.info(`[${functionName}] Processing book transfer for completed payment`, {
            requestId,
            transactionId: transaction.transactionId,
            recipientId: transaction.recipient.entityId,
            amount: transaction.amount,
        });

        // Get recipient's Cybrid account details
        const recipientCybridAccount = await this.getRecipientCybridAccount(transaction.recipient.entityId, requestId);

        this.logger.info('recipientCybridAccount', recipientCybridAccount);

        if (!recipientCybridAccount) {
            throw new Error(`Cybrid account not found for recipient: ${transaction.recipient.entityId}`);
        }

        // Create book transfer from platform bank to customer
        const bookTransferResult = await BookTransferService.createBookTransfer(
            {
                sourceAccountId: PLATFORM_FEE_ACCOUNT_GUID, // Platform's fee account as source
                destinationAccountId: recipientCybridAccount.accountId,
                amount: transaction.amount, // Already in cents
                asset: transaction.asset || 'USD',
                memo: `NMI Payment ${transaction.transactionId}`,
                metadata: {
                    nmiTransactionId: transaction.paymentProviderId,
                    transactionId: transaction.transactionId,
                    source: 'nmi_webhook',
                },
                // Source is the platform bank
                sourceParticipantType: 'bank',
                sourceParticipantGuid: PLATFORM_BANK_GUID,
                // Destination is the customer
                destinationParticipantType: 'customer',
                destinationParticipantGuid: recipientCybridAccount.customerId,
            },
            requestId,
        );

        this.logger.info(`[${functionName}] Book transfer created`, {
            requestId,
            transferGuid: bookTransferResult.transferGuid,
            quoteGuid: bookTransferResult.quoteGuid,
            state: bookTransferResult.state,
        });

        // Update transaction with book transfer details
        await UnifiedTransactionService.updateTransaction(
            {
                transactionId: transaction.transactionId,
                completedAt: new Date().toISOString(),
                metadata: {
                    ...transaction.metadata,
                    bookTransferGuid: bookTransferResult.transferGuid,
                    bookTransferQuoteGuid: bookTransferResult.quoteGuid,
                    bookTransferState: bookTransferResult.state,
                    bookTransferCreatedAt: bookTransferResult.createdAt,
                },
            },
            requestId,
        );
    }

    /**
     * Get recipient's Cybrid account details
     */
    private async getRecipientCybridAccount(userId: string, requestId: string): Promise<any> {
        const functionName = 'getRecipientCybridAccount';

        this.logger.info(`[${functionName}] Getting Cybrid account for user`, {
            requestId,
            userId,
        });

        // First, get the user record to find their Cybrid customer ID
        const userKeys = SingleTableKeys.user(userId);
        const userRecord = await dynamoDB.get({
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
        });

        if (!userRecord) {
            throw new Error(`User not found: ${userId}`);
        }

        const cybridCustomerId =
            (userRecord as any).metadata?.cybrid?.customerId || (userRecord as any).metadata?.cybrid?.customer?.guid;

        if (!cybridCustomerId) {
            throw new Error(`Cybrid customer ID not found for user: ${userId}`);
        }

        const fiatAccountId = (userRecord as any).metadata?.cybrid?.fiatAccountId;

        if (!fiatAccountId) {
            throw new Error(`Cybrid fiat account not found for user: ${userId}`);
        }

        // Get the fiat account record
        const accountKeys = SingleTableKeys.cybridFiatAccount(userId, fiatAccountId);
        const accountRecord = await dynamoDB.get({
            TableName: SINGLE_TABLE_NAME,
            Key: accountKeys,
        });

        if (!accountRecord) {
            throw new Error(`Fiat account record not found: ${fiatAccountId}`);
        }

        this.logger.info(`[${functionName}] Found Cybrid account`, {
            requestId,
            userId,
            accountId: fiatAccountId,
            customerId: cybridCustomerId,
        });

        return {
            accountId: fiatAccountId,
            customerId: cybridCustomerId,
            userId,
        };
    }
}
</file>

<file path="lambdas/nmi/webhooks/types/nmi.ts">
/**
 * NMI API Response and Request Type Definitions
 */

import { TransactionType } from '../../../layers/commons/data/entities/transaction';

// Transaction types
export enum NmiTransactionType {
    AUTH = 'auth',
    CAPTURE = 'capture',
    SALE = 'sale',
    REFUND = 'refund',
    VOID = 'void',
    CREDIT = 'credit',
    VALIDATE = 'validate',
    UPDATE = 'update',
}

// Response codes
export enum ResponseCode {
    APPROVED = '1',
    DECLINED = '2',
    ERROR = '3',
}

// Result codes
export enum ResultCode {
    APPROVED = '100',
    DECLINED = '200',
    DO_NOT_HONOR = '201',
    INSUFFICIENT_FUNDS = '202',
    OVER_LIMIT = '203',
    TRANSACTION_NOT_ALLOWED = '204',
    INCORRECT_PAYMENT_INFO = '220',
    NO_CARD_ISSUER = '221',
    NO_CARD_NUMBER = '222',
    EXPIRED_CARD = '223',
    INVALID_EXPIRATION_DATE = '224',
    INVALID_CVV = '225',
    INVALID_PIN = '226',
    CALL_ISSUER = '240',
    PICK_UP_CARD = '250',
    LOST_CARD = '251',
    STOLEN_CARD = '252',
    FRAUDULENT_CARD = '253',
    DECLINED_WITH_INSTRUCTIONS = '260',
    DECLINED_RECURRING_STOP_ALL = '261',
    DECLINED_RECURRING_STOP_THIS = '262',
    UPDATE_CARDHOLDER_DATA = '263',
    RETRY_LATER = '264',
    GATEWAY_REJECTED = '300',
    PROCESSOR_ERROR = '400',
    INVALID_MERCHANT_CONFIG = '410',
    MERCHANT_ACCOUNT_INACTIVE = '411',
    COMMUNICATION_ERROR = '420',
    ISSUER_COMMUNICATION_ERROR = '421',
    DUPLICATE_TRANSACTION = '430',
    PROCESSOR_FORMAT_ERROR = '440',
    INVALID_TRANSACTION_INFO = '441',
    PROCESSOR_FEATURE_UNAVAILABLE = '460',
    UNSUPPORTED_CARD_TYPE = '461',
    RATE_LIMIT_EXCEEDED = '301',
}

// Base authorization request parameters
export interface AuthorizationRequest {
    type: NmiTransactionType.AUTH;
    payment_token?: string;
    amount: string;
    customer_vault?: 'add_customer';
    customer_vault_id?: string;
    use_saved_card?: boolean; // Flag to indicate if we should use the user's saved card
    security_key: string;
    orderid?: string;
    // Customer information
    first_name?: string;
    last_name?: string;
    email?: string;
    phone?: string;
    // Address information
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
    country?: string;
}

// Capture request parameters
export interface CaptureRequest {
    type: NmiTransactionType.CAPTURE;
    transactionid: string; // Original transaction ID to capture
    amount?: string; // Can be equal to or less than the original amount
    security_key: string;
}

// Transaction response interface
export interface TransactionResponse {
    response: string; // 1=Approved, 2=Declined, 3=Error
    responsetext: string;
    authcode?: string;
    transactionid?: string;
    cvvresponse?: string;
    avsresponse?: string;
    orderid?: string;
    response_code?: string;
    // Customer vault related fields
    customer_vault_id?: string;
    customer_vault?: string;  // For identifying if this was an add_customer, update_customer, etc.
    cc_type?: string;
    cc_number?: string;
}

// Database transaction record
export interface TransactionRecord {
    id?: string; // UUID for the transaction record
    userId: string; // User who made the transaction
    transactionId?: string; // NMI transaction ID
    customerVaultId?: string; // NMI customer vault ID
    type: TransactionType;
    amount: string;
    status: 'pending' | 'authorized' | 'captured' | 'failed' | 'voided' | 'refunded';
    statusReason?: string;
    authCode?: string;
    responseCode?: string;
    responseText?: string;
    orderReference?: string;
    createdAt: Date;
    updatedAt: Date;
}

// Client-facing payment response
export interface PaymentResponse {
    success: boolean;
    transactionId?: string; // Provider's transaction ID
    internalTransactionId?: string; // Our internal transaction ID
    customerVaultId?: string;
    message: string;
    orderReference?: string;
    status: 'pending' | 'authorized' | 'captured' | 'failed' | 'voided' | 'refunded';
    errorCode?: string;
    transactionRecord?: TransactionRecord;
}

/**
 * Query transaction interface for NMI API
 */
export interface QueryTransactionRequest {
    security_key: string;
    transaction_id?: string;
    condition?: string;
    transaction_type?: string;
    action_type?: string;
    source?: string;
    start_date?: string;
    end_date?: string;
    result_limit?: string;
    page_number?: string;
    order_id?: string;
    email?: string;
    result_order?: 'standard' | 'reverse';
}

/**
 * Query transaction response interface for the specific fields
 * Extracting from the XML response
 */
export interface QueryTransactionResponse {
    success: boolean;
    message: string;
    transactions?: Array<{
        transaction_id: string;
        cc_bin: string;
        cc_type: string;
        condition: string;
        customerid: string;
        amount?: string;
        action_type?: string;
        date?: string;
    }>;
    errorCode?: string;
}

/**
 * Card Type Check Response from NMI API
 */
export interface CardTypeCheckResponse {
    success: boolean;
    result?: 'debit' | 'credit' | 'prepaid' | 'charge' | 'deferred_debit' | 'unknown' | 'unavailable';
    message?: string;
    errorCode?: string;
}

/**
 * Customer Vault Request for NMI API
 */
export interface CustomerVaultRequest {
    customer_vault: 'add_customer' | 'update_customer' | 'delete_customer';
    customer_vault_id?: string;
    security_key: string;
    payment_token?: string;
    first_name?: string;
    last_name?: string;
    email?: string;
    phone?: string;
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
    country?: string;
    company?: string;
    orderid?: string;
}

/**
 * Customer Vault Response from NMI API
 */
export interface CustomerVaultResponse {
    success: boolean;
    customerVaultId?: string;
    message: string;
    ccType?: string;
    ccNumber?: string;
    errorCode?: string;
}
</file>

<file path="lambdas/nmi/webhooks/types/request-types.ts">
/**
 * TypeScript interfaces for NMI API request bodies
 */

/**
 * Base transaction request interface with common properties
 */
export interface BaseTransactionRequest {
    amount?: string;
    orderid?: string;
}

/**
 * Customer information interface for payment requests
 */
export interface CustomerInfo {
    first_name?: string;
    last_name?: string;
    email?: string;
    phone?: string;
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
    country?: string;
}

/**
 * Interface for the authorize transaction request
 */
export interface AuthorizeRequest extends BaseTransactionRequest, CustomerInfo {
    payment_token: string;
    customer_vault?: 'add_customer';
    use_saved_card?: boolean; // Flag to indicate if we should use the user's saved card
    use_wallet_balance?: boolean; // Flag to indicate if we should use wallet balance instead of card
    type: 'deposit' | 'p2p' | 'p2b';
    amount: string; // Making amount required to match NMI service expectations
    captureImmediately?: boolean; // Whether to capture the transaction immediately after authorization

    // Additional fields for P2P and P2B transactions
    recipient_entity_id?: string; // ID of the recipient (user or business)
    recipient_type?: string; // Type of recipient (USER or BUSINESS)
    recipient_clkk_tag?: string; // Username of the recipient
    sender_clkk_tag?: string; // Username of the sender
    recipient_current_email?: string; // Email of the recipient
    sender_current_email?: string; // Email of the sender
}

/**
 * Interface for the capture transaction request
 */
export interface CaptureRequest extends BaseTransactionRequest {
    transactionId: string;
}

/**
 * Interface for query transaction request
 */
export interface QueryTransactionRequest extends BaseTransactionRequest {
    transaction_id?: string;
    condition?: string;
    transaction_type?: string;
    action_type?: string;
    source?: string;
    start_date?: string;
    end_date?: string;
    result_limit?: string;
    page_number?: string;
    email?: string;
    result_order?: 'standard' | 'reverse';
}

/**
 * Interface for the card type check request
 */
export interface CardTypeCheckRequest {
    ccnumber: string;
}
</file>

<file path="lambdas/nmi/webhooks/types/transaction.types.ts">
/**
 * Unified transaction types for all payment providers
 */

export enum TransactionType {
    DEPOSIT = 'DEPOSIT',
    WITHDRAWAL = 'WITHDRAWAL',
    P2P_TRANSFER = 'P2P_TRANSFER',
    P2B_TRANSFER = 'P2B_TRANSFER',
    B2P_TRANSFER = 'B2P_TRANSFER',
    BOOK_TRANSFER = 'BOOK_TRANSFER',
}

export enum TransactionStatus {
    PENDING = 'PENDING',
    PROCESSING = 'PROCESSING',
    COMPLETED = 'COMPLETED',
    FAILED = 'FAILED',
    CANCELLED = 'CANCELLED',
}

export enum EntityType {
    USER = 'USER',
    BUSINESS = 'BUSINESS',
    SYSTEM = 'SYSTEM', // For master account transfers
}

export enum PaymentProvider {
    CYBRID = 'CYBRID',
    NMI = 'NMI',
    CHECKBOOK = 'CHECKBOOK',
    INTERNAL = 'INTERNAL',
}

export interface TransactionEntity {
    entityId: string;
    entityType: EntityType;
    name?: string;
    clkktag?: string;
    email?: string;
}

export interface TransactionFees {
    amount: number;
    percentage: number;
    isPending: boolean;
}

export interface UnifiedTransaction {
    // Primary identifiers
    userId: string;
    transactionId: string;
    
    // Type and status
    type: TransactionType;
    status: TransactionStatus;
    provider: PaymentProvider;
    
    // Amounts (in smallest unit - cents)
    amount: number;
    asset: string;
    fees?: TransactionFees;
    netAmount?: number;
    
    // Entities
    sender: TransactionEntity;
    recipient: TransactionEntity;
    
    // Provider-specific IDs
    paymentProviderId?: string; // Cybrid transfer GUID, NMI transaction ID, etc.
    quoteGuid?: string; // Cybrid quote GUID
    
    // Account references
    sourceAccountId?: string;
    destinationAccountId?: string;
    
    // Metadata
    memo?: string;
    metadata?: Record<string, any>;
    
    // Timestamps
    createdAt: string;
    updatedAt: string;
    completedAt?: string;
    
    // Error tracking
    failureCode?: string;
    failureReason?: string;
    
    // DynamoDB single-table design fields
    PK?: string;
    SK?: string;
    TransactionIdKey?: string;
    SenderIdKey?: string;
    RecipientIdKey?: string;
}

export interface CreateTransactionInput {
    type: TransactionType;
    provider: PaymentProvider;
    amount: number;
    asset: string;
    sender: TransactionEntity;
    recipient: TransactionEntity;
    fees?: Partial<TransactionFees>;
    memo?: string;
    metadata?: Record<string, any>;
    sourceAccountId?: string;
    destinationAccountId?: string;
}

export interface UpdateTransactionInput {
    transactionId: string;
    status?: TransactionStatus;
    paymentProviderId?: string;
    quoteGuid?: string;
    completedAt?: string;
    failureCode?: string;
    failureReason?: string;
    metadata?: Record<string, any>;
}

export interface TransactionQueryOptions {
    userId?: string;
    businessId?: string;
    transactionId?: string;
    senderId?: string;
    recipientId?: string;
    status?: TransactionStatus;
    type?: TransactionType;
    provider?: PaymentProvider;
    startDate?: string;
    endDate?: string;
    limit?: number;
}
</file>

<file path="lambdas/nmi/webhooks/types/webhook.ts">
/**
 * NMI Webhook Types
 * Defines types for NMI webhook events and processing
 */

/**
 * NMI Webhook Event Types
 */
export enum NmiWebhookEventType {
    AUTH_SUCCESS = 'transaction.auth.success',
    AUTH_FAILURE = 'transaction.auth.failure',
    CAPTURE_SUCCESS = 'transaction.capture.success',
    CAPTURE_FAILURE = 'transaction.capture.failure',
    SALE_SUCCESS = 'transaction.sale.success',
    SALE_FAILURE = 'transaction.sale.failure',
    REFUND_SUCCESS = 'transaction.refund.success',
    REFUND_FAILURE = 'transaction.refund.failure',
    VOID_SUCCESS = 'transaction.void.success',
    VOID_FAILURE = 'transaction.void.failure',
}

/**
 * NMI Webhook Event Payload
 */
export interface NmiWebhookEvent {
    event_id: string;
    event_type: NmiWebhookEventType | string;
    event_body: NmiWebhookEventBody;
}

/**
 * NMI Webhook Event Body
 */
export interface NmiWebhookEventBody {
    merchant: {
        id: string;
        name: string;
    };
    features: {
        is_test_mode: boolean;
    };
    transaction_id: string;
    transaction_type: string;
    condition: string;
    processor_id: string;
    ponumber: string;
    order_description: string;
    order_id: string;
    customerid: string;
    customertaxid: string;
    website: string;
    shipping: string;
    currency: string;
    tax: string;
    surcharge: string;
    convenience_fee: string;
    misc_fee: string;
    misc_fee_name: string;
    cash_discount: string;
    tip: string;
    requested_amount: string;
    shipping_carrier: string;
    tracking_number: string;
    shipping_date: string;
    partial_payment_id: string;
    partial_payment_balance: string;
    platform_id: string;
    authorization_code: string;
    social_security_number: string;
    drivers_license_number: string;
    drivers_license_state: string;
    drivers_license_dob: string;
    duty_amount: string;
    discount_amount: string;
    national_tax_amount: string;
    summary_commodity_code: string;
    alternate_tax_amount: string;
    vat_tax_amount: string;
    vat_tax_rate: string;
    merchant_advice_code: string;
    merchant_advice_code_description: string;
    association_response_code: string;
    association_response_code_description: string;
    additional_processor_responses: string;
    additional_processor_response_descriptions: string;
    billing_address: {
        first_name: string;
        last_name: string;
        address_1: string;
        address_2: string;
        company: string;
        city: string;
        state: string;
        postal_code: string;
        country: string;
        email: string;
        phone: string;
        cell_phone: string;
        fax: string;
    };
    shipping_address: {
        first_name: string;
        last_name: string;
        address_1: string;
        address_2: string;
        company: string;
        city: string;
        state: string;
        postal_code: string;
        country: string;
        email: string;
        phone: string;
        fax: string;
    };
    card: {
        cc_number: string;
        cc_exp: string;
        cavv: string;
        cavv_result: string;
        xid: string;
        eci: string;
        avs_response: string;
        csc_response: string;
        cardholder_auth: string;
        cc_start_date: string;
        cc_issue_number: string;
        card_balance: string;
        card_available_balance: string;
        entry_mode: string;
        cc_bin: string;
        cc_type: string;
        feature_token: string;
    };
    merchant_defined_fields: Record<string, string>;
    action: {
        amount: string;
        action_type: string;
        date: string;
        success: string;
        ip_address: string;
        source: string;
        api_method: string;
        username: string;
        response_text: string;
        response_code: string;
        processor_response_text: string;
        tap_to_mobile: boolean;
        network_token_used: boolean;
        processor_response_code: string;
        processor_response_description: string;
        device_license_number: string;
        device_nickname: string;
    };
}

/**
 * NMI Webhook Verification Request
 */
export interface WebhookVerificationRequest {
    webhookBody: string;
    signingKey: string;
    nonce: string;
    signature: string;
}

/**
 * NMI Webhook Verification Result
 */
export interface WebhookVerificationResult {
    isValid: boolean;
    message?: string;
    webhook?: NmiWebhookEvent;
}

/**
 * NMI Webhook Handler Response
 */
export interface WebhookHandlerResponse {
    statusCode: number;
    headers?: Record<string, string>;
    body: string;
}

/**
 * NMI Webhook Processing Result
 */
export interface WebhookProcessingResult {
    success: boolean;
    message: string;
    transactionId?: string;
    updatedStatus?: string;
}
</file>

<file path="lambdas/nmi/webhooks/utils/date-util.ts">
/**
 * Simple date utilities for shared services
 */

export class DateUtil {
    static now(): string {
        return new Date().toISOString();
    }

    static formatDate(date: Date | string): string {
        return new Date(date).toISOString();
    }
}
</file>

<file path="lambdas/nmi/webhooks/utils/dynamodb.ts">
/**
 * DynamoDB utilities for shared services
 */

import { DynamoDB } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';

const client = new DynamoDB({});
export const dynamoDB = DynamoDBDocument.from(client);
</file>

<file path="lambdas/nmi/webhooks/utils/single-table-keys.ts">
/**
 * Helper functions for generating keys for the single table design
 */

export const SingleTableKeys = {
    // User/Entity keys
    user: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PROFILE`,
    }),

    // Cybrid Fiat Account keys
    cybridFiatAccount: (userId: string, accountId: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_FIAT#${accountId}`,
    }),

    // Cybrid Identity Verification keys
    cybridIdentityVerification: (userId: string, verificationId: string, timestamp: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_KYC#${timestamp}#${verificationId}`,
    }),

    // Plaid Access Token keys
    plaidAccessToken: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PLAID_TOKEN`,
    }),

    // Transaction keys
    transaction: (userId: string, timestamp: string, transactionId: string) => ({
        PK: `USER#${userId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Transaction keys for business accounts
    businessTransaction: (businessId: string, timestamp: string, transactionId: string) => ({
        PK: `BUSINESS#${businessId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Query patterns for GSIs
    gsiKeys: {
        // For querying by Cybrid customer ID (using ExternalIdIndex)
        byCybridCustomerId: (customerId: string) => ({
            ExternalIdKey: `CYBRID_CUSTOMER#${customerId}`,
            ProviderIdKey: 'CYBRID',
        }),

        // For querying fiat accounts by customer ID
        fiatAccountByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_FIAT_ACCOUNT',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For KYC status queries
        byKycStatus: (status: string, userId: string) => ({
            KYCStatusKey: `STATUS#${status}`,
            EntityTypeIdKey: `USER#${userId}`,
        }),

        // For identity verifications by customer ID
        identityVerificationByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_IDENTITY_VERIFICATION',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For transaction lookups by ID
        transactionById: (transactionId: string) => ({
            TransactionIdKey: `TXN#${transactionId}`,
        }),

        // For querying transactions by sender
        transactionsBySender: (senderId: string) => ({
            SenderIdKey: `SENDER#${senderId}`,
        }),

        // For querying transactions by recipient
        transactionsByRecipient: (recipientId: string) => ({
            RecipientIdKey: `RECIPIENT#${recipientId}`,
        }),
    },
};

// Single table name constant
export const SINGLE_TABLE_NAME = process.env.SINGLE_TABLE_NAME || process.env.TABLE_NAME || 'clkk-app-table-dev';
</file>

<file path="lambdas/nmi/webhooks/package.json">
{
    "name": "nmi-webhooks",
    "version": "1.0.0",
    "description": "NMI Webhook Handlers",
    "main": "webhook-receiver.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0",
        "@aws-sdk/client-secrets-manager": "^3.716.0",
        "@aws-sdk/client-sns": "^3.716.0",
        "@aws-sdk/client-dynamodb": "^3.716.0",
        "@aws-sdk/lib-dynamodb": "^3.716.0",
        "axios": "^1.7.9",
        "uuid": "^11.0.3"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="lambdas/nmi/webhooks/README.md">
# NMI Webhook Integration

This module provides webhook integration with NMI (Network Merchants Inc.) payment gateway. The system supports real-time webhook notifications for transaction events such as authorizations and captures.

## Architecture

The webhook integration follows a serverless architecture pattern:

1. **API Gateway Endpoint** - Receives webhook requests from NMI
2. **Webhook Receiver Lambda** - Validates and publishes the webhook events to SNS
3. **SNS Topic** - Fans out webhook events to subscribers
4. **SQS Queue** - Provides a buffer and reliable message queue for webhook processing
5. **Webhook Processor Lambda** - Consumes events from SQS and updates transactions accordingly

```
NMI --> API Gateway --> Webhook Receiver --> SNS Topic --> SQS Queue --> Webhook Processor --> DynamoDB
```

## Webhook Events

NMI sends webhook notifications for the following event types:

-   `transaction.auth.success` - Successful transaction authorization
-   `transaction.auth.failure` - Failed transaction authorization
-   `transaction.capture.success` - Successful transaction capture
-   `transaction.capture.failure` - Failed transaction capture
-   `transaction.sale.success` - Successful direct sale
-   `transaction.sale.failure` - Failed direct sale
-   `transaction.refund.success` - Successful refund
-   `transaction.refund.failure` - Failed refund
-   `transaction.void.success` - Successful void
-   `transaction.void.failure` - Failed void

## Webhook Verification

NMI webhooks are signed with a secret key using HMAC-SHA256. The signature is sent in the `Webhook-Signature` header in the format:

```
Webhook-Signature: t=<timestamp>,s=<signature>
```

The signature is verified by computing an HMAC with the webhook signing key over the string `<timestamp>.<webhook_body>` and comparing it to the provided signature.

## Webhook Processing

When a webhook is received:

1. The webhook receiver validates the request and forwards it to SNS
2. The SNS topic fans out the message to the SQS queue
3. The webhook processor function consumes messages from the queue and:
    - Verifies the webhook signature
    - Looks up the relevant transaction using the transaction ID
    - Updates the transaction status based on the webhook event type
    - Logs the outcome of the operation

## Configuration

The webhook integration requires the following configuration:

-   `NMI_WEBHOOK_TOPIC_ARN` - ARN of the SNS topic for webhook events
-   `NMI_SECRET_NAME` - Name of the Secrets Manager secret containing webhook credentials
-   `NMI_WEBHOOK_SIGNING_KEY` - The signing key for verifying webhook signatures (stored in Secrets Manager)

## Setup in NMI Dashboard

To set up webhooks in the NMI dashboard:

1. Log in to your NMI gateway account
2. Navigate to Settings > Webhooks
3. Add a new webhook with the following settings:
    - URL: `https://{api-id}.execute-api.{region}.amazonaws.com/{stage}/nmi/webhooks`
    - Events: Select all transaction events you want to receive
    - Format: JSON
4. Copy the webhook signing key and store it in AWS Secrets Manager

## Testing

To test the webhook integration:

1. Use the NMI dashboard to send a test webhook
2. Verify that the webhook is received by checking CloudWatch logs for the webhook receiver
3. Check that the webhook is processed by the webhook processor
4. Verify that the transaction is updated correctly in DynamoDB
</file>

<file path="lambdas/nmi/webhooks/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/nmi/webhooks/webhook-processor.ts">
import { SQSEvent, SQSHandler, SNSMessage } from 'aws-lambda';
import { createLogger } from 'commons/utils/logger_v2';
import { WebhookService } from './services/webhook-service';
import { NmiWebhookEvent } from './types/webhook';
import { getNmiWebhookSigningKey } from './services/secrets-service';

/**
 * Logger for the webhook processor
 */
const logger = createLogger('NmiWebhookProcessor');

/**
 * Parse SNS message to get webhook data
 * @param message - SNS message
 * @returns Webhook event data and verification flag
 */
function parseMessage(message: SNSMessage): {
    webhook: NmiWebhookEvent;
    wasVerified: boolean;
} {
    try {
        logger.info('Parsing SNS message');

        // Get the webhook body from the message
        const webhookBody = message.Message;

        // Parse the webhook body
        const webhook = JSON.parse(webhookBody) as NmiWebhookEvent;

        // Check if the webhook was verified by the receiver
        const wasVerified = message.MessageAttributes?.['webhook_verified']?.Value === 'true';

        logger.info('Successfully parsed SNS message', {
            eventId: webhook.event_id,
            eventType: webhook.event_type,
            wasVerified,
        });

        return { webhook, wasVerified };
    } catch (error) {
        logger.error('Error parsing SNS message', error);
        throw error;
    }
}

/**
 * Process a webhook event
 * @param webhook - Webhook event
 * @param wasVerified - Whether the webhook was verified by the receiver
 * @returns Processing result
 */
async function processWebhook(
    webhook: NmiWebhookEvent,
    wasVerified: boolean,
): Promise<{ success: boolean; message: string }> {
    try {
        logger.info('Processing webhook', {
            eventId: webhook.event_id,
            eventType: webhook.event_type,
            wasVerified,
        });

        // Get signing key for WebhookService using the common secrets service
        const signingKey = await getNmiWebhookSigningKey();

        // Create webhook service
        const webhookService = new WebhookService(signingKey);

        // Skip verification since it was done in the receiver
        if (!wasVerified) {
            logger.warn('Processing unverified webhook - this should only happen in development');
        }

        // Process the webhook to update transaction
        const result = await webhookService.processWebhook(webhook);

        logger.info('Webhook processing result', {
            success: result.success,
            message: result.message,
            transactionId: result.transactionId,
            updatedStatus: result.updatedStatus,
        });

        return {
            success: result.success,
            message: result.message,
        };
    } catch (error) {
        logger.error('Error processing webhook', error);

        return {
            success: false,
            message: error instanceof Error ? error.message : 'Unknown error',
        };
    }
}

/**
 * Lambda handler for processing NMI webhooks from SQS messages
 * @param event - SQS event
 */
export const nmiWebhookProcessor: SQSHandler = async (event: SQSEvent) => {
    try {
        logger.info('Processing SQS event', {
            recordCount: event.Records.length,
        });

        // Process each SQS record
        const results = await Promise.all(
            event.Records.map(async (record) => {
                try {
                    logger.info('Processing SQS record', {
                        messageId: record.messageId,
                    });

                    // Parse SNS message from SQS record body
                    const message = JSON.parse(record.body) as SNSMessage;

                    // Parse webhook data from SNS message
                    const { webhook, wasVerified } = parseMessage(message);

                    // Process the webhook
                    const result = await processWebhook(webhook, wasVerified);

                    logger.info('SQS record processed', {
                        messageId: record.messageId,
                        success: result.success,
                        message: result.message,
                    });

                    return {
                        recordId: record.messageId,
                        ...result,
                    };
                } catch (error) {
                    logger.error('Error processing SQS record', {
                        messageId: record.messageId,
                        error,
                    });

                    return {
                        recordId: record.messageId,
                        success: false,
                        message: error instanceof Error ? error.message : 'Unknown error',
                    };
                }
            }),
        );

        // Summarize results
        const successCount = results.filter((r) => r.success).length;
        const failureCount = results.length - successCount;

        logger.info('SQS event processing completed', {
            totalRecords: results.length,
            successCount,
            failureCount,
        });
    } catch (error) {
        logger.error('Error processing SQS event', error);
        throw error;
    }
};
</file>

<file path="lambdas/nmi/webhooks/webhook-receiver.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { createLogger } from 'commons/utils/logger_v2';
import { SNS } from '@aws-sdk/client-sns';
import { WebhookService } from './services/webhook-service';
import { getNmiWebhookSigningKey } from './services/secrets-service';

/**
 * Logger for the webhook receiver
 */
const logger = createLogger('NmiWebhookReceiver');

/**
 * SNS client
 */
const sns = new SNS({ region: process.env.AWS_REGION });

/**
 * SNS topic ARN for NMI webhooks
 */
const NMI_WEBHOOK_TOPIC_ARN = process.env.NMI_WEBHOOK_TOPIC_ARN;

/**
 * Extract nonce and signature from the Webhook-Signature header
 * @param signatureHeader - Webhook-Signature header value
 * @returns Nonce and signature
 */
function extractSignatureComponents(signatureHeader: string): { nonce: string; signature: string } {
    try {
        const matches = /t=(.*),s=(.*)/.exec(signatureHeader);

        if (!matches || matches.length < 3) {
            throw new Error('Invalid webhook signature format');
        }

        return {
            nonce: matches[1],
            signature: matches[2],
        };
    } catch (error) {
        logger.error('Error extracting signature components', error);
        throw error;
    }
}

/**
 * Lambda handler for receiving NMI webhooks via API Gateway
 * @param event - API Gateway proxy event
 * @returns API Gateway proxy result
 */
export const nmiWebhookReceiver = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    try {
        logger.info('Received webhook from NMI', {
            path: event.path,
            method: event.httpMethod,
            hasBody: !!event.body,
        });

        // Check if webhook topic ARN is configured
        if (!NMI_WEBHOOK_TOPIC_ARN) {
            logger.error('NMI_WEBHOOK_TOPIC_ARN environment variable is not set');
            return {
                statusCode: 500,
                body: JSON.stringify({
                    message: 'Internal server error',
                }),
            };
        }

        // Check if body is present
        if (!event.body) {
            logger.warn('Webhook body is empty');
            return {
                statusCode: 400,
                body: JSON.stringify({
                    message: 'Webhook body is required',
                }),
            };
        }

        // Extract webhook signature from headers
        const webhookSignature = event.headers['Webhook-Signature'] || event.headers['webhook-signature'] || null;

        // Parse webhook body if it's base64 encoded
        const webhookBody = event.isBase64Encoded ? Buffer.from(event.body, 'base64').toString('utf-8') : event.body;

        try {
            // Parse webhook body to verify it's valid JSON
            const parsedBody = JSON.parse(webhookBody);

            //Parsed whole webhook body
            logger.info('Parsed webhook body', {
                webhookBody,
            });

            logger.info('Parsed webhook body', {
                eventId: parsedBody.event_id,
                eventType: parsedBody.event_type,
                hasSignature: !!webhookSignature,
            });

            // Validate webhook signature if available
            if (webhookSignature) {
                try {
                    // Get the NMI webhook signing key using the common secrets service
                    const signingKey = await getNmiWebhookSigningKey();

                    // Create webhook service
                    const webhookService = new WebhookService(signingKey);

                    // Extract signature components
                    const { nonce, signature } = extractSignatureComponents(webhookSignature);

                    // Verify webhook
                    const verificationResult = webhookService.verifyWebhook({
                        webhookBody,
                        signingKey,
                        nonce,
                        signature,
                    });

                    // If verification fails, return error
                    if (!verificationResult.isValid) {
                        logger.warn('Webhook verification failed', {
                            message: verificationResult.message,
                        });

                        return {
                            statusCode: 401,
                            body: JSON.stringify({
                                message: verificationResult.message || 'Webhook verification failed',
                            }),
                        };
                    }

                    logger.info('Webhook verification succeeded');
                } catch (validationError) {
                    logger.error('Error validating webhook', validationError);

                    return {
                        statusCode: 500,
                        body: JSON.stringify({
                            message: 'Error validating webhook',
                        }),
                    };
                }
            } else {
                logger.warn('No webhook signature provided, webhook will be processed without verification');

                return {
                    statusCode: 401,
                    body: JSON.stringify({
                        message: 'Webhook signature is required',
                    }),
                };
            }

            // Prepare MessageAttributes for SNS
            const messageAttributes: Record<string, any> = {};

            // Add event type for filtering if available
            if (parsedBody.event_type) {
                messageAttributes['event_type'] = {
                    DataType: 'String',
                    StringValue: parsedBody.event_type,
                };
            }

            // Add a flag indicating the webhook was verified
            messageAttributes['webhook_verified'] = {
                DataType: 'String',
                StringValue: webhookSignature ? 'true' : 'false',
            };

            // Publish webhook to SNS
            await sns.publish({
                TopicArn: NMI_WEBHOOK_TOPIC_ARN,
                Message: webhookBody,
                MessageAttributes: messageAttributes,
            });

            logger.info('Successfully published webhook to SNS', {
                topicArn: NMI_WEBHOOK_TOPIC_ARN,
                eventId: parsedBody.event_id,
                verified: !!webhookSignature,
            });

            // Return success response
            return {
                statusCode: 200,
                body: JSON.stringify({
                    message: 'Webhook received and processed successfully',
                }),
            };
        } catch (parseError) {
            logger.error('Error parsing webhook body', parseError);

            return {
                statusCode: 400,
                body: JSON.stringify({
                    message: 'Invalid webhook body format',
                }),
            };
        }
    } catch (error) {
        logger.error('Error processing webhook', error);

        return {
            statusCode: 500,
            body: JSON.stringify({
                message: 'Internal server error',
            }),
        };
    }
};
</file>

<file path="lambdas/nmi/package.json">
{
    "name": "nmi",
    "version": "1.0.0",
    "description": "NMI Payment",
    "main": "dist/app.js",
    "author": "CLKK",
    "license": "MIT",
    "scripts": {
        "unit": "jest",
        "lint": "eslint '*.ts' --quiet --fix",
        "compile": "tsc",
        "test": "npm run compile && npm run unit"
    },
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0",
        "@aws-sdk/client-secrets-manager": "^3.716.0",
        "@aws-sdk/client-sns": "^3.716.0",
        "@aws-sdk/client-sqs": "^3.716.0",
        "crypto": "^1.0.1",
        "fast-xml-parser": "^5.2.0"
    },
    "devDependencies": {
        "@jest/globals": "^29.2.0",
        "@types/aws-lambda": "^8.10.146",
        "@types/jest": "^29.2.0",
        "@types/node": "^18.11.4",
        "@typescript-eslint/eslint-plugin": "^5.10.2",
        "@typescript-eslint/parser": "^5.10.2",
        "esbuild": "^0.14.14",
        "eslint": "^8.8.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^29.2.1",
        "prettier": "^2.5.1",
        "ts-jest": "^29.0.5",
        "ts-node": "^10.9.1",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="lambdas/notifications/services/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/notifications/package.json">
{
    "name": "user-notifications",
    "version": "1.0.0",
    "description": "User Notifications Lambda",
    "main": "user-notifications.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "axios": "^1.7.9",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="lambdas/notifications/push-notification.ts">
import { SNSEvent, SQSEvent } from 'aws-lambda';
import { logger } from 'commons';
import { NotificationService } from './services/notification-service';
import { TransactionService } from '../cybrid/quotes/services/transaction-service';
import axios from 'axios';
import { DateUtil } from 'commons';
import { getSecret } from 'commons';
import { getCybridToken, CybridConfig } from 'commons';
import { DYNAMO_TABLES, dynamoDB } from 'commons';
import { AccountBankModel, TransferBankModel } from '@cybrid/cybrid-api-bank-typescript';
import { QueryCommand, DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { unmarshall } from '@aws-sdk/util-dynamodb';
import { Transaction } from '@/API';

// Initialize the DynamoDB client
const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });

/**
 * Processes incoming SNS events and sends push notifications
 * @param event SNS event containing transfer data
 */
export const processNotification = async (event: SQSEvent): Promise<void> => {
    for (const record of event.Records) {
        try {
            logger.info('Processing SQS message', {
                messageId: record.messageId,
                body: record.body,
            });
            // Add validation before parsing
            if (!record.body) {
                logger.error('Empty SQS message body', { messageId: record.messageId });
                continue;
            }

            const message = JSON.parse(record.body);
            const messageData = JSON.parse(message.Message);

            logger.info('MessageData', messageData);
            const eventSource = messageData.eventSource;
            const eventType = messageData.eventType;
            const transferGuid = messageData.transferGuid;

            logger.info('Processing SQS message', {
                messageId: record.messageId,
                eventSource,
                eventType,
                message,
                transferGuid,
            });

            // If this is a transfer event, process it
            if (messageData.eventType === 'transfer.completed') {
                logger.info('Processing transfer notification', { messageData });

                // Query transaction using transferGuid as paymentProviderId
                try {
                    const transactionResult = await queryTransactionByPaymentProviderId(transferGuid);
                    logger.info('Transaction lookup result', {
                        transferGuid,
                        transactionFound: transactionResult ? true : false,
                        transaction: transactionResult,
                    });

                    // Process the notification with the found transaction
                    if (transactionResult) {
                        await processTransferNotification(messageData, transactionResult);
                    } else {
                        logger.warn('No transaction found for transfer', { transferGuid });
                    }
                } catch (queryError) {
                    logger.error('Error querying transaction', {
                        transferGuid,
                        error: queryError,
                    });
                }
            } else {
                logger.info('Ignoring non-transfer event', { eventType: messageData.eventType });
            }
        } catch (error) {
            logger.error('Error processing notification record', {
                error,
                recordId: record.messageId || 'unknown',
            });
            // Continue processing other records
        }
    }
};

/**
 * Queries the CLKK_TRANSACTIONS table using the PaymentProviderIndex
 * @param paymentProviderId The transferGuid to lookup
 * @returns The transaction if found, or null if not found
 */
async function queryTransactionByPaymentProviderId(paymentProviderId: string) {
    try {
        const params = {
            TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
            IndexName: 'PaymentProviderIdIndex',
            KeyConditionExpression: 'paymentProviderId = :paymentProviderId',
            ExpressionAttributeValues: {
                ':paymentProviderId': { S: paymentProviderId },
            },
            Limit: 1, // We only need the first match
        };

        logger.info('Querying CLKK_TRANSACTIONS', { params });

        const command = new QueryCommand(params);
        const result = await dynamoClient.send(command);

        if (result.Items && result.Items.length > 0) {
            const transaction = unmarshall(result.Items[0]);
            return transaction;
        }

        return null;
    } catch (error) {
        logger.error('Error querying CLKK_TRANSACTIONS table', {
            paymentProviderId,
            error,
        });
        throw error;
    }
}

/**
 * Process a transfer notification
 * @param message The transfer message data
 * @param transaction The transaction associated with the transfer
 */
async function processTransferNotification(message: any, transaction?: any): Promise<void> {
    try {
        const transferGuid = message.transferGuid;
        if (!transferGuid) {
            logger.warn('Transfer message missing transferGuid', { message });
            return;
        }

        // If transaction wasn't provided, try to find it
        let transactionData = transaction;
        if (!transactionData) {
            // Find transaction related to this transfer
            const transactions = await TransactionService.getTransactionsByPaymentProviderId(transferGuid);

            if (!transactions || transactions.length === 0) {
                logger.warn('No transaction found for transfer', { transferGuid });
                return;
            }

            transactionData = transactions[0];
        }

        logger.info('Transaction', { transaction: transactionData as Transaction });
        logger.info('Transaction recipientId', { recipientId: transactionData.recipientEntityId });

        // For transfers, we notify the recipient
        if (!transactionData || !transactionData.recipientEntityId) {
            logger.warn('Transaction has no recipient ID', {
                transactionId: transactionData?.transactionId || 'unknown',
            });
            return;
        }

        // Create notification payload
        const payload = NotificationService.createTransferNotificationPayload({
            guid: transferGuid,
            amount: transactionData.amount,
            asset: transactionData.asset,
            state: transactionData.status,
        });

        logger.info('Notification payload', { payload });

        // Send notification to recipient
        const result = await NotificationService.sendNotificationToUser(transactionData.recipientEntityId, payload);

        logger.info('Transfer notification result', {
            transferGuid,
            recipientId: transactionData.recipientId,
            ...result,
        });
    } catch (error) {
        logger.error('Error processing transfer notification', { error, message });
    }
}
</file>

<file path="lambdas/notifications/saveDeviceToken.ts">
import { DynamoDBClient, UpdateItemCommand, GetItemCommand } from '@aws-sdk/client-dynamodb';
import { marshall, unmarshall } from '@aws-sdk/util-dynamodb';
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { DYNAMO_TABLES } from 'commons';

const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });

// Interface for device metadata
interface DeviceMetadata {
    deviceName?: string;
    brand?: string;
    modelName?: string;
    modelId?: string;
    osName?: string;
    osVersion?: string;
    osBuildId?: string;
    platformApiLevel?: number;
    totalMemory?: number;
    appVersion?: string;
    deviceYearClass?: number;
    deviceType?: number;
    manufacturer?: string;
}

/**
 * Lambda handler that saves a device token to a user's preferences in the entities table
 * @param event - API Gateway event containing userId and deviceToken
 * @returns API Gateway response
 */
export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    try {
        const userId = event.requestContext.authorizer?.userId;

        if (!userId) {
            return {
                statusCode: 401,
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message: 'Unauthorized',
                }),
            };
        }

        // Parse request body
        const body = JSON.parse(event.body || '{}');
        const { deviceToken, platform = 'expo', deviceMetadata = {} } = body;

        console.log('Saving device token:', deviceToken, platform);
        console.log('Device metadata:', deviceMetadata);

        if (!deviceToken) {
            return {
                statusCode: 400,
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message: 'Missing required fields: deviceToken',
                }),
            };
        }

        // Update user entity with device token and metadata
        await updateUserDeviceToken(userId, deviceToken, platform, deviceMetadata);

        return {
            statusCode: 200,
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                message: 'Device token saved successfully',
                userId,
            }),
        };
    } catch (error) {
        console.error('Error saving device token:', error);
        return {
            statusCode: 500,
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                message: 'Internal server error',
                error: (error as Error).message,
            }),
        };
    }
};

/**
 * Updates the user entity with the provided device token and metadata
 * @param userId - The ID of the user entity to update
 * @param deviceToken - The device token to save
 * @param platform - The platform of the device (expo, ios, android, etc.)
 * @param deviceMetadata - Additional device information
 */
async function updateUserDeviceToken(
    userId: string,
    deviceToken: string,
    platform: string,
    deviceMetadata: DeviceMetadata = {},
): Promise<void> {
    try {
        // First, check if the user already has preferences
        const getParams = {
            TableName: DYNAMO_TABLES.ENTITIES,
            Key: marshall({ entityId: userId }),
            ProjectionExpression: 'preferences',
        };

        const userResult = await dynamoClient.send(new GetItemCommand(getParams));
        const hasPreferences = userResult.Item && userResult.Item.preferences;

        // Initialize the device tokens array
        let existingTokens: any[] = [];

        if (hasPreferences) {
            const userData = unmarshall(userResult.Item!);
            if (userData.preferences && userData.preferences.deviceTokens) {
                // Filter out tokens with the same platform - we'll replace them
                existingTokens = userData.preferences.deviceTokens.filter((item: any) => item.platform !== platform);
                console.log(`Filtered out existing tokens for platform ${platform}`);
            }
        }

        // Add the new token with metadata
        existingTokens.push({
            token: deviceToken,
            platform: platform,
            updatedAt: new Date().toISOString(),
            deviceMetadata: deviceMetadata || {},
        });

        console.log(`Adding token ${deviceToken} for platform ${platform} with metadata`);

        // Create update parameters based on whether preferences exists
        let updateParams;
        if (hasPreferences) {
            // Update with the filtered and new token list
            updateParams = {
                TableName: DYNAMO_TABLES.ENTITIES,
                Key: marshall({ entityId: userId }),
                UpdateExpression: 'SET preferences.deviceTokens = :tokens',
                ExpressionAttributeValues: marshall({
                    ':tokens': existingTokens,
                }),
            };
        } else {
            // If preferences doesn't exist, create the whole structure
            updateParams = {
                TableName: DYNAMO_TABLES.ENTITIES,
                Key: marshall({ entityId: userId }),
                UpdateExpression: 'SET preferences = :preferences',
                ExpressionAttributeValues: marshall({
                    ':preferences': {
                        deviceTokens: existingTokens,
                    },
                }),
            };
        }

        await dynamoClient.send(new UpdateItemCommand(updateParams));
        console.log(`Successfully updated device token for user ${userId}`);
    } catch (error) {
        console.error(`Error updating device token for user ${userId}:`, error);
        throw error;
    }
}
</file>

<file path="lambdas/notifications/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/notifications/user-notifications.ts">
import { type SQSEvent } from 'aws-lambda';
import { EmailService, logger } from 'commons';
// Initialize with your template registry
const emailService = new EmailService({
    WELCOME_EMAIL: {
        subject: 'Welcome to CLKK',
        html: '<h1>Welcome {{name}}!</h1>',
        text: 'Welcome {{name}}!',
    },
});

export const handler = async (event: SQSEvent): Promise<void> => {
    logger.info('Processing SQS message', { event });

    for (const record of event.Records) {
        try {
            // Parse the SNS message from SQS
            const snsMessage = JSON.parse(record.body);
            // Parse the actual message content
            const messageData = JSON.parse(snsMessage.Message);
            logger.info('MessageData', messageData);

            // Extract email from the clerk data structure
            const userEmail = messageData.data.email_addresses[0]?.email_address;
            const userName = `${messageData.data.first_name} ${messageData.data.last_name}`.trim();

            if (!userEmail) {
                logger.error('No email address found in message', { messageId: record.messageId });
            }

            logger.info('Sending welcome email', { userEmail, userName });

            await emailService.sendEmail(
                'WELCOME_EMAIL',
                {
                    to: userEmail,
                    from: process.env.EMAIL_FROM_ADDRESS || '',
                },
                { name: userName },
            );

            logger.info('Notification sent', { messageId: record.messageId, userEmail });
        } catch (error) {
            logger.error('Notification failed', { error, messageId: record.messageId });
            throw error;
        }
    }
};
</file>

<file path="lambdas/plaid/data/app.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { DynamoDB, type GetItemCommandOutput } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { DYNAMO_TABLES } from 'commons';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';

// --- Types ---

interface UserClaims {
    sub: string; // Assuming 'sub' is the user ID
    [key: string]: any; // Allow other claims
}

interface PlaidData {
    metadata: {
        accounts: {
            id: string;
            mask: string;
            name: string;
            subtype: string;
            type: string;
            verificationStatus?: string;
        }[];
        institution: {
            id: string;
            name: string;
        };
        linkSessionId: string;
        metadataJson: string; // You might want to parse this into a more specific type later
    };
}

interface UserItem {
    userId: string;
    email?: string;
    firstName?: string;
    lastName?: string;
    username?: string;
    imageUrl?: string;
    profileImageUrl?: string;
    plaid?: PlaidData;
    createdAt?: string;
    updatedAt?: string;
    // Add other fields as needed from your USERS table
}

interface BankAccount {
    account_id: string;
    name: string;
    type: string;
    subtype: string;
    mask: string;
}

interface BankData {
    accounts: BankAccount[];
    institution: {
        institution_id: string;
        name: string;
    };
}

interface UserProfile {
    userId: string;
    email?: string;
    firstName?: string;
    lastName?: string;
    username?: string;
    imageUrl?: string;
    profileImageUrl?: string;
    bankData?: BankData;
    createdAt?: string;
    updatedAt?: string;
}

// --- Logger ---
const logger = new Logger({ 
    logLevel: 'INFO',
    serviceName: 'plaid-user-data' 
});

// --- DynamoDB ---
const dynamoDb = DynamoDBDocument.from(new DynamoDB({}));

// Request/Response types
export interface GetPlaidDataRequest {
    // No body params needed, userId comes from auth context
}

export interface GetPlaidDataResponse {
    user: UserProfile;
}

// --- Lambda Handler ---
export const getUserProfile = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'PlaidGetUserProfile';
    
    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });

    // Step 1: Extract and validate user ID
    const userId = event.requestContext.authorizer?.userId;

    logger.info(`[${functionName}] Step 1: Extracting user ID from authorizer`, {
        requestId,
        userIdFound: !!userId,
        authorizerContext: event.requestContext.authorizer,
    });

    if (!userId) {
        logger.error(`[${functionName}] Authorization failed - User ID not found`, {
            requestId,
            authorizerContext: event.requestContext.authorizer,
        });
        return {
            statusCode: 401,
            body: JSON.stringify({ message: 'Unauthorized' }),
        };
    }

    try {
        // Step 2: Get user data from DynamoDB
        logger.info(`[${functionName}] Step 2: Retrieving user data from DynamoDB`, {
            requestId,
            userId,
        });
        
        const dbStartTime = Date.now();
        const userData = await getUserData(userId, requestId, functionName);
        const dbLatency = Date.now() - dbStartTime;
        
        logger.info(`[${functionName}] User data retrieved successfully`, {
            requestId,
            userId,
            hasPlaidData: !!userData.plaid,
            dbLatencyMs: dbLatency,
        });

        // Step 3: Build the user profile
        logger.info(`[${functionName}] Step 3: Building user profile`, {
            requestId,
            userId,
            hasPlaidMetadata: !!userData.plaid?.metadata,
        });
        
        const userProfile = buildUserProfile(userData, requestId, functionName);
        
        logger.info(`[${functionName}] User profile built successfully`, {
            requestId,
            userId,
            hasBankData: !!userProfile.bankData,
            accountsCount: userProfile.bankData?.accounts?.length || 0,
            totalExecutionTime: Date.now() - startTime,
        });

        return {
            statusCode: 200,
            body: JSON.stringify(userProfile),
        };
    } catch (error: any) {
        const errorDetails = {
            requestId,
            userId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            totalExecutionTime: Date.now() - startTime,
        };
        
        logger.error(`[${functionName}] Error fetching user data`, errorDetails);

        // Return appropriate status code based on error
        const statusCode = error.message === 'User not found' ? 404 : 500;
        
        return {
            statusCode,
            body: JSON.stringify({ 
                message: error.message === 'User not found' ? 'User not found' : 'Failed to fetch user data' 
            }),
        };
    }
};

// --- Helper Functions ---

const getUserData = async (userId: string, requestId: string, functionName: string): Promise<UserItem> => {
    const keys = SingleTableKeys.user(userId);
    
    logger.debug(`[${functionName}] DynamoDB GetItem parameters`, {
        requestId,
        tableName: SINGLE_TABLE_NAME,
        keys,
    });
    
    const { Item }: GetItemCommandOutput = await dynamoDb.get({
        TableName: SINGLE_TABLE_NAME,
        Key: keys,
    });

    if (!Item) {
        logger.warn(`[${functionName}] User not found in DynamoDB`, {
            requestId,
            userId,
        });
        throw new Error('User not found');
    }
    
    logger.debug(`[${functionName}] User item retrieved`, {
        requestId,
        userId,
        hasEmail: !!Item.email,
        hasPlaidData: !!Item.plaid,
    });

    return Item as unknown as UserItem;
};

const buildUserProfile = (userData: UserItem, requestId: string, functionName: string): UserProfile => {
    logger.debug(`[${functionName}] Extracting bank data`, {
        requestId,
        userId: userData.userId,
        hasPlaidData: !!userData.plaid,
    });
    
    const bankData = extractBankData(userData, requestId, functionName);

    // Construct the user profile object, including only the necessary fields
    const userProfile: UserProfile = {
        userId: userData.userId,
        email: userData.email,
        firstName: userData.firstName,
        lastName: userData.lastName,
        username: userData.username,
        imageUrl: userData.imageUrl,
        profileImageUrl: userData.profileImageUrl,
        createdAt: userData.createdAt,
        updatedAt: userData.updatedAt,
        ...(bankData && { bankData }), // Include bankData only if it exists
    };
    
    logger.debug(`[${functionName}] User profile constructed`, {
        requestId,
        userId: userData.userId,
        profileFields: Object.keys(userProfile),
        hasBankData: !!userProfile.bankData,
    });

    return userProfile;
};

const extractBankData = (userData: UserItem, requestId: string, functionName: string): BankData | undefined => {
    if (!userData.plaid) {
        logger.debug(`[${functionName}] No Plaid data found for user`, {
            requestId,
            userId: userData.userId,
        });
        return undefined;
    }

    const { accounts, institution } = userData.plaid.metadata;
    
    logger.debug(`[${functionName}] Extracting bank data from Plaid metadata`, {
        requestId,
        userId: userData.userId,
        accountsCount: accounts?.length || 0,
        institutionName: institution?.name,
        institutionId: institution?.id,
    });

    const formattedAccounts: BankAccount[] = accounts.map((account, index) => {
        logger.debug(`[${functionName}] Processing account ${index + 1}`, {
            requestId,
            accountType: account.type,
            accountSubtype: account.subtype,
            accountMask: account.mask,
        });
        
        return {
            account_id: account.id,
            name: account.name,
            type: account.type,
            subtype: account.subtype,
            mask: account.mask,
        };
    });

    const bankData: BankData = {
        accounts: formattedAccounts,
        institution: {
            institution_id: institution.id,
            name: institution.name,
        },
    };
    
    logger.debug(`[${functionName}] Bank data extraction completed`, {
        requestId,
        userId: userData.userId,
        totalAccounts: formattedAccounts.length,
    });
    
    return bankData;
};
</file>

<file path="lambdas/plaid/identity/app.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';

import { PlaidService } from '../services/plaidService';
import { type CustomerDetails } from '../types';

const logger = new Logger({ serviceName: 'plaid-account-details' });
const plaidService = new PlaidService();

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    logger.info('Incoming request', { event });

    const accountId = event.pathParameters?.account_id;

    if (!accountId) {
        logger.warn('Missing account_id in path parameters');
        return createErrorResponse(400, 'Missing account_id in path parameters');
    }

    try {
        const customerDetails: CustomerDetails = await plaidService.getAccountDetails(accountId);

        logger.info('Successfully fetched customer details from Plaid', {
            customerDetails,
        });

        return {
            statusCode: 200,
            body: JSON.stringify({
                success: true,
                message: 'Successfully fetched customer details from Plaid',
                data: customerDetails,
            }),
        };
    } catch (error) {
        logger.error('Error fetching customer details from Plaid', { error });
        return createErrorResponse(500, 'Failed to fetch customer details from Plaid');
    }
};

const createErrorResponse = (statusCode: number, message: string): APIGatewayProxyResult => {
    return {
        statusCode,
        body: JSON.stringify({
            success: false,
            message,
        }),
    };
};
</file>

<file path="lambdas/plaid/services/plaidService.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { plaidClient } from '../utils/plaid';
import { CustomerDetails } from '../types';
import { PlaidApi } from 'plaid';

const logger = new Logger({ serviceName: 'plaid-service' });

export class PlaidService {
    async getAccountDetails(accessToken: string): Promise<CustomerDetails> {
        try {
            // Await the shared Plaid client which has been properly initialized using secrets.
            const client: PlaidApi = await plaidClient;

            const response = await client.accountsGet({ access_token: accessToken });

            if (!response.data || !response.data.accounts || response.data.accounts.length === 0) {
                logger.error('No accounts found for the given access token', {
                    accessToken,
                });
                throw new Error('No accounts found for the given access token');
            }

            // Fetch identity data
            const identityResponse = await client.identityGet({ access_token: accessToken });

            if (
                !identityResponse.data ||
                !identityResponse.data.accounts ||
                identityResponse.data.accounts.length === 0
            ) {
                logger.error('No identity data found for the given access token', {
                    accessToken,
                });
                throw new Error('No identity data found for the given access token');
            }

            const identity = identityResponse.data.accounts[0];
            const owner = identity.owners[0];

            const address = owner.addresses[0].data;
            const phoneNumber = owner.phone_numbers[0].data;
            const emailAddress = owner.emails[0].data;
            const name = owner.names[0];

            const customerDetails: CustomerDetails = {
                name: {
                    first: name.split(' ')[0] || '',
                    last: name.split(' ')[1] || '',
                    full: name,
                },
                address: {
                    street: address.street || '',
                    city: address.city || '',
                    subdivision: address.region || '',
                    postal_code: address.postal_code || '',
                    country_code: address.country || '',
                },
                email_address: emailAddress,
                phone_number: phoneNumber,
            };

            return customerDetails;
        } catch (error: any) {
            logger.error('Error calling Plaid API', { error });
            throw error;
        }
    }
}
</file>

<file path="lambdas/plaid/types/index.ts">
export interface Name {
  first: string;
  last: string;
  full: string;
}

export interface Address {
  street: string;
  city: string;
  subdivision: string;
  postal_code: string;
  country_code: string;
}

export interface IdentificationNumber {
  type: string;
  issuing_country_code: string;
  identification_number: string;
}

export interface CustomerDetails {
  name: Name;
  address: Address;
  email_address: string;
  phone_number: string;
}
</file>

<file path="lambdas/plaid/utils/auth.ts">
import { Logger } from "@aws-lambda-powertools/logger";
import {
  SecretsManagerClient,
  GetSecretValueCommand,
} from "@aws-sdk/client-secrets-manager";
import axios from "axios";

const logger = new Logger({
  serviceName: "cybrid-auth",
  logLevel: "INFO",
});

const secretsClient = new SecretsManagerClient({
  region: process.env.AWS_REGION,
});

interface Secret {
  client_id: string;
  client_secret: string;
}

export const getToken = async (): Promise<string> => {
  const secretName = process.env.CYBRID_SECRET_NAME;
  if (!secretName) {
    logger.error("CYBRID_SECRET_NAME environment variable not set.");
    throw new Error("Failed to get Cybrid client credentials");
  }

  try {
    // Fetch the secret
    const command = new GetSecretValueCommand({ SecretId: secretName });
    const data = await secretsClient.send(command);
    logger.info("Cybrid secret response", { response: data }); // Log the entire response for debugging

    if (!data.SecretString) {
      logger.error("Cybrid secret value is empty or not a string.");
      throw new Error("Failed to get Cybrid client credentials");
    }

    const secret: Secret = JSON.parse(data.SecretString);

    // Validate the secret structure
    if (!secret.client_id || !secret.client_secret) {
      logger.error("Cybrid secret is missing client_id or client_secret.");
      throw new Error("Failed to get Cybrid client credentials");
    }

    const authUrl = `${process.env.CYBRID_URL_SCHEME}://id.${process.env.CYBRID_BASE_URL}/oauth/token`;
    const scopes = [
      "accounts:read",
      "accounts:execute",
      "banks:read",
      "banks:write",
      "customers:read",
      "customers:write",
      "customers:execute",
      "identity_verifications:read",
      "identity_verifications:execute",
      "prices:read",
      "quotes:read",
      "quotes:execute",
      "trades:read",
      "trades:execute",
      "transfers:read",
      "transfers:execute",
      "external_wallets:read",
      "external_wallets:execute",
      "external_bank_accounts:execute",
    ];

    // Prepare request for token
    const requestData = {
      grant_type: "client_credentials",
      client_id: secret.client_id,
      client_secret: secret.client_secret,
      scope: scopes.join(" "),
    };

    const config = {
      headers: {
        "Content-Type": "application/json",
      },
    };

    // Make the request to get a new token
    logger.info("Requesting access token from Cybrid", { authUrl });
    const response = await axios.post(authUrl, requestData, config);

    logger.info("Successfully obtained access token from Cybrid.");

    return response.data.access_token;
  } catch (error) {
    logger.error("Error retrieving or using Cybrid secret", { error });
    throw new Error("Failed to get Cybrid authentication token");
  }
};
</file>

<file path="lambdas/plaid/utils/config.ts">
export const Config = {
    URL_SCHEME: process.env.CYBRID_URL_SCHEME || 'https',
    BASE_URL: process.env.CYBRID_BASE_URL || 'api.cybrid.dev',
    TIMEOUT: 30000, // 30 seconds
} as const;
</file>

<file path="lambdas/plaid/utils/constants.ts">
export const AWS_SECRETS = {
  CLERK: {
    SECRET_NAME: "clerk-secrets",
    KEYS: {
      WEBHOOK_SECRET: "webhookSecret",
    },
  },
  CYBRID: {
    SECRET_NAME: "cybrid-secrets",
    KEYS: {
      SIGNING_KEY: "signingKey",
    },
  },
  PLAID: {
    SECRET_NAME: "plaid-secrets",
    KEYS: {
      CLIENT_ID: "clientId",
      SECRET: "secret",
    },
  },
} as const;

export const DYNAMO_TABLES = {
  USERS: "Users",
  IDENTITY_VERIFICATIONS: "IdentityVerifications",
  FIAT_ACCOUNTS: "FiatAccounts",
  PLAID_ACCESS_TOKENS: "PlaidAccessToken",
} as const;

export const PERSONA = {
  BASE_URL: "https://withpersona.com/verify?inquiry-id=",
} as const;
</file>

<file path="lambdas/plaid/utils/getSecret.ts">
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'secrets-manager' });
const secretsManager = new SecretsManagerClient({ region: process.env.AWS_REGION });

interface SecretError extends Error {
    code?: string;
}

export async function getSecret(secretName: string, key: string): Promise<string> {
    try {
        logger.debug('Fetching secret', { secretName, key });

        const command = new GetSecretValueCommand({
            SecretId: secretName,
            VersionStage: 'AWSCURRENT',
        });

        const response = await secretsManager.send(command);

        if (!response.SecretString) {
            throw new Error(`Secret ${secretName} not found`);
        }

        const secretObject = JSON.parse(response.SecretString);
        logger.debug('Secret fetched successfully', { secretObject });

        if (!(key in secretObject)) {
            throw new Error(`Key ${key} not found in secret ${secretName}`);
        }

        logger.debug('Secret fetched successfully');
        return secretObject[key];
    } catch (error) {
        const secretError = error as SecretError;

        // Handle specific AWS errors
        if (secretError.code === 'DecryptionFailureException') {
            logger.error('Could not decrypt the secret', { secretName, error: secretError });
            throw new Error('Secret decryption failed');
        }

        if (secretError.code === 'ResourceNotFoundException') {
            logger.error('Secret not found', { secretName, error: secretError });
            throw new Error(`Secret ${secretName} not found`);
        }

        if (secretError.code === 'InvalidParameterException') {
            logger.error('Invalid parameter provided', { secretName, error: secretError });
            throw new Error('Invalid parameter provided to Secrets Manager');
        }

        // Log any other unexpected errors
        logger.error('Error fetching secret', {
            secretName,
            errorMessage: secretError.message,
            errorCode: secretError.code,
        });

        throw new Error('Failed to fetch secret');
    }
}
</file>

<file path="lambdas/plaid/utils/plaid.ts">
import { Configuration, PlaidApi, PlaidEnvironments } from 'plaid';
import { SecretsManager } from '@aws-sdk/client-secrets-manager';
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({
    serviceName: 'plaid-client',
    logLevel: process.env.LOG_LEVEL || 'INFO',
});

const secretsManager = new SecretsManager({});

const getPlaidSecret = async () => {
    try {
        //Log environment variables
        logger.debug('Environment variables', {
            PLAID_CLIENT_ID: process.env.PLAID_CLIENT_ID,
            PLAID_SECRET: process.env.PLAID_SECRET,
            PLAID_ENV: process.env.PLAID_ENV,
        });
        logger.debug('Fetching Plaid secrets from Secrets Manager', {
            secretId: process.env.PLAID_SECRET,
        });

        const secret = await secretsManager.getSecretValue({
            SecretId: process.env.PLAID_SECRET,
        });

        logger.info('Successfully retrieved Plaid secrets', {
            secretArn: secret.ARN,
            createdDate: secret.CreatedDate,
        });

        return JSON.parse(secret.SecretString || '{}');
    } catch (error) {
        logger.error('Failed to retrieve Plaid secrets', {
            error: error instanceof Error ? error.message : 'Unknown error',
            stack: error instanceof Error ? error.stack : undefined,
        });
        throw new Error('Plaid secret configuration error');
    }
};

const initPlaidClient = async () => {
    try {
        const secrets = await getPlaidSecret();
        logger.info('Secrets', { secrets });

        //log secrets.clientID

        logger.debug('Initializing Plaid client configuration', {
            env: secrets.PLAID_ENV,
            clientId: secrets.clientId ? '***' : 'MISSING',
            secret: secrets.secret ? '***' : 'MISSING',
        });

        const config = new Configuration({
            basePath: PlaidEnvironments[secrets.PLAID_ENV] || PlaidEnvironments.sandbox,
            baseOptions: {
                headers: {
                    'PLAID-CLIENT-ID': secrets.clientId,
                    'PLAID-SECRET': secrets.secret,
                    'Plaid-Version': '2020-09-14',
                },
            },
        });

        logger.info('Plaid client initialized successfully', {
            environment: secrets.PLAID_ENV,
            apiBasePath: config.basePath,
            sdkVersion: PlaidEnvironments.sandbox, // Version is same across all envs
        });

        return new PlaidApi(config);
    } catch (error) {
        logger.error('Plaid client initialization failed', {
            error: error instanceof Error ? error.message : 'Unknown error',
            stack: error instanceof Error ? error.stack : undefined,
        });
        throw error;
    }
};

export const plaidClient = initPlaidClient();
</file>

<file path="lambdas/plaid/utils/single-table-keys.ts">
/**
 * Helper functions for generating keys for the single table design
 */

export const SingleTableKeys = {
    // User/Entity keys
    user: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PROFILE`,
    }),

    // Cybrid Fiat Account keys
    cybridFiatAccount: (userId: string, accountId: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_FIAT#${accountId}`,
    }),

    // Cybrid Identity Verification keys
    cybridIdentityVerification: (userId: string, verificationId: string, timestamp: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_KYC#${timestamp}#${verificationId}`,
    }),

    // Plaid Access Token keys
    plaidAccessToken: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PLAID_TOKEN`,
    }),

    // Transaction keys
    transaction: (userId: string, timestamp: string, transactionId: string) => ({
        PK: `USER#${userId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Transaction keys for business accounts
    businessTransaction: (businessId: string, timestamp: string, transactionId: string) => ({
        PK: `BUSINESS#${businessId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Query patterns for GSIs
    gsiKeys: {
        // For querying by Cybrid customer ID (using ExternalIdIndex)
        byCybridCustomerId: (customerId: string) => ({
            ExternalIdKey: `CYBRID_CUSTOMER#${customerId}`,
            ProviderIdKey: 'CYBRID',
        }),

        // For querying fiat accounts by customer ID
        fiatAccountByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_FIAT_ACCOUNT',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For KYC status queries
        byKycStatus: (status: string, userId: string) => ({
            KYCStatusKey: `STATUS#${status}`,
            EntityTypeIdKey: `USER#${userId}`,
        }),

        // For identity verifications by customer ID
        identityVerificationByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_IDENTITY_VERIFICATION',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For transaction lookups by ID
        transactionById: (transactionId: string) => ({
            TransactionIdKey: `TXN#${transactionId}`,
        }),

        // For querying transactions by sender
        transactionsBySender: (senderId: string) => ({
            SenderIdKey: `SENDER#${senderId}`,
        }),

        // For querying transactions by recipient
        transactionsByRecipient: (recipientId: string) => ({
            RecipientIdKey: `RECIPIENT#${recipientId}`,
        }),
    },
};

// Single table name constant
export const SINGLE_TABLE_NAME = process.env.SINGLE_TABLE_NAME || 'clkk-app-table-dev';
</file>

<file path="lambdas/plaid/verificationStatus/app.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { DYNAMO_TABLES } from 'commons';
import { dynamoDB } from 'commons';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';

//TODO:Add gsi and improve search
const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'plaid-verification-status',
});

interface VerificationRecord {
    identityVerificationId: string;
    customerId: string;
    userId: string;
    personaInquiryId: string;
    personaUrl: string;
    status: string;
    createdAt: string;
    updatedAt?: string;
    source: string; // Changed from verificationType to match database field
    outcome?: string;
    failure_codes?: string[];
    metadata?: {
        plaidAccessToken?: string;
        plaidAccountId?: string;
        plaidInstitutionId?: string;
    };
}

// Request/Response types
export interface GetVerificationStatusRequest {
    // No body params needed, userId comes from auth context
}

export interface GetVerificationStatusResponse {
    verificationId: string;
    status: string;
    bankName?: string;
    accountMask?: string;
    accountId?: string;
    verificationType: string;
    createdAt: string;
    metadata?: {
        plaidAccessToken?: string;
        plaidAccountId?: string;
        plaidInstitutionId?: string;
    };
}

export const getVerificationStatus = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'PlaidGetVerificationStatus';

    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });

    // Step 1: Extract and validate user ID
    const userId = event.requestContext.authorizer?.userId;

    logger.info(`[${functionName}] Step 1: Extracting user ID from authorizer`, {
        requestId,
        userIdFound: !!userId,
        authorizerContext: event.requestContext.authorizer,
    });

    if (!userId) {
        logger.error(`[${functionName}] Authorization failed - User ID not found`, {
            requestId,
            authorizerContext: event.requestContext.authorizer,
        });
        return {
            statusCode: 401,
            body: JSON.stringify({ message: 'Unauthorized' }),
        };
    }

    try {
        // Step 2: Query identity verifications for this user
        logger.info(`[${functionName}] Step 2: Querying identity verifications from DynamoDB`, {
            requestId,
            userId,
            tableName: SINGLE_TABLE_NAME,
            verificationType: 'plaid',
        });

        const params = {
            TableName: SINGLE_TABLE_NAME,
            KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
            FilterExpression: '#source = :source',
            ExpressionAttributeNames: {
                '#source': 'source',
            },
            ExpressionAttributeValues: {
                ':pk': `USER#${userId}`,
                ':skPrefix': 'CYBRID_KYC#',
                ':source': 'plaid',
            },
            ScanIndexForward: false, // Get latest first
            Limit: 1,
        };

        logger.debug(`[${functionName}] DynamoDB Query parameters`, {
            requestId,
            params,
        });

        const queryStartTime = Date.now();
        const queryResponse = await dynamoDB.query(params);
        const queryLatency = Date.now() - queryStartTime;

        logger.info(`[${functionName}] DynamoDB query completed`, {
            requestId,
            queryLatencyMs: queryLatency,
            itemsFound: queryResponse.Items?.length || 0,
            scannedCount: queryResponse.ScannedCount || 0,
        });

        // Convert DynamoDB response to array of items
        const items = Object.values(queryResponse).filter(
            (item) => item && typeof item === 'object' && !Array.isArray(item),
        );

        logger.debug(`[${functionName}] Processed verification items`, {
            requestId,
            processedItemCount: items.length,
        });

        if (items.length === 0) {
            logger.warn(`[${functionName}] No verification record found for user`, {
                requestId,
                userId,
                queryFound: 0,
                totalExecutionTime: Date.now() - startTime,
            });
            return {
                statusCode: 404,
                body: JSON.stringify({
                    message: 'No verification record found',
                    details: {
                        userId,
                        queryFound: 0,
                    },
                }),
            };
        }

        // Step 3: Process and return verification record
        logger.info(`[${functionName}] Step 3: Processing verification record`, {
            requestId,
            userId,
        });

        const verificationRecord = items[0] as VerificationRecord;

        logger.info(`[${functionName}] Verification record found`, {
            requestId,
            userId,
            verificationId: verificationRecord.identityVerificationId,
            status: verificationRecord.status,
            verificationType: verificationRecord.verificationType,
            customerId: verificationRecord.customerId,
            hasPersonaUrl: !!verificationRecord.personaUrl,
            hasMetadata: !!verificationRecord.metadata,
            createdAt: verificationRecord.createdAt,
        });

        const response: GetVerificationStatusResponse = {
            verificationId: verificationRecord.identityVerificationId,
            status: verificationRecord.status,
            verificationType: verificationRecord.source || 'plaid', // Map source to verificationType for backward compatibility
            createdAt: verificationRecord.createdAt,
            metadata: verificationRecord.metadata,
        };

        logger.info(`[${functionName}] Verification status retrieved successfully`, {
            requestId,
            userId,
            verificationStatus: response.status,
            totalExecutionTime: Date.now() - startTime,
        });

        return {
            statusCode: 200,
            body: JSON.stringify({
                status: verificationRecord.status,
                personaUrl: verificationRecord.personaUrl,
                metadata: verificationRecord.metadata,
                createdAt: verificationRecord.createdAt,
                updatedAt: verificationRecord.updatedAt,
                identityVerificationId: verificationRecord.identityVerificationId,
                verificationType: verificationRecord.source || 'plaid', // Map source to verificationType for backward compatibility
                customerId: verificationRecord.customerId,
                outcome: verificationRecord.outcome || null,
                failureReason: verificationRecord.failure_codes || null,
            }),
        };
    } catch (error: any) {
        const errorDetails = {
            requestId,
            userId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            dynamoError: error.name === 'ResourceNotFoundException' ? 'Table not found' : undefined,
            totalExecutionTime: Date.now() - startTime,
        };

        logger.error(`[${functionName}] Error fetching verification status`, errorDetails);

        return {
            statusCode: 500,
            body: JSON.stringify({
                message: 'Failed to fetch verification status',
                details: error instanceof Error ? error.message : 'Unknown error',
            }),
        };
    }
};
</file>

<file path="lambdas/plaid/app.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { Lambda } from '@aws-sdk/client-lambda';
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import axios from 'axios';
import { DateUtil, DYNAMO_TABLES, responseBuilder } from 'commons';
import { dynamoDB } from 'commons';
import { type Entity } from 'commons/types/users/entities.i';
import { CountryCode, DepositoryAccountSubtype, Products } from 'plaid';
import { SingleTableKeys, SINGLE_TABLE_NAME } from './utils/single-table-keys';

import { PlaidService } from './services/plaidService';
import { getToken } from './utils/auth';
import { Config } from './utils/config';
import { PERSONA } from './utils/constants';
import { plaidClient } from './utils/plaid';
export enum IdentityVerificationSource {
    PLAID = 'plaid',
    CYBRID = 'cybrid',
}

export interface IdentityVerificationRecord {
    identityVerificationId: string;
    customerId: string;
    userId: string;
    personaInquiryId: string;
    personaUrl: string;
    status: string;
    createdAt: string;
    source: IdentityVerificationSource;
    metadata?: {
        plaidAccessToken?: string;
        plaidAccountId?: string;
        plaidInstitutionId?: string;
        [key: string]: any;
    };
}

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'plaid-api',
});

// No longer using separate PLAID_ACCESS_TOKENS table - will use single table
const lambda = new Lambda({});
const plaidService = new PlaidService();

// Request/Response types
export interface CreateLinkTokenRequest {
    // No body params needed, userId comes from auth context
}

export interface CreateLinkTokenResponse {
    link_token: string;
    expiration: string;
}

export const createLinkToken = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'PlaidCreateLinkToken';

    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });

    // Step 1: Validate environment configuration
    logger.info(`[${functionName}] Step 1: Validating environment configuration`, {
        requestId,
        hasPlaidSecretName: !!process.env.PLAID_SECRET_NAME,
        hasPlaidClientId: !!process.env.PLAID_CLIENT_ID,
        plaidEnv: process.env.PLAID_ENV,
    });

    // Step 2: Extract and validate user ID
    const userId = event.requestContext.authorizer?.userId;

    logger.info(`[${functionName}] Step 2: Extracting user ID from authorizer`, {
        requestId,
        userIdFound: !!userId,
        authorizerContext: event.requestContext.authorizer,
    });

    if (!userId) {
        logger.error(`[${functionName}] Authorization failed - User ID not found`, {
            requestId,
            authorizerContext: event.requestContext.authorizer,
        });
        return {
            statusCode: 401,
            body: JSON.stringify({ message: 'Unauthorized' }),
        };
    }

    try {
        // Step 3: Create link token with Plaid
        logger.info(`[${functionName}] Step 3: Creating link token with Plaid`, {
            requestId,
            userId,
        });

        const client = await plaidClient;

        const linkTokenConfig = {
            user: {
                client_user_id: userId,
            },
            client_name: 'CLKK',
            products: [Products.Auth],
            country_codes: [CountryCode.Us],
            language: 'en',
            redirect_uri: 'http://localhost:3000',
            account_filters: {
                depository: {
                    account_subtypes: [DepositoryAccountSubtype.Checking],
                },
            },
        };

        logger.debug(`[${functionName}] Link token configuration`, {
            requestId,
            config: {
                ...linkTokenConfig,
                redirect_uri: 'REDACTED', // Don't log redirect URI
            },
        });

        const plaidStartTime = Date.now();
        const createTokenResponse = await client.linkTokenCreate(linkTokenConfig);
        const plaidLatency = Date.now() - plaidStartTime;

        logger.info(`[${functionName}] Link token created successfully`, {
            requestId,
            userId,
            linkTokenExpiration: createTokenResponse.data.expiration,
            plaidRequestId: createTokenResponse.data.request_id,
            plaidLatencyMs: plaidLatency,
        });

        // Step 4: Return success response
        const response: CreateLinkTokenResponse = {
            link_token: createTokenResponse.data.link_token,
            expiration: createTokenResponse.data.expiration,
        };

        logger.info(`[${functionName}] Link token creation completed`, {
            requestId,
            userId,
            totalExecutionTime: Date.now() - startTime,
        });

        return {
            statusCode: 200,
            body: JSON.stringify(response),
        };
    } catch (error: any) {
        const errorDetails = {
            requestId,
            userId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            plaidErrorCode: error.response?.data?.error_code,
            plaidErrorType: error.response?.data?.error_type,
            plaidErrorMessage: error.response?.data?.error_message,
            plaidDisplayMessage: error.response?.data?.display_message,
            plaidRequestId: error.response?.data?.request_id,
            httpStatus: error.response?.status,
            totalExecutionTime: Date.now() - startTime,
        };

        logger.error(`[${functionName}] Error creating Link token`, errorDetails);

        // Determine appropriate status code
        const statusCode = error.response?.status || 500;

        return {
            statusCode,
            body: JSON.stringify({
                error: 'Failed to create Link token',
                details: error.response?.data || 'Unknown error',
            }),
        };
    }
};

// Exchange Public Token types
export interface ExchangePublicTokenRequest {
    public_token: string;
    linkSuccessMetadata?: any;
}

export interface ExchangePublicTokenResponse {
    message: string;
    data?: {
        identityRecord: IdentityVerificationRecord;
        userRecord: Entity;
    };
}

export const exchangePublicToken = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'PlaidExchangePublicToken';

    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });

    // Step 1: Parse and validate request body
    logger.info(`[${functionName}] Step 1: Parsing request body`, {
        requestId,
    });

    let requestBody: any;
    try {
        requestBody = JSON.parse(event.body || '{}');
        logger.debug(`[${functionName}] Request body parsed successfully`, {
            requestId,
            hasPublicToken: !!requestBody.public_token,
            hasLinkSuccessMetadata: !!requestBody.linkSuccessMetadata,
        });
    } catch (error) {
        logger.error(`[${functionName}] Failed to parse request body`, {
            requestId,
            error: error instanceof Error ? error.message : 'Unknown error',
            body: event.body,
        });
        return {
            statusCode: 400,
            body: JSON.stringify({ message: 'Invalid request body' }),
        };
    }

    const { public_token, linkSuccessMetadata } = requestBody;

    logger.info(`[${functionName}] Link success metadata`, {
        requestId,
        institutionName: linkSuccessMetadata?.institution?.name,
        institutionId: linkSuccessMetadata?.institution?.id,
        accountsCount: linkSuccessMetadata?.accounts?.length || 0,
    });

    // Step 2: Extract and validate user ID
    const userId = event.requestContext.authorizer?.userId;

    logger.info(`[${functionName}] Step 2: Extracting user ID from authorizer`, {
        requestId,
        userIdFound: !!userId,
        authorizerContext: event.requestContext.authorizer,
    });

    if (!public_token) {
        logger.error(`[${functionName}] Missing public_token in request`, {
            requestId,
            requestBody,
        });
        return {
            statusCode: 400,
            body: JSON.stringify({ message: 'Missing public_token' }),
        };
    }

    if (!userId) {
        logger.error(`[${functionName}] Authorization failed - User ID not found`, {
            requestId,
            authorizerContext: event.requestContext.authorizer,
        });
        return {
            statusCode: 401,
            body: JSON.stringify({ message: 'Unauthorized' }),
        };
    }

    try {
        // Step 3: Exchange public token for access token
        logger.info(`[${functionName}] Step 3: Exchanging public token with Plaid`, {
            requestId,
            userId,
        });

        const plaidStartTime = Date.now();
        const exchangeResponse = await (
            await plaidClient
        ).itemPublicTokenExchange({
            public_token: public_token,
        });
        const plaidLatency = Date.now() - plaidStartTime;

        logger.info(`[${functionName}] Public token exchanged successfully`, {
            requestId,
            userId,
            plaidRequestId: exchangeResponse.data.request_id,
            plaidLatencyMs: plaidLatency,
        });

        const accessToken = exchangeResponse.data.access_token;

        // Step 4: Get User Record from DynamoDB using single table
        logger.info(`[${functionName}] Step 4: Retrieving user record from DynamoDB`, {
            requestId,
            userId,
            tableName: SINGLE_TABLE_NAME,
        });

        const userKeys = SingleTableKeys.user(userId);
        const getParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
        };

        logger.debug(`[${functionName}] DynamoDB GetItem parameters`, {
            requestId,
            params: getParams,
        });

        const dbStartTime = Date.now();
        const userRecord = (await dynamoDB.get(getParams)) as Entity | null;
        const dbLatency = Date.now() - dbStartTime;

        logger.info(`[${functionName}] User record retrieval completed`, {
            requestId,
            userId,
            recordFound: !!userRecord,
            latencyMs: dbLatency,
        });

        if (!userRecord) {
            logger.error(`[${functionName}] User record not found`, {
                requestId,
                userId,
            });
            return responseBuilder('User record not found', 404);
        }

        logger.info(`[${functionName}] User record details`, {
            requestId,
            userId,
            userEmail: userRecord.email,
            hasMetadata: !!userRecord.metadata,
            hasCybridMetadata: !!userRecord.metadata?.cybrid,
        });

        // Handle both old format (metadata.cybrid.customerId) and new format (metadata.cybrid with customerId as string)
        const cybridMetadata = userRecord.metadata?.cybrid;
        const cybridId = typeof cybridMetadata === 'string' ? cybridMetadata : cybridMetadata?.customerId;

        if (!cybridId) {
            logger.error(`[${functionName}] Cybrid customer ID not found for user`, {
                requestId,
                userId,
                metadata: userRecord.metadata,
                cybridMetadata: cybridMetadata,
                metadataType: typeof cybridMetadata,
            });
            return {
                statusCode: 400,
                body: JSON.stringify({ message: 'cybridId not found' }),
            };
        }

        // Step 5: Update DynamoDB with access token and metadata
        logger.info(`[${functionName}] Step 5: Preparing DynamoDB transaction`, {
            requestId,
            userId,
            cybridId,
        });

        const plaidTokenKeys = SingleTableKeys.plaidAccessToken(userId);
        const transactionItems = [
            {
                Put: {
                    TableName: SINGLE_TABLE_NAME,
                    Item: {
                        ...plaidTokenKeys,
                        accessToken: accessToken,
                        userId: userId,
                        createdAt: DateUtil.now(),
                        updatedAt: DateUtil.now(),
                    },
                },
            },
            {
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: userKeys,
                    UpdateExpression: 'SET #plaid = :plaidLinkMetadata, updatedAt = :updatedAt',
                    ExpressionAttributeNames: {
                        '#plaid': 'plaid',
                    },
                    ExpressionAttributeValues: {
                        ':plaidLinkMetadata': { metadata: linkSuccessMetadata },
                        ':updatedAt': DateUtil.now(),
                    },
                },
            },
        ];

        const transactStartTime = Date.now();
        await dynamoDB.transactWrite({ TransactItems: transactionItems as any });
        const transactLatency = Date.now() - transactStartTime;

        logger.info(`[${functionName}] DynamoDB transaction completed successfully`, {
            requestId,
            userId,
            transactionLatencyMs: transactLatency,
        });

        // Step 6: Prepare external bank account data
        logger.info(`[${functionName}] Step 6: Preparing external bank account data`, {
            requestId,
            userId,
            accountName: linkSuccessMetadata.accounts[0].name,
            accountMask: linkSuccessMetadata.accounts[0].mask,
            institutionId: linkSuccessMetadata.institution.id,
        });

        const externalBankAccountData = {
            account_kind: 'plaid_processor_token',
            name: linkSuccessMetadata.accounts[0].name,
            customer_guid: cybridId,
            asset: 'USD',
            plaid_institution_id: linkSuccessMetadata.institution.id,
            plaid_account_mask: linkSuccessMetadata.accounts[0].mask,
            plaid_account_name: linkSuccessMetadata.accounts[0].name,
            plaid_processor_token: accessToken,
        };

        logger.debug(`[${functionName}] External bank account data prepared`, {
            requestId,
            externalBankAccountData: {
                ...externalBankAccountData,
                plaid_processor_token: 'REDACTED', // Don't log sensitive token
            },
        });

        // Step 7: Invoke external bank account creation Lambda
        logger.info(`[${functionName}] Step 7: Invoking external bank account creation Lambda`, {
            requestId,
            userId,
            cybridId,
            functionName: process.env.CREATE_EXTERNAL_BANK_ACCOUNT_FUNCTION_NAME,
        });

        const lambdaPayload = {
            body: JSON.stringify({ userId, externalBankAccountData }),
        };

        const lambdaStartTime = Date.now();
        const lambdaResponse = await lambda.invoke({
            FunctionName: process.env.CREATE_EXTERNAL_BANK_ACCOUNT_FUNCTION_NAME!,
            InvocationType: 'RequestResponse',
            Payload: JSON.stringify(lambdaPayload),
        });
        const lambdaLatency = Date.now() - lambdaStartTime;

        const payload = JSON.parse(Buffer.from(lambdaResponse.Payload || '').toString());

        logger.info(`[${functionName}] External bank account Lambda response`, {
            requestId,
            statusCode: payload.statusCode,
            lambdaLatencyMs: lambdaLatency,
            externalAccountCreated: payload.statusCode < 400,
        });

        if (payload.statusCode >= 400) {
            logger.error(`[${functionName}] Failed to create external bank account`, {
                requestId,
                userId,
                lambdaStatusCode: payload.statusCode,
                lambdaErrorBody: payload.body,
            });
            throw new Error(`Failed to create external bank account: ${payload.body}`);
        }

        // Parse the response body to get the external account GUID
        const externalAccountResponse = JSON.parse(payload.body || '{}');
        const externalAccountGuid = externalAccountResponse.externalAccountGuid;

        logger.info(`[${functionName}] External bank account created`, {
            requestId,
            userId,
            externalAccountGuid,
            hasGuid: !!externalAccountGuid,
        });

        // Step 8: Create bank account identity verification
        logger.info(`[${functionName}] Step 8: Creating bank account identity verification`, {
            requestId,
            userId,
            cybridId,
        });

        const idvStartTime = Date.now();
        const identityVerificationResponse = await createBankAccountIdentityVerification(
            userId,
            accessToken,
            cybridId,
            externalAccountGuid,
        );
        const idvLatency = Date.now() - idvStartTime;

        logger.info(`[${functionName}] Identity verification completed`, {
            requestId,
            userId,
            verificationId: identityVerificationResponse?.identityVerificationId,
            personaUrl: identityVerificationResponse?.personaUrl,
            idvLatencyMs: idvLatency,
        });

        const totalExecutionTime = Date.now() - startTime;

        logger.info(`[${functionName}] Public token exchange completed successfully`, {
            requestId,
            userId,
            totalExecutionTimeMs: totalExecutionTime,
            hasPersonaUrl: !!identityVerificationResponse?.personaUrl,
            verificationStatus: identityVerificationResponse?.status,
        });

        return {
            statusCode: 200,
            body: JSON.stringify({
                success: true,
                message: 'Bank account linked successfully',
                identityVerificationResponse,
            }),
        };
    } catch (error: any) {
        const errorDetails = {
            requestId,
            userId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            plaidErrorCode: error.response?.data?.error_code,
            plaidErrorType: error.response?.data?.error_type,
            totalExecutionTime: Date.now() - startTime,
        };

        logger.error(`[${functionName}] Error processing public token exchange`, errorDetails);

        return {
            statusCode: 500,
            body: JSON.stringify({
                message: 'Failed to process transaction',
                error: error instanceof Error ? error.message : 'Unknown error',
            }),
        };
    }
};

const createBankAccountIdentityVerification = async (
    userId: string,
    accessToken: string,
    cybridId: string,
    externalAccountGuid?: string,
) => {
    try {
        // 1. Fetch user details from Plaid Identity API
        const plaidIdentity = await plaidService.getAccountDetails(accessToken);
        logger.info('Plaid Identity', { plaidIdentity });

        // 2. Get user data from DynamoDB for Cybrid data (with ConsistentRead to ensure latest data)
        const userKeys = SingleTableKeys.user(userId);
        const userParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: userKeys,
            ConsistentRead: true, // Ensure we get the latest data after external account creation
        };

        logger.info('Fetching user record with params', {
            userId,
            tableName: SINGLE_TABLE_NAME,
            keys: userKeys,
        });

        const userData = (await dynamoDB.get(userParams)) as Entity | null;

        logger.info('DynamoDB response for user', {
            userId,
            hasItem: !!userData,
            itemKeys: userData ? Object.keys(userData) : [],
        });

        if (!userData) {
            logger.error('User record not found', {
                userId,
                userKeys,
                tableName: SINGLE_TABLE_NAME,
            });
            throw new Error('User record not found');
        }

        // Extract user info from userInfo field if main fields are not populated
        const userInfoData = userData?.userInfo || {};
        const firstName = userData?.firstName || userInfoData?.firstName || '';
        const lastName = userData?.lastName || userInfoData?.lastName || '';
        let phoneNumber = userData?.phoneNumber || userInfoData?.phoneNumber || '';
        
        // Ensure phone number has country code for Cybrid
        if (phoneNumber && !phoneNumber.startsWith('+')) {
            // If it's a 10-digit US number, add +1
            if (phoneNumber.length === 10 || (phoneNumber.length === 11 && phoneNumber.startsWith('1'))) {
                phoneNumber = phoneNumber.length === 10 ? `+1${phoneNumber}` : `+${phoneNumber}`;
            }
        }
        
        const dob = userData?.dob || userData?.date_of_birth || userInfoData?.dob || '';
        const identificationNumbers = userData?.identificationNumbers || userInfoData?.identificationNumbers || [];
        
        logger.info('User data retrieved', {
            userId,
            hasMetadata: !!userData?.metadata,
            metadataKeys: userData?.metadata ? Object.keys(userData.metadata) : [],
            hasFirstName: !!firstName,
            hasLastName: !!lastName,
            hasDob: !!dob,
            hasEmail: !!userData?.email,
            hasAddress: !!userData?.address,
            hasUserInfo: !!userData?.userInfo,
            userInfoKeys: userData?.userInfo ? Object.keys(userData.userInfo) : [],
        });

        // Handle both old format (userData.metadata.cybrid) and new format (userData.metadata with direct cybrid properties)
        const cybridMetadata = userData?.metadata?.cybrid || userData?.metadata;
        if (!cybridMetadata || (!cybridMetadata.customerId && !cybridMetadata.cybrid?.customerId)) {
            logger.error('User Cybrid metadata not found', {
                userId,
                hasMetadata: !!userData?.metadata,
                metadataKeys: userData?.metadata ? Object.keys(userData.metadata) : [],
                metadata: userData?.metadata,
            });
            throw new Error('User Cybrid data not found');
        }

        logger.info('User Cybrid data', {
            cybridMetadata: cybridMetadata,
            hasExternalAccount: !!cybridMetadata?.externalAccount,
            externalAccountGuid: cybridMetadata?.externalAccount?.guid,
            hasCustomerId: !!cybridMetadata?.customerId || !!cybridMetadata?.cybrid?.customerId,
            customerId: cybridMetadata?.customerId || cybridMetadata?.cybrid?.customerId,
        });

        // 3. Create identity verification
        const cybridToken = await getToken();
        const identityVerificationsApiUrl = `${Config.URL_SCHEME}://bank.${Config.BASE_URL}/api/identity_verifications`;

        // Get the actual cybrid customer ID from metadata
        const actualCybridId = cybridMetadata?.customerId || cybridMetadata?.cybrid?.customerId || cybridId;

        // Get the external account GUID
        const finalExternalAccountGuid = externalAccountGuid || cybridMetadata?.externalAccount?.guid;

        if (!finalExternalAccountGuid) {
            logger.error('External bank account GUID not found', {
                userId,
                passedGuid: externalAccountGuid,
                metadataGuid: cybridMetadata?.externalAccount?.guid,
                cybridMetadata: cybridMetadata,
            });
            throw new Error('External bank account GUID not found');
        }

        // Log the data we're about to use
        logger.info('Building identity verification data', {
            userId,
            userFirstName: firstName,
            userLastName: lastName,
            userDob: dob,
            userEmail: userData.email,
            userAddress: userData.address,
            plaidAddress: plaidIdentity.address,
            plaidEmail: plaidIdentity.email_address,
            plaidPhoneNumber: plaidIdentity.phone_number,
            phoneNumber,
            cybridId,
            finalExternalAccountGuid,
            hasIdentificationNumbers: identificationNumbers.length > 0,
        });

        // Use userData fields from Cybrid customer data (stored during KYC) for name, DOB, and identification
        // Use plaidIdentity fields for address and email
        const identityVerificationData = {
            type: 'bank_account',
            method: 'attested_ownership',
            name: {
                first: firstName,
                last: lastName,
                full: `${firstName} ${lastName}`.trim(),
            },
            address: {
                street: plaidIdentity.address.street,
                city: plaidIdentity.address.city,
                subdivision: plaidIdentity.address.subdivision,
                postal_code: plaidIdentity.address.postal_code,
                country_code: plaidIdentity.address.country_code,
            },
            customer_guid: actualCybridId,
            country_code: plaidIdentity.address.country_code,
            date_of_birth: dob,
            phone_number: phoneNumber,
            identification_numbers: identificationNumbers,
            email_address: plaidIdentity.email_address || '',
            external_bank_account_guid: finalExternalAccountGuid,
        };

        logger.info('Identity verification data prepared', {
            identityVerificationData,
            hasName: !!identityVerificationData.name.first && !!identityVerificationData.name.last,
            hasAddress: !!identityVerificationData.address.street,
            hasDob: !!identityVerificationData.date_of_birth,
            hasEmail: !!identityVerificationData.email_address,
            hasIdentificationNumbers: identityVerificationData.identification_numbers.length > 0,
        });
        //
        try {
            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
            };

            const response = await axios.post(identityVerificationsApiUrl, identityVerificationData, { headers });

            logger.info('Identity verification created:', {
                response: response.data,
            });

            console.log('[IDENTITY VERIFICATION RESPONSE states ]', response.data.state, response.data.outcome);
            // Check if verification passed automatically
            if (response.data.state === 'completed' && response.data.outcome === 'passed') {
                logger.info('Identity verification passed automatically', {
                    verificationId: response.data.guid,
                    outcome: response.data.outcome,
                });

                const now = new Date().toISOString();

                // Create Identity Verification record with source and metadata
                const identityVerificationRecord: IdentityVerificationRecord = {
                    identityVerificationId: response.data.guid,
                    customerId: actualCybridId,
                    userId,
                    personaInquiryId: '',
                    personaUrl: '',
                    status: response.data.state,
                    createdAt: now,
                    source: IdentityVerificationSource.PLAID,
                    metadata: {
                        plaidAccessToken: accessToken,
                        plaidAccountId: userData.plaid?.metadata?.accounts[0]?.id,
                        plaidInstitutionId: userData.plaid?.metadata?.institution?.id,
                        outcome: response.data.outcome,
                        compliance_checks: response.data.compliance_checks,
                        compliance_decisions: response.data.compliance_decisions,
                        failure_codes: response.data.failure_codes,
                    },
                };

                // Store identity verification in single table
                const verificationKeys = SingleTableKeys.cybridIdentityVerification(userId, response.data.guid, now);
                await dynamoDB.put({
                    TableName: SINGLE_TABLE_NAME,
                    Item: {
                        ...verificationKeys,
                        ...identityVerificationRecord,
                    },
                    ConditionExpression: 'attribute_not_exists(PK)',
                });

                return {
                    personaInquiryId: '',
                    personaUrl: '',
                    identityVerificationId: response.data.guid,
                    status: 'completed',
                    outcome: 'passed',
                };
            }

            // Only poll if not already completed and passed
            if (response.data.state !== 'completed') {
                const personaInquiryId = await pollForPersonaInquiryId(response.data.guid);
                logger.info('Persona inquiry ID received:', { personaInquiryId });

                const personaUrl = `${PERSONA.BASE_URL}${personaInquiryId}`;
                const now = new Date().toISOString();

                // Create Identity Verification record with source and metadata
                const identityVerificationRecord: IdentityVerificationRecord = {
                    identityVerificationId: response.data.guid,
                    customerId: actualCybridId,
                    userId,
                    personaInquiryId,
                    personaUrl,
                    status: response.data.state,
                    createdAt: now,
                    source: IdentityVerificationSource.PLAID,
                    metadata: {
                        plaidAccessToken: accessToken,
                        plaidAccountId: userData.plaid?.metadata?.accounts[0]?.id,
                        plaidInstitutionId: userData.plaid?.metadata?.institution?.id,
                    },
                };

                logger.info('Identity verification record', { identityVerificationRecord });

                // Store identity verification in single table
                const verificationKeys = SingleTableKeys.cybridIdentityVerification(userId, response.data.guid, now);
                await dynamoDB.put({
                    TableName: SINGLE_TABLE_NAME,
                    Item: {
                        ...verificationKeys,
                        ...identityVerificationRecord,
                    },
                    ConditionExpression: 'attribute_not_exists(PK)',
                });

                logger.info('Successfully created identity verification record for PLAID', {
                    identityVerificationId: response.data.guid,
                    source: IdentityVerificationSource.PLAID,
                });

                return {
                    personaInquiryId: personaInquiryId || '',
                    personaUrl,
                    identityVerificationId: response.data.guid,
                };
            }
        } catch (error) {
            if (axios.isAxiosError(error)) {
                logger.error('Cybrid identity verification API error:', {
                    status: error.response?.status,
                    statusText: error.response?.statusText,
                    data: error.response?.data,
                    url: identityVerificationsApiUrl,
                    requestData: identityVerificationData,
                });
                throw new Error(
                    `Failed to create identity verification: ${error.response?.data?.message || error.message}`,
                );
            }
            throw error;
        }
    } catch (error) {
        logger.error('Error in createBankAccountIdentityVerification:', { error });
        throw error;
    }
};

// Add the polling function
async function pollForPersonaInquiryId(identityVerificationGuid: string): Promise<string | null> {
    const cybridToken = await getToken();
    const identityVerificationApiUrl = `${Config.URL_SCHEME}://bank.${Config.BASE_URL}/api/identity_verifications/${identityVerificationGuid}`;

    const headers = {
        Authorization: `Bearer ${cybridToken}`,
        'Content-Type': 'application/json',
    };

    return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 6;
        const pollInterval = 4000;

        const pollingInterval = setInterval(async () => {
            attempts++;
            logger.info('Polling for Persona Inquiry ID', {
                attempt: attempts,
                maxAttempts,
                identityVerificationGuid,
            });

            try {
                const response = await axios.get(identityVerificationApiUrl, {
                    headers,
                    timeout: 3000,
                });

                logger.info('Identity verification response', {
                    response: response.data,
                });

                // If verification is completed and passed, resolve with null
                if (response.data.state === 'completed' && response.data.outcome === 'passed') {
                    clearInterval(pollingInterval);
                    logger.info('Verification completed and passed, no Persona ID needed', {
                        attempts,
                        verificationId: identityVerificationGuid,
                    });
                    resolve(null);
                    return;
                }

                if (response.data.persona_inquiry_id) {
                    clearInterval(pollingInterval);
                    logger.info('Persona Inquiry ID found', {
                        attempts,
                        personaInquiryId: response.data.persona_inquiry_id,
                    });
                    resolve(response.data.persona_inquiry_id);
                    return;
                }

                if (attempts >= maxAttempts) {
                    clearInterval(pollingInterval);
                    const error = new Error('Max polling attempts reached');
                    logger.error('Polling timeout', { attempts, error });
                    reject(error);
                }
            } catch (error) {
                clearInterval(pollingInterval);
                logger.error('Error polling for Persona Inquiry ID:', {
                    attempts,
                    error,
                    identityVerificationGuid,
                });
                reject(error);
            }
        }, pollInterval);
    });
}

export const deleteAccount = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'PlaidDeleteAccount';

    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });

    // Step 1: Extract and validate user ID
    const userId = event.requestContext.authorizer?.userId;

    logger.info(`[${functionName}] Step 1: Extracting user ID from authorizer`, {
        requestId,
        userIdFound: !!userId,
        authorizerContext: event.requestContext.authorizer,
    });

    if (!userId) {
        logger.error(`[${functionName}] Authorization failed - User ID not found`, {
            requestId,
            authorizerContext: event.requestContext.authorizer,
        });
        return {
            statusCode: 401,
            body: JSON.stringify({ message: 'Unauthorized' }),
        };
    }

    try {
        // Step 2: Get access token from DynamoDB
        logger.info(`[${functionName}] Step 2: Retrieving Plaid access token from DynamoDB`, {
            requestId,
            userId,
            tableName: SINGLE_TABLE_NAME,
        });

        const plaidTokenKeys = SingleTableKeys.plaidAccessToken(userId);
        const getParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: plaidTokenKeys,
        };

        logger.debug(`[${functionName}] DynamoDB GetItem parameters`, {
            requestId,
            params: getParams,
        });

        const dbStartTime = Date.now();
        const Item = await dynamoDB.get(getParams);
        const dbLatency = Date.now() - dbStartTime;

        logger.info(`[${functionName}] Access token retrieval completed`, {
            requestId,
            userId,
            hasToken: !!Item?.access_token,
            latencyMs: dbLatency,
        });

        // Step 3: Query identity verification records
        logger.info(`[${functionName}] Step 3: Querying identity verification records`, {
            requestId,
            userId,
        });

        const identityVerificationParams = {
            TableName: SINGLE_TABLE_NAME,
            KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
            FilterExpression: '#source = :source',
            ExpressionAttributeNames: {
                '#source': 'source',
            },
            ExpressionAttributeValues: {
                ':pk': `USER#${userId}`,
                ':skPrefix': 'CYBRID_KYC#',
                ':source': IdentityVerificationSource.PLAID,
            },
        };

        logger.debug(`[${functionName}] Identity verification query parameters`, {
            requestId,
            params: identityVerificationParams,
        });

        const queryStartTime = Date.now();
        const identityVerifications = (await dynamoDB.query(identityVerificationParams)) as any;
        const queryLatency = Date.now() - queryStartTime;

        logger.info(`[${functionName}] Identity verification query completed`, {
            requestId,
            userId,
            recordsFound: identityVerifications.Items?.length || 0,
            queryLatencyMs: queryLatency,
        });

        // Step 4: Prepare transaction items for cleanup
        logger.info(`[${functionName}] Step 4: Preparing DynamoDB transaction for cleanup`, {
            requestId,
            userId,
        });

        const userKeys = SingleTableKeys.user(userId);
        const plaidAccessTokenKeys = SingleTableKeys.plaidAccessToken(userId);
        const transactionItems = [
            {
                Delete: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: plaidAccessTokenKeys,
                },
            },
            {
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: userKeys,
                    UpdateExpression: 'REMOVE #plaid',
                    ExpressionAttributeNames: {
                        '#plaid': 'plaid',
                    },
                },
            },
        ];

        logger.debug(`[${functionName}] Base transaction items prepared`, {
            requestId,
            itemCount: transactionItems.length,
        });

        // Step 5: Add identity verification deletion if found
        if (identityVerifications && identityVerifications.Items && identityVerifications.Items[0]) {
            const verificationRecord = identityVerifications.Items[0];

            logger.info(`[${functionName}] Step 5: Adding identity verification deletion to transaction`, {
                requestId,
                userId,
                verificationId: verificationRecord.identityVerificationId,
                verificationStatus: verificationRecord.status,
            });

            // Need to construct the full single table key for deletion
            const verificationSK =
                verificationRecord.SK ||
                `CYBRID_KYC#${verificationRecord.createdAt}#${verificationRecord.identityVerificationId}`;
            transactionItems.push({
                Delete: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: {
                        PK: `USER#${userId}`,
                        SK: verificationSK,
                    },
                },
            });

            logger.debug(`[${functionName}] Identity verification deletion added`, {
                requestId,
                verificationKey: { PK: `USER#${userId}`, SK: verificationSK },
            });
        } else {
            logger.info(`[${functionName}] Step 5: No identity verification records to delete`, {
                requestId,
                userId,
            });
        }

        // Step 6: Remove item from Plaid if access token exists
        if (Item?.access_token) {
            logger.info(`[${functionName}] Step 6: Removing item from Plaid`, {
                requestId,
                userId,
            });

            try {
                const plaidStartTime = Date.now();
                await (
                    await plaidClient
                ).itemRemove({
                    access_token: Item.access_token,
                });
                const plaidLatency = Date.now() - plaidStartTime;

                logger.info(`[${functionName}] Successfully removed Plaid item`, {
                    requestId,
                    userId,
                    plaidLatencyMs: plaidLatency,
                });
            } catch (plaidError: any) {
                logger.error(`[${functionName}] Error removing Plaid item (non-critical)`, {
                    requestId,
                    userId,
                    errorType: plaidError.constructor.name,
                    errorMessage: plaidError.message,
                    plaidErrorCode: plaidError.response?.data?.error_code,
                    plaidErrorType: plaidError.response?.data?.error_type,
                });
                // Continue with deletion even if Plaid removal fails
            }
        } else {
            logger.info(`[${functionName}] Step 6: No Plaid item to remove (no access token)`, {
                requestId,
                userId,
            });
        }

        // Step 7: Execute cleanup transaction
        logger.info(`[${functionName}] Step 7: Executing DynamoDB cleanup transaction`, {
            requestId,
            userId,
            transactionItemCount: transactionItems.length,
        });

        const transactStartTime = Date.now();
        await dynamoDB.transactWrite({ TransactItems: transactionItems });
        const transactLatency = Date.now() - transactStartTime;

        logger.info(`[${functionName}] Cleanup transaction completed successfully`, {
            requestId,
            userId,
            transactionLatencyMs: transactLatency,
            deletedItems: transactionItems.map((item) => {
                if ('Delete' in item) return 'PlaidAccessToken or IdentityVerification';
                if ('Update' in item) return 'UserPlaidMetadata';
                return 'Unknown';
            }),
        });

        const successResponse = {
            message: 'Account and all related data deleted successfully',
            details: {
                plaidItemRemoved: !!Item?.access_token,
                identityVerificationRemoved: !!identityVerifications.Items?.[0],
                localDataCleaned: true,
            },
        };

        logger.info(`[${functionName}] Account deletion completed successfully`, {
            requestId,
            userId,
            plaidItemRemoved: successResponse.details.plaidItemRemoved,
            identityVerificationRemoved: successResponse.details.identityVerificationRemoved,
            totalExecutionTime: Date.now() - startTime,
        });

        return {
            statusCode: 200,
            body: JSON.stringify(successResponse),
        };
    } catch (error: any) {
        const errorDetails = {
            requestId,
            userId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            dynamoError: error.name === 'TransactionCanceledException' ? error.CancellationReasons : undefined,
            totalExecutionTime: Date.now() - startTime,
        };

        logger.error(`[${functionName}] Error during account deletion`, errorDetails);

        return {
            statusCode: 500,
            body: JSON.stringify({
                error: 'Failed to delete account',
                details: error instanceof Error ? error.message : 'Unknown error',
            }),
        };
    }
};

export const getBalance = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const startTime = Date.now();
    const requestId = event.requestContext?.requestId || 'unknown';
    const functionName = 'PlaidGetBalance';

    logger.info(`[${functionName}] Lambda invoked`, {
        requestId,
        path: event.path,
        httpMethod: event.httpMethod,
        sourceIp: event.requestContext?.identity?.sourceIp,
        userAgent: event.requestContext?.identity?.userAgent,
    });

    // Step 1: Extract and validate user ID
    const userId = event.requestContext.authorizer?.userId;

    logger.info(`[${functionName}] Step 1: Extracting user ID from authorizer`, {
        requestId,
        userIdFound: !!userId,
        authorizerContext: event.requestContext.authorizer,
    });

    if (!userId) {
        logger.error(`[${functionName}] Authorization failed - User ID not found`, {
            requestId,
            authorizerContext: event.requestContext.authorizer,
        });
        return {
            statusCode: 401,
            body: JSON.stringify({ message: 'Unauthorized' }),
        };
    }

    try {
        // Step 2: Retrieve Plaid access token from DynamoDB
        logger.info(`[${functionName}] Step 2: Retrieving Plaid access token from DynamoDB`, {
            requestId,
            userId,
            tableName: SINGLE_TABLE_NAME,
        });

        const plaidTokenKeys = SingleTableKeys.plaidAccessToken(userId);
        const getParams = {
            TableName: SINGLE_TABLE_NAME,
            Key: plaidTokenKeys,
        };

        logger.debug(`[${functionName}] DynamoDB GetItem parameters`, {
            requestId,
            params: getParams,
        });

        const dbStartTime = Date.now();
        const Item = await dynamoDB.get(getParams);
        const dbLatency = Date.now() - dbStartTime;

        logger.info(`[${functionName}] Access token retrieval completed`, {
            requestId,
            userId,
            tokenFound: !!Item?.access_token,
            latencyMs: dbLatency,
        });

        if (!Item || !Item.access_token) {
            logger.warn(`[${functionName}] Access token not found for user`, {
                requestId,
                userId,
                itemFound: !!Item,
            });
            return {
                statusCode: 404,
                body: JSON.stringify({
                    message: 'Access token not found for this user',
                }),
            };
        }

        // Step 3: Fetch balance from Plaid
        logger.info(`[${functionName}] Step 3: Fetching balance from Plaid`, {
            requestId,
            userId,
        });

        const plaidStartTime = Date.now();
        const balanceResponse = await (
            await plaidClient
        ).accountsBalanceGet({
            access_token: Item.access_token,
        });
        const plaidLatency = Date.now() - plaidStartTime;

        logger.info(`[${functionName}] Balance retrieved successfully`, {
            requestId,
            userId,
            accountCount: balanceResponse.data.accounts.length,
            plaidRequestId: balanceResponse.data.request_id,
            plaidLatencyMs: plaidLatency,
            totalExecutionTime: Date.now() - startTime,
        });

        // Log account details without sensitive info
        balanceResponse.data.accounts.forEach((account, index) => {
            logger.debug(`[${functionName}] Account ${index + 1} details`, {
                requestId,
                accountName: account.name,
                accountType: account.type,
                accountSubtype: account.subtype,
                balanceAvailable: account.balances.available,
                balanceCurrent: account.balances.current,
                currency: account.balances.iso_currency_code,
            });
        });

        return {
            statusCode: 200,
            body: JSON.stringify({ Balance: balanceResponse.data }),
        };
    } catch (error: any) {
        const errorDetails = {
            requestId,
            userId,
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            plaidErrorCode: error.response?.data?.error_code,
            plaidErrorType: error.response?.data?.error_type,
            plaidErrorMessage: error.response?.data?.error_message,
            httpStatus: error.response?.status,
            totalExecutionTime: Date.now() - startTime,
        };

        logger.error(`[${functionName}] Error fetching balance`, errorDetails);

        return {
            statusCode: error.response?.status || 500,
            body: JSON.stringify({ error: 'Failed to fetch balance' }),
        };
    }
};
</file>

<file path="lambdas/plaid/package.json">
{
  "name": "plaid",
  "version": "1.0.0",
  "description": "plaid lambda",
  "main": "app.js",
  "author": "CLKK",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^2.11.0",
    "@aws-sdk/client-dynamodb": "^3.705.0",
    "@aws-sdk/client-lambda": "^3.716.0",
    "@aws-sdk/client-secrets-manager": "^3.699.0",
    "@aws-sdk/client-sqs": "^3.716.0",
    "@aws-sdk/lib-dynamodb": "^3.705.0",
    "@cybrid/cybrid-api-bank-typescript": "^0.123.122",
    "axios": "^1.7.9",
    "esbuild": "^0.14.14",
    "jsonwebtoken": "^9.0.2",
    "plaid": "^30.0.0",
    "svix": "^1.43.0"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "@types/aws-lambda": "^8.10.146",
    "@types/jest": "^29.2.0",
    "@types/node": "^18.11.4",
    "@typescript-eslint/eslint-plugin": "^5.10.2",
    "@typescript-eslint/parser": "^5.10.2",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.2.1",
    "prettier": "^2.5.1",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
</file>

<file path="lambdas/plaid/tsconfig.json">
{
    "compilerOptions": {
      "target": "es2020",
      "strict": true,
      "preserveConstEnums": true,
      "noEmit": true,
      "sourceMap": false,
      "module":"es2015",
      "moduleResolution":"node",
      "esModuleInterop": true, 
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,  
    },
    "exclude": ["node_modules", "**/*.test.ts"]
  }
</file>

<file path="lambdas/prove/handlers/identity.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { ProveIdentityService } from '../services/ProveIdentityService';
import { KmsService } from '../../../layers/commons/services/KmsService';
import { createLogger } from '../../../layers/commons/utils/logger_v2';
import { kmsKeyId } from '../../../layers/commons/utils/variables';
import { validateRequest } from '../validators/request-validator';
import {
    v3StartRequestSchema,
    v3ValidateRequestSchema,
    v3ChallengeRequestSchema,
    v3CompleteRequestSchema,
} from '../validators/schemas';

// HTTP Status Codes
enum StatusCodes {
    OK = 200,
    BAD_REQUEST = 400,
    INTERNAL_SERVER_ERROR = 500,
}

const logger = createLogger('ProveIdentityHandlers');

// Initialize services
const kmsService = new KmsService(kmsKeyId);
const proveIdentityService = new ProveIdentityService(kmsService);

/**
 * Parse JSON body with error handling
 * @param body - Request body as string
 * @returns Parsed body object or null if invalid
 */
const parseBody = (body: string | null): any => {
    if (!body) return null;

    try {
        return JSON.parse(body);
    } catch (error) {
        logger.error('Error parsing request body', error);
        return null;
    }
};

/**
 * Build a standardized Lambda response
 * @param statusCode - HTTP status code
 * @param body - Response body object
 * @returns Formatted API Gateway response
 */
const buildResponse = (statusCode: number, body: any): APIGatewayProxyResult => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type,Authorization',
            'Access-Control-Allow-Methods': 'OPTIONS,POST,GET',
        },
        body: JSON.stringify(body),
    };
};

/**
 * Echo endpoint handler for health checks
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const echoHandler = async (event: APIGatewayProxyEvent, context: Context): Promise<APIGatewayProxyResult> => {
    logger.info('Echo endpoint called', { requestId: context.awsRequestId });

    try {
        const result = await proveIdentityService.getEchoEndpoint();
        return buildResponse(StatusCodes.OK, result);
    } catch (error) {
        logger.error('Error in echo endpoint', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, { error: 'Internal server error' });
    }
};

/**
 * Start verification handler
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const startHandler = async (event: APIGatewayProxyEvent, context: Context): Promise<APIGatewayProxyResult> => {
    logger.info('Start verification called', { requestId: context.awsRequestId });

    try {
        const body = parseBody(event.body);
        if (!body) {
            return buildResponse(StatusCodes.BAD_REQUEST, { error: 'Invalid request body' });
        }

        // Validate request
        const { errors, isValid } = validateRequest(body, v3StartRequestSchema);
        if (!isValid) {
            return buildResponse(StatusCodes.BAD_REQUEST, { success: false, error_type: 'ValidationError', errors });
        }

        const { phoneNumber, last4SSN, flowType, finalTargetUrl } = body;
        logger.info('Starting verification', {
            phoneNumber: phoneNumber.slice(-2),
            flowType,
            finalTargetUrl,
        });

        const response = await proveIdentityService.startVerification(phoneNumber, last4SSN, flowType, finalTargetUrl);

        return buildResponse(StatusCodes.OK, response);
    } catch (error) {
        logger.error('Error in start verification', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, { error: 'Internal server error' });
    }
};

/**
 * Validate verification handler
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const validateHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Validate verification called', { requestId: context.awsRequestId });

    try {
        const body = parseBody(event.body);
        if (!body) {
            return buildResponse(StatusCodes.BAD_REQUEST, { error: 'Invalid request body' });
        }

        // Validate request
        const { errors, isValid } = validateRequest(body, v3ValidateRequestSchema);
        if (!isValid) {
            return buildResponse(StatusCodes.BAD_REQUEST, { success: false, error_type: 'ValidationError', errors });
        }

        const { correlationId } = body;
        logger.info('Validating verification', { correlationId });

        const response = await proveIdentityService.validateVerification(correlationId);

        return buildResponse(StatusCodes.OK, response);
    } catch (error) {
        logger.error('Error in validate verification', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, { error: 'Internal server error' });
    }
};

/**
 * Challenge request handler
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const challengeHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Challenge request called', { requestId: context.awsRequestId });

    try {
        const body = parseBody(event.body);
        if (!body) {
            return buildResponse(StatusCodes.BAD_REQUEST, { error: 'Invalid request body' });
        }

        // Validate request
        const { errors, isValid } = validateRequest(body, v3ChallengeRequestSchema);
        if (!isValid) {
            return buildResponse(StatusCodes.BAD_REQUEST, { success: false, error_type: 'ValidationError', errors });
        }

        const { correlationId, dob, last4SSN } = body;
        logger.info('Processing challenge request', { correlationId });

        const response = await proveIdentityService.processChallengeRequest(correlationId, dob, last4SSN);

        return buildResponse(StatusCodes.OK, response);
    } catch (error) {
        logger.error('Error in challenge request', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, { error: 'Internal server error' });
    }
};

/**
 * Complete verification handler
 * @param event - API Gateway event
 * @param context - Lambda context
 * @returns API Gateway response
 */
export const completeHandler = async (
    event: APIGatewayProxyEvent,
    context: Context,
): Promise<APIGatewayProxyResult> => {
    logger.info('Complete verification called', { requestId: context.awsRequestId });

    try {
        const body = parseBody(event.body);
        if (!body) {
            return buildResponse(StatusCodes.BAD_REQUEST, { error: 'Invalid request body' });
        }

        // Validate request
        const { errors, isValid } = validateRequest(body, v3CompleteRequestSchema);
        if (!isValid) {
            return buildResponse(StatusCodes.BAD_REQUEST, { success: false, error_type: 'ValidationError', errors });
        }

        // Additional userId validation
        const { individual, correlationId, userId } = body;
        if (!userId || typeof userId !== 'string' || userId.trim() === '') {
            return buildResponse(StatusCodes.BAD_REQUEST, { success: false, error: 'Invalid or missing userId' });
        }

        logger.info('Completing verification', { correlationId, userId });

        const response = await proveIdentityService.completeVerification(individual, correlationId, userId);

        return buildResponse(StatusCodes.OK, response);
    } catch (error) {
        logger.error('Error in complete verification', error);
        return buildResponse(StatusCodes.INTERNAL_SERVER_ERROR, { error: 'Internal server error' });
    }
};
</file>

<file path="lambdas/prove/identity-verification/(constants).ts">
export interface CreateRecordsParams {
    userId: string;
    sessionId: string;
    isMobile?: boolean;
}

export interface GetRecordsParams {
    id: number;
    sourceIP: string;
    phoneNumber: string;
    last4?: string;
}
</file>

<file path="lambdas/prove/identity-verification/(definitions).ts">
export interface V3ChallengeResponse {
    next: Next;
    individual: Individual;
    success: boolean;
}

interface Individual {
    firstName: string;
    lastName: string;
    addresses: Address[];
    emailAddresses: string[];
    dob: string;
    ssn: string;
}

interface Address {
    address: string;
    city: string;
    postalCode: string;
    extendedAddress: string;
    region: string;
}

interface Next {
    'v3-validate': '/v3/validate';
    'v3-challenge': '/v3/challenge';
    'v3-complete': '/v3/complete';
    done: null;
}
</file>

<file path="lambdas/prove/identity-verification/(models).ts">
import { body } from 'express-validator';

export const v3StartRequestValidation = [
    body('phoneNumber').isString().withMessage('Phone number must be a string'),
    body('last4SSN').isString().isLength({ min: 4, max: 4 }).withMessage('Last 4 SSN must be exactly 4 digits'),
    body('ipAddress').optional().isIP().withMessage('IP address must be valid'),
    body('flowType').isIn(['desktop', 'mobile']).withMessage('Flow type must be either desktop or mobile'),
    body('finalTargetUrl').optional().isURL().withMessage('Final target URL must be valid'),
];

export const v3ValidateRequestValidation = [
    body('correlationId').isString().withMessage('Correlation ID must be a string'),
];

export const v3ChallengeRequestValidation = [
    body('correlationId').isString().withMessage('Correlation ID must be a string'),
    body('dob').optional().isISO8601().withMessage('Date of birth must be in YYYY-MM-DD format'),
    body('last4SSN').optional().isLength({ min: 4, max: 4 }).withMessage('Last 4 SSN must be exactly 4 digits'),
];

export const v3CompleteRequestValidation = [
    body('correlationId').isString().withMessage('Correlation ID must be a string'),
    body('individual').isObject().withMessage('Individual must be an object'),
    body('individual.firstName').optional().isString().withMessage('First name must be a string'),
    body('individual.lastName').optional().isString().withMessage('Last name must be a string'),
    body('individual.dob').optional().isISO8601().withMessage('Date of birth must be in YYYY-MM-DD format'),
    body('individual.last4SSN')
        .optional()
        .isLength({ min: 4, max: 4 })
        .withMessage('Last 4 SSN must be exactly 4 digits'),
    body('individual.ssn').optional().isString().withMessage('SSN must be a string'),
    body('individual.emailAddresses').optional().isArray().withMessage('Email addresses must be an array'),
    body('individual.emailAddresses.*').optional().isEmail().withMessage('Each email address must be valid'),
    body('individual.addresses').optional().isArray().withMessage('Addresses must be an array'),
    body('individual.addresses.*.address').optional().isString().withMessage('Address must be a string'),
    body('individual.addresses.*.city').optional().isString().withMessage('City must be a string'),
    body('individual.addresses.*.extendedAddress')
        .optional()
        .isString()
        .withMessage('Extended address must be a string'),
    body('individual.addresses.*.postalCode').optional().isString().withMessage('Postal code must be a string'),
    body('individual.addresses.*.region').optional().isString().withMessage('Region must be a string'),
];
</file>

<file path="lambdas/prove/integrations/prove-backend-sdk/(constants).ts">
export const PROVE_CLIENT_ID: string = process.env.PROVE_CLIENT_ID!;
export const PROVE_CLIENT_SECRET: string = process.env.PROVE_CLIENT_SECRET!;
</file>

<file path="lambdas/prove/integrations/prove-backend-sdk/index.ts">
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable require-jsdoc */
import { Proveapi } from '@prove-identity/prove-api';
import { ProveServerEnvs } from '../(definitions)';
import { getLatestSecretManagerSecretValue } from '../../../../utils/secretManager';
import { defaultClkkProjectId } from '../../../../layers/commons/utils/variables';

class ProveBackendSdk {
    private static instance: Proveapi;

    private constructor() {}

    private static getServerEnv(): ProveServerEnvs {
        const envVariable = process.env.PROVE_ENVIRONMENT;
        if (envVariable === 'SANDBOX') {
            return ProveServerEnvs.SANDBOX;
        } else if (envVariable === 'PROD' || envVariable === 'PRODUCTION') {
            return ProveServerEnvs.PROD;
        } else {
            console.warn(`Invalid PROVE_ENVIRONMENT: ${envVariable}. Defaulting to SANDBOX.`);
            return ProveServerEnvs.SANDBOX;
        }
    }

    public static async getInstance(): Promise<Proveapi> {
        console.log('ProveBackendSdk.getInstance called');
        if (!ProveBackendSdk.instance) {
            try {
                const clientIdSecret = 'PROVE_CLIENT_ID';
                const clientSecretSecret = 'PROVE_CLIENT_SECRET';

                const clientId = await getLatestSecretManagerSecretValue(defaultClkkProjectId, clientIdSecret);
                const clientSecret = await getLatestSecretManagerSecretValue(defaultClkkProjectId, clientSecretSecret);

                if (!clientId || !clientSecret) {
                    throw new Error('Failed to retrieve Prove SDK credentials from Secret Manager');
                }

                const serverEnv = ProveBackendSdk.getServerEnv();
                console.log('Using Prove environment:', serverEnv);
                console.log('clientId', clientId.slice(-4));
                console.log('clientSecret', clientSecret.slice(-4));

                ProveBackendSdk.instance = new Proveapi({
                    server: serverEnv,
                    security: {
                        clientID: clientId,
                        clientSecret: clientSecret,
                    },
                });
            } catch (error) {
                console.error('Error initializing Prove SDK:', error);
                throw new Error('Failed to initialize Prove SDK');
            }
        }

        return ProveBackendSdk.instance;
    }
}

export default ProveBackendSdk;
</file>

<file path="lambdas/prove/integrations/(definitions).ts">
export enum ProveServerEnvs {
    PROD = "prod-us",
    SANDBOX = "uat-us"
}
</file>

<file path="lambdas/prove/integrations/prove-backend-sdk.ts">
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable require-jsdoc */
import { Proveapi } from '@prove-identity/prove-api';
import { ProveServerEnvs } from './(definitions)';
import { createLogger } from 'commons';
import { proveApiConfig } from 'commons';

const logger = createLogger('ProveBackendSDK');

/**
 * Singleton class for initializing and accessing the Prove Backend SDK
 */
class ProveBackendSdk {
    private static instance: Proveapi;

    private constructor() {}

    /**
     * Determines the Prove server environment based on environment variables
     * @returns The appropriate Prove server environment
     */
    private static getServerEnv(): ProveServerEnvs {
        const envVariable = process.env.PROVE_ENVIRONMENT;
        if (envVariable === 'SANDBOX') {
            return ProveServerEnvs.SANDBOX;
        } else if (envVariable === 'PROD' || envVariable === 'PRODUCTION') {
            return ProveServerEnvs.PROD;
        } else {
            logger.warn(`Invalid PROVE_ENVIRONMENT: ${envVariable}. Defaulting to SANDBOX.`);
            return ProveServerEnvs.SANDBOX;
        }
    }

    /**
     * Gets or initializes the Prove Backend SDK singleton instance
     * @returns Initialized Prove API instance
     */
    public static async getInstance(): Promise<Proveapi> {
        logger.info('ProveBackendSdk.getInstance called');
        if (!ProveBackendSdk.instance) {
            try {
                // Use values from proveApiConfig
                const clientId = proveApiConfig.clientId;
                const clientSecret = proveApiConfig.clientSecret;

                if (!clientId || !clientSecret) {
                    throw new Error('Missing required Prove API configuration');
                }

                const serverEnv = ProveBackendSdk.getServerEnv();
                logger.info('Using Prove environment:', { serverEnv });
                logger.debug('Using credentials', {
                    clientIdSuffix: clientId.slice(-4),
                    clientSecretSuffix: clientSecret.slice(-4),
                });

                ProveBackendSdk.instance = new Proveapi({
                    server: serverEnv,
                    security: {
                        clientID: clientId,
                        clientSecret: clientSecret,
                    },
                });

                logger.info('Prove Backend SDK initialized successfully');
            } catch (error) {
                logger.error('Error initializing Prove SDK:', error);
                throw new Error('Failed to initialize Prove SDK');
            }
        }

        return ProveBackendSdk.instance;
    }
}

export default ProveBackendSdk;
</file>

<file path="lambdas/prove/services/ProveIdentityService.ts">
import * as proveInterfaces from '@prove-identity/prove-api/models/components';
import { createLogger } from '../../../layers/commons/utils/logger_v2';
import { getProveBackendSdk } from '../integrations/prove-backend-sdk';
import { UserStatus } from '../../../types/users';
import { KmsService } from '../../../layers/commons/services/KmsService';

/**
 * Service class for handling Prove Identity verification
 */
export class ProveIdentityService {
    private logger = createLogger('ProveIdentityService');
    private kmsService: KmsService;

    /**
     * Initialize the ProveIdentityService
     * @param adminFirebaseService - Firebase admin service for user management
     * @param kmsService - KMS service for data encryption
     */
    constructor(kmsService: KmsService) {
        this.kmsService = kmsService;
    }

    /**
     * Health check endpoint
     * @returns Success response
     */
    async getEchoEndpoint(): Promise<{ message: string; success: boolean }> {
        this.logger.info('Executing echo endpoint');
        return {
            message: 'ok',
            success: true,
        };
    }

    /**
     * Start the identity verification process
     * @param phoneNumber - User's phone number
     * @param last4SSN - Last 4 digits of SSN
     * @param flowType - Type of verification flow
     * @param finalTargetUrl - Target URL after verification
     * @returns Response from Prove API
     */
    async startVerification(
        phoneNumber: string,
        last4SSN: string,
        flowType: string,
        finalTargetUrl: string,
    ): Promise<proveInterfaces.V3StartResponse> {
        this.logger.info('Starting verification process', {
            phoneNumber: phoneNumber.slice(-2),
            flowType,
            finalTargetUrl,
        });

        try {
            const sdk = await getProveBackendSdk();

            const response = await sdk.v3.v3StartRequest({
                phoneNumber,
                ssn: last4SSN,
                flowType,
                finalTargetUrl,
            } as proveInterfaces.V3StartRequest);

            if (!response.v3StartResponse) {
                throw new Error('v3StartResponse is undefined in the SDK response');
            }

            this.logger.info('Verification started successfully', {
                correlationId: response.v3StartResponse.correlationId,
            });

            return response.v3StartResponse;
        } catch (error) {
            this.logger.error('Error starting verification', error);
            throw error;
        }
    }

    /**
     * Validate verification request
     * @param correlationId - Correlation ID from start request
     * @returns Validation response from Prove API
     */
    async validateVerification(correlationId: string): Promise<proveInterfaces.V3ValidateResponse> {
        this.logger.info('Validating verification request', { correlationId });

        try {
            const sdk = await getProveBackendSdk();

            const response = await sdk.v3.v3ValidateRequest({
                correlationId,
            } as proveInterfaces.V3ValidateRequest);

            if (!response.v3ValidateResponse) {
                throw new Error('v3ValidateResponse is undefined in the SDK response');
            }

            this.logger.info('Validation completed', { correlationId });
            return response.v3ValidateResponse;
        } catch (error) {
            this.logger.error('Error validating verification', error);
            throw error;
        }
    }

    /**
     * Process challenge request
     * @param correlationId - Correlation ID from start request
     * @param dob - Date of birth
     * @param last4SSN - Last 4 digits of SSN
     * @returns Challenge response from Prove API
     */
    async processChallengeRequest(
        correlationId: string,
        dob: string,
        last4SSN: string,
    ): Promise<proveInterfaces.V3ChallengeResponse> {
        this.logger.info('Processing challenge request', { correlationId });

        try {
            const sdk = await getProveBackendSdk();

            const response = await sdk.v3.v3ChallengeRequest({
                correlationId,
                dob,
                last4SSN,
            } as proveInterfaces.V3ChallengeRequest);

            if (!response.v3ChallengeResponse) {
                throw new Error('v3ChallengeResponse is undefined in the SDK response');
            }

            this.logger.info('Challenge processed successfully', { correlationId });
            return response.v3ChallengeResponse;
        } catch (error) {
            this.logger.error('Error processing challenge', error);
            throw error;
        }
    }

    /**
     * Complete the verification process
     * @param individual - Individual information
     * @param correlationId - Correlation ID from start request
     * @param userId - User ID to update with verification data
     * @returns Complete response from Prove API
     */
    async completeVerification(
        individual: proveInterfaces.V3CompleteRequest,
        correlationId: string,
        userId: string,
    ): Promise<proveInterfaces.V3CompleteResponse> {
        this.logger.info('Completing verification process', { correlationId, userId });

        try {
            const sdk = await getProveBackendSdk();

            const response = await sdk.v3.v3CompleteRequest({
                correlationId,
                individual,
            } as proveInterfaces.V3CompleteRequest);

            if (!response.v3CompleteResponse) {
                throw new Error('v3CompleteResponse is undefined in the SDK response');
            }

            // Store verification data and set custom claims if verification was successful
            if (response.v3CompleteResponse.success) {
                await this.updateUserWithVerificationData(userId, individual);
            }

            this.logger.info('Verification completed', {
                correlationId,
                success: response.v3CompleteResponse.success,
            });

            return response.v3CompleteResponse;
        } catch (error) {
            this.logger.error('Error completing verification', error);
            throw error;
        }
    }

    /**
     * Update user with verification data
     * @param userId - User ID
     * @param individual - Individual information from Prove
     */
    private async updateUserWithVerificationData(
        userId: string,
        individual: proveInterfaces.V3CompleteRequest,
    ): Promise<void> {
        try {
            this.logger.info('Updating user with verification data', { userId });

            // Encrypt sensitive data
            const encryptedSSN = await this.kmsService.encryptData(individual.ssn || '');
            if (!encryptedSSN) {
                throw new Error('Failed to encrypt SSN');
            }

            this.logger.info('Successfully updated user verification status', { userId });
        } catch (error) {
            this.logger.error('Error updating user with verification data', error);
            throw error;
        }
    }
}
</file>

<file path="lambdas/prove/validators/request-validator.ts">
import Joi from 'joi';
import { createLogger } from '../../../layers/commons/utils/logger_v2';

const logger = createLogger('RequestValidator');

/**
 * Validation error interface
 */
export interface ValidationError {
    field: string;
    message: string;
}

/**
 * Validation result interface
 */
export interface ValidationResult {
    isValid: boolean;
    errors: ValidationError[];
}

/**
 * Validate request against a Joi schema
 * @param data - Data to validate
 * @param schema - Joi schema to validate against
 * @returns Validation result with errors if any
 */
export const validateRequest = (data: any, schema: Joi.Schema): ValidationResult => {
    logger.debug('Validating request data', { data });

    const validationOptions: Joi.ValidationOptions = {
        abortEarly: false,
        allowUnknown: true,
        stripUnknown: true,
    };

    const { error, value } = schema.validate(data, validationOptions);

    if (error) {
        const validationErrors: ValidationError[] = error.details.map((detail: Joi.ValidationErrorItem) => ({
            field: detail.path.join('.'),
            message: detail.message,
        }));

        logger.warn('Validation failed', { errors: validationErrors });

        return {
            isValid: false,
            errors: validationErrors,
        };
    }

    logger.debug('Validation succeeded');

    return {
        isValid: true,
        errors: [],
    };
};
</file>

<file path="lambdas/prove/validators/schemas.ts">
import Joi from 'joi';

/**
 * Schema for v3StartRequest
 * Validates the required fields for starting identity verification
 */
export const v3StartRequestSchema = Joi.object({
    phoneNumber: Joi.string()
        .required()
        .pattern(/^\+?[1-9]\d{1,14}$/)
        .messages({
            'string.empty': 'Phone number is required',
            'string.pattern.base': 'Phone number must be in E.164 format',
            'any.required': 'Phone number is required',
        }),

    last4SSN: Joi.string()
        .required()
        .length(4)
        .pattern(/^\d{4}$/)
        .messages({
            'string.empty': 'Last 4 digits of SSN is required',
            'string.length': 'Last 4 digits of SSN must be exactly 4 digits',
            'string.pattern.base': 'Last 4 digits of SSN must be numeric',
            'any.required': 'Last 4 digits of SSN is required',
        }),

    flowType: Joi.string().required().valid('standard', 'kyc', 'instant').messages({
        'string.empty': 'Flow type is required',
        'any.only': 'Flow type must be one of: standard, kyc, instant',
        'any.required': 'Flow type is required',
    }),

    finalTargetUrl: Joi.string().required().uri().messages({
        'string.empty': 'Final target URL is required',
        'string.uri': 'Final target URL must be a valid URL',
        'any.required': 'Final target URL is required',
    }),
});

/**
 * Schema for v3ValidateRequest
 * Validates the required fields for validating identity verification
 */
export const v3ValidateRequestSchema = Joi.object({
    correlationId: Joi.string().required().messages({
        'string.empty': 'Correlation ID is required',
        'any.required': 'Correlation ID is required',
    }),
});

/**
 * Schema for v3ChallengeRequest
 * Validates the required fields for challenge requests
 */
export const v3ChallengeRequestSchema = Joi.object({
    correlationId: Joi.string().required().messages({
        'string.empty': 'Correlation ID is required',
        'any.required': 'Correlation ID is required',
    }),

    dob: Joi.string()
        .required()
        .pattern(/^\d{4}-\d{2}-\d{2}$/)
        .messages({
            'string.empty': 'Date of birth is required',
            'string.pattern.base': 'Date of birth must be in YYYY-MM-DD format',
            'any.required': 'Date of birth is required',
        }),

    last4SSN: Joi.string()
        .required()
        .length(4)
        .pattern(/^\d{4}$/)
        .messages({
            'string.empty': 'Last 4 digits of SSN is required',
            'string.length': 'Last 4 digits of SSN must be exactly 4 digits',
            'string.pattern.base': 'Last 4 digits of SSN must be numeric',
            'any.required': 'Last 4 digits of SSN is required',
        }),
});

/**
 * Schema for v3CompleteRequest
 * Validates the required fields for completing identity verification
 */
export const v3CompleteRequestSchema = Joi.object({
    correlationId: Joi.string().required().messages({
        'string.empty': 'Correlation ID is required',
        'any.required': 'Correlation ID is required',
    }),

    userId: Joi.string().required().messages({
        'string.empty': 'User ID is required',
        'any.required': 'User ID is required',
    }),

    individual: Joi.object({
        firstName: Joi.string().required(),
        lastName: Joi.string().required(),
        dob: Joi.string(),
        ssn: Joi.string(),
        phoneNumber: Joi.string(),
        addresses: Joi.array().items(
            Joi.object({
                address: Joi.string(),
                extendedAddress: Joi.string().allow('', null),
                city: Joi.string(),
                region: Joi.string(),
                postalCode: Joi.string(),
            }),
        ),
    })
        .required()
        .messages({
            'object.base': 'Individual data object is required',
            'any.required': 'Individual data object is required',
        }),
});
</file>

<file path="lambdas/prove/identity.ts">
import { onRequest, HttpsFunction } from 'firebase-functions/v2/https';
import { logger } from 'firebase-functions';
import { Request, Response } from 'express';
import { StatusCodes } from 'http-status-codes';
import * as proveInterfaces from '@prove-identity/prove-api/models/components';
import proveBackendSdk from './integrations/prove-backend-sdk';
import { handleValidationErrors, runValidation } from '../../utils/prove/helpers/validation.helper';
import {
    v3ValidateRequestValidation,
    v3ChallengeRequestValidation,
    v3CompleteRequestValidation,
    v3StartRequestValidation,
} from './identity-verification/(models)';
import { allowedOrigins } from '../../layers/commons/utils/variables';
import { admin } from '../../config/firebaseConfig';
import { UserStatus } from '../../types/users';
import { getServerTimestamp } from '../../utils/firestoreUtils';
import { encryptData } from '../../layers/commons/encryption/kmsService';

const functionConfig: any = {
    region: 'us-central1',
    vpcConnector: 'clkk-connector',
    vpcConnectorEgressSettings: 'ALL_TRAFFIC',
    cors: allowedOrigins,
    minInstances: 1,
};

export const getEchoEndpoint: HttpsFunction = onRequest(functionConfig, async (req: Request, res: Response) => {
    try {
        res.status(StatusCodes.OK).json({
            message: 'ok',
            success: true,
        });
    } catch (error) {
        logger.error('Error in getEchoEndpoint', error);
        if (error instanceof Error) {
            logger.error('Error details:', { message: error.message, stack: error.stack });
        }
        res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({ error: 'Internal server error' });
    }
});

export const v3StartRequest: HttpsFunction = onRequest(functionConfig, async (req: Request, res: Response) => {
    try {
        logger.info('v3StartRequest initiated', req.body);

        // Validation
        const errors = await runValidation(v3StartRequestValidation)(req);
        console.log('errors', errors);
        if (errors.length > 0 || !handleValidationErrors(req, res)) {
            logger.warn('Validation failed for v3StartRequest', { errors });
            res.status(StatusCodes.BAD_REQUEST).json({ success: false, error_type: 'ValidationError', errors });
            return;
        }

        const { phoneNumber, last4SSN, flowType, finalTargetUrl } = req.body;
        logger.info('Request body received start', { phoneNumber, flowType, finalTargetUrl });
        console.log('Request body received start', {
            phoneNumber: phoneNumber.slice(-2),
            last4SSN: last4SSN.slice(-2),
            flowType,
            finalTargetUrl,
        });

        const sdk = await proveBackendSdk.getInstance();
        logger.info('Calling Prove SDK v3StartRequest', { phoneNumber, flowType, finalTargetUrl });

        const response = await sdk.v3.v3StartRequest({
            phoneNumber,
            ssn: last4SSN,
            flowType,
            finalTargetUrl: finalTargetUrl,
        } as proveInterfaces.V3StartRequest);

        if (!response.v3StartResponse) {
            throw new Error('v3StartResponse is undefined in the SDK response');
        }

        const { v3StartResponse } = response;
        logger.info('v3StartResponse received', { correlationId: v3StartResponse.correlationId });
        console.log('v3StartResponse received', {
            correlationId: v3StartResponse.correlationId,
            phoneNumber: phoneNumber.slice(-2),
            last4SSN: last4SSN.slice(-2),
        });

        res.status(StatusCodes.OK).json(v3StartResponse);
        return;
    } catch (error) {
        const { phoneNumber, last4SSN } = req.body;
        logger.error('Error in v3StartRequest', error);
        if (error instanceof Error) {
            logger.error('Error details:', {
                message: error.message,
                stack: error.stack,
                phoneNumber: phoneNumber?.slice(-2),
                last4SSN: last4SSN?.slice(-2),
            });
        }
        console.log('error in v3StartRequest for', {
            phoneNumber: phoneNumber?.slice(-2),
            last4SSN: last4SSN?.slice(-2),
        });
        res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({ error: 'Internal server error' });
    }
});

export const v3ValidateRequest: HttpsFunction = onRequest(functionConfig, async (req: Request, res: Response) => {
    try {
        logger.info('v3ValidateRequest initiated with correlationId', req.body);

        // Validation
        const errors = await runValidation(v3ValidateRequestValidation)(req);
        if (errors.length > 0 || !handleValidationErrors(req, res)) {
            logger.warn('Validation failed for v3ValidateRequest', { errors });
            res.status(StatusCodes.BAD_REQUEST).json({ success: false, error_type: 'ValidationError', errors });
            return;
        }

        const { correlationId } = req.body;
        logger.info('Request body received', { correlationId });

        const sdk = await proveBackendSdk.getInstance();
        logger.info('Calling Prove SDK v3ValidateRequest');

        const response = await sdk.v3.v3ValidateRequest({
            correlationId,
        } as proveInterfaces.V3ValidateRequest);

        if (!response.v3ValidateResponse) {
            throw new Error('v3ValidateResponse is undefined in the SDK response');
        }

        console.log('response', response);

        const { v3ValidateResponse } = response;
        logger.info('v3ValidateResponse received', { v3ValidateResponse });

        res.status(StatusCodes.OK).json(v3ValidateResponse);
        return;
    } catch (error) {
        const { correlationId } = req.body;
        logger.error('Error in v3ValidateRequest', error);
        if (error instanceof Error) {
            logger.error('Error details:', {
                message: error.message,
                stack: error.stack,
                correlationId,
            });
        }
        console.log('error in v3ValidateRequest for', { correlationId });
        res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({ error: 'Internal server error' });
    }
});

export const v3ChallengeRequest: HttpsFunction = onRequest(functionConfig, async (req: Request, res: Response) => {
    try {
        logger.info('v3ChallengeRequest initiated');

        // Validation
        const errors = await runValidation(v3ChallengeRequestValidation)(req);
        if (errors.length > 0 || !handleValidationErrors(req, res)) {
            logger.warn('Validation failed for v3ChallengeRequest', { errors });
            res.status(StatusCodes.BAD_REQUEST).json({ success: false, error_type: 'ValidationError', errors });
            return;
        }

        const { correlationId, dob, last4SSN } = req.body;
        logger.info('Request body received', { correlationId });

        const sdk = await proveBackendSdk.getInstance();
        logger.info('Calling Prove SDK v3ChallengeRequest');

        const response = await sdk.v3.v3ChallengeRequest({
            correlationId,
            dob,
            last4SSN,
        } as proveInterfaces.V3ChallengeRequest);

        if (!response.v3ChallengeResponse) {
            throw new Error('v3ChallengeResponse is undefined in the SDK response');
        }

        const { v3ChallengeResponse } = response;
        logger.info('v3ChallengeResponse received', { v3ChallengeResponse });

        res.status(StatusCodes.OK).json(v3ChallengeResponse);
    } catch (error) {
        const { correlationId, last4SSN } = req.body;
        logger.error('Error in v3ChallengeRequest', error);
        if (error instanceof Error) {
            logger.error('Error details:', {
                message: error.message,
                stack: error.stack,
                correlationId,
                last4SSN: last4SSN?.slice(-2),
            });
        }
        console.log('error in v3ChallengeRequest for', {
            correlationId,
            last4SSN: last4SSN?.slice(-2),
        });
        res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({ error: 'Internal server error' });
    }
});

export const v3CompleteRequest: HttpsFunction = onRequest(functionConfig, async (req: Request, res: Response) => {
    try {
        logger.info('v3CompleteRequest initiated');

        // Validation
        const errors = await runValidation(v3CompleteRequestValidation)(req);
        if (errors.length > 0 || !handleValidationErrors(req, res)) {
            logger.warn('Validation failed for v3CompleteRequest', { errors });
            res.status(StatusCodes.BAD_REQUEST).json({ success: false, error_type: 'ValidationError', errors });
            return;
        }

        const { individual, correlationId, userId } = req.body;

        // Add explicit userId validation
        if (!userId || typeof userId !== 'string' || userId.trim() === '') {
            logger.error('Invalid or missing userId in request body');
            res.status(StatusCodes.BAD_REQUEST).json({
                success: false,
                error: 'Invalid or missing userId',
            });
            return;
        }

        logger.info('Request body received', { correlationId, userId }); // Add userId to logging

        const sdk = await proveBackendSdk.getInstance();
        logger.info('Calling Prove SDK v3CompleteRequest');

        const response = await sdk.v3.v3CompleteRequest({
            correlationId,
            individual,
        } as proveInterfaces.V3CompleteRequest);

        if (!response.v3CompleteResponse) {
            throw new Error('v3CompleteResponse is undefined in the SDK response');
        }

        const { v3CompleteResponse } = response;
        logger.info('v3CompleteResponse received', { v3CompleteResponse });

        // Store verification data and set custom claims if verification was successful
        if (v3CompleteResponse.success) {
            try {
                logger.info('Attempting to update user document', { userId });

                // Update user profile with verification data directly in the root
                const userRef = admin.firestore().collection('users').doc(userId.trim());
                const encryptedSSN = await encryptData(individual.ssn);
                if (!encryptedSSN) {
                    throw new Error('Failed to encrypt SSN');
                }

                await userRef.update({
                    firstName: individual.firstName?.toLowerCase() || '',
                    lastName: individual.lastName?.toLowerCase() || '',
                    displayName: `${individual.firstName?.toLowerCase() || ''} ${
                        individual.lastName?.toLowerCase() || ''
                    }`,
                    address: {
                        street: individual.addresses?.[0]?.address?.toLowerCase() || '',
                        extendedAddress: individual.addresses?.[0]?.extendedAddress?.toLowerCase() || '',
                        city: individual.addresses?.[0]?.city?.toLowerCase() || '',
                        region: individual.addresses?.[0]?.region?.toLowerCase() || '',
                        postalCode: individual.addresses?.[0]?.postalCode?.toLowerCase() || '',
                    },
                    dob: individual.dob?.toLowerCase() || '',
                    ssn: encryptedSSN,
                    phoneNumber: individual.phoneNumber?.toLowerCase() || '',
                    verifiedAt: getServerTimestamp(),
                    status: UserStatus.ACTIVE,
                    isVerified: true,
                });

                logger.info('Successfully updated user document', { userId });

                // Set custom claims
                await admin.auth().setCustomUserClaims(userId, {
                    isVerified: true,
                    verifiedAt: new Date().toISOString(),
                });

                // Force token refresh
                await admin.auth().revokeRefreshTokens(userId);

                logger.info('Successfully updated user verification status and claims', { userId });
            } catch (error) {
                logger.error('Error updating user verification status:', error);
                if (error instanceof Error) {
                    logger.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        userId,
                    });
                }
            }
        }

        res.status(StatusCodes.OK).json(v3CompleteResponse);
        return;
    } catch (error) {
        const { correlationId, userId } = req.body;
        logger.error('Error in v3CompleteRequest', error);
        if (error instanceof Error) {
            logger.error('Error details:', {
                message: error.message,
                stack: error.stack,
                correlationId,
                userId,
            });
        }
        console.log('error in v3CompleteRequest for', { correlationId, userId });
        res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({ error: 'Internal server error' });
    }
});
</file>

<file path="lambdas/prove/package.json">
{
    "name": "prove-identity",
    "version": "1.0.0",
    "description": "Prove Identity Verification Lambda",
    "main": "identity.js",
    "author": "CLKK",
    "license": "MIT",
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0",
        "@aws-sdk/client-secrets-manager": "^3.716.0",
        "@prove-identity/prove-api": "^0.9.4"
    },
    "devDependencies": {
        "esbuild": "^0.14.14",
        "@types/aws-lambda": "^8.10.146",
        "@types/node": "^18.11.4",
        "typescript": "^4.8.4"
    }
}
</file>

<file path="lambdas/prove/README.md">
# Prove Identity Verification Lambda Functions

This module implements identity verification using the Prove Identity API as AWS Lambda functions with static outbound IP addresses.

## Architecture

The architecture consists of the following components:

1. **Lambda Functions**:

    - AWS Lambda functions for each step of the identity verification flow
    - Handlers with consistent error handling and response formatting
    - Class-based service layer for business logic

2. **Static IP Implementation**:

    - Lambda functions run in a VPC with private subnet
    - NAT Gateway with Elastic IP for outbound API calls to Prove
    - This ensures requests to Prove always come from the same static IP

3. **Security**:
    - API Gateway with Cognito authorizer
    - KMS encryption for sensitive data
    - IAM policies with least privilege
    - VPC isolation for Lambda functions

## Functions

| Function           | Description                           | Endpoint                |
| ------------------ | ------------------------------------- | ----------------------- |
| `echoHandler`      | Health check endpoint                 | `GET /prove/echo`       |
| `startHandler`     | Start identity verification           | `POST /prove/start`     |
| `validateHandler`  | Validate verification request         | `POST /prove/validate`  |
| `challengeHandler` | Process challenge request             | `POST /prove/challenge` |
| `completeHandler`  | Complete verification and update user | `POST /prove/complete`  |

## Dependencies

-   `@prove-identity/prove-api`: SDK for Prove Identity API
-   `firebase-admin`: Firebase Admin SDK for user management
-   `aws-sdk`: AWS SDK for KMS encryption
-   `joi`: Request validation
-   `http-status-codes`: HTTP status code constants

## Infrastructure as Code

The AWS infrastructure is defined using CloudFormation/SAM templates:

-   `iac/shared/networking.yaml`: VPC, subnets, NAT Gateway with static IP
-   `iac/shared/iam-policies.yaml`: IAM roles and policies
-   `iac/prove/identity-stack.yaml`: Lambda functions, API Gateway, Cognito

## Environment Variables

| Variable                | Description                                |
| ----------------------- | ------------------------------------------ |
| `KMS_KEY_ID`            | KMS Key ID for encryption                  |
| `PROVE_CLIENT_ID`       | Prove API Client ID                        |
| `PROVE_CLIENT_SECRET`   | Prove API Client Secret                    |
| `PROVE_API_KEY`         | Prove API Key                              |
| `PROVE_ENVIRONMENT`     | Prove API Environment (sandbox/production) |
| `FIREBASE_PROJECT_ID`   | Firebase Project ID                        |
| `FIREBASE_CLIENT_EMAIL` | Firebase Client Email                      |
| `FIREBASE_PRIVATE_KEY`  | Firebase Private Key                       |
| `FIREBASE_DATABASE_URL` | Firebase Database URL                      |
| `ALLOWED_ORIGINS`       | Comma-separated CORS allowed origins       |

## Deployment

```bash
# Build and deploy the application
sam build
sam deploy --guided

# Check the static IP address that will be used for outbound API calls
aws cloudformation describe-stacks --stack-name clkk-backend-networking \
  --query "Stacks[0].Outputs[?OutputKey=='NatGatewayEIP'].OutputValue" --output text
```

## Testing

```bash
# Test the echo endpoint
curl -X GET https://your-api-endpoint.execute-api.us-east-1.amazonaws.com/dev/prove/echo

# Start verification (requires authentication)
curl -X POST https://your-api-endpoint.execute-api.us-east-1.amazonaws.com/dev/prove/start \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "phoneNumber": "+12025550123",
    "last4SSN": "1234",
    "flowType": "standard",
    "finalTargetUrl": "https://app.clkk.com/verify/complete"
  }'
```

## Monitoring and Logging

-   All Lambda functions use structured logging with AWS CloudWatch
-   Sensitive data is redacted from logs
-   Error handling with detailed error information
</file>

<file path="lambdas/search/app.ts">
import { DynamoDBClient, QueryCommand } from '@aws-sdk/client-dynamodb';
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { unmarshall } from '@aws-sdk/util-dynamodb';
import { DYNAMO_TABLES } from 'commons/utils/constants';
import { logger } from 'commons/utils/logger';

const dynamoClient = new DynamoDBClient({});
const RESULTS_LIMIT = 25;

// GSI Index structure:
// - PK: entityType (user/business)
// - SK: searchClkktag (lowercase, no $ prefix)
// - GSI1: PK=entityType, SK=name (lowercase)
export const getEntityProfile = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const searchTerm = event.queryStringParameters?.q?.trim().toLowerCase();

    //Current user entityId
    const currentUserEntityId = event.requestContext.authorizer?.userId;
    logger.info('currentUserEntityId', { currentUserEntityId });

    logger.info('getEntityProfile', { searchTerm });

    if (!searchTerm || searchTerm.length < 2) {
        return {
            statusCode: 400,
            body: JSON.stringify({ message: 'Search term must be at least 2 characters' }),
        };
    }

    try {
        const isTagSearch = searchTerm.startsWith('@') || /^\w+$/.test(searchTerm);
        const cleanTerm = searchTerm.replace(/^@/, '');

        logger.info('getEntityProfiles', { isTagSearch, cleanTerm });

        const queryParams = {
            TableName: DYNAMO_TABLES.ENTITIES,
            IndexName: 'EntityTypeClkkTagIndexV2',
            KeyConditionExpression: 'entityType = :type AND begins_with(clkktag, :term)',
            ExpressionAttributeValues: {
                ':type': { S: 'user' },
                ':term': { S: isTagSearch ? cleanTerm : searchTerm },
            },
            ProjectionExpression:
                'entityId, entityType, clkktag, firstName, lastName, metadata, profileImageUrl, kyc, email',
            Limit: RESULTS_LIMIT,
        };

        let { Items } = await dynamoClient.send(new QueryCommand(queryParams));

        if (isTagSearch) {
            const businessResults = await dynamoClient.send(
                new QueryCommand({
                    ...queryParams,
                    ExpressionAttributeValues: {
                        ':type': { S: 'business' },
                        ':term': { S: cleanTerm },
                    },
                }),
            );

            Items = [...(Items || []), ...(businessResults.Items || [])];
        }

        // Filter out the current user
        const filteredItems =
            Items?.filter((item) => {
                const data = unmarshall(item);
                return data.entityId !== currentUserEntityId;
            }) || [];

        const results = filteredItems.map((item) => {
            const data = unmarshall(item);
            // Capitalize first and last name
            const firstName = data.firstName ? data.firstName : '';
            const lastName = data.lastName ? data.lastName : '';

            return {
                entityId: data.entityId,
                entityType: data.entityType,
                name: `${firstName} ${lastName}`.trim(),
                clkktag: data.clkktag,
                profileImageUrl: data.profileImageUrl,
                email: data.email,
                kycStatus: data.kyc?.status,
                cybridCustomerId: data.metadata?.cybrid?.customerId,
                fiatAccountId: data.metadata?.cybrid?.fiatAccountId,
            };
        });

        return {
            statusCode: 200,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(results),
        };
    } catch (error) {
        logger.error('getEntityProfile', { error });
        return {
            statusCode: 500,
            body: JSON.stringify({ message: 'Search failed' }),
        };
    }
};
</file>

<file path="lambdas/search/package.json">
{
  "name": "user-profile",
  "version": "1.0.0",
  "description": "user profile lambda",
  "main": "app.js",
  "author": "CLKK",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit"
  },
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.782.0",
    "@aws-sdk/util-dynamodb": "^3.782.0",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "@types/aws-lambda": "^8.10.146",
    "@types/jest": "^29.2.0",
    "@types/node": "^18.11.4",
    "@typescript-eslint/eslint-plugin": "^5.10.2",
    "@typescript-eslint/parser": "^5.10.2",
    "esbuild": "^0.14.14",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.2.1",
    "prettier": "^2.5.1",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
</file>

<file path="lambdas/services/currencyService.ts">
/**
 * Currency Service - Handles all currency conversions and calculations
 *
 * This service ensures consistent handling of monetary values throughout the application.
 * All amounts are stored and processed in the smallest currency unit (cents for USD)
 * to avoid floating point precision issues.
 */
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'currency-service' });

// Currency configuration
export interface CurrencyConfig {
    code: string; // Currency code (e.g., 'USD')
    decimals: number; // Number of decimal places (e.g., 2 for USD)
    symbol: string; // Currency symbol (e.g., '$')
}

// Supported currencies and their configurations
export const CURRENCIES: Record<string, CurrencyConfig> = {
    USD: { code: 'USD', decimals: 2, symbol: '$' },
    EUR: { code: 'EUR', decimals: 2, symbol: 'â‚¬' },
    // Add other currencies as needed
};

export class CurrencyService {
    /**
     * Convert a decimal amount (dollars) to the smallest unit (cents)
     * @param amount - Amount in decimal form (e.g., 10.99)
     * @param currencyCode - Currency code (defaults to USD)
     * @returns Amount in smallest units (e.g., 1099)
     */
    public static toSmallestUnit(amount: number, currencyCode = 'USD'): number {
        const currency = CURRENCIES[currencyCode] || CURRENCIES.USD;
        const factor = Math.pow(10, currency.decimals);

        // Use Math.round to handle potential floating point issues
        const result = Math.round(amount * factor);

        logger.debug('Converted to smallest unit', {
            from: amount,
            to: result,
            currency: currencyCode,
            operation: 'toSmallestUnit',
        });

        return result;
    }

    /**
     * Convert from smallest unit (cents) to decimal amount (dollars)
     * @param amount - Amount in smallest units (e.g., 1099)
     * @param currencyCode - Currency code (defaults to USD)
     * @returns Amount in decimal form (e.g., 10.99)
     */
    public static fromSmallestUnit(amount: number, currencyCode = 'USD'): number {
        const currency = CURRENCIES[currencyCode] || CURRENCIES.USD;
        const factor = Math.pow(10, currency.decimals);

        const result = amount / factor;

        logger.debug('Converted from smallest unit', {
            from: amount,
            to: result,
            currency: currencyCode,
            operation: 'fromSmallestUnit',
        });

        return result;
    }

    /**
     * Add two monetary amounts safely
     * @param a - First amount (in smallest units)
     * @param b - Second amount (in smallest units)
     * @returns Sum (in smallest units)
     */
    public static add(a: number, b: number): number {
        return a + b;
    }

    /**
     * Subtract one monetary amount from another safely
     * @param a - First amount (in smallest units)
     * @param b - Amount to subtract (in smallest units)
     * @returns Difference (in smallest units)
     */
    public static subtract(a: number, b: number): number {
        return a - b;
    }

    /**
     * Multiply a monetary amount by a factor
     * @param amount - Amount (in smallest units)
     * @param factor - Multiplication factor
     * @returns Product (in smallest units)
     */
    public static multiply(amount: number, factor: number): number {
        return Math.round(amount * factor);
    }

    /**
     * Calculate percentage of an amount
     * @param amount - Base amount (in smallest units)
     * @param percentage - Percentage as decimal (e.g., 0.01 for 1%)
     * @returns Percentage amount (in smallest units)
     */
    public static calculatePercentage(amount: number, percentage: number): number {
        const result = Math.round(amount * percentage);

        logger.debug('Calculated percentage', {
            amount,
            percentage: percentage * 100 + '%',
            result,
            operation: 'calculatePercentage',
        });

        return result;
    }

    /**
     * Format amount for display
     * @param amount - Amount (in smallest units)
     * @param currencyCode - Currency code
     * @returns Formatted string (e.g., "$10.99")
     */
    public static format(amount: number, currencyCode = 'USD'): string {
        const currency = CURRENCIES[currencyCode] || CURRENCIES.USD;
        const decimalAmount = this.fromSmallestUnit(amount, currencyCode);

        return `${currency.symbol}${decimalAmount.toFixed(currency.decimals)}`;
    }

    /**
     * Converts dollars to cents (integer)
     * @param dollars Amount in dollars (can be decimal)
     * @returns Amount in cents as integer
     */
    static dollarsToCents(dollars: number): number {
        return Math.round(dollars * 100);
    }

    /**
     * Converts cents to dollars
     * @param cents Amount in cents (integer)
     * @returns Amount in dollars (decimal)
     */
    static centsToDollars(cents: number): number {
        return cents / 100;
    }

    /**
     * Calculates fee amount based on percentage
     * @param amount Amount in cents
     * @param feePercentage Fee percentage (e.g., 0.01 for 1%)
     * @returns Fee amount in cents
     */
    static calculateFee(amount: number, feePercentage: number): number {
        return Math.round(amount * feePercentage);
    }

    /**
     * Formats amount for display with currency symbol
     * @param amount Amount in cents
     * @param currency Currency code
     * @returns Formatted currency string
     */
    static formatCurrency(amount: number, currency: string = 'USD'): string {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency,
        }).format(this.centsToDollars(amount));
    }
}
</file>

<file path="lambdas/services/feeService.ts">
/**
 * Service for calculating and processing transaction fees
 */
import { DynamoDBClient, UpdateItemCommand, GetItemCommand } from '@aws-sdk/client-dynamodb';
import { marshall, unmarshall } from '@aws-sdk/util-dynamodb';
import { v4 as uuidv4 } from 'uuid';
import { DYNAMO_TABLES } from 'commons';
import { CurrencyService } from './currencyService';
import { logger } from 'commons';

interface Transaction {
    transactionId: string;
    senderEntityId: string;
    recipientId: string;
    amount: number;
    asset: string;
    status: string;
    type: string;
    memo?: string;
    fee?: number;
    netAmount?: number;
    createdAt: string;
    // Additional properties as needed
}

interface BusinessProfile {
    businessId: string;
    name: string;
    feeStructure: {
        transactionFeePercent: number; // e.g., 1.0 for 1%
        flatFee?: number; // optional flat fee
        minimumFee?: number; // optional minimum fee amount
    };
    masterWalletId: string; // The wallet/account to receive fees
}

// Default fee percentage (1%)
export const DEFAULT_FEE_PERCENTAGE = 0.01;

const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });

/**
 * Fee structure for different business types
 */
export const FEE_STRUCTURE = {
    DEFAULT: 0.005,
    // Premium businesses pay lower fees (0.3%)
    PREMIUM: 0.003,
    // Enterprise businesses pay even lower fees (0.1%)
    ENTERPRISE: 0.001,
    // No fee for certain special accounts
    EXEMPT: 0.0,
};

export interface FeeCalculationResult {
    originalAmount: number;
    feeAmount: number;
    recipientAmount: number;
    feePercentage: number;
}

/**
 * Service to handle all fee-related operations
 */
export class FeeService {
    private readonly BUSINESS_PROFILES_TABLE = process.env.BUSINESS_PROFILES_TABLE || 'BusinessProfiles';
    private readonly PLATFORM_REVENUE_TABLE = process.env.REVENUE_TABLE || 'PlatformRevenue';
    private readonly TRANSACTIONS_TABLE = process.env.CLKK_TRANSACTIONS_TABLE || 'CLKKTransactions';
    private readonly ENTITIES_TABLE = DYNAMO_TABLES.ENTITIES;
    private dynamoClient: DynamoDBClient;

    constructor(region?: string) {
        this.dynamoClient = new DynamoDBClient({ region: region || process.env.AWS_REGION });
    }

    /**
     * Process a business payment including fee calculation and transaction splitting
     * @param transaction The original transaction to process
     * @param businessProfile The business profile with fee structure
     * @returns The updated transaction with fee details
     */
    public async processBusinessPayment(
        transaction: Transaction,
        businessProfile: BusinessProfile,
    ): Promise<{ mainTransaction: Transaction; feeTransaction: Transaction }> {
        console.log('Processing business payment', { transaction, businessProfile });

        // Calculate fee based on business profile fee structure
        const { amount, fee, netAmount } = this.calculateFee(
            transaction.amount,
            businessProfile.feeStructure.transactionFeePercent,
            businessProfile.feeStructure.flatFee,
            businessProfile.feeStructure.minimumFee,
        );

        const timestamp = new Date().toISOString();

        // Update the main transaction with fee information
        const mainTransaction: Transaction = {
            ...transaction,
            fee,
            netAmount,
            memo: transaction.memo
                ? `${transaction.memo} (Fee: ${fee} ${transaction.asset})`
                : `Fee: ${fee} ${transaction.asset}`,
            status: 'COMPLETED',
            createdAt: timestamp,
        };

        // Create a separate fee transaction
        const feeTransaction: Transaction = {
            transactionId: uuidv4(), // Generate a new unique ID
            senderEntityId: transaction.senderEntityId,
            recipientId: businessProfile.masterWalletId, // Send to master wallet
            amount: fee,
            asset: transaction.asset,
            status: 'COMPLETED',
            type: 'fee',
            memo: `Fee for transaction ${transaction.transactionId}`,
            createdAt: timestamp,
        };

        // Save both transactions
        await this.saveTransaction(mainTransaction);
        await this.saveTransaction(feeTransaction);

        // Record the fee as platform revenue
        await this.recordFeeRevenue(feeTransaction, mainTransaction.transactionId);

        return { mainTransaction, feeTransaction };
    }

    /**
     * Save a transaction to the transactions table
     * @param transaction The transaction to save
     */
    private async saveTransaction(transaction: Transaction): Promise<void> {
        try {
            await this.dynamoClient.send(
                new UpdateItemCommand({
                    TableName: this.TRANSACTIONS_TABLE,
                    Key: marshall({ transactionId: transaction.transactionId }),
                    UpdateExpression:
                        'SET #senderEntityId = :senderEntityId, recipientId = :recipientId, #amount = :amount, #asset = :asset, #status = :status, #type = :type, memo = :memo, createdAt = :createdAt, fee = :fee, netAmount = :netAmount',
                    ExpressionAttributeNames: {
                        '#senderEntityId': 'senderEntityId',
                        '#amount': 'amount',
                        '#asset': 'asset',
                        '#status': 'status',
                        '#type': 'type',
                    },
                    ExpressionAttributeValues: marshall({
                        ':senderEntityId': transaction.senderEntityId,
                        ':recipientId': transaction.recipientId,
                        ':amount': transaction.amount,
                        ':asset': transaction.asset,
                        ':status': transaction.status,
                        ':type': transaction.type,
                        ':memo': transaction.memo || null,
                        ':createdAt': transaction.createdAt,
                        ':fee': transaction.fee || null,
                        ':netAmount': transaction.netAmount || null,
                    }),
                }),
            );
            console.log('Transaction saved successfully', { transactionId: transaction.transactionId });
        } catch (error) {
            console.error('Error saving transaction', { error, transaction });
            throw error;
        }
    }

    /**
     * Record fee revenue in the platform revenue table
     * @param feeTransaction The fee transaction
     * @param originalTransactionId The ID of the original transaction
     */
    private async recordFeeRevenue(feeTransaction: Transaction, originalTransactionId: string): Promise<void> {
        try {
            const revenueId = `FEE-${feeTransaction.transactionId}`;
            const revenueItem = {
                revenueId,
                originalTransactionId,
                transactionId: feeTransaction.transactionId,
                amount: feeTransaction.amount,
                asset: feeTransaction.asset,
                type: 'transaction_fee',
                source: 'business_payment',
                businessId: feeTransaction.recipientId,
                createdAt: feeTransaction.createdAt,
            };

            await this.dynamoClient.send(
                new UpdateItemCommand({
                    TableName: this.PLATFORM_REVENUE_TABLE,
                    Key: marshall({ revenueId }),
                    UpdateExpression:
                        'SET originalTransactionId = :originalTransactionId, transactionId = :transactionId, amount = :amount, asset = :asset, #type = :type, #source = :source, businessId = :businessId, createdAt = :createdAt',
                    ExpressionAttributeNames: {
                        '#type': 'type',
                        '#source': 'source',
                    },
                    ExpressionAttributeValues: marshall(revenueItem),
                }),
            );
            console.log('Fee revenue recorded successfully', { revenueId });
        } catch (error) {
            console.error('Error recording fee revenue', { error, feeTransaction });
            throw error;
        }
    }

    /**
     * Calculate the fee for a P2B transaction
     * @param amount - The original transaction amount in decimal (dollars)
     * @param businessId - The ID of the recipient business
     * @param currencyCode - The currency code (defaults to USD)
     * @returns The fee calculation result with all amounts in decimal (dollars)
     */
    public async calculateFee(amount: number, businessId: string, currencyCode = 'USD'): Promise<FeeCalculationResult> {
        try {
            // Convert input amount to smallest unit (cents)
            const amountInCents = CurrencyService.toSmallestUnit(amount, currencyCode);

            logger.debug('Fee calculation - amount converted to cents', {
                originalAmount: amount,
                amountInCents,
                currencyCode,
            });

            // Get the business entity from DynamoDB
            const params = {
                TableName: this.ENTITIES_TABLE,
                Key: {
                    entityId: { S: businessId },
                },
            };

            const response = await this.dynamoClient.send(new GetItemCommand(params));

            let feePercentage = DEFAULT_FEE_PERCENTAGE; // Default to 1%

            if (response.Item) {
                const business = unmarshall(response.Item);

                // Check if business has custom fee defined
                if (
                    business.businessDetails &&
                    business.businessDetails.fee !== undefined &&
                    typeof business.businessDetails.fee === 'number'
                ) {
                    // Use the custom fee (stored as decimal, e.g., 0.005 for 0.5%)
                    feePercentage = business.businessDetails.fee;
                    logger.info(`Using custom fee for business ${businessId}: ${feePercentage * 100}%`);
                } else {
                    logger.info(
                        `No custom fee found for business ${businessId}, using default: ${
                            DEFAULT_FEE_PERCENTAGE * 100
                        }%`,
                    );
                }
            } else {
                logger.info(`Business ${businessId} not found, using default fee: ${DEFAULT_FEE_PERCENTAGE * 100}%`);
            }

            // Calculate the fee amount in cents
            const feeAmountInCents = CurrencyService.calculatePercentage(amountInCents, feePercentage);

            // Calculate the recipient amount in cents (original amount minus fee)
            const recipientAmountInCents = CurrencyService.subtract(amountInCents, feeAmountInCents);

            logger.debug('Fee calculation details', {
                amountInCents,
                feePercentage,
                feeAmountInCents,
                recipientAmountInCents,
                currencyCode,
            });

            // Convert back to decimal for the response
            const result = {
                originalAmount: amount, // Keep original input for reference
                feeAmount: CurrencyService.fromSmallestUnit(feeAmountInCents, currencyCode),
                recipientAmount: CurrencyService.fromSmallestUnit(recipientAmountInCents, currencyCode),
                feePercentage,
            };

            logger.info('Fee calculation result', result);

            return result;
        } catch (error) {
            logger.error('Error calculating fee:', error);

            // In case of errors, use the default 1% fee
            const amountInCents = CurrencyService.toSmallestUnit(amount, currencyCode);
            const feeAmountInCents = CurrencyService.calculatePercentage(amountInCents, DEFAULT_FEE_PERCENTAGE);
            const recipientAmountInCents = CurrencyService.subtract(amountInCents, feeAmountInCents);

            const result = {
                originalAmount: amount,
                feeAmount: CurrencyService.fromSmallestUnit(feeAmountInCents, currencyCode),
                recipientAmount: CurrencyService.fromSmallestUnit(recipientAmountInCents, currencyCode),
                feePercentage: DEFAULT_FEE_PERCENTAGE,
            };

            logger.info('Fee calculation result (fallback)', result);

            return result;
        }
    }

    /**
     * Check if an entity is a business
     * @param entityId - The ID of the entity to check
     * @returns Boolean indicating if the entity is a business
     */
    public async isEntityBusiness(entityId: string): Promise<boolean> {
        try {
            const params = {
                TableName: this.ENTITIES_TABLE,
                Key: {
                    entityId: { S: entityId },
                },
            };

            const response = await this.dynamoClient.send(new GetItemCommand(params));

            if (!response.Item) {
                return false;
            }

            const entity = unmarshall(response.Item);
            return entity.type === 'business';
        } catch (error) {
            console.error('Error checking if entity is business:', error);
            return false;
        }
    }

    /**
     * Get a business profile if it exists
     * @param businessId - The business ID to lookup
     * @returns The business profile or null if not found
     */
    public async getBusinessProfile(businessId: string): Promise<any | null> {
        try {
            const response = await this.dynamoClient.send(
                new GetItemCommand({
                    TableName: this.BUSINESS_PROFILES_TABLE,
                    Key: marshall({ businessId }),
                }),
            );

            if (!response.Item) {
                return null;
            }

            return unmarshall(response.Item);
        } catch (error) {
            console.error('Error retrieving business profile:', error);
            return null;
        }
    }
}

// Export a singleton instance for convenience
export const feeService = new FeeService();
</file>

<file path="lambdas/services/package.json">
{
    "description": "Lambda layer with common utils",
    "main": "index.ts",
    "name": "layer-commons",
    "version": "1.0.0",
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0",
        "@aws-sdk/client-dynamodb": "^3.705.0",
        "@aws-sdk/client-kms": "^3.782.0",
        "@aws-sdk/client-secrets-manager": "^3.699.0",
        "@aws-sdk/client-ses": "^3.734.0",
        "@aws-sdk/client-sns": "^3.734.0",
        "@aws-sdk/client-sqs": "^3.716.0",
        "@aws-sdk/util-dynamodb": "^3.705.0",
        "@aws-sdk/client-dynamodb": "^3.705.0",
        "@aws-sdk/lib-dynamodb": "^3.705.0",
        "@clerk/types": "^4.40.2",
        "@cybrid/cybrid-api-bank-typescript": "^0.123.137",
        "aws-lambda": "^1.0.7",
        "axios": "^1.7.9",
        "decimal.js": "^10.5.0",
        "f-labs": "^1.0.7",
        "joi": "^17.13.3",
        "graphql": "^16.10.0",
        "zod": "^3.24.1"
    },
    "devDependencies": {
        "@types/aws-lambda": "^8.10.148",
        "@types/jest": "^29.5.14",
        "@types/node": "^16.18.126",
        "@types/uuid": "^10.0.0",
        "typescript": "^5.0.3"
    },
    "scripts": {
        "build": "node_modules/typescript/bin/tsc",
        "test": "jest",
        "test:watch": "jest --watch",
        "test:coverage": "jest --coverage"
    }
}
</file>

<file path="lambdas/services/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/shared/services/AdminFirebaseService.ts">
import * as admin from 'firebase-admin';
import { createLogger } from '../../../layers/commons/utils/logger_v2';

/**
 * Service for Firebase Admin SDK operations
 */
export class AdminFirebaseService {
    private logger = createLogger('AdminFirebaseService');
    private firebaseAdmin: admin.app.App;

    /**
     * Initialize the Firebase Admin service
     * @param app - Firebase Admin app instance
     */
    constructor(app: admin.app.App) {
        this.firebaseAdmin = app;
    }

    /**
     * Get a server timestamp for Firestore
     * @returns Firestore server timestamp
     */
    getServerTimestamp(): admin.firestore.FieldValue {
        return admin.firestore.FieldValue.serverTimestamp();
    }

    /**
     * Update a user document in Firestore
     * @param userId - User ID
     * @param data - Data to update
     */
    async updateUserDocument(userId: string, data: Record<string, any>): Promise<void> {
        try {
            this.logger.info('Updating user document', { userId });
            const userRef = this.firebaseAdmin.firestore().collection('users').doc(userId.trim());
            await userRef.update(data);
            this.logger.info('User document updated successfully', { userId });
        } catch (error) {
            this.logger.error('Error updating user document', error);
            throw error;
        }
    }

    /**
     * Set a user as verified in Firebase Auth
     * @param userId - User ID
     */
    async setUserVerified(userId: string): Promise<void> {
        try {
            this.logger.info('Setting user as verified', { userId });

            // Set custom claims
            await this.firebaseAdmin.auth().setCustomUserClaims(userId, {
                isVerified: true,
                verifiedAt: new Date().toISOString(),
            });

            // Force token refresh
            await this.firebaseAdmin.auth().revokeRefreshTokens(userId);

            this.logger.info('User set as verified successfully', { userId });
        } catch (error) {
            this.logger.error('Error setting user as verified', error);
            throw error;
        }
    }
}
</file>

<file path="lambdas/shared/services/book-transfer-service.ts">
/**
 * Book transfer service for handling Cybrid book transfers
 * Used for internal money movement between accounts
 */

import { Logger } from '@aws-lambda-powertools/logger';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'book-transfer-service',
});

const secretsClient = new SecretsManagerClient({ region: process.env.AWS_REGION });

// Helper functions
const getCybridToken = async (): Promise<string> => {
    const secretName = process.env.CYBRID_SECRET_NAME || '/cybrid/api-keys/dev';
    
    try {
        const command = new GetSecretValueCommand({ SecretId: secretName });
        const data = await secretsClient.send(command);
        
        if (!data.SecretString) {
            throw new Error('Failed to get Cybrid client credentials');
        }
        
        const secret = JSON.parse(data.SecretString);
        
        const authUrl = `${process.env.CYBRID_URL_SCHEME || 'https'}://id.${process.env.CYBRID_BASE_URL || 'sandbox.cybrid.app'}/oauth/token`;
        const scopes = [
            'quotes:read',
            'quotes:execute',
            'transfers:read',
            'transfers:execute',
        ];
        
        const requestData = {
            grant_type: 'client_credentials',
            client_id: secret.client_id,
            client_secret: secret.client_secret,
            scope: scopes.join(' '),
        };
        
        const response = await axios.post(authUrl, requestData, {
            headers: { 'Content-Type': 'application/json' },
        });
        
        return response.data.access_token;
    } catch (error) {
        logger.error('Error retrieving Cybrid token', { error });
        throw new Error('Failed to get Cybrid authentication token');
    }
};

const getCybridUrl = {
    quotes: () => `${process.env.CYBRID_URL_SCHEME || 'https'}://bank.${process.env.CYBRID_BASE_URL || 'sandbox.cybrid.app'}/api/quotes`,
    transfers: () => `${process.env.CYBRID_URL_SCHEME || 'https'}://bank.${process.env.CYBRID_BASE_URL || 'sandbox.cybrid.app'}/api/transfers`,
};

export interface BookTransferRequest {
    sourceAccountId: string;
    destinationAccountId: string;
    amount: number; // Amount in cents
    asset: string;
    memo?: string;
    metadata?: Record<string, any>;
    // Source participant details
    sourceParticipantType: 'bank' | 'customer';
    sourceParticipantGuid: string;
    // Destination participant details
    destinationParticipantType: 'bank' | 'customer';
    destinationParticipantGuid: string;
}

export interface BookTransferResponse {
    transferGuid: string;
    quoteGuid: string;
    state: string;
    amount: number;
    asset: string;
    sourceAccountGuid: string;
    destinationAccountGuid: string;
    createdAt: string;
}

export interface CybridQuoteRequest {
    product_type: string;
    customer_guid: string;
    asset: string;
    side: string;
    receive_amount?: number;
    deliver_amount?: number;
}

export interface CybridTransferRequest {
    quote_guid: string;
    transfer_type: string;
    source_account_guid: string;
    destination_account_guid: string;
    source_participants: Array<{
        type: string;
        amount: number;
        guid: string;
    }>;
    destination_participants: Array<{
        type: string;
        amount: number;
        guid: string;
    }>;
}

export class BookTransferService {
    /**
     * Creates a book transfer between two Cybrid accounts
     * This is a two-step process: create a quote, then create a transfer
     * Can handle both bank-to-customer and customer-to-customer transfers
     */
    static async createBookTransfer(request: BookTransferRequest, requestId: string): Promise<BookTransferResponse> {
        const functionName = 'createBookTransfer';

        logger.info(`[${functionName}] Creating book transfer`, {
            requestId,
            sourceAccountId: request.sourceAccountId,
            destinationAccountId: request.destinationAccountId,
            amount: request.amount,
            asset: request.asset,
        });

        try {
            // Step 1: Create a quote for the book transfer
            // Use the appropriate customer GUID based on participant type
            const customerGuid =
                request.sourceParticipantType === 'customer'
                    ? request.sourceParticipantGuid
                    : request.destinationParticipantGuid;

            const quote = await this.createBookTransferQuote(customerGuid, request.amount, request.asset, requestId);

            logger.info(`[${functionName}] Quote created successfully`, {
                requestId,
                quoteGuid: quote.guid,
                receiveAmount: quote.receive_amount,
                deliverAmount: quote.deliver_amount,
            });

            // Step 2: Create the transfer using the quote
            const transfer = await this.createTransferFromQuote(quote.guid, request, requestId);

            logger.info(`[${functionName}] Book transfer created successfully`, {
                requestId,
                transferGuid: transfer.guid,
                state: transfer.state,
            });

            return {
                transferGuid: transfer.guid || '',
                quoteGuid: quote.guid || '',
                state: transfer.state || 'pending',
                amount: request.amount,
                asset: request.asset,
                sourceAccountGuid: request.sourceAccountId,
                destinationAccountGuid: request.destinationAccountId,
                createdAt: transfer.created_at || new Date().toISOString(),
            };
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to create book transfer`, {
                requestId,
                error: error.message,
                errorResponse: error.response?.data,
                errorStatus: error.response?.status,
            });
            throw new Error(`Failed to create book transfer: ${error.message}`);
        }
    }

    /**
     * Creates a quote for a book transfer
     */
    private static async createBookTransferQuote(
        customerGuid: string,
        amount: number,
        asset: string,
        requestId: string,
    ): Promise<any> {
        const functionName = 'createBookTransferQuote';

        logger.info(`[${functionName}] Creating book transfer quote`, {
            requestId,
            customerGuid,
            amount,
            asset,
        });

        const cybridToken = await getCybridToken();
        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        const quoteRequest: CybridQuoteRequest = {
            product_type: 'book_transfer',
            customer_guid: customerGuid,
            asset: asset,
            side: 'deposit',
            receive_amount: amount, // Amount in cents
        };

        try {
            const startTime = Date.now();
            const response = await axios.post(getCybridUrl.quotes(), quoteRequest, { headers });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Quote created`, {
                requestId,
                quoteGuid: response.data.guid,
                latencyMs: latency,
            });

            return response.data;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to create quote`, {
                requestId,
                error: error.message,
                errorResponse: error.response?.data,
            });
            throw error;
        }
    }

    /**
     * Creates a transfer from a quote
     */
    private static async createTransferFromQuote(
        quoteGuid: string,
        request: BookTransferRequest,
        requestId: string,
    ): Promise<any> {
        const functionName = 'createTransferFromQuote';

        logger.info(`[${functionName}] Creating transfer from quote`, {
            requestId,
            quoteGuid,
            sourceAccountGuid: request.sourceAccountId,
            destinationAccountGuid: request.destinationAccountId,
        });

        const cybridToken = await getCybridToken();
        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        const transferRequest: CybridTransferRequest = {
            quote_guid: quoteGuid,
            transfer_type: 'book',
            source_account_guid: request.sourceAccountId,
            destination_account_guid: request.destinationAccountId,
            source_participants: [
                {
                    type: request.sourceParticipantType,
                    amount: request.amount,
                    guid: request.sourceParticipantGuid,
                },
            ],
            destination_participants: [
                {
                    type: request.destinationParticipantType,
                    amount: request.amount,
                    guid: request.destinationParticipantGuid,
                },
            ],
        };

        try {
            const startTime = Date.now();
            const response = await axios.post(getCybridUrl.transfers(), transferRequest, { headers });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Transfer created`, {
                requestId,
                transferGuid: response.data.guid,
                state: response.data.state,
                latencyMs: latency,
            });

            return response.data;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to create transfer`, {
                requestId,
                error: error.message,
                errorResponse: error.response?.data,
            });
            throw error;
        }
    }

    /**
     * Gets the status of a transfer
     */
    static async getTransferStatus(transferGuid: string, requestId: string): Promise<any> {
        const functionName = 'getTransferStatus';

        logger.info(`[${functionName}] Getting transfer status`, {
            requestId,
            transferGuid,
        });

        const cybridToken = await getCybridToken();
        const headers = {
            Authorization: `Bearer ${cybridToken}`,
            'Content-Type': 'application/json',
        };

        try {
            const startTime = Date.now();
            const response = await axios.get(`${getCybridUrl.transfers()}/${transferGuid}`, { headers });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Transfer status retrieved`, {
                requestId,
                transferGuid,
                state: response.data.state,
                latencyMs: latency,
            });

            return response.data;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to get transfer status`, {
                requestId,
                transferGuid,
                error: error.message,
                errorResponse: error.response?.data,
            });
            throw error;
        }
    }
}
</file>

<file path="lambdas/shared/services/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/shared/services/unified-transaction-service.test.ts">
/**
 * Unit tests for unified transaction service
 */

import { mockClient } from 'aws-sdk-client-mock';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, GetCommand, TransactWriteCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';
import { UnifiedTransactionService } from './unified-transaction-service';
import {
    CreateTransactionInput,
    UpdateTransactionInput,
    TransactionType,
    TransactionStatus,
    EntityType,
    PaymentProvider,
} from '../types/transaction.types';

// Mock the DynamoDB client
const ddbMock = mockClient(DynamoDBDocumentClient);

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn(() => 'test-transaction-id'),
}));

// Mock DateUtil
jest.mock('commons', () => ({
    DateUtil: {
        now: jest.fn(() => '2025-01-01T00:00:00.000Z'),
    },
    dynamoDB: {
        transactWrite: jest.fn((params) => ddbMock.send(new TransactWriteCommand(params))),
        get: jest.fn((params) => ddbMock.send(new GetCommand(params))),
        query: jest.fn((params) => ddbMock.send(new QueryCommand(params))),
    },
}));

describe('UnifiedTransactionService', () => {
    beforeEach(() => {
        ddbMock.reset();
        jest.clearAllMocks();
    });

    describe('createTransaction', () => {
        it('should create a transaction for P2P transfer', async () => {
            // Arrange
            const input: CreateTransactionInput = {
                type: TransactionType.P2P_TRANSFER,
                provider: PaymentProvider.CYBRID,
                amount: 10000, // $100.00 in cents
                asset: 'USD',
                sender: {
                    entityId: 'user123',
                    entityType: EntityType.USER,
                    name: 'John Doe',
                    clkktag: 'johndoe',
                    email: 'john@example.com',
                },
                recipient: {
                    entityId: 'user456',
                    entityType: EntityType.USER,
                    name: 'Jane Smith',
                    clkktag: 'janesmith',
                    email: 'jane@example.com',
                },
                memo: 'Test payment',
                sourceAccountId: 'acc123',
                destinationAccountId: 'acc456',
            };

            ddbMock.on(TransactWriteCommand).resolves({});

            // Act
            const result = await UnifiedTransactionService.createTransaction(input, 'req123');

            // Assert
            expect(result).toMatchObject({
                transactionId: 'test-transaction-id',
                type: TransactionType.P2P_TRANSFER,
                status: TransactionStatus.PENDING,
                provider: PaymentProvider.CYBRID,
                amount: 10000,
                asset: 'USD',
                sender: input.sender,
                recipient: input.recipient,
                memo: 'Test payment',
                sourceAccountId: 'acc123',
                destinationAccountId: 'acc456',
                createdAt: '2025-01-01T00:00:00.000Z',
                updatedAt: '2025-01-01T00:00:00.000Z',
            });

            // Verify DynamoDB call
            const calls = ddbMock.commandCalls(TransactWriteCommand);
            expect(calls).toHaveLength(1);
            
            const transactItems = calls[0].args[0].input.TransactItems;
            expect(transactItems).toHaveLength(3); // Sender, recipient, and index records
        });

        it('should create a transaction for P2B transfer', async () => {
            // Arrange
            const input: CreateTransactionInput = {
                type: TransactionType.P2B_TRANSFER,
                provider: PaymentProvider.CYBRID,
                amount: 50000, // $500.00 in cents
                asset: 'USD',
                sender: {
                    entityId: 'user123',
                    entityType: EntityType.USER,
                    name: 'John Doe',
                    clkktag: 'johndoe',
                },
                recipient: {
                    entityId: 'biz789',
                    entityType: EntityType.BUSINESS,
                    name: 'Acme Corp',
                    clkktag: 'acmecorp',
                },
                fees: {
                    amount: 500, // $5.00 fee
                    percentage: 1,
                    isPending: true,
                },
            };

            ddbMock.on(TransactWriteCommand).resolves({});

            // Act
            const result = await UnifiedTransactionService.createTransaction(input, 'req123');

            // Assert
            expect(result).toMatchObject({
                type: TransactionType.P2B_TRANSFER,
                amount: 50000,
                fees: {
                    amount: 500,
                    percentage: 1,
                    isPending: true,
                },
                netAmount: 49500,
            });
        });

        it('should create a transaction for deposit from system', async () => {
            // Arrange
            const input: CreateTransactionInput = {
                type: TransactionType.DEPOSIT,
                provider: PaymentProvider.NMI,
                amount: 20000, // $200.00 in cents
                asset: 'USD',
                sender: {
                    entityId: 'system',
                    entityType: EntityType.SYSTEM,
                    name: 'CLKK System',
                },
                recipient: {
                    entityId: 'user123',
                    entityType: EntityType.USER,
                    name: 'John Doe',
                    clkktag: 'johndoe',
                },
            };

            ddbMock.on(TransactWriteCommand).resolves({});

            // Act
            const result = await UnifiedTransactionService.createTransaction(input, 'req123');

            // Assert
            expect(result).toMatchObject({
                type: TransactionType.DEPOSIT,
                provider: PaymentProvider.NMI,
                amount: 20000,
            });

            // Verify only 2 records created (no sender record for system)
            const calls = ddbMock.commandCalls(TransactWriteCommand);
            const transactItems = calls[0].args[0].input.TransactItems;
            expect(transactItems).toHaveLength(2); // Recipient and index records only
        });

        it('should handle transaction creation failure', async () => {
            // Arrange
            const input: CreateTransactionInput = {
                type: TransactionType.P2P_TRANSFER,
                provider: PaymentProvider.CYBRID,
                amount: 10000,
                asset: 'USD',
                sender: {
                    entityId: 'user123',
                    entityType: EntityType.USER,
                },
                recipient: {
                    entityId: 'user456',
                    entityType: EntityType.USER,
                },
            };

            ddbMock.on(TransactWriteCommand).rejects(new Error('DynamoDB error'));

            // Act & Assert
            await expect(
                UnifiedTransactionService.createTransaction(input, 'req123')
            ).rejects.toThrow('Failed to create transaction: DynamoDB error');
        });
    });

    describe('updateTransaction', () => {
        it('should update a transaction status', async () => {
            // Arrange
            const transactionData = {
                transactionId: 'txn123',
                senderEntityId: 'user123',
                senderEntityType: EntityType.USER,
                recipientEntityId: 'user456',
                recipientEntityType: EntityType.USER,
            };

            ddbMock.on(GetCommand).resolves({ Item: transactionData });
            ddbMock.on(TransactWriteCommand).resolves({});

            const input: UpdateTransactionInput = {
                transactionId: 'txn123',
                status: TransactionStatus.COMPLETED,
                completedAt: '2025-01-01T00:05:00.000Z',
            };

            // Act
            await UnifiedTransactionService.updateTransaction(input, 'req123');

            // Assert
            const getCalls = ddbMock.commandCalls(GetCommand);
            expect(getCalls).toHaveLength(1);
            expect(getCalls[0].args[0].input.Key).toEqual({
                PK: 'TXN#txn123',
                SK: 'TXN#txn123',
            });

            const updateCalls = ddbMock.commandCalls(TransactWriteCommand);
            expect(updateCalls).toHaveLength(1);
            
            const transactItems = updateCalls[0].args[0].input.TransactItems;
            expect(transactItems).toHaveLength(3); // Update sender, recipient, and index records
        });

        it('should update a transaction with payment provider ID', async () => {
            // Arrange
            const transactionData = {
                transactionId: 'txn123',
                senderEntityId: 'user123',
                senderEntityType: EntityType.USER,
                recipientEntityId: 'biz456',
                recipientEntityType: EntityType.BUSINESS,
            };

            ddbMock.on(GetCommand).resolves({ Item: transactionData });
            ddbMock.on(TransactWriteCommand).resolves({});

            const input: UpdateTransactionInput = {
                transactionId: 'txn123',
                paymentProviderId: 'cybrid-transfer-123',
                quoteGuid: 'cybrid-quote-456',
                metadata: { cybridTransferId: 'cybrid-transfer-123' },
            };

            // Act
            await UnifiedTransactionService.updateTransaction(input, 'req123');

            // Assert
            const updateCalls = ddbMock.commandCalls(TransactWriteCommand);
            expect(updateCalls).toHaveLength(1);
        });

        it('should handle transaction not found', async () => {
            // Arrange
            ddbMock.on(GetCommand).resolves({});

            const input: UpdateTransactionInput = {
                transactionId: 'nonexistent',
                status: TransactionStatus.COMPLETED,
            };

            // Act & Assert
            await expect(
                UnifiedTransactionService.updateTransaction(input, 'req123')
            ).rejects.toThrow('Transaction nonexistent not found');
        });
    });

    describe('getTransactionById', () => {
        it('should retrieve a transaction by ID', async () => {
            // Arrange
            const transactionData = {
                PK: 'TXN#txn123',
                SK: 'TXN#txn123',
                transactionId: 'txn123',
                type: TransactionType.P2P_TRANSFER,
                status: TransactionStatus.COMPLETED,
                amount: 10000,
                asset: 'USD',
            };

            ddbMock.on(GetCommand).resolves({ Item: transactionData });

            // Act
            const result = await UnifiedTransactionService.getTransactionById('txn123', 'req123');

            // Assert
            expect(result).toEqual({
                transactionId: 'txn123',
                type: TransactionType.P2P_TRANSFER,
                status: TransactionStatus.COMPLETED,
                amount: 10000,
                asset: 'USD',
            });

            const calls = ddbMock.commandCalls(GetCommand);
            expect(calls).toHaveLength(1);
            expect(calls[0].args[0].input.Key).toEqual({
                PK: 'TXN#txn123',
                SK: 'TXN#txn123',
            });
        });

        it('should return null for non-existent transaction', async () => {
            // Arrange
            ddbMock.on(GetCommand).resolves({});

            // Act
            const result = await UnifiedTransactionService.getTransactionById('nonexistent', 'req123');

            // Assert
            expect(result).toBeNull();
        });
    });

    describe('queryTransactions', () => {
        it('should query transactions by user ID', async () => {
            // Arrange
            const transactionItems = [
                {
                    PK: 'USER#user123',
                    SK: 'TXN#2025-01-01T00:00:00.000Z#txn1',
                    transactionId: 'txn1',
                    type: TransactionType.P2P_TRANSFER,
                    status: TransactionStatus.COMPLETED,
                    amount: 10000,
                },
                {
                    PK: 'USER#user123',
                    SK: 'TXN#2025-01-01T00:01:00.000Z#txn2',
                    transactionId: 'txn2',
                    type: TransactionType.DEPOSIT,
                    status: TransactionStatus.COMPLETED,
                    amount: 20000,
                },
            ];

            ddbMock.on(QueryCommand).resolves({ Items: transactionItems });

            // Act
            const result = await UnifiedTransactionService.queryTransactions(
                { userId: 'user123', limit: 10 },
                'req123'
            );

            // Assert
            expect(result).toHaveLength(2);
            expect(result[0]).toEqual({
                transactionId: 'txn1',
                type: TransactionType.P2P_TRANSFER,
                status: TransactionStatus.COMPLETED,
                amount: 10000,
            });

            const calls = ddbMock.commandCalls(QueryCommand);
            expect(calls).toHaveLength(1);
            expect(calls[0].args[0].input.KeyConditionExpression).toContain('PK = :pk');
        });

        it('should query transactions with filters', async () => {
            // Arrange
            const transactionItems = [
                {
                    PK: 'USER#user123',
                    SK: 'TXN#2025-01-01T00:00:00.000Z#txn1',
                    transactionId: 'txn1',
                    type: TransactionType.P2P_TRANSFER,
                    status: TransactionStatus.COMPLETED,
                    provider: PaymentProvider.CYBRID,
                    amount: 10000,
                    createdAt: '2025-01-01T00:00:00.000Z',
                },
            ];

            ddbMock.on(QueryCommand).resolves({ Items: transactionItems });

            // Act
            const result = await UnifiedTransactionService.queryTransactions(
                {
                    userId: 'user123',
                    status: TransactionStatus.COMPLETED,
                    type: TransactionType.P2P_TRANSFER,
                    provider: PaymentProvider.CYBRID,
                    startDate: '2025-01-01T00:00:00.000Z',
                    endDate: '2025-01-01T23:59:59.999Z',
                },
                'req123'
            );

            // Assert
            expect(result).toHaveLength(1);

            const calls = ddbMock.commandCalls(QueryCommand);
            expect(calls).toHaveLength(1);
            const queryInput = calls[0].args[0].input;
            expect(queryInput.FilterExpression).toContain('status = :status');
            expect(queryInput.FilterExpression).toContain('type = :type');
            expect(queryInput.FilterExpression).toContain('provider = :provider');
            expect(queryInput.FilterExpression).toContain('createdAt >= :startDate');
            expect(queryInput.FilterExpression).toContain('createdAt <= :endDate');
        });
    });
});
</file>

<file path="lambdas/shared/services/unified-transaction-service.ts">
/**
 * Unified transaction service for all payment providers
 */

import { Logger } from '@aws-lambda-powertools/logger';
import { v4 as uuidv4 } from 'uuid';
import { DateUtil } from '../utils/date-util';
import { dynamoDB } from '../utils/dynamodb';
import {
    UnifiedTransaction,
    CreateTransactionInput,
    UpdateTransactionInput,
    TransactionStatus,
    TransactionType,
    EntityType,
    PaymentProvider,
    TransactionQueryOptions,
} from '../types/transaction.types';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'unified-transaction-service',
});

export class UnifiedTransactionService {
    /**
     * Creates a new transaction in the database
     * Creates records for both sender and recipient entities
     */
    static async createTransaction(input: CreateTransactionInput, requestId: string): Promise<UnifiedTransaction> {
        const functionName = 'createTransaction';
        const transactionId = uuidv4();
        const timestamp = DateUtil.now();

        logger.info(`[${functionName}] Creating new transaction`, {
            requestId,
            transactionId,
            type: input.type,
            provider: input.provider,
            amount: input.amount,
            senderEntityId: input.sender.entityId,
            recipientEntityId: input.recipient.entityId,
        });

        // Build the base transaction object
        const transaction: UnifiedTransaction = {
            // Identifiers
            userId: input.sender.entityType === EntityType.USER ? input.sender.entityId : '',
            transactionId,

            // Type and status
            type: input.type,
            status: TransactionStatus.PENDING,
            provider: input.provider,

            // Amounts
            amount: input.amount,
            asset: input.asset,
            fees: input.fees
                ? {
                      amount: input.fees.amount || 0,
                      percentage: input.fees.percentage || 0,
                      isPending: input.fees.isPending ?? true,
                  }
                : undefined,
            netAmount: input.amount - (input.fees?.amount || 0),

            // Entities
            sender: input.sender,
            recipient: input.recipient,

            // Account references
            sourceAccountId: input.sourceAccountId,
            destinationAccountId: input.destinationAccountId,

            // Metadata
            memo: input.memo,
            metadata: input.metadata,

            // Timestamps
            createdAt: timestamp,
            updatedAt: timestamp,
        };

        // Prepare DynamoDB items
        const transactionItems = [];

        // 1. Create sender's transaction record
        if (input.sender.entityType === EntityType.USER) {
            const senderKeys = SingleTableKeys.transaction(input.sender.entityId, timestamp, transactionId);
            const senderRecord = {
                ...senderKeys,
                ...transaction,
                entityType: 'TRANSACTION',
                // GSI keys for efficient querying
                TransactionIdKey: `TXN#${transactionId}`,
                SenderIdKey: `SENDER#${input.sender.entityId}`,
                RecipientIdKey: `RECIPIENT#${input.recipient.entityId}`,
                // Additional fields for queries
                senderEntityId: input.sender.entityId,
                senderEntityType: input.sender.entityType,
                senderName: input.sender.name,
                senderClkktag: input.sender.clkktag,
                senderEmail: input.sender.email,
                recipientEntityId: input.recipient.entityId,
                recipientEntityType: input.recipient.entityType,
                recipientName: input.recipient.name,
                recipientClkktag: input.recipient.clkktag,
                recipientEmail: input.recipient.email,
            };

            transactionItems.push({
                Put: {
                    TableName: SINGLE_TABLE_NAME,
                    Item: senderRecord,
                },
            });
        }

        // 2. Create recipient's transaction record (if user or business)
        if (input.recipient.entityType !== EntityType.SYSTEM) {
            const recipientUserId =
                input.recipient.entityType === EntityType.USER
                    ? input.recipient.entityId
                    : `BUSINESS#${input.recipient.entityId}`;

            const recipientKeys = SingleTableKeys.transaction(recipientUserId, timestamp, transactionId);
            const recipientRecord = {
                ...recipientKeys,
                ...transaction,
                entityType: 'TRANSACTION',
                userId: input.recipient.entityType === EntityType.USER ? input.recipient.entityId : '',
                // GSI keys
                TransactionIdKey: `TXN#${transactionId}`,
                SenderIdKey: `SENDER#${input.sender.entityId}`,
                RecipientIdKey: `RECIPIENT#${input.recipient.entityId}`,
                // Additional fields
                senderEntityId: input.sender.entityId,
                senderEntityType: input.sender.entityType,
                senderName: input.sender.name,
                senderClkktag: input.sender.clkktag,
                senderEmail: input.sender.email,
                recipientEntityId: input.recipient.entityId,
                recipientEntityType: input.recipient.entityType,
                recipientName: input.recipient.name,
                recipientClkktag: input.recipient.clkktag,
                recipientEmail: input.recipient.email,
            };

            transactionItems.push({
                Put: {
                    TableName: SINGLE_TABLE_NAME,
                    Item: recipientRecord,
                },
            });
        }

        // 3. Create a transaction index record for quick lookups
        const indexKeys = {
            PK: `TXN#${transactionId}`,
            SK: `TXN#${transactionId}`,
        };

        const indexRecord = {
            ...indexKeys,
            ...transaction,
            entityType: 'TRANSACTION_INDEX',
            // Store entity details for quick access
            senderEntityId: input.sender.entityId,
            senderEntityType: input.sender.entityType,
            recipientEntityId: input.recipient.entityId,
            recipientEntityType: input.recipient.entityType,
            // Add timestamp for reference when updating user records
            transactionTimestamp: timestamp,
        };

        transactionItems.push({
            Put: {
                TableName: SINGLE_TABLE_NAME,
                Item: indexRecord,
            },
        });

        logger.debug(`[${functionName}] Transaction items prepared`, {
            requestId,
            transactionId,
            itemCount: transactionItems.length,
        });

        // Execute the transaction
        try {
            const startTime = Date.now();
            await dynamoDB.transactWrite({ TransactItems: transactionItems });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Transaction created successfully`, {
                requestId,
                transactionId,
                latencyMs: latency,
                recordsCreated: transactionItems.length,
            });

            return transaction;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to create transaction`, {
                requestId,
                transactionId,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to create transaction: ${error.message}`);
        }
    }

    /**
     * Updates an existing transaction
     */
    static async updateTransaction(input: UpdateTransactionInput, requestId: string): Promise<void> {
        const functionName = 'updateTransaction';
        const timestamp = DateUtil.now();

        logger.info(`[${functionName}] Updating transaction`, {
            requestId,
            transactionId: input.transactionId,
            updates: Object.keys(input).filter((k) => k !== 'transactionId'),
        });

        // First, get the transaction index to find all related records
        const indexKeys = {
            PK: `TXN#${input.transactionId}`,
            SK: `TXN#${input.transactionId}`,
        };

        const indexResult = await dynamoDB.get({
            TableName: SINGLE_TABLE_NAME,
            Key: indexKeys,
        });

        if (!indexResult) {
            logger.error(`[${functionName}] Transaction not found`, {
                requestId,
                transactionId: input.transactionId,
            });
            throw new Error(`Transaction ${input.transactionId} not found`);
        }

        const transactionIndex = indexResult as any;

        // Build update expression
        const updateExpressions: string[] = ['SET #updatedAt = :updatedAt'];
        const expressionAttributeNames: any = {
            '#updatedAt': 'updatedAt',
        };
        const expressionAttributeValues: any = {
            ':updatedAt': timestamp,
        };

        if (input.status !== undefined) {
            updateExpressions.push('#status = :status');
            expressionAttributeNames['#status'] = 'status';
            expressionAttributeValues[':status'] = input.status;
        }

        if (input.paymentProviderId !== undefined) {
            updateExpressions.push('paymentProviderId = :paymentProviderId');
            updateExpressions.push('ProviderTransactionIdKey = :providerTransactionIdKey');
            expressionAttributeValues[':paymentProviderId'] = input.paymentProviderId;
            expressionAttributeValues[':providerTransactionIdKey'] = input.paymentProviderId;
        }

        if (input.quoteGuid !== undefined) {
            updateExpressions.push('quoteGuid = :quoteGuid');
            expressionAttributeValues[':quoteGuid'] = input.quoteGuid;
        }

        if (input.completedAt !== undefined) {
            updateExpressions.push('completedAt = :completedAt');
            expressionAttributeValues[':completedAt'] = input.completedAt;
        }

        if (input.failureCode !== undefined) {
            updateExpressions.push('failureCode = :failureCode');
            expressionAttributeValues[':failureCode'] = input.failureCode;
        }

        if (input.failureReason !== undefined) {
            updateExpressions.push('failureReason = :failureReason');
            expressionAttributeValues[':failureReason'] = input.failureReason;
        }

        if (input.metadata !== undefined) {
            updateExpressions.push('metadata = :metadata');
            expressionAttributeValues[':metadata'] = input.metadata;
        }

        const updateExpression = updateExpressions.join(', ');

        // Prepare update items for all transaction records
        const updateItems = [];

        // Get the transaction timestamp from the index record
        const transactionTimestamp = transactionIndex.transactionTimestamp || transactionIndex.createdAt;

        // Update sender's record if exists
        if (transactionIndex.senderEntityType === EntityType.USER) {
            const senderKeys = SingleTableKeys.transaction(transactionIndex.senderEntityId, transactionTimestamp, input.transactionId);
            updateItems.push({
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: senderKeys,
                    UpdateExpression: updateExpression,
                    ExpressionAttributeNames: expressionAttributeNames,
                    ExpressionAttributeValues: expressionAttributeValues,
                },
            });
        }

        // Update recipient's record if exists
        if (transactionIndex.recipientEntityType !== EntityType.SYSTEM) {
            const recipientUserId =
                transactionIndex.recipientEntityType === EntityType.USER
                    ? transactionIndex.recipientEntityId
                    : `BUSINESS#${transactionIndex.recipientEntityId}`;

            const recipientKeys = SingleTableKeys.transaction(recipientUserId, transactionTimestamp, input.transactionId);
            updateItems.push({
                Update: {
                    TableName: SINGLE_TABLE_NAME,
                    Key: recipientKeys,
                    UpdateExpression: updateExpression,
                    ExpressionAttributeNames: expressionAttributeNames,
                    ExpressionAttributeValues: expressionAttributeValues,
                },
            });
        }

        // Update the index record
        updateItems.push({
            Update: {
                TableName: SINGLE_TABLE_NAME,
                Key: indexKeys,
                UpdateExpression: updateExpression,
                ExpressionAttributeNames: expressionAttributeNames,
                ExpressionAttributeValues: expressionAttributeValues,
            },
        });

        logger.debug(`[${functionName}] Update items prepared`, {
            requestId,
            transactionId: input.transactionId,
            itemCount: updateItems.length,
            updateExpression,
        });

        // Execute the updates
        try {
            const startTime = Date.now();
            await dynamoDB.transactWrite({ TransactItems: updateItems });
            const latency = Date.now() - startTime;

            logger.info(`[${functionName}] Transaction updated successfully`, {
                requestId,
                transactionId: input.transactionId,
                latencyMs: latency,
                recordsUpdated: updateItems.length,
            });
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to update transaction`, {
                requestId,
                transactionId: input.transactionId,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to update transaction: ${error.message}`);
        }
    }

    /**
     * Helper function to transform raw transaction data to UnifiedTransaction format
     */
    private static transformToUnifiedTransaction(rawTransaction: any): UnifiedTransaction {
        // For deposits, the userId should be the receiverId (the person receiving the deposit)
        let userId = rawTransaction.userId || '';
        if (!userId && rawTransaction.type === 'DEPOSIT' && rawTransaction.receiverId) {
            userId = rawTransaction.receiverId;
        } else if (!userId && rawTransaction.senderId) {
            userId = rawTransaction.senderId;
        }

        return {
            userId,
            transactionId: rawTransaction.transactionId,
            type: rawTransaction.type,
            status: rawTransaction.status,
            provider: rawTransaction.provider || PaymentProvider.CYBRID,
            amount: typeof rawTransaction.amount === 'string' ? parseFloat(rawTransaction.amount) * 100 : rawTransaction.amount,
            asset: rawTransaction.currency || rawTransaction.asset || 'USD',
            sender: rawTransaction.sender || {
                entityId: rawTransaction.senderId || 'system',
                entityType: rawTransaction.senderType || EntityType.SYSTEM,
                name: rawTransaction.senderName || 'System',
            },
            recipient: rawTransaction.recipient || {
                entityId: rawTransaction.receiverId || rawTransaction.recipientEntityId || userId || '',
                entityType: rawTransaction.receiverType || rawTransaction.recipientType || EntityType.USER,
                name: rawTransaction.recipientName || rawTransaction.receiverName || '',
                email: rawTransaction.recipientEmail || rawTransaction.receiverEmail,
            },
            paymentProviderId: rawTransaction.paymentProviderId || rawTransaction.providerTransactionId,
            quoteGuid: rawTransaction.quoteGuid,
            sourceAccountId: rawTransaction.sourceAccountId,
            destinationAccountId: rawTransaction.destinationAccountId,
            memo: rawTransaction.memo,
            metadata: rawTransaction.metadata,
            createdAt: rawTransaction.createdAt || rawTransaction.CreatedAt,
            updatedAt: rawTransaction.updatedAt || rawTransaction.UpdatedAt,
            completedAt: rawTransaction.completedAt,
            failureCode: rawTransaction.failureCode,
            failureReason: rawTransaction.failureReason,
        };
    }

    /**
     * Retrieves a transaction by ID
     */
    static async getTransactionById(transactionId: string, requestId: string): Promise<UnifiedTransaction | null> {
        const functionName = 'getTransactionById';

        logger.info(`[${functionName}] Retrieving transaction`, {
            requestId,
            transactionId,
        });

        const keys = {
            PK: `TXN#${transactionId}`,
            SK: `TXN#${transactionId}`,
        };

        try {
            const startTime = Date.now();
            const result = await dynamoDB.get({
                TableName: SINGLE_TABLE_NAME,
                Key: keys,
            });
            const latency = Date.now() - startTime;

            if (!result) {
                logger.info(`[${functionName}] Transaction not found`, {
                    requestId,
                    transactionId,
                    latencyMs: latency,
                });
                return null;
            }

            logger.info(`[${functionName}] Transaction retrieved successfully`, {
                requestId,
                transactionId,
                latencyMs: latency,
            });

            // Remove DynamoDB specific fields and transform to UnifiedTransaction format
            const { PK, SK, ...rawTransaction } = result as any;
            
            return this.transformToUnifiedTransaction(rawTransaction);
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to retrieve transaction`, {
                requestId,
                transactionId,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to retrieve transaction: ${error.message}`);
        }
    }

    /**
     * Retrieves a transaction by payment provider ID
     */
    static async getTransactionByProviderId(
        providerId: string,
        provider: PaymentProvider,
        requestId: string,
    ): Promise<UnifiedTransaction | null> {
        const functionName = 'getTransactionByProviderId';

        logger.info(`[${functionName}] Retrieving transaction by provider ID`, {
            requestId,
            providerId,
            provider,
        });

        try {
            const startTime = Date.now();

            // Use the ProviderTransactionIndex GSI for efficient lookup
            const params = {
                TableName: SINGLE_TABLE_NAME,
                IndexName: 'ProviderTransactionIndex',
                KeyConditionExpression: 'ProviderTransactionIdKey = :providerId',
                ExpressionAttributeValues: {
                    ':providerId': providerId,
                },
                Limit: 1,
            };

            const result = await dynamoDB.query(params);
            const latency = Date.now() - startTime;

            if (!result.Items || result.Items.length === 0) {
                logger.info(`[${functionName}] Transaction not found by provider ID`, {
                    requestId,
                    providerId,
                    provider,
                    latencyMs: latency,
                });
                return null;
            }

            logger.info(`[${functionName}] Transaction retrieved successfully`, {
                requestId,
                providerId,
                provider,
                latencyMs: latency,
            });

            // Remove DynamoDB specific fields and transform to UnifiedTransaction format
            const { PK, SK, ...rawTransaction } = result.Items[0] as any;
            
            return this.transformToUnifiedTransaction(rawTransaction);
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to retrieve transaction by provider ID`, {
                requestId,
                providerId,
                provider,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to retrieve transaction by provider ID: ${error.message}`);
        }
    }

    /**
     * Queries transactions based on various criteria
     */
    static async queryTransactions(options: TransactionQueryOptions, requestId: string): Promise<UnifiedTransaction[]> {
        const functionName = 'queryTransactions';

        logger.info(`[${functionName}] Querying transactions`, {
            requestId,
            options,
        });

        try {
            const transactions: UnifiedTransaction[] = [];
            const limit = options.limit || 20;

            // Determine the best query strategy based on provided options
            if (options.transactionId) {
                // Direct lookup by transaction ID
                const transaction = await this.getTransactionById(options.transactionId, requestId);
                if (transaction) {
                    transactions.push(transaction);
                }
            } else if (options.userId) {
                // Query by user ID
                const params: any = {
                    TableName: SINGLE_TABLE_NAME,
                    KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
                    ExpressionAttributeValues: {
                        ':pk': `USER#${options.userId}`,
                        ':skPrefix': 'TXN#',
                    },
                    Limit: limit,
                    ScanIndexForward: false, // Most recent first
                };

                // Add filters
                const filterExpressions = [];
                const expressionAttributeNames: any = {};

                if (options.status) {
                    filterExpressions.push('#status = :status');
                    expressionAttributeNames['#status'] = 'status';
                    params.ExpressionAttributeValues[':status'] = options.status;
                }

                if (options.type) {
                    filterExpressions.push('#type = :type');
                    expressionAttributeNames['#type'] = 'type';
                    params.ExpressionAttributeValues[':type'] = options.type;
                }

                if (options.provider) {
                    filterExpressions.push('#provider = :provider');
                    expressionAttributeNames['#provider'] = 'provider';
                    params.ExpressionAttributeValues[':provider'] = options.provider;
                }

                if (options.startDate) {
                    filterExpressions.push('#createdAt >= :startDate');
                    expressionAttributeNames['#createdAt'] = 'createdAt';
                    params.ExpressionAttributeValues[':startDate'] = options.startDate;
                }

                if (options.endDate) {
                    filterExpressions.push('#createdAt <= :endDate');
                    expressionAttributeNames['#createdAt'] = 'createdAt';
                    params.ExpressionAttributeValues[':endDate'] = options.endDate;
                }

                if (filterExpressions.length > 0) {
                    params.FilterExpression = filterExpressions.join(' AND ');
                }

                if (Object.keys(expressionAttributeNames).length > 0) {
                    params.ExpressionAttributeNames = expressionAttributeNames;
                }

                const result = await dynamoDB.query(params);

                if (result.Items) {
                    result.Items.forEach((item) => {
                        const { PK, SK, ...rawTransaction } = item as any;
                        transactions.push(this.transformToUnifiedTransaction(rawTransaction));
                    });
                }
            } else if (options.businessId) {
                // Query by business ID
                const params: any = {
                    TableName: SINGLE_TABLE_NAME,
                    KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
                    ExpressionAttributeValues: {
                        ':pk': `BUSINESS#${options.businessId}`,
                        ':skPrefix': 'TXN#',
                    },
                    Limit: limit,
                    ScanIndexForward: false,
                };

                const result = await dynamoDB.query(params);

                if (result.Items) {
                    result.Items.forEach((item) => {
                        const { PK, SK, ...rawTransaction } = item as any;
                        transactions.push(this.transformToUnifiedTransaction(rawTransaction));
                    });
                }
            }

            logger.info(`[${functionName}] Query completed`, {
                requestId,
                transactionsFound: transactions.length,
            });

            return transactions;
        } catch (error: any) {
            logger.error(`[${functionName}] Failed to query transactions`, {
                requestId,
                options,
                error: error.message,
                errorType: error.constructor.name,
            });
            throw new Error(`Failed to query transactions: ${error.message}`);
        }
    }
}
</file>

<file path="lambdas/shared/types/transaction.types.ts">
/**
 * Unified transaction types for all payment providers
 */

export enum TransactionType {
    DEPOSIT = 'DEPOSIT',
    WITHDRAWAL = 'WITHDRAWAL',
    P2P_TRANSFER = 'P2P_TRANSFER',
    P2B_TRANSFER = 'P2B_TRANSFER',
    B2P_TRANSFER = 'B2P_TRANSFER',
    BOOK_TRANSFER = 'BOOK_TRANSFER',
}

export enum TransactionStatus {
    PENDING = 'PENDING',
    PROCESSING = 'PROCESSING',
    COMPLETED = 'COMPLETED',
    FAILED = 'FAILED',
    CANCELLED = 'CANCELLED',
}

export enum EntityType {
    USER = 'USER',
    BUSINESS = 'BUSINESS',
    SYSTEM = 'SYSTEM', // For master account transfers
}

export enum PaymentProvider {
    CYBRID = 'CYBRID',
    NMI = 'NMI',
    CHECKBOOK = 'CHECKBOOK',
    INTERNAL = 'INTERNAL',
}

export interface TransactionEntity {
    entityId: string;
    entityType: EntityType;
    name?: string;
    clkktag?: string;
    email?: string;
}

export interface TransactionFees {
    amount: number;
    percentage: number;
    isPending: boolean;
}

export interface UnifiedTransaction {
    // Primary identifiers
    userId: string;
    transactionId: string;
    
    // Type and status
    type: TransactionType;
    status: TransactionStatus;
    provider: PaymentProvider;
    
    // Amounts (in smallest unit - cents)
    amount: number;
    asset: string;
    fees?: TransactionFees;
    netAmount?: number;
    
    // Entities
    sender: TransactionEntity;
    recipient: TransactionEntity;
    
    // Provider-specific IDs
    paymentProviderId?: string; // Cybrid transfer GUID, NMI transaction ID, etc.
    quoteGuid?: string; // Cybrid quote GUID
    
    // Account references
    sourceAccountId?: string;
    destinationAccountId?: string;
    
    // Metadata
    memo?: string;
    metadata?: Record<string, any>;
    
    // Timestamps
    createdAt: string;
    updatedAt: string;
    completedAt?: string;
    
    // Error tracking
    failureCode?: string;
    failureReason?: string;
    
    // DynamoDB single-table design fields
    PK?: string;
    SK?: string;
    TransactionIdKey?: string;
    SenderIdKey?: string;
    RecipientIdKey?: string;
}

export interface CreateTransactionInput {
    type: TransactionType;
    provider: PaymentProvider;
    amount: number;
    asset: string;
    sender: TransactionEntity;
    recipient: TransactionEntity;
    fees?: Partial<TransactionFees>;
    memo?: string;
    metadata?: Record<string, any>;
    sourceAccountId?: string;
    destinationAccountId?: string;
}

export interface UpdateTransactionInput {
    transactionId: string;
    status?: TransactionStatus;
    paymentProviderId?: string;
    quoteGuid?: string;
    completedAt?: string;
    failureCode?: string;
    failureReason?: string;
    metadata?: Record<string, any>;
}

export interface TransactionQueryOptions {
    userId?: string;
    businessId?: string;
    transactionId?: string;
    senderId?: string;
    recipientId?: string;
    status?: TransactionStatus;
    type?: TransactionType;
    provider?: PaymentProvider;
    startDate?: string;
    endDate?: string;
    limit?: number;
}
</file>

<file path="lambdas/shared/utils/date-util.ts">
/**
 * Simple date utilities for shared services
 */

export class DateUtil {
    static now(): string {
        return new Date().toISOString();
    }

    static formatDate(date: Date | string): string {
        return new Date(date).toISOString();
    }
}
</file>

<file path="lambdas/shared/utils/dynamodb.ts">
/**
 * DynamoDB utilities for shared services
 */

import { DynamoDB } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';

const client = new DynamoDB({});
export const dynamoDB = DynamoDBDocument.from(client);
</file>

<file path="lambdas/shared/utils/single-table-keys.ts">
/**
 * Helper functions for generating keys for the single table design
 */

export const SingleTableKeys = {
    // User/Entity keys
    user: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PROFILE`,
    }),

    // Cybrid Fiat Account keys
    cybridFiatAccount: (userId: string, accountId: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_FIAT#${accountId}`,
    }),

    // Cybrid Identity Verification keys
    cybridIdentityVerification: (userId: string, verificationId: string, timestamp: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_KYC#${timestamp}#${verificationId}`,
    }),

    // Plaid Access Token keys
    plaidAccessToken: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PLAID_TOKEN`,
    }),

    // Transaction keys
    transaction: (userId: string, timestamp: string, transactionId: string) => ({
        PK: `USER#${userId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Transaction keys for business accounts
    businessTransaction: (businessId: string, timestamp: string, transactionId: string) => ({
        PK: `BUSINESS#${businessId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Query patterns for GSIs
    gsiKeys: {
        // For querying by Cybrid customer ID (using ExternalIdIndex)
        byCybridCustomerId: (customerId: string) => ({
            ExternalIdKey: `CYBRID_CUSTOMER#${customerId}`,
            ProviderIdKey: 'CYBRID',
        }),

        // For querying fiat accounts by customer ID
        fiatAccountByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_FIAT_ACCOUNT',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For KYC status queries
        byKycStatus: (status: string, userId: string) => ({
            KYCStatusKey: `STATUS#${status}`,
            EntityTypeIdKey: `USER#${userId}`,
        }),

        // For identity verifications by customer ID
        identityVerificationByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_IDENTITY_VERIFICATION',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For transaction lookups by ID
        transactionById: (transactionId: string) => ({
            TransactionIdKey: `TXN#${transactionId}`,
        }),

        // For querying transactions by sender
        transactionsBySender: (senderId: string) => ({
            SenderIdKey: `SENDER#${senderId}`,
        }),

        // For querying transactions by recipient
        transactionsByRecipient: (recipientId: string) => ({
            RecipientIdKey: `RECIPIENT#${recipientId}`,
        }),
    },
};

// Single table name constant
export const SINGLE_TABLE_NAME = process.env.SINGLE_TABLE_NAME || process.env.TABLE_NAME || 'clkk-app-table-dev';
</file>

<file path="lambdas/shared/package.json">
{
  "name": "shared",
  "version": "1.0.0",
  "description": "Shared services and utilities for lambdas",
  "main": "index.js",
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.755.0",
    "@aws-sdk/lib-dynamodb": "^3.755.0",
    "@aws-lambda-powertools/logger": "^1.0.0",
    "axios": "^1.0.0",
    "uuid": "^9.0.0"
  }
}
</file>

<file path="lambdas/shared/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2018",
    "module": "commonjs",
    "lib": ["ES2018"],
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "commons": ["../../layers/commons"],
      "commons/*": ["../../layers/commons/*"]
    }
  },
  "include": [
    "**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "**/*.test.ts"
  ]
}
</file>

<file path="lambdas/streams/transaction-processor/app.ts">
import { DynamoDBStreamEvent, DynamoDBRecord, Context, Callback } from 'aws-lambda';
import { unmarshall } from '@aws-sdk/util-dynamodb';
import { EventBridgeClient, PutEventsCommand } from '@aws-sdk/client-eventbridge';
import { SNSClient, PublishCommand } from '@aws-sdk/client-sns';
import { logger } from 'commons';
import { Transaction } from 'commons';

const eventBridgeClient = new EventBridgeClient({ region: process.env.AWS_REGION });
const snsClient = new SNSClient({ region: process.env.AWS_REGION });

/**
 * Processes DynamoDB stream events from the transactions table
 * and broadcasts them to EventBridge and SNS for notification
 */
export const handler = async (event: DynamoDBStreamEvent, context: Context, callback: Callback): Promise<void> => {
    logger.info('Processing transaction stream events:', {
        recordCount: event.Records.length,
        requestId: context.awsRequestId,
    });

    try {
        // Process each record in the stream batch
        const processPromises = event.Records.map(async (record, index) => {
            // Only process new or modified records
            if (record.eventName === 'INSERT' || record.eventName === 'MODIFY') {
                await processTransactionRecord(record, index, context.awsRequestId);
            }
        });

        await Promise.all(processPromises);
        callback(null, 'Successfully processed transaction stream');
    } catch (error) {
        console.error('Error processing transaction stream:', error);
        callback(error as Error);
    }
};

/**
 * Process an individual transaction record from the stream
 */
async function processTransactionRecord(record: DynamoDBRecord, recordIndex: number, requestId: string): Promise<void> {
    const recordId = `${requestId}-record-${recordIndex}`;

    // Only continue if we have new image data
    if (!record.dynamodb?.NewImage) {
        logger.info('Record missing NewImage, skipping', { recordId });
        return;
    }

    // Convert DynamoDB format to JavaScript object
    const newTransaction = unmarshall(record.dynamodb.NewImage as any) as Transaction;
    logger.info('Processing transaction:', {
        recordId,
        transactionId: newTransaction.transactionId,
        eventName: record.eventName,
    });

    // Get previous state if this is a MODIFY operation
    const oldTransaction = record.dynamodb.OldImage
        ? (unmarshall(record.dynamodb.OldImage as any) as Transaction)
        : null;

    // Check if this is a fee-related update to prevent infinite loops
    if (shouldSkipFeeUpdate(oldTransaction, newTransaction)) {
        logger.info('Skipping fee-related update to prevent infinite loop', {
            recordId,
            transactionId: newTransaction.transactionId,
        });
        // DEBUG: Ensure this early return is being executed
        logger.info('Early return point reached, no events will be sent', { recordId });
        return; // Return early, don't send any events
    }

    // If we get here, we should send the event
    logger.info('Sending event to EventBridge', {
        recordId,
        transactionId: newTransaction.transactionId,
        eventName: record.eventName,
    });

    // Send event to EventBridge for further processing
    await sendToEventBridge(newTransaction, record.eventName as string);
}

/**
 * Determines if an update should be skipped to prevent infinite loops
 * from fee processing updates
 */
function shouldSkipFeeUpdate(oldTransaction: Transaction | null, newTransaction: Transaction): boolean {
    // Only applies to MODIFY operations with old image
    if (!oldTransaction) return false;

    // If the only changes are to fee_pending, fee_transfer_id, or fee_processed_at
    // then this is likely an update from the fee processor and should be skipped
    const feeFieldsChanged =
        oldTransaction.fee_pending !== newTransaction.fee_pending ||
        oldTransaction.fee_transfer_id !== newTransaction.fee_transfer_id ||
        oldTransaction.fee_processed_at !== newTransaction.fee_processed_at;

    const otherFieldsChanged =
        oldTransaction.status !== newTransaction.status ||
        oldTransaction.amount !== newTransaction.amount ||
        // Add other important fields you don't want to skip
        oldTransaction.type !== newTransaction.type;

    // Skip if only fee fields changed but no other important fields
    return feeFieldsChanged && !otherFieldsChanged;
}

/**
 * Sends transaction data to EventBridge event bus
 */
async function sendToEventBridge(transaction: Transaction, eventType: string): Promise<void> {
    try {
        // Generate a process ID for fee processing
        const processId = `fee-${transaction.transactionId}-${Date.now()}`;

        // Determine if this transaction needs fee processing
        const needsFeeProcessing =
            eventType === 'MODIFY' &&
            transaction.status === 'completed' &&
            transaction.type === 'p2b_transfer' &&
            transaction.fee_amount > 0 &&
            transaction.fee_pending !== false &&
            !transaction.fee_transfer_id;

        const command = new PutEventsCommand({
            Entries: [
                {
                    EventBusName: process.env.EVENT_BUS_NAME,
                    Source: 'clkk.transactions',
                    DetailType: `Transaction${eventType}`,
                    Detail: JSON.stringify({
                        transactionId: transaction.transactionId,
                        transactionType: transaction.type,
                        // Add processId for transactions that need fee processing
                        ...(needsFeeProcessing ? { processId } : {}),
                        quoteGuid: transaction.quoteGuid,
                        source_account_guid: transaction.source_account_guid,
                        destination_account_guid: transaction.destination_account_guid,
                        sender_cy_guid: transaction.sender_cy_guid,
                        recipient_cy_guid: transaction.recipient_cy_guid,
                        amount: transaction.amount,
                        currency: transaction.asset,
                        status: transaction.status,
                        senderEntityId: transaction.senderEntityId,
                        recipientEntityId: transaction.recipientEntityId,
                        createdAt: transaction.createdAt,
                        fee_amount: transaction.fee_amount,
                        fee_percentage: transaction.fee_percentage,
                        recipient_name: transaction.recipient_name,
                        recipient_clkktag: transaction.recipient_clkktag,
                    }),
                },
            ],
        });

        logger.info('Sending event to EventBridge:', JSON.stringify(command));

        const result = await eventBridgeClient.send(command);
        logger.info('Successfully sent event to EventBridge:', result);
    } catch (error) {
        logger.error('Error sending to EventBridge:', error);
        throw error;
    }
}
</file>

<file path="lambdas/streams/transaction-processor/package.json">
{
  "name": "plaid",
  "version": "1.0.0",
  "description": "plaid lambda",
  "main": "app.js",
  "author": "CLKK",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^2.11.0",
    "@aws-sdk/client-eventbridge": "^3.705.0",
    "@aws-sdk/client-sns": "^3.705.0",
    "@aws-sdk/util-dynamodb": "^3.705.0",
    "@aws-sdk/client-dynamodb": "^3.705.0",
    "@aws-sdk/client-lambda": "^3.716.0",
    "@aws-sdk/client-secrets-manager": "^3.699.0",
    "@aws-sdk/client-sqs": "^3.716.0",
    "@aws-sdk/lib-dynamodb": "^3.705.0",
    "@cybrid/cybrid-api-bank-typescript": "^0.123.122",
    "axios": "^1.7.9",
    "esbuild": "^0.14.14",
    "jsonwebtoken": "^9.0.2",
    "plaid": "^30.0.0",
    "svix": "^1.43.0"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "@types/aws-lambda": "^8.10.146",
    "@types/jest": "^29.2.0",
    "@types/node": "^18.11.4",
    "@typescript-eslint/eslint-plugin": "^5.10.2",
    "@typescript-eslint/parser": "^5.10.2",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.2.1",
    "prettier": "^2.5.1",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
</file>

<file path="lambdas/streams/transaction-processor/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/transactions/services/package.json">
{
  "name": "plaid",
  "version": "1.0.0",
  "description": "plaid lambda",
  "main": "app.js",
  "author": "CLKK",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^2.11.0",
    "@aws-sdk/client-eventbridge": "^3.705.0",
    "@aws-sdk/client-sns": "^3.705.0",
    "@aws-sdk/util-dynamodb": "^3.705.0",
    "@aws-sdk/client-dynamodb": "^3.705.0",
    "@aws-sdk/client-lambda": "^3.716.0",
    "@aws-sdk/client-secrets-manager": "^3.699.0",
    "@aws-sdk/client-sqs": "^3.716.0",
    "@aws-sdk/lib-dynamodb": "^3.705.0",
    "@cybrid/cybrid-api-bank-typescript": "^0.123.122",
    "axios": "^1.7.9",
    "esbuild": "^0.14.14",
    "jsonwebtoken": "^9.0.2",
    "plaid": "^30.0.0",
    "svix": "^1.43.0"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "@types/aws-lambda": "^8.10.146",
    "@types/jest": "^29.2.0",
    "@types/node": "^18.11.4",
    "@typescript-eslint/eslint-plugin": "^5.10.2",
    "@typescript-eslint/parser": "^5.10.2",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.2.1",
    "prettier": "^2.5.1",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
</file>

<file path="lambdas/transactions/services/quote-service.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { getSecret } from 'commons/utils/getSecret';
import { AWS_SECRETS } from 'commons/utils/constants';
import { QuoteBankModel, PostQuoteBankModel, TransferBankModel } from '@cybrid/cybrid-api-bank-typescript';
import { CybridConfig } from 'commons/utils/cybrid';
import axios from 'axios';
import { getCybridToken } from 'commons/utils/cybrid-auth';

const logger = new Logger({ serviceName: 'cybrid-quotes' });

export class QuoteService {
    private baseUrl: string;

    constructor() {
        this.baseUrl = process.env.CYBRID_BASE_URL || '';
    }

    async createQuote(request: QuoteBankModel): Promise<QuoteBankModel> {
        logger.info('Creating quote from quote service', { request });
        const cybridToken = await getCybridToken();
        logger.info('Cybrid token REQUEST RECEIVED FROM QUOTE SERVICE');

        //log baseUrl
        logger.info('Base URL', { baseUrl: this.baseUrl });

        //TODO:use service to create quote
        try {
            const response = await axios.post(
                `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/quotes`,
                request,
                {
                    headers: {
                        'Content-Type': 'application/json',
                        Authorization: `Bearer ${cybridToken}`,
                    },
                },
            );

            logger.info('Quote response', { response: response.data });
            if (response.status !== 200 && response.status !== 201) {
                const error = response.data;
                logger.error('Failed to create quote', { error, status: response.status });
                throw new Error(`Failed to create quote: ${response.status} - ${JSON.stringify(error)}`);
            }

            const data = response.data;
            logger.info('Successfully created quote', { data });
            return data as QuoteBankModel;
        } catch (error) {
            logger.error('Error creating quote', { error });
            throw error;
        }
    }

    async getQuote(quoteId: string): Promise<QuoteBankModel> {
        logger.info('Getting quote', { quoteId });
        const cybridToken = await getCybridToken();

        try {
            const response = await axios.get(
                `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/quotes/${quoteId}`,
                {
                    headers: {
                        'Content-Type': 'application/json',
                        Authorization: `Bearer ${cybridToken}`,
                    },
                },
            );

            if (response.status !== 200) {
                const error = response.data;
                logger.error('Failed to get quote', { error, status: response.status, quoteId });
                throw new Error(`Failed to get quote: ${response.status} - ${JSON.stringify(error)}`);
            }

            const data = response.data;
            logger.info('Successfully retrieved quote', { data });
            return data as QuoteBankModel;
        } catch (error) {
            logger.error('Error getting quote', { error, quoteId });
            throw error;
        }
    }

    async createTransfer(request: any): Promise<TransferBankModel> {
        const cybridToken = await getCybridToken();
        const url = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}/api/transfers`;
        logger.info('Creating transfer', { url, request });

        const headers = {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${cybridToken}`,
        };

        const response = await axios.post(url, request, { headers });

        if (response.status !== 200 && response.status !== 201) {
            const error = response.data;
            logger.error('Error creating transfer', { error, status: response.status });
            throw new Error(JSON.stringify(error));
        }

        const data: TransferBankModel = response.data;
        logger.info('Transfer created successfully', { data });
        return data;
    }
}
</file>

<file path="lambdas/transactions/services/transaction-service.ts">
import { DynamoDB } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from '@aws-lambda-powertools/logger';
import { SingleTableKeys, SINGLE_TABLE_NAME } from '../utils/single-table-keys';

const logger = new Logger({ serviceName: 'transaction-service' });
const dynamoDb = DynamoDBDocument.from(new DynamoDB());

export enum TransactionType {
    DEPOSIT = 'deposit',
    WITHDRAWAL = 'withdrawal',
    P2P_TRANSFER = 'p2p_transfer',
    P2B_TRANSFER = 'p2b_transfer',
    TRADE = 'trade',
}

export enum TransactionStatus {
    PENDING = 'pending',
    COMPLETED = 'completed',
    FAILED = 'failed',
    CANCELLED = 'cancelled',
}

export interface Transaction {
    userId: string;
    transactionId: string;
    type: TransactionType;
    status: TransactionStatus;
    amount: number;
    asset: string;
    createdAt: string;
    updatedAt: string;
    sourceAccountId?: string;
    destinationAccountId?: string;
    quoteGuid?: string;
    paymentProviderId?: string;
    recipientId?: string;
    memo?: string;
    senderName?: string;
    senderClkktag?: string;
    recipientName?: string;
    recipientClkktag?: string;
    transferState?: string;
    failureCode?: string;
    returnCode?: string;
    recipientEntityId: string;
    senderEntityId: string;
    recipient_entity_type?: string;
    sender_entity_type?: string;
    recipient_current_email?: string;
    sender_current_email?: string;
    source_account_guid?: string;
    destination_account_guid?: string;
    recipient_cy_guid?: string;
    sender_cy_guid?: string;
    sender_name?: string;
    recipient_name?: string;
    sender_clkktag?: string;
    recipient_clkktag?: string;
    fees?: Fee;
    fee_amount?: number;
    fee_pending?: boolean;
    fee_percentage?: number;
    net_amount?: number;
}

export interface Fee {
    type: string;
    rate: number;
    spread_fee: number;
    fixed_fee: number;
}

export class TransactionService {
    /**
     * Create a new transaction record
     */
    static async createTransaction(
        transaction: Omit<Transaction, 'transactionId' | 'createdAt' | 'updatedAt'>,
    ): Promise<Transaction> {
        const now = new Date().toISOString();
        const transactionId = uuidv4();

        const newTransaction: Transaction = {
            ...transaction,
            transactionId,
            createdAt: now,
            updatedAt: now,
        };

        // Determine if this is a business or user transaction
        const isBusinessTransaction = transaction.recipientEntityId?.startsWith('business_') || 
                                     transaction.recipient_entity_type === 'business';
        
        // Create single table keys
        const keys = isBusinessTransaction && transaction.recipientEntityId
            ? SingleTableKeys.businessTransaction(transaction.recipientEntityId, now, transactionId)
            : SingleTableKeys.transaction(transaction.userId, now, transactionId);

        // Create item with single table keys
        const item = {
            ...keys,
            ...newTransaction,
            // Add GSI keys for querying
            TransactionIdKey: SingleTableKeys.gsiKeys.transactionById(transactionId).TransactionIdKey,
            SenderIdKey: transaction.senderEntityId ? SingleTableKeys.gsiKeys.transactionsBySender(transaction.senderEntityId).SenderIdKey : undefined,
            RecipientIdKey: transaction.recipientEntityId ? SingleTableKeys.gsiKeys.transactionsByRecipient(transaction.recipientEntityId).RecipientIdKey : undefined,
        };

        logger.info('Creating transaction in single table', { item });

        await dynamoDb.put({
            TableName: SINGLE_TABLE_NAME,
            Item: item,
        });

        return newTransaction;
    }

    /**
     * Update an existing transaction
     */
    static async updateTransaction(
        transactionId: string,
        updates: Partial<Omit<Transaction, 'transactionId' | 'userId' | 'createdAt'>>,
    ): Promise<Transaction> {
        const now = new Date().toISOString();

        const allUpdates = {
            ...updates,
            updatedAt: now,
        };

        let updateExpression = 'SET';
        const expressionAttributeValues: Record<string, any> = {};
        const expressionAttributeNames: Record<string, string> = {};

        Object.entries(allUpdates).forEach(([key, value], index) => {
            if (value !== undefined) {
                const prefix = index === 0 ? ' ' : ', ';
                updateExpression += `${prefix}#${key} = :${key}`;
                expressionAttributeValues[`:${key}`] = value;
                expressionAttributeNames[`#${key}`] = key;
            }
        });

        logger.info('Updating transaction', {
            transactionId,
            updates: allUpdates,
            updateExpression,
            expressionAttributeValues,
            expressionAttributeNames,
        });

        // First, get the transaction to find its PK/SK
        const existingTransaction = await this.getTransactionById(transactionId);
        if (!existingTransaction) {
            throw new Error(`Transaction not found: ${transactionId}`);
        }

        // Reconstruct the keys
        const isBusinessTransaction = existingTransaction.recipientEntityId?.startsWith('business_') || 
                                     existingTransaction.recipient_entity_type === 'business';
        
        const keys = isBusinessTransaction && existingTransaction.recipientEntityId
            ? SingleTableKeys.businessTransaction(existingTransaction.recipientEntityId, existingTransaction.createdAt, transactionId)
            : SingleTableKeys.transaction(existingTransaction.userId, existingTransaction.createdAt, transactionId);

        const result = await dynamoDb.update({
            TableName: SINGLE_TABLE_NAME,
            Key: keys,
            UpdateExpression: updateExpression,
            ExpressionAttributeValues: expressionAttributeValues,
            ExpressionAttributeNames: expressionAttributeNames,
            ReturnValues: 'ALL_NEW',
        });

        // Remove single table keys before returning
        const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = result.Attributes as any;
        return transaction as Transaction;
    }

    /**
     * Get a transaction by ID
     */
    static async getTransaction(transactionId: string): Promise<Transaction | null> {
        return this.getTransactionById(transactionId);
    }

    /**
     * Get a transaction by ID using GSI
     */
    static async getTransactionById(transactionId: string): Promise<Transaction | null> {
        logger.info('Getting transaction by ID', { transactionId });

        const result = await dynamoDb.query({
            TableName: SINGLE_TABLE_NAME,
            IndexName: 'TransactionIdIndex',
            KeyConditionExpression: 'TransactionIdKey = :tid',
            ExpressionAttributeValues: {
                ':tid': SingleTableKeys.gsiKeys.transactionById(transactionId).TransactionIdKey,
            },
            Limit: 1,
        });

        if (!result.Items || result.Items.length === 0) {
            return null;
        }

        // Remove single table keys before returning
        const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = result.Items[0] as any;
        return transaction as Transaction;
    }

    /**
     * Get all transactions for a user
     */
    static async getUserTransactions(userId: string, limit = 50): Promise<Transaction[]> {
        logger.info('Getting user transactions', { userId, limit });

        const result = await dynamoDb.query({
            TableName: SINGLE_TABLE_NAME,
            KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',
            ExpressionAttributeValues: {
                ':pk': `USER#${userId}`,
                ':skPrefix': 'TXN#',
            },
            ScanIndexForward: false, // descending order (newest first)
            Limit: limit,
        });

        // Remove single table keys from each item before returning
        return (result.Items || []).map((item: any) => {
            const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = item;
            return transaction as Transaction;
        });
    }

    /**
     * Get transactions by payment provider ID (e.g., Cybrid transfer GUID)
     */
    static async getTransactionsByPaymentProviderId(paymentProviderId: string): Promise<Transaction[]> {
        logger.info('Getting transactions by payment provider ID', { paymentProviderId });

        // Since we don't have a GSI for paymentProviderId, we need to scan with filter
        // In production, you might want to add a GSI for this access pattern
        const result = await dynamoDb.scan({
            TableName: SINGLE_TABLE_NAME,
            FilterExpression: 'paymentProviderId = :ppid AND begins_with(SK, :skPrefix)',
            ExpressionAttributeValues: {
                ':ppid': paymentProviderId,
                ':skPrefix': 'TXN#',
            },
        });

        // Remove single table keys from each item before returning
        return (result.Items || []).map((item: any) => {
            const { PK, SK, TransactionIdKey, SenderIdKey, RecipientIdKey, ...transaction } = item;
            return transaction as Transaction;
        });
    }
}
</file>

<file path="lambdas/transactions/services/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/transactions/utils/single-table-keys.ts">
/**
 * Helper functions for generating keys for the single table design
 */

export const SingleTableKeys = {
    // User/Entity keys
    user: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PROFILE`,
    }),

    // Cybrid Fiat Account keys
    cybridFiatAccount: (userId: string, accountId: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_FIAT#${accountId}`,
    }),

    // Cybrid Identity Verification keys
    cybridIdentityVerification: (userId: string, verificationId: string, timestamp: string) => ({
        PK: `USER#${userId}`,
        SK: `CYBRID_KYC#${timestamp}#${verificationId}`,
    }),

    // Plaid Access Token keys
    plaidAccessToken: (userId: string) => ({
        PK: `USER#${userId}`,
        SK: `PLAID_TOKEN`,
    }),

    // Transaction keys
    transaction: (userId: string, timestamp: string, transactionId: string) => ({
        PK: `USER#${userId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Transaction keys for business accounts
    businessTransaction: (businessId: string, timestamp: string, transactionId: string) => ({
        PK: `BUSINESS#${businessId}`,
        SK: `TXN#${timestamp}#${transactionId}`,
    }),

    // Query patterns for GSIs
    gsiKeys: {
        // For querying by Cybrid customer ID (using ExternalIdIndex)
        byCybridCustomerId: (customerId: string) => ({
            ExternalIdKey: `CYBRID_CUSTOMER#${customerId}`,
            ProviderIdKey: 'CYBRID',
        }),

        // For querying fiat accounts by customer ID
        fiatAccountByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_FIAT_ACCOUNT',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For KYC status queries
        byKycStatus: (status: string, userId: string) => ({
            KYCStatusKey: `STATUS#${status}`,
            EntityTypeIdKey: `USER#${userId}`,
        }),

        // For identity verifications by customer ID
        identityVerificationByCustomerId: (customerId: string) => ({
            EntityTypeKey: 'CYBRID_IDENTITY_VERIFICATION',
            EntityStatusSortKey: `CUSTOMER#${customerId}`,
        }),

        // For transaction lookups by ID
        transactionById: (transactionId: string) => ({
            TransactionIdKey: `TXN#${transactionId}`,
        }),

        // For querying transactions by sender
        transactionsBySender: (senderId: string) => ({
            SenderIdKey: `SENDER#${senderId}`,
        }),

        // For querying transactions by recipient
        transactionsByRecipient: (recipientId: string) => ({
            RecipientIdKey: `RECIPIENT#${recipientId}`,
        }),
    },
};

// Single table name constant
export const SINGLE_TABLE_NAME = process.env.SINGLE_TABLE_NAME || 'clkk-app-table-dev';
</file>

<file path="lambdas/transactions/package.json">
{
  "name": "plaid",
  "version": "1.0.0",
  "description": "plaid lambda",
  "main": "app.js",
  "author": "CLKK",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^2.11.0",
    "@aws-sdk/client-eventbridge": "^3.705.0",
    "@aws-sdk/client-sns": "^3.705.0",
    "@aws-sdk/util-dynamodb": "^3.705.0",
    "@aws-sdk/client-dynamodb": "^3.705.0",
    "@aws-sdk/client-lambda": "^3.716.0",
    "@aws-sdk/client-secrets-manager": "^3.699.0",
    "@aws-sdk/client-sqs": "^3.716.0",
    "@aws-sdk/lib-dynamodb": "^3.705.0",
    "@cybrid/cybrid-api-bank-typescript": "^0.123.122",
    "axios": "^1.7.9",
    "esbuild": "^0.14.14",
    "jsonwebtoken": "^9.0.2",
    "plaid": "^30.0.0",
    "svix": "^1.43.0"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "@types/aws-lambda": "^8.10.146",
    "@types/jest": "^29.2.0",
    "@types/node": "^18.11.4",
    "@typescript-eslint/eslint-plugin": "^5.10.2",
    "@typescript-eslint/parser": "^5.10.2",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.2.1",
    "prettier": "^2.5.1",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
</file>

<file path="lambdas/transactions/processPlatformFee.ts">
import { EventBridgeEvent } from 'aws-lambda';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, TransactWriteCommand, TransactWriteCommandInput } from '@aws-sdk/lib-dynamodb';
import { DYNAMO_TABLES, logger } from 'commons';
import { v4 as uuidv4 } from 'uuid';
import { QuoteService } from './services/quote-service';
import { UpdateItemCommand } from '@aws-sdk/client-dynamodb';
import { TransactionService } from './services/transaction-service';
import { UpdateCommand } from '@aws-sdk/lib-dynamodb';

// Initialize clients
const client = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(client);
const quoteService = new QuoteService();

// Constants
const PLATFORM_FEE_ACCOUNT_GUID = '9ca294342049188799998df4d86655f0';
const PLATFORM_BANK_GUID = '59d6b3a8cd8274024cde9e1cba94af28';

// Define interfaces for our data model
interface PlatformRevenueItem {
    revenueId: string;
    transactionId: string;
    businessId: string;
    businessName: string;
    businessClkkTag: string;
    amount: number;
    asset: string;
    sourceAccountId: string;
    status: string;
    type: string;
    provider: string;
    createdAt: string;
    updatedAt: string;
}

interface Transaction {
    transactionId: string;
    type: string;
    status: string;
    fee_amount: number;
    asset: string;
    source_account_guid: string;
    sender_cy_guid: string;
    recipient_cy_guid: string;
    recipient_name: string;
    recipient_clkktag: string;
    destination_account_guid: string;
    [key: string]: any;
}

/**
 * Processes platform fees for business transactions
 * @param event EventBridge event containing transaction details
 */
export const handler = async (event: EventBridgeEvent<string, any>): Promise<void> => {
    logger.info('Processing platform fee event:', event);

    const transaction = event.detail;
    const transactionId = transaction.transactionId;
    const processId = transaction.processId; // From the stream processor

    logger.info('Processing platform fee event:', { transactionId, processId });
    logger.info('Transaction:', transaction);
    logger.info('processId:', processId);

    // First, check if we've already processed this fee
    const existingTransaction = await TransactionService.getTransaction(transactionId);

    logger.info('Existing transaction:', existingTransaction);
    if (existingTransaction?.fee_pending === false || existingTransaction?.fee_transfer_id) {
        logger.info('Fee already processed, skipping', {
            transactionId,
            fee_pending: existingTransaction.fee_pending,
            fee_transfer_id: existingTransaction.fee_transfer_id,
        });
        return;
    }

    // Try to acquire a lock for processing using a DynamoDB conditional write
    try {
        await docClient.send(
            new UpdateItemCommand({
                TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
                Key: {
                    transactionId: { S: transactionId },
                },
                UpdateExpression: 'SET processing_lock = :processId, lock_acquired_at = :timestamp',
                ConditionExpression:
                    'attribute_not_exists(processing_lock) AND (attribute_not_exists(fee_pending) OR fee_pending = :true)',
                ExpressionAttributeValues: {
                    ':processId': { S: processId },
                    ':timestamp': { S: new Date().toISOString() },
                    ':true': { BOOL: true },
                },
            }),
        );

        // Now we have the lock, process the fee
        try {
            // Extract and validate transaction details
            const transaction = validateAndMapTransaction(event.detail);
            if (!transaction) return;

            // Create quote for fee transfer
            const quote = await createFeeQuote(transaction);

            // Create fee transfer
            const transfer = await createFeeTransfer(quote, transaction);

            // Record platform revenue and update transaction in a single atomic transaction
            await recordRevenueAndUpdateTransaction(transaction, transfer, quote.asset || 'USD');

            logger.info('Successfully processed platform fee', {
                transactionId: transaction.transactionId,
                feeAmount: transaction.fee_amount,
                transferId: transfer.guid,
            });

            // After successful processing, update the transaction
            await docClient.send(
                new UpdateCommand({
                    TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
                    Key: { transactionId },
                    UpdateExpression:
                        'SET fee_pending = :false, fee_processed_at = :timestamp, fee_transfer_id = :transferId REMOVE processing_lock',
                    ExpressionAttributeValues: {
                        ':false': false,
                        ':timestamp': new Date().toISOString(),
                        ':transferId': transfer.guid,
                    },
                }),
            );
        } catch (error) {
            // If fee processing fails, release the lock
            await docClient.send(
                new UpdateCommand({
                    TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
                    Key: { transactionId },
                    UpdateExpression: 'REMOVE processing_lock',
                    ConditionExpression: 'processing_lock = :processId',
                    ExpressionAttributeValues: {
                        ':processId': processId,
                    },
                }),
            );
            throw error;
        }
    } catch (error) {
        if (error.name === 'ConditionalCheckFailedException') {
            logger.info('Another processor already has the lock, skipping', { transactionId });
            return;
        }
        logger.error('Error processing fee', { error, transactionId });
        throw error;
    }
};

/**
 * Validates transaction and maps event fields to expected format
 */
function validateAndMapTransaction(detail: any): Transaction | null {
    // Validate this is a completed p2b_transfer transaction with fees
    if (detail.transactionType !== 'p2b_transfer' || detail.status !== 'completed' || !detail.fee_amount) {
        logger.info('Not a completed p2b_transfer transaction with fees, skipping', {
            type: detail.transactionType,
            status: detail.status,
            fee_amount: detail.fee_amount,
        });
        return null;
    }

    logger.info(`Processing platform fee for transaction ${detail.transactionId}`);

    // Map event fields to what's expected by the remaining code
    return {
        ...detail,
        type: detail.transactionType, // For backward compatibility
        asset: detail.currency || detail.asset, // Handle both field names
        sender_cy_guid: detail.sender_cy_guid,
    };
}

/**
 * Creates a quote for fee collection
 */
async function createFeeQuote(transaction: Transaction) {
    const quoteRequest = {
        receive_amount: transaction.fee_amount, // Already in cents
        asset: transaction.asset,
        customer_guid: transaction.sender_cy_guid,
        product_type: 'book_transfer',
    };

    logger.info('Creating fee quote', { quoteRequest });
    const quote = await quoteService.createQuote(quoteRequest);
    logger.info('Fee quote created', { quoteGuid: quote.guid });

    return quote;
}

/**
 * Creates a transfer for fee collection
 */
async function createFeeTransfer(quote: any, transaction: Transaction) {
    const feeAmountInCents = transaction.fee_amount; // Already in cents

    const feeTransferRequest = {
        quote_guid: quote.guid,
        source_account_guid: transaction.source_account_guid,
        destination_account_guid: PLATFORM_FEE_ACCOUNT_GUID,
        transfer_type: 'book',
        source_participants: [
            {
                type: 'customer',
                amount: feeAmountInCents,
                guid: transaction.sender_cy_guid,
            },
        ],
        destination_participants: [
            {
                type: 'bank',
                amount: feeAmountInCents,
                guid: PLATFORM_BANK_GUID,
            },
        ],
    };

    logger.info('Creating fee transfer', { feeTransferRequest });
    const transfer = await quoteService.createTransfer(feeTransferRequest);
    logger.info('Fee transfer created', { transferGuid: transfer.guid });

    return transfer;
}

/**
 * Records platform revenue and updates transaction status in a single atomic transaction
 */
async function recordRevenueAndUpdateTransaction(
    transaction: Transaction,
    transfer: any,
    asset: string,
): Promise<void> {
    const revenueId = uuidv4();
    const timestamp = new Date().toISOString();

    // Create platform revenue record
    const platformRevenue: PlatformRevenueItem = {
        revenueId,
        transactionId: transaction.transactionId,
        businessId: transaction.recipient_cy_guid || '',
        businessName: transaction.recipient_name || 'Unknown Business',
        businessClkkTag: transaction.recipient_clkktag || '',
        amount: transaction.fee_amount, // Already in cents
        asset: asset || transaction.asset,
        sourceAccountId: transaction.destination_account_guid || '',
        status: 'completed',
        type: 'platform_fee',
        provider: 'cybrid',
        createdAt: timestamp,
        updatedAt: timestamp,
    };

    // Create a transaction with both operations
    const transactParams: TransactWriteCommandInput = {
        TransactItems: [
            {
                // Write the platform revenue record
                Put: {
                    TableName: DYNAMO_TABLES.PLATFORM_REVENUE,
                    Item: platformRevenue,
                },
            },
            {
                // Update the transaction record
                Update: {
                    TableName: DYNAMO_TABLES.CLKK_TRANSACTIONS,
                    Key: { transactionId: transaction.transactionId },
                    UpdateExpression:
                        'SET fee_pending = :feePending, fee_processed_at = :processedAt, fee_transfer_id = :feeTransferId, updatedAt = :updatedAt',
                    ExpressionAttributeValues: {
                        ':feePending': false,
                        ':processedAt': timestamp,
                        ':feeTransferId': transfer.guid,
                        ':updatedAt': timestamp,
                    },
                },
            },
        ],
    };

    logger.info('Executing atomic transaction', {
        revenueId,
        transactionId: transaction.transactionId,
    });

    await docClient.send(new TransactWriteCommand(transactParams));

    logger.info('Successfully recorded platform fee and updated transaction', {
        revenueId,
        transactionId: transaction.transactionId,
    });
}
</file>

<file path="lambdas/transactions/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "commonjs",
        "outDir": "./dist",
        "strict": true,
        "baseUrl": "../../layers",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/user/details/app.ts">
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { logger } from 'commons';
import { Entity, getEntity } from 'commons/data/entities/entity';
import { getWallet } from 'commons/data/entities/wallet';
import { listEntityTransactions, listAllEntityTransactions } from 'commons/data/entities/transaction';
import { listNmiCustomersByEntity } from 'commons';
import { UserDetailsResponse, Transaction, WalletInfo, PaymentCardInfo, CheckbookCardInfo } from './types';
import { QueryCommand, QueryCommandInput, QueryCommandOutput, AttributeValue } from 'commons/dynamodb/dynamodb-types';
import { docClient } from 'commons/dynamodb/db-client';
import { CHECKBOOK_CARD_SK_PREFIX, CHECKBOOK_FIELDS } from 'commons/data/entities/entity';
import { EntityKeys } from 'commons/data/entities/entity';

// Create API response helper function locally
const responseBuilder = (body: any, statusCode: number): APIGatewayProxyResult => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Credentials': 'true',
        },
        body: JSON.stringify(body),
    };
};

/**
 * Fetches comprehensive user details including wallet balance, profile, and transactions
 * This endpoint consolidates important user data in a single response for client applications
 */
export const getUserDetails = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        return responseBuilder({ message: 'Unauthorized' }, 401);
    }

    logger.info('Fetching user details', { userId });

    try {
        // Get user profile
        const userEntity = await getUserEntity(userId);
        if (!userEntity) {
            logger.warn('User entity not found', { userId });
            return responseBuilder({ message: 'User not found' }, 404);
        }

        // Get user wallet balance
        const walletInfo = await getUserWallet(userId);

        // Get recent transactions (latest 10)
        const recentTransactions = await getUserTransactions(userId, 10);

        // Get payment card information
        const paymentCardInfo = await getUserPaymentCard(userId);

        // Get withdrawal card information (Checkbook card)
        const withdrawalCardInfo = await getUserWithdrawalCard(userId);

        // Construct the response with all user details
        const userDetails: UserDetailsResponse = {
            userId: userEntity.id,
            email: userEntity.email,
            username: userEntity.username,
            displayName: userEntity.displayName || userEntity.fullName,
            firstName: userEntity.userInfo?.firstName,
            lastName: userEntity.userInfo?.lastName,
            phoneNumber: userEntity.userInfo?.phoneNumber,
            profileImageUrl: userEntity.userInfo?.profilePictureUrl,
            status: userEntity.status,
            createdAt: userEntity.createdAt,
            updatedAt: userEntity.updatedAt,
            lastLoginAt: userEntity.lastLoginAt,
            kycStatus: userEntity.kycStatus,
            wallet: walletInfo,
            recentTransactions: recentTransactions,
            paymentCard: paymentCardInfo,
            withdrawalCard: withdrawalCardInfo,
        };

        logger.info('User details fetched successfully');
        return responseBuilder(userDetails, 200);
    } catch (error) {
        logger.error('Error fetching user details:', { error, userId });
        return responseBuilder({ message: 'Failed to fetch user details' }, 500);
    }
};

/**
 * Get user entity from DynamoDB using Entity class method
 * @param userId User's entity ID
 * @returns User Entity object or null if not found
 */
async function getUserEntity(userId: string): Promise<Entity | null> {
    try {
        logger.info('Getting user entity', { userId });

        // Get the entity using Entity class method
        const entity = await getEntity(userId, 'USER');

        if (!entity) {
            logger.warn('User entity not found', { userId });
            return null;
        }

        return entity;
    } catch (error) {
        logger.error('Error getting user entity:', { error, userId });
        throw error;
    }
}

/**
 * Get wallet information for the user using Wallet class method
 * @param userId User's entity ID
 * @returns Wallet information object with balances
 */
async function getUserWallet(userId: string): Promise<WalletInfo> {
    try {
        // Get the wallet using the Wallet class method
        const wallet = await getWallet(userId, 'USER', 'USD');

        if (!wallet) {
            logger.info('Wallet not found for user, will return empty wallet info', { userId });
            return {
                walletId: 'default',
                currency: 'USD',
                balance: '0.00',
                availableBalance: '0.00',
                pendingBalance: '0.00',
                updatedAt: new Date().toISOString(),
            };
        }

        return {
            walletId: wallet.walletId,
            currency: wallet.currency,
            balance: wallet.balance,
            availableBalance: wallet.availableBalance,
            pendingBalance: wallet.pendingBalance,
            updatedAt: wallet.updatedAt,
        };
    } catch (error) {
        logger.error('Error getting user wallet:', { error, userId });
        // Return default wallet info on error to maintain response structure
        return {
            walletId: 'error',
            currency: 'USD',
            balance: '0.00',
            availableBalance: '0.00',
            pendingBalance: '0.00',
            updatedAt: new Date().toISOString(),
        };
    }
}

/**
 * Get recent transactions for the user using Transaction class method
 * @param userId User's entity ID
 * @param limit Maximum number of transactions to retrieve
 * @returns Array of recent transactions
 */
async function getUserTransactions(userId: string, limit: number = 10): Promise<Transaction[]> {
    try {
        const { transactions } = await listAllEntityTransactions(userId, { limit });

        logger.info('Transactions fetched', { transactions });

        if (!transactions || transactions.length === 0) {
            logger.info('No transactions found for user', { userId });
            return [];
        }

        // Map transactions to a client-friendly format
        // Filter out sensitive information
        return transactions.map((transaction) => ({
            transactionId: transaction.transactionId,
            type: transaction.type,
            status: transaction.status,
            amount: transaction.amount.toString(),
            currency: transaction.currency,
            createdAt: transaction.createdAt,
            updatedAt: transaction.updatedAt,
            completedAt: transaction.completedAt,
            // Include sender/receiver information if available
            sender: transaction.senderId
                ? {
                      id: transaction.senderId,
                      type: transaction.senderType || 'USER', // Ensure type is never undefined
                      name: transaction.senderName,
                  }
                : undefined,
            receiver: transaction.receiverId
                ? {
                      id: transaction.receiverId,
                      type: transaction.receiverType || 'USER', // Ensure type is never undefined
                      name: transaction.receiverName,
                  }
                : undefined,
            // Include minimal metadata that's safe for client
            metadata: transaction.metadata
                ? {
                      description: transaction.metadata.description,
                      category: transaction.metadata.category,
                      counterpartyName: transaction.metadata.counterpartyName,
                  }
                : undefined,
        }));
    } catch (error) {
        logger.error('Error getting user transactions:', { error, userId });
        return [];
    }
}

/**
 * Get payment card information for the user from NMI vault
 * @param userId User's entity ID
 * @returns Payment card information or null if no card on file
 */
async function getUserPaymentCard(userId: string): Promise<PaymentCardInfo> {
    try {
        // Get NMI customer records for the user
        const nmiCustomers = await listNmiCustomersByEntity(userId);

        if (!nmiCustomers || nmiCustomers.length === 0) {
            logger.info('No payment cards found for user', { userId });
            return {
                hasCard: false,
            };
        }

        // Use the first NMI customer record (most recent one)
        const nmiCustomer = nmiCustomers[0];

        // Check if the NMI customer has credit card information
        if (!nmiCustomer.ccNumber || !nmiCustomer.ccType) {
            logger.info('NMI customer found but no card details available', { userId });
            return {
                hasCard: true,
            };
        }

        // Return the payment card information
        return {
            hasCard: true,
            lastFourDigits: nmiCustomer.ccNumber,
            cardType: nmiCustomer.ccType,
        };
    } catch (error) {
        logger.error('Error getting user payment card:', { error, userId });
        // Return default object on error to indicate no card information available
        return {
            hasCard: false,
        };
    }
}

/**
 * Get withdrawal card (Checkbook card) information for the user from DynamoDB
 * @param userId User's entity ID
 * @returns Checkbook card information or default object if no card on file
 */
async function getUserWithdrawalCard(userId: string): Promise<CheckbookCardInfo> {
    try {
        logger.info('Getting user withdrawal card information (Checkbook)', { userId });

        // Query DynamoDB for checkbook cards associated with this user
        const params: QueryCommandInput = {
            TableName: process.env.TABLE_NAME,
            KeyConditionExpression: '#pk = :pk AND begins_with(#sk, :sk_prefix)',
            ExpressionAttributeNames: {
                '#pk': EntityKeys.ATTR_PK,
                '#sk': EntityKeys.ATTR_SK,
            },
            ExpressionAttributeValues: {
                ':pk': { S: `${EntityKeys.USER_PREFIX}${userId}` },
                ':sk_prefix': { S: CHECKBOOK_CARD_SK_PREFIX },
            },
            Limit: 10, // Limit to 10 cards, we'll use the default one if available
        };

        const response = await docClient.send(new QueryCommand(params));

        if (!response.Items || response.Items.length === 0) {
            logger.info('No Checkbook cards found for user', { userId });
            return {
                hasCard: false,
            };
        }

        // Look for a default card first
        const defaultCard = response.Items.find((item) => {
            const isDefault = item[CHECKBOOK_FIELDS.IS_DEFAULT];
            return isDefault && isDefault.BOOL === true;
        });

        // If no default card, use the first one
        const card = defaultCard || response.Items[0];

        // Safely extract values from DynamoDB attributes
        const cardNumber = card[CHECKBOOK_FIELDS.CARD_NUMBER]?.S;
        const expirationDate = card[CHECKBOOK_FIELDS.EXPIRATION_DATE]?.S;
        const isDefault = card[CHECKBOOK_FIELDS.IS_DEFAULT]?.BOOL || false;
        const name = card.name?.S;

        return {
            hasCard: true,
            lastFourDigits: cardNumber || '',
            expirationDate: expirationDate || '',
            isDefault: isDefault,
            name: name || '',
        };
    } catch (error) {
        logger.error('Error getting user withdrawal card:', { error, userId });
        return {
            hasCard: false,
        };
    }
}

// Handler function
export const handler = getUserDetails;
</file>

<file path="lambdas/user/details/package.json">
{
  "name": "user-details-lambda",
  "version": "1.0.0",
  "description": "Lambda function to fetch user details including wallet balance and transactions",
  "main": "app.ts",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^1.5.1",
    "aws-lambda": "^1.0.7",
    "aws-sdk": "^2.1425.0"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.119",
    "@types/node": "^18.16.0",
    "typescript": "^5.1.6"
  }
}
</file>

<file path="lambdas/user/details/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2018",
    "module": "commonjs",
    "outDir": "./dist",
    "strict": true,
    "baseUrl": "../../../layers",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/user/details/types.ts">
/**
 * Shared type definitions for User Details API
 * These types can be used on both backend and frontend
 */

// User entity types
export interface UserInfo {
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    profileImageUrl?: string;
}

export type EntityStatus = 'ACTIVE' | 'INACTIVE' | 'PENDING' | 'SUSPENDED';

// Wallet information
export interface WalletInfo {
    walletId: string;
    currency: string;
    balance: string;
    availableBalance: string;
    pendingBalance: string;
    updatedAt: string;
}

// Transaction types
export type TransactionType = 'deposit' | 'withdrawal' | 'p2p_transfer' | 'p2b_transfer' | 'trade';
export type TransactionStatus = 'pending' | 'completed' | 'failed' | 'cancelled' | 'reversed';

export interface EntityReference {
    id: string;
    type: string;
    name?: string;
}

export interface TransactionMetadata {
    description?: string;
    category?: string;
    counterpartyName?: string;
    [key: string]: any;
}

export interface Transaction {
    transactionId: string;
    type: TransactionType;
    status: TransactionStatus;
    amount: string;
    currency: string;
    createdAt: string;
    updatedAt: string;
    completedAt?: string;
    sender?: EntityReference;
    receiver?: EntityReference;
    metadata?: TransactionMetadata;
}

// Payment card information
export interface PaymentCardInfo {
    lastFourDigits?: string;
    cardType?: string;
    hasCard: boolean;
}

// Checkbook card information (for withdrawals/payouts)
export interface CheckbookCardInfo {
    lastFourDigits?: string;
    expirationDate?: string;
    isDefault?: boolean;
    name?: string;
    hasCard: boolean;
}

// Main User Details response
export interface UserDetailsResponse {
    userId: string;
    email: string;
    username: string;
    displayName: string;
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    profileImageUrl?: string;
    status: EntityStatus;
    createdAt: string;
    updatedAt: string;
    lastLoginAt?: string;
    kycStatus?: string;
    wallet: WalletInfo;
    recentTransactions: Transaction[];
    paymentCard?: PaymentCardInfo;
    withdrawalCard?: CheckbookCardInfo; // Checkbook card for withdrawals/payouts
}
</file>

<file path="lambdas/user/profile/app.ts">
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { DYNAMO_TABLES, dynamoDB, logger, responseBuilder } from 'commons';
import { type Entity } from 'commons/types';

export const getProfile = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        return responseBuilder({ message: 'Unauthorized' }, 401);
    }

    logger.info('Fetching user profile', { userId });

    try {
        const params = {
            TableName: DYNAMO_TABLES.ENTITIES,
            Key: { entityId: userId },
        };

        logger.info('DynamoDB get params', { params });

        const response = (await dynamoDB.get(params)) as Entity | null;

        logger.info('DynamoDB get response', { response });

        if (!response) {
            logger.warn('User profile not found', { userId });
            return responseBuilder({ message: 'User not found' }, 404);
        }

        const Item: Entity = response;

        // Return only the necessary user profile fields
        const userProfile = {
            userId: Item.entityId,
            email: Item.email,
            firstName: Item.firstName,
            lastName: Item.lastName,
            phoneNumber: Item.phoneNumber,
            profileImageUrl: Item.profileImageUrl,
            createdAt: Item.createdAt,
            clkkTag: Item.clkktag,
            updatedAt: Item.updatedAt,
            kyc: Item.kyc,
            accountId: Item.metadata?.cybrid?.fiatAccountId,
            plaid: {
                metadata: Item.plaid?.metadata,
            },
        };

        logger.info('User profile fetched successfully', { userProfile });
        return responseBuilder(userProfile, 200);
    } catch (error) {
        logger.error('Error fetching user profile:', { error, userId });
        return responseBuilder({ message: 'Failed to fetch user profile' }, 500);
    }
};
</file>

<file path="lambdas/user/profile/package.json">
{
  "name": "user-profile",
  "version": "1.0.0",
  "description": "user profile lambda",
  "main": "app.js",
  "author": "CLKK",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit"
  },
  "dependencies": {
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "@types/aws-lambda": "^8.10.146",
    "@types/jest": "^29.2.0",
    "@types/node": "^18.11.4",
    "@typescript-eslint/eslint-plugin": "^5.10.2",
    "@typescript-eslint/parser": "^5.10.2",
    "esbuild": "^0.14.14",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.2.1",
    "prettier": "^2.5.1",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
</file>

<file path="lambdas/user/profile/tsconfig.json">
{
    "compilerOptions": {
        "target": "es2020",
        "strict": true,
        "preserveConstEnums": true,
        "noEmit": true,
        "sourceMap": false,
        "module": "es2015",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="lambdas/user/search/app.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { SearchResult, SearchEntitiesResult, EntityObject } from './types';

// These will be available through the Lambda layer at runtime
const { logger } = require('commons');
const {
    getEntityByEmail,
    getEntityByPhoneNumber,
    normalizePhoneNumber,
    getEntity,
} = require('commons/data/entities/entity');

// Use our fixed search implementation instead of the one from Entity class
import { searchEntitiesByUsername } from './search-entity';

// Response builder helper function
const responseBuilder = (body: any, statusCode: number): APIGatewayProxyResult => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Credentials': 'true',
        },
        body: JSON.stringify(body),
    };
};

/**
 * Search for users by username (partial match), email, or phone number
 *
 * This endpoint supports three search modes:
 * 1. Username search - Partial matching for usernames or "clkktags" (e.g. "john" or "@john")
 * 2. Email search - Exact matching for email addresses
 *    - Uses direct GetItem on the lookup item PK (EMAIL#email) for efficiency
 *    - Falls back to a query on the PK if the SK format is different
 *    - As a last resort, uses the original getEntityByEmail method for compatibility
 * 3. Phone search - Exact matching for phone numbers (normalized) - NO partial matches allowed
 *    - Uses direct query on the phone lookup PK (PHONE#number) for efficiency
 *    - Handles different phone formats (e.g., 3177304333, 317-730-4333, (317) 730-4333)
 *    - For US numbers, tries both with and without country code (e.g., 3177304333 and 13177304333)
 *    - Falls back to the original getEntityByPhoneNumber method for compatibility
 */
export const searchUsers = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const currentUserId = event.requestContext.authorizer?.userId;

    if (!currentUserId) {
        return responseBuilder({ message: 'Unauthorized' }, 401);
    }

    try {
        const searchTerm = event.queryStringParameters?.q?.trim();

        if (!searchTerm || searchTerm.length < 2) {
            return responseBuilder({ message: 'Search term must be at least 2 characters' }, 400);
        }

        logger.info('Searching users', { currentUserId, searchTerm });

        // Determine search type
        let searchResults: SearchResult[] = [];
        const isEmailSearch = searchTerm.includes('@') && searchTerm.includes('.');
        const isPhoneSearch = /^[\d+\s()-]+$/.test(searchTerm); // Simple regex to detect phone numbers

        if (isEmailSearch) {
            // Email search (exact match)
            logger.info('Performing email search', { email: searchTerm });

            // Following the recommendation to use the direct lookup approach
            // This relies on the transactional guarantee from write operations
            const normalizedEmail = searchTerm.toLowerCase();

            // Import the required AWS SDK commands
            const { GetItemCommand } = require('@aws-sdk/client-dynamodb');
            const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');

            const client = new DynamoDBClient();

            try {
                // Direct GetItem on the lookup item PK
                logger.info('Performing direct GetItem on email lookup', { pk: `EMAIL#${normalizedEmail}` });

                const response = await client.send(
                    new GetItemCommand({
                        TableName: process.env.TABLE_NAME || 'clkk-app-table-dev',
                        Key: {
                            PK: { S: `EMAIL#${normalizedEmail}` },
                            SK: { S: `USER#${normalizedEmail}` }, // This is the expected format based on entity.ts
                        },
                    }),
                );

                if (response.Item) {
                    logger.info('Found email lookup item', {
                        keys: Object.keys(response.Item),
                        id: response.Item.id?.S,
                        type: response.Item.type?.S,
                    });

                    // If lookup exists, get the entity details
                    if (response.Item.id?.S && response.Item.type?.S) {
                        const entityId = response.Item.id.S;
                        const entityType = response.Item.type.S;

                        const entity = await getEntity(entityId, entityType);
                        if (entity && entity.id !== currentUserId) {
                            logger.info('Found entity by email lookup', { entityId: entity.id, email: entity.email });
                            searchResults = [mapEntityToSearchResult(entity)];
                        }
                    }
                } else {
                    // If the SK format might be different, try a query on just the PK
                    logger.info('No exact match found, trying query on PK');

                    const { QueryCommand } = require('@aws-sdk/lib-dynamodb');
                    const { docClient } = require('commons/dynamodb/db-client');

                    const queryParams = {
                        TableName: process.env.TABLE_NAME || 'clkk-app-table-dev',
                        KeyConditionExpression: 'PK = :pk',
                        ExpressionAttributeValues: {
                            ':pk': `EMAIL#${normalizedEmail}`,
                        },
                        Limit: 5,
                    };

                    const queryResponse = await docClient.send(new QueryCommand(queryParams));

                    if (queryResponse.Items && queryResponse.Items.length > 0) {
                        logger.info('Found entities by email PK query', {
                            count: queryResponse.Items.length,
                            firstItemKeys: Object.keys(queryResponse.Items[0]),
                        });

                        // Process each item to get the full entity
                        for (const item of queryResponse.Items) {
                            if (item.id && item.type) {
                                const entity = await getEntity(item.id, item.type);
                                if (entity && entity.id !== currentUserId) {
                                    searchResults.push(mapEntityToSearchResult(entity));
                                }
                            }
                        }
                    } else {
                        // As a last resort, try the original getEntityByEmail method
                        // This maintains backward compatibility
                        logger.info('No results from PK query, trying original getEntityByEmail');
                        const entity = await getEntityByEmail(searchTerm);

                        if (entity && entity.id !== currentUserId) {
                            logger.info('Found entity by original getEntityByEmail', {
                                entityId: entity.id,
                                email: entity.email,
                            });
                            searchResults = [mapEntityToSearchResult(entity)];
                        } else {
                            logger.info('No entity found by any email lookup method');
                        }
                    }
                }
            } catch (error) {
                logger.warn('Error during email lookup', { error });

                // Fall back to the original method as a safety net
                logger.info('Falling back to original getEntityByEmail after error');
                const entity = await getEntityByEmail(searchTerm);

                if (entity && entity.id !== currentUserId) {
                    logger.info('Found entity by fallback getEntityByEmail', {
                        entityId: entity.id,
                        email: entity.email,
                    });
                    searchResults = [mapEntityToSearchResult(entity)];
                }
            }
        } else if (isPhoneSearch) {
            // Phone search (exact match after normalization only)
            logger.info('Performing phone search', { phone: searchTerm });

            // Following the recommendation to use the direct lookup approach
            const normalizedPhone = normalizePhoneNumber(searchTerm);

            // Import the required AWS SDK commands
            const { QueryCommand } = require('@aws-sdk/lib-dynamodb');
            const { docClient } = require('commons/dynamodb/db-client');

            // Try with the normalized phone number first
            let entity = null;
            let phoneVariations = [normalizedPhone];

            // Add US number variations
            if (normalizedPhone.length === 10) {
                // If it's a 10-digit number, also try with country code
                phoneVariations.push(`1${normalizedPhone}`);
            } else if (normalizedPhone.length === 11 && normalizedPhone.startsWith('1')) {
                // If it's an 11-digit number starting with 1, also try without country code
                phoneVariations.push(normalizedPhone.substring(1));
            }

            // Try each phone variation
            for (const phoneNumber of phoneVariations) {
                logger.info('Trying phone variation', { phoneNumber });

                try {
                    // Direct query on the phone lookup PK
                    const queryParams = {
                        TableName: process.env.TABLE_NAME || 'clkk-app-table-dev',
                        KeyConditionExpression: 'PK = :pk',
                        ExpressionAttributeValues: {
                            ':pk': `PHONE#${phoneNumber}`,
                        },
                        Limit: 1,
                    };

                    const response = await docClient.send(new QueryCommand(queryParams));

                    if (response.Items && response.Items.length > 0) {
                        logger.info('Found phone lookup item', {
                            phoneNumber,
                            firstItemKeys: Object.keys(response.Items[0]),
                        });

                        const item = response.Items[0];
                        if (item.id && item.type) {
                            entity = await getEntity(item.id, item.type);
                            if (entity && entity.id !== currentUserId) {
                                logger.info('Found entity by phone lookup', {
                                    entityId: entity.id,
                                    phone: phoneNumber,
                                });
                                searchResults = [mapEntityToSearchResult(entity)];
                                break; // Exit the loop once we find a match
                            }
                        }
                    }
                } catch (error) {
                    logger.warn('Error during phone lookup', { error, phoneNumber });
                }
            }

            // If no match found through direct queries, fall back to the original method
            if (searchResults.length === 0) {
                logger.info('No match found through direct queries, trying original method');

                // Try with the normalized phone number
                entity = await getEntityByPhoneNumber(normalizedPhone);

                // If no match and it looks like a US number without country code, try with country code
                if (!entity && normalizedPhone.length === 10) {
                    logger.info('Trying US number with country code via original method', { normalizedPhone });
                    entity = await getEntityByPhoneNumber(`1${normalizedPhone}`);
                }

                // If no match and it looks like a US number with country code, try without it
                if (!entity && normalizedPhone.length === 11 && normalizedPhone.startsWith('1')) {
                    logger.info('Trying US number without country code via original method', { normalizedPhone });
                    entity = await getEntityByPhoneNumber(normalizedPhone.substring(1));
                }

                if (entity && entity.id !== currentUserId) {
                    logger.info('Found entity by original phone method', { entityId: entity.id });
                    searchResults = [mapEntityToSearchResult(entity)];
                }
            }
        } else {
            // Username search (partial match)
            const cleanTerm = searchTerm.replace(/^@/, ''); // Remove @ prefix if present

            // Search users first
            const userResults = await searchEntitiesByUsername(cleanTerm, {
                type: 'USER',
                limit: 20,
            });

            // Search businesses if not enough user results
            let businessResults: SearchEntitiesResult = { entities: [] };
            if (userResults.entities.length < 10) {
                businessResults = await searchEntitiesByUsername(cleanTerm, {
                    type: 'BUSINESS',
                    limit: 10,
                });
            }

            // Combine and filter out current user
            const allEntities = [...userResults.entities, ...businessResults.entities];
            searchResults = allEntities
                .filter((entity) => entity.id !== currentUserId)
                .map((entity) => mapEntityToSearchResult(entity));
        }

        logger.info('Search results', { count: searchResults.length });
        return responseBuilder(searchResults, 200);
    } catch (error) {
        logger.error('Error searching users', { error, currentUserId });
        return responseBuilder({ message: 'Failed to search users' }, 500);
    }
};

/**
 * Map entity to client-friendly search result
 */
function mapEntityToSearchResult(entity: any): SearchResult {
    // Log entity for debugging
    logger.debug('Mapping entity to search result', {
        entityId: entity.id,
        hasDirectProfilePic: entity.profilePictureUrl ? 'yes' : 'no',
        hasUserInfoProfilePic: entity.userInfo?.profilePictureUrl ? 'yes' : 'no',
    });

    // Common fields for both user and business entities
    const result = {
        entityId: entity.id,
        entityType: entity.type,
        name: entity.displayName || entity.fullName,
        username: entity.username,
        clkktag: entity.username, // Return without @ prefix as per client needs
        email: entity.email,
    };

    // Add type-specific fields
    if (entity.type === 'USER') {
        // Try getting profile image from multiple possible locations
        const profileImageUrl =
            entity.profilePictureUrl || // From our direct added field
            entity.userInfo?.profilePictureUrl || // From the nested userInfo
            null;

        return {
            ...result,
            profileImageUrl,
        };
    } else {
        // Business entity - also check multiple locations
        const profileImageUrl = entity.profilePictureUrl || entity.businessInfo?.profilePictureUrl || null;

        return {
            ...result,
            profileImageUrl,
            businessName: entity.businessInfo?.businessName || null,
        };
    }
}

// Default handler
export const handler = searchUsers;
</file>

<file path="lambdas/user/search/package.json">
{
  "name": "user-search-lambda",
  "version": "1.0.0",
  "description": "Lambda function for user search API",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "aws-lambda": "^1.0.7"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.92"
  }
}
</file>

<file path="lambdas/user/search/search-entity.ts">
import { SearchEntitiesResult, EntityObject } from './types';

// Using require instead of import for layer dependencies to avoid TS errors
const { logger } = require('commons');
const { docClient } = require('commons/dynamodb/db-client');

// Set a specific context for this service's logs
const TABLE_NAME = process.env.TABLE_NAME || 'clkk-app-table-dev';

/**
 * Search for entities by username
 * This implementation uses query or scan operations based on the search type for optimal performance
 */
export const searchEntitiesByUsername = async (
    usernameSearch: string,
    options: {
        type?: 'USER' | 'BUSINESS';
        limit?: number;
    } = {},
): Promise<SearchEntitiesResult> => {
    if (!usernameSearch || usernameSearch.length < 2) {
        return { entities: [] };
    }

    const normalizedSearch = usernameSearch.toLowerCase();
    const { type, limit = 20 } = options;

    try {
        logger.info('Searching entities by username', { usernameSearch, type });

        // Import the required AWS SDK command
        const { QueryCommand } = require('@aws-sdk/lib-dynamodb');

        // Use an efficient prefix search using the UsernameIndex GSI
        // This is more efficient for when users are typing from the beginning of a username
        if (usernameSearch.length >= 2) {
            // For the UsernameIndex GSI, we'll use a consistent key format
            const queryParams: any = {
                TableName: TABLE_NAME,
                IndexName: 'UsernameIndex',
                KeyConditionExpression: 'UsernameIndexKey = :hashKey AND begins_with(UsernameIndexValue, :username)',
                ExpressionAttributeValues: {
                    ':hashKey': 'USERNAME', // This should match how your data is indexed
                    ':username': normalizedSearch.toLowerCase(),
                },
                Limit: limit,
            };

            // Add type filter if specified
            if (type) {
                queryParams.FilterExpression = '#type = :type';
                queryParams.ExpressionAttributeNames = {
                    '#type': 'type',
                };
                queryParams.ExpressionAttributeValues = {
                    ...queryParams.ExpressionAttributeValues,
                    ':type': type,
                };
            }

            const queryResults = await docClient.send(new QueryCommand(queryParams));
            return processQueryResults(queryResults.Items || [], queryResults.LastEvaluatedKey);
        }

        // If the search term is too short, return empty results
        return { entities: [] };
    } catch (error) {
        logger.error('Error searching entities by username', { error, usernameSearch });
        throw error;
    }
};

/**
 * Process query results and map them to entity objects
 */
function processQueryResults(
    items: Record<string, any>[],
    lastEvaluatedKey?: Record<string, any>,
): SearchEntitiesResult {
    // Map results to the expected format
    const entities: EntityObject[] = items.map((item: Record<string, any>) => {
        // Extract entity from direct username lookups if needed
        const entityId = item.entityId || item.id || '';
        const entityType = item.entityType || item.type || '';

        // Process user and business info to ensure profile images are included
        let userInfo = item.userInfo || {};
        let businessInfo = item.businessInfo || {};
        let profilePictureUrl = null;

        // Handle userInfo parsing if it's a string
        if (typeof item.userInfo === 'string') {
            try {
                userInfo = JSON.parse(item.userInfo);
            } catch (e) {
                logger.warn('Failed to parse userInfo JSON', { error: e });
            }
        }

        // Handle businessInfo parsing if it's a string
        if (typeof item.businessInfo === 'string') {
            try {
                businessInfo = JSON.parse(item.businessInfo);
            } catch (e) {
                logger.warn('Failed to parse businessInfo JSON', { error: e });
            }
        }

        // Extract profilePictureUrl from userInfo if it exists
        if (userInfo.profilePictureUrl) {
            if (typeof userInfo.profilePictureUrl === 'string') {
                profilePictureUrl = userInfo.profilePictureUrl;
            } else if (userInfo.profilePictureUrl.S) {
                profilePictureUrl = userInfo.profilePictureUrl.S;
                userInfo.profilePictureUrl = profilePictureUrl;
            }
        }

        // Extract profilePictureUrl from businessInfo if it exists
        if (businessInfo.profilePictureUrl) {
            if (typeof businessInfo.profilePictureUrl === 'string') {
                if (entityType === 'BUSINESS') {
                    profilePictureUrl = businessInfo.profilePictureUrl;
                }
            } else if (businessInfo.profilePictureUrl.S) {
                businessInfo.profilePictureUrl = businessInfo.profilePictureUrl.S;
                if (entityType === 'BUSINESS') {
                    profilePictureUrl = businessInfo.profilePictureUrl;
                }
            }
        }

        // Use direct profilePictureUrl if available
        if (item.profilePictureUrl) {
            profilePictureUrl = item.profilePictureUrl;

            // Also update the info objects
            if (entityType === 'USER') {
                userInfo.profilePictureUrl = profilePictureUrl;
            } else if (entityType === 'BUSINESS') {
                businessInfo.profilePictureUrl = profilePictureUrl;
            }
        }

        return {
            id: entityId,
            type: entityType,
            email: item.email || '',
            username: item.username || '',
            displayName: item.displayName || '',
            userInfo: userInfo,
            businessInfo: businessInfo,
            profilePictureUrl: profilePictureUrl,
            status: item.status || 'ACTIVE',
            role: item.role || 'USER',
            createdAt: item.createdAt || '',
            updatedAt: item.updatedAt || '',
            // Helper method for client app
            fullName: function () {
                if (this.type === 'USER' && this.userInfo) {
                    return (
                        `${this.userInfo.firstName || ''} ${this.userInfo.lastName || ''}`.trim() ||
                        this.displayName ||
                        this.username
                    );
                } else if (this.type === 'BUSINESS' && this.businessInfo) {
                    return this.businessInfo.businessName || this.displayName || this.username;
                }
                return this.displayName || this.username;
            },
        };
    });

    logger.info('Search results', { count: entities.length });
    return {
        entities,
        lastEvaluatedKey,
    };
}
</file>

<file path="lambdas/user/search/types.ts">
/**
 * Types for the User Search API
 */

// Supported entity types in the system
export type EntityType = 'USER' | 'BUSINESS';

// Common search result shape
export interface UserSearchResult {
    entityId: string;
    entityType: EntityType;
    name: string;
    username: string;
    clkktag: string;
    email: string;
    profileImageUrl: string | null;
}

// Type for business-specific search results
export interface BusinessSearchResult extends UserSearchResult {
    businessName: string | null;
}

// Union type for search results
export type SearchResult = UserSearchResult | BusinessSearchResult;

// Type for entity object returned from database functions
export interface EntityObject {
    id: string;
    type: string;
    email: string;
    username: string;
    displayName?: string;
    userInfo?: any;
    businessInfo?: any;
    status?: string;
    role?: string;
    createdAt?: string;
    updatedAt?: string;
    fullName?: () => string;
}

// Type for search results from searchEntitiesByUsername
export interface SearchEntitiesResult {
    entities: EntityObject[];
    lastEvaluatedKey?: Record<string, any>;
}
</file>

<file path="lambdas/user/transactions/app.ts">
import { type APIGatewayProxyEvent, type APIGatewayProxyResult } from 'aws-lambda';
import { logger } from 'commons/utils/logger';
import {
    listAllEntityTransactions,
    Transaction,
    TransactionStatus,
    TransactionType,
} from 'commons/data/entities/transaction';

/**
 * Response builder helper function
 */
const responseBuilder = (body: any, statusCode: number): APIGatewayProxyResult => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Credentials': 'true',
        },
        body: JSON.stringify(body),
    };
};

/**
 * Get transactions with filtering and pagination
 *
 * This endpoint allows for detailed transaction history with various filters:
 * - Transaction type (deposits, withdrawals, p2p transfers, etc.)
 * - Status filters (pending, completed, failed, etc.)
 * - Date range selection
 * - Pagination for large result sets
 */
export const getFilteredTransactions = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        return responseBuilder({ message: 'Unauthorized' }, 401);
    }

    try {
        const queryParams = event.queryStringParameters || {};

        // Parse filter parameters
        const limit = queryParams.limit ? parseInt(queryParams.limit, 10) : 20;
        const startKey = queryParams.nextToken ? JSON.parse(decodeURIComponent(queryParams.nextToken)) : undefined;
        const statusFilter = queryParams.status as TransactionStatus | undefined;
        const typeFilter = queryParams.type as TransactionType | undefined;

        // Handle date range options
        let startDate = queryParams.startDate;
        let endDate = queryParams.endDate;
        const dateRangeOption = queryParams.dateRange;

        if (dateRangeOption) {
            const now = new Date();
            endDate = now.toISOString().split('T')[0]; // Today's date in YYYY-MM-DD format

            switch (dateRangeOption) {
                case 'last7days':
                    const sevenDaysAgo = new Date();
                    sevenDaysAgo.setDate(now.getDate() - 7);
                    startDate = sevenDaysAgo.toISOString().split('T')[0];
                    break;

                case 'last30days':
                    const thirtyDaysAgo = new Date();
                    thirtyDaysAgo.setDate(now.getDate() - 30);
                    startDate = thirtyDaysAgo.toISOString().split('T')[0];
                    break;

                case 'last90days':
                    const ninetyDaysAgo = new Date();
                    ninetyDaysAgo.setDate(now.getDate() - 90);
                    startDate = ninetyDaysAgo.toISOString().split('T')[0];
                    break;

                case 'thisYear':
                    const thisYear = now.getFullYear();
                    startDate = `${thisYear}-01-01`;
                    break;

                case 'custom':
                    // For custom, we expect startDate and endDate to be provided separately
                    // No need to do anything here as we'll use the explicitly provided dates
                    break;

                default:
                    // No date range filter
                    startDate = undefined;
                    endDate = undefined;
            }
        }

        logger.info('Getting filtered transactions', {
            userId,
            limit,
            statusFilter,
            typeFilter,
            dateRangeOption,
            startDate,
            endDate,
            hasStartKey: !!startKey,
        });

        // Use the common listEntityTransactions function
        const { transactions, lastEvaluatedKey } = await listAllEntityTransactions(userId, {
            limit,
            startKey,
            status: statusFilter,
            type: typeFilter,
            startDate,
            endDate,
        });
        logger.info('Transactions retrieved', { userId, count: transactions.length, lastEvaluatedKey, transactions });

        // Format response for client with proper pagination
        const response = {
            transactions: transactions.map((transaction: Transaction) => ({
                transactionId: transaction.transactionId,
                type: transaction.type,
                status: transaction.status,
                amount: transaction.amount.toString(),
                currency: transaction.currency,
                createdAt: transaction.createdAt,
                updatedAt: transaction.updatedAt,
                completedAt: transaction.completedAt,
                // Include sender/receiver information if available
                sender: transaction.senderId
                    ? {
                          id: transaction.senderId,
                          type: transaction.senderType,
                          name: transaction.senderName,
                      }
                    : undefined,
                receiver: transaction.receiverId
                    ? {
                          id: transaction.receiverId,
                          type: transaction.receiverType,
                          name: transaction.receiverName,
                      }
                    : undefined,
                // Include metadata that's safe for client
                metadata: transaction.metadata
                    ? {
                          description: transaction.metadata.description,
                          category: transaction.metadata.category,
                          counterpartyName: transaction.metadata.counterpartyName,
                      }
                    : undefined,
            })),
            pagination: {
                nextToken: lastEvaluatedKey ? encodeURIComponent(JSON.stringify(lastEvaluatedKey)) : null,
                limit,
                hasMore: !!lastEvaluatedKey,
            },
        };

        return responseBuilder(response, 200);
    } catch (error) {
        logger.error('Error getting filtered transactions:', { error, userId });
        return responseBuilder({ message: 'Failed to retrieve transactions' }, 500);
    }
};

/**
 * Get transaction types and filters metadata
 *
 * This endpoint provides the metadata about available transaction types and filters
 * to help the UI display appropriate filtering options
 */
export const getTransactionFilters = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        return responseBuilder({ message: 'Unauthorized' }, 401);
    }

    try {
        // Return metadata about transaction types and filters
        const filters = {
            transactionTypes: [
                { id: TransactionType.DEPOSIT, label: 'Deposit', description: 'Money added to your account' },
                {
                    id: TransactionType.WITHDRAWAL,
                    label: 'Withdrawal',
                    description: 'Money withdrawn from your account',
                },
                { id: TransactionType.P2P, label: 'Person to Person', description: 'Transfers to other users' },
                { id: TransactionType.P2B, label: 'Person to Business', description: 'Payments to businesses' },
                { id: TransactionType.TRADE, label: 'Trade', description: 'Currency exchange transactions' },
            ],
            statuses: [
                { id: TransactionStatus.PENDING, label: 'Pending', description: 'Transaction is being processed' },
                { id: TransactionStatus.COMPLETED, label: 'Completed', description: 'Transaction was successful' },
                { id: TransactionStatus.FAILED, label: 'Failed', description: 'Transaction failed to process' },
                { id: TransactionStatus.CANCELLED, label: 'Cancelled', description: 'Transaction was cancelled' },
                { id: TransactionStatus.REVERSED, label: 'Reversed', description: 'Transaction was reversed/refunded' },
            ],
            dateRangeOptions: [
                { id: 'last7days', label: 'Last 7 days' },
                { id: 'last30days', label: 'Last 30 days' },
                { id: 'last90days', label: 'Last 90 days' },
                { id: 'thisYear', label: 'This year' },
                { id: 'custom', label: 'Custom range' },
            ],
            sortOptions: [
                { id: 'date-desc', label: 'Date (newest first)' },
                { id: 'date-asc', label: 'Date (oldest first)' },
                { id: 'amount-desc', label: 'Amount (highest first)' },
                { id: 'amount-asc', label: 'Amount (lowest first)' },
            ],
        };

        return responseBuilder(filters, 200);
    } catch (error) {
        logger.error('Error getting transaction filters metadata:', { error, userId });
        return responseBuilder({ message: 'Failed to retrieve transaction filters' }, 500);
    }
};

/**
 * Get transaction details by ID
 */
export const getTransactionDetails = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    const userId = event.requestContext.authorizer?.userId;

    if (!userId) {
        return responseBuilder({ message: 'Unauthorized' }, 401);
    }

    try {
        // Get the transaction ID from path parameters
        const transactionId = event.pathParameters?.transactionId;

        if (!transactionId) {
            return responseBuilder({ message: 'Transaction ID is required' }, 400);
        }

        // Import the getTransaction function directly here to avoid circular dependencies
        const { getTransaction } = require('commons/data/entities/transaction');

        // Get the transaction using the provided ID and user context
        const transaction = await getTransaction(userId, 'USER', transactionId);

        if (!transaction) {
            return responseBuilder({ message: 'Transaction not found or access denied' }, 404);
        }

        // Format the transaction for client
        const transactionResponse = {
            transactionId: transaction.transactionId,
            type: transaction.type,
            status: transaction.status,
            amount: transaction.amount.toString(),
            currency: transaction.currency,
            createdAt: transaction.createdAt,
            updatedAt: transaction.updatedAt,
            completedAt: transaction.completedAt,
            balanceBefore: transaction.balanceBefore,
            balanceAfter: transaction.balanceAfter,
            // Provider information if available
            provider: transaction.providerType
                ? {
                      type: transaction.providerType,
                      id: transaction.providerId,
                      name: transaction.providerName,
                      transactionId: transaction.providerTransactionId,
                      reference: transaction.providerReference,
                  }
                : undefined,
            // Sender/receiver information
            sender: transaction.senderId
                ? {
                      id: transaction.senderId,
                      type: transaction.senderType,
                      name: transaction.senderName,
                  }
                : undefined,
            receiver: transaction.receiverId
                ? {
                      id: transaction.receiverId,
                      type: transaction.receiverType,
                      name: transaction.receiverName,
                  }
                : undefined,
            // Full metadata
            metadata: transaction.metadata,
        };

        return responseBuilder(transactionResponse, 200);
    } catch (error) {
        logger.error('Error getting transaction details:', { error, userId });
        return responseBuilder({ message: 'Failed to retrieve transaction details' }, 500);
    }
};

// Export handler functions
export const getTransactionsHandler = getFilteredTransactions;
export const getTransactionFiltersHandler = getTransactionFilters;
export const getTransactionDetailsHandler = getTransactionDetails;

// Default handler
export const handler = getFilteredTransactions;
</file>

<file path="lambdas/user/transactions/package.json">
{
  "name": "user-transactions-lambda",
  "version": "1.0.0",
  "description": "Lambda function for filtered user transactions",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "aws-lambda": "^1.0.7"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.92"
  }
}
</file>

<file path="layers/commons/data/entities/__tests__/entity.mock.ts">
import { AttributeValue } from '@aws-sdk/client-dynamodb';
import { EntityTypeString, EntityStatus, EntityRole, KYCStatus } from '../entity';

interface UserInfo {
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    profilePictureUrl?: string;
}

interface BusinessInfo {
    businessName: string;
    businessType?: string;
    phoneNumber?: string;
    website?: string;
}

interface KycInfo {
    provider: string;
    reference?: string;
    documentType?: string;
}

interface UserData {
    id: string;
    type: EntityTypeString;
    email: string;
    username: string;
    role: EntityRole;
    status: EntityStatus;
    displayName?: string;
    userInfo?: UserInfo;
    businessInfo?: BusinessInfo;
    kycStatus?: KYCStatus;
    kycInfo?: KycInfo;
    lastLoginAt?: string;
    verifiedAt?: string;
    createdAt: string;
    updatedAt: string;
}

/**
 * Creates a sample user entity for testing
 */
export const createSampleUser = (overrides: Partial<UserData> = {}): UserData => {
    return {
        id: 'user123',
        type: 'USER',
        email: 'test@example.com',
        username: 'testuser',
        role: 'USER',
        status: 'ACTIVE',
        userInfo: {
            firstName: 'Test',
            lastName: 'User',
            phoneNumber: '1234567890',
            profilePictureUrl: 'https://example.com/profile.jpg',
        },
        createdAt: '2023-01-01T00:00:00.000Z',
        updatedAt: '2023-01-01T00:00:00.000Z',
        ...overrides,
    };
};

/**
 * Creates a sample business entity for testing
 */
export const createSampleBusiness = (overrides: Partial<UserData> = {}): UserData => {
    return {
        id: 'business123',
        type: 'BUSINESS',
        email: 'business@example.com',
        username: 'businessuser',
        role: 'BUSINESS_OWNER',
        status: 'ACTIVE',
        displayName: 'Test Business',
        businessInfo: {
            businessName: 'Test Business',
            businessType: 'LLC',
            phoneNumber: '9876543210',
            website: 'https://business.example.com',
        },
        createdAt: '2023-01-01T00:00:00.000Z',
        updatedAt: '2023-01-01T00:00:00.000Z',
        ...overrides,
    };
};

/**
 * Converts a user entity to DynamoDB item format for mocking responses
 */
export const userToDynamoDBItem = (userData: UserData): Record<string, AttributeValue> => {
    const item: Record<string, AttributeValue> = {
        PK: { S: `${userData.type}#${userData.id}` },
        SK: { S: 'PROFILE' },
        GSI1PK: { S: `ENTITY_TYPE#${userData.type}` },
        GSI1SK: { S: `STATUS#${userData.status}#ROLE#${userData.role}#${userData.displayName || userData.email}` },
        GSI2PK: { S: 'EMAIL' },
        GSI2SK: { S: userData.email },
        id: { S: userData.id },
        type: { S: userData.type },
        email: { S: userData.email },
        role: { S: userData.role },
        status: { S: userData.status },
        username: { S: userData.username },
        createdAt: { S: userData.createdAt },
        updatedAt: { S: userData.updatedAt },
    };

    if (userData.displayName) {
        item.displayName = { S: userData.displayName };
    }

    if (userData.userInfo) {
        item.userInfo = {
            M: Object.entries(userData.userInfo).reduce((acc: Record<string, AttributeValue>, [key, value]) => {
                if (value !== undefined && value !== null) {
                    acc[key] = { S: String(value) };
                }
                return acc;
            }, {}),
        };
    }

    if (userData.businessInfo) {
        item.businessInfo = {
            M: Object.entries(userData.businessInfo).reduce((acc: Record<string, AttributeValue>, [key, value]) => {
                if (value !== undefined && value !== null) {
                    acc[key] = { S: String(value) };
                }
                return acc;
            }, {}),
        };
    }

    if (userData.kycStatus) {
        item.kycStatus = { S: userData.kycStatus };
    }

    if (userData.kycInfo) {
        item.kycInfo = {
            M: Object.entries(userData.kycInfo).reduce((acc: Record<string, AttributeValue>, [key, value]) => {
                if (value !== undefined && value !== null) {
                    acc[key] = { S: String(value) };
                }
                return acc;
            }, {}),
        };
    }

    if (userData.lastLoginAt) {
        item.lastLoginAt = { S: userData.lastLoginAt };
    }

    if (userData.verifiedAt) {
        item.verifiedAt = { S: userData.verifiedAt };
    }

    return item;
};

/**
 * Creates a mock email lookup item
 */
export const createEmailLookupItem = (
    id: string,
    type: EntityTypeString,
    email: string,
): Record<string, AttributeValue> => {
    return {
        PK: { S: `EMAIL#${email.toLowerCase()}` },
        SK: { S: `${type}#${id}` },
        GSI1PK: { S: 'EMAIL' },
        GSI1SK: { S: email.toLowerCase() },
        id: { S: id },
        type: { S: type },
        email: { S: email.toLowerCase() },
        createdAt: { S: '2023-01-01T00:00:00.000Z' },
    };
};

/**
 * Creates a mock username lookup item
 */
export const createUsernameLookupItem = (
    id: string,
    type: EntityTypeString,
    username: string,
    displayName?: string,
): Record<string, AttributeValue> => {
    const item: Record<string, AttributeValue> = {
        PK: { S: `USERNAME#${username.toLowerCase()}` },
        SK: { S: `${type}#${id}` },
        GSI1PK: { S: 'USERNAME' },
        GSI1SK: { S: username.toLowerCase() },
        id: { S: id },
        type: { S: type },
        username: { S: username.toLowerCase() },
        createdAt: { S: '2023-01-01T00:00:00.000Z' },
    };

    if (displayName) {
        item.displayName = { S: displayName };
    }

    return item;
};

/**
 * Creates a mock phone lookup item
 */
export const createPhoneLookupItem = (
    id: string,
    type: EntityTypeString,
    phoneNumber: string,
): Record<string, AttributeValue> => {
    return {
        PK: { S: `PHONE#${phoneNumber}` },
        SK: { S: `${type}#${id}` },
        GSI3PK: { S: 'PHONE' },
        GSI3SK: { S: phoneNumber },
        id: { S: id },
        type: { S: type },
        phone: { S: phoneNumber },
        createdAt: { S: '2023-01-01T00:00:00.000Z' },
    };
};
</file>

<file path="layers/commons/data/entities/__tests__/entity.test.ts">
/// <reference types="jest" />

// Mock the client module directly to avoid import issues
jest.mock(
    '../../../client',
    () => ({
        getClient: jest.fn(),
    }),
    { virtual: true },
);

import {
    DynamoDBClient,
    GetItemCommand,
    QueryCommand,
    PutItemCommand,
    UpdateItemCommand,
    TransactWriteItemsCommand,
} from '@aws-sdk/client-dynamodb';
import { mockClient } from 'aws-sdk-client-mock';
import {
    Entity,
    EntityType,
    EntityTypeString,
    EntityStatus,
    EntityRole,
    KYCStatus,
    normalizePhoneNumber,
    isValidEmail,
    getEntityByEmail,
    getEntityByUsername,
    getEntityByPhoneNumber,
    createUser,
    createBusiness,
    getEntity,
    listUsers,
    listBusinesses,
    listEntitiesByKycStatus,
    searchEntitiesByUsername,
    verifyUniqueConstraints,
} from '../entity';
import {
    createSampleUser,
    createSampleBusiness,
    userToDynamoDBItem,
    createEmailLookupItem,
    createUsernameLookupItem,
    createPhoneLookupItem,
} from './entity.mock';

// Set up the DynamoDB mock
const mockDynamoClient = mockClient(DynamoDBClient);

// Configure the mocked client
// Note: We're using the mocked version from the jest.mock above
const client = require('../../../client');
client.getClient.mockReturnValue(mockDynamoClient);

describe('Entity Class', () => {
    beforeEach(() => {
        mockDynamoClient.reset();
        jest.clearAllMocks();
    });

    describe('Helper Functions', () => {
        test('normalizePhoneNumber should remove non-numeric characters', () => {
            expect(normalizePhoneNumber('(123) 456-7890')).toBe('1234567890');
            expect(normalizePhoneNumber('123-456-7890')).toBe('1234567890');
            expect(normalizePhoneNumber('123.456.7890')).toBe('1234567890');
            expect(normalizePhoneNumber('123 456 7890')).toBe('1234567890');
        });

        test('isValidEmail should validate email format', () => {
            expect(isValidEmail('test@example.com')).toBe(true);
            expect(isValidEmail('test.user@domain.co.uk')).toBe(true);
            expect(isValidEmail('invalid-email')).toBe(false);
            expect(isValidEmail('missing@domain')).toBe(false);
            expect(isValidEmail('')).toBe(false);
        });
    });

    describe('Entity Construction', () => {
        test('should create a user entity with all properties', () => {
            const userData = createSampleUser();
            const entity = new Entity(
                userData.id,
                userData.type,
                userData.email,
                userData.role,
                userData.status,
                userData.username,
                {
                    userInfo: userData.userInfo,
                    createdAt: userData.createdAt,
                    updatedAt: userData.updatedAt,
                },
            );

            expect(entity.id).toBe(userData.id);
            expect(entity.type).toBe(userData.type);
            expect(entity.email).toBe(userData.email);
            expect(entity.role).toBe(userData.role);
            expect(entity.status).toBe(userData.status);
            expect(entity.username).toBe(userData.username);
            expect(entity.userInfo).toEqual(userData.userInfo);
            expect(entity.createdAt).toBe(userData.createdAt);
            expect(entity.updatedAt).toBe(userData.updatedAt);
        });

        test('should create a business entity with all properties', () => {
            const businessData = createSampleBusiness();
            const entity = new Entity(
                businessData.id,
                businessData.type,
                businessData.email,
                businessData.role,
                businessData.status,
                businessData.username,
                {
                    displayName: businessData.displayName,
                    businessInfo: businessData.businessInfo,
                    createdAt: businessData.createdAt,
                    updatedAt: businessData.updatedAt,
                },
            );

            expect(entity.id).toBe(businessData.id);
            expect(entity.type).toBe(businessData.type);
            expect(entity.email).toBe(businessData.email);
            expect(entity.role).toBe(businessData.role);
            expect(entity.status).toBe(businessData.status);
            expect(entity.username).toBe(businessData.username);
            expect(entity.displayName).toBe(businessData.displayName);
            expect(entity.businessInfo).toEqual(businessData.businessInfo);
            expect(entity.createdAt).toBe(businessData.createdAt);
            expect(entity.updatedAt).toBe(businessData.updatedAt);
        });

        test('should generate a new ID if not provided', () => {
            const entity = new Entity('', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser');
            expect(entity.id).toBeTruthy();
            expect(entity.id.length).toBeGreaterThan(0);
        });

        test('should normalize email to lowercase', () => {
            const entity = new Entity('user123', 'USER', 'Test@Example.COM', 'USER', 'ACTIVE', 'testuser');
            expect(entity.email).toBe('test@example.com');
        });

        test('should set default timestamps if not provided', () => {
            const entity = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser');
            expect(entity.createdAt).toBeTruthy();
            expect(entity.updatedAt).toBeTruthy();
        });
    });

    describe('Entity Methods', () => {
        test('pk should return the correct primary key format', () => {
            const userData = createSampleUser();
            const entity = new Entity(
                userData.id,
                userData.type,
                userData.email,
                userData.role,
                userData.status,
                userData.username,
            );
            expect(entity.pk).toBe(`USER#${userData.id}`);

            const businessData = createSampleBusiness();
            const businessEntity = new Entity(
                businessData.id,
                businessData.type,
                businessData.email,
                businessData.role,
                businessData.status,
                businessData.username,
            );
            expect(businessEntity.pk).toBe(`BUSINESS#${businessData.id}`);
        });

        test('sk should return the correct sort key', () => {
            const userData = createSampleUser();
            const entity = new Entity(
                userData.id,
                userData.type,
                userData.email,
                userData.role,
                userData.status,
                userData.username,
            );
            expect(entity.sk).toBe('PROFILE');
        });

        test('fullName should return the correct formatted name', () => {
            // User with first and last name
            const userEntity = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser', {
                userInfo: {
                    firstName: 'John',
                    lastName: 'Doe',
                },
            });
            expect(userEntity.fullName).toBe('John Doe');

            // User with only first name
            const userFirstNameOnly = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser', {
                userInfo: {
                    firstName: 'John',
                },
            });
            expect(userFirstNameOnly.fullName).toBe('John');

            // Business with business name
            const businessEntity = new Entity(
                'business123',
                'BUSINESS',
                'business@example.com',
                'BUSINESS_OWNER',
                'ACTIVE',
                'bizuser',
                {
                    businessInfo: {
                        businessName: 'Test Company',
                    },
                },
            );
            expect(businessEntity.fullName).toBe('Test Company');

            // Entity with display name but no other info
            const entityWithDisplayName = new Entity(
                'user123',
                'USER',
                'test@example.com',
                'USER',
                'ACTIVE',
                'testuser',
                {
                    displayName: 'Display Name',
                },
            );
            expect(entityWithDisplayName.fullName).toBe('Display Name');

            // Entity with only email
            const entityWithEmailOnly = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser');
            expect(entityWithEmailOnly.fullName).toBe('test@example.com');
        });

        test('isBusiness should return correct boolean value', () => {
            const userEntity = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser');
            expect(userEntity.isBusiness()).toBe(false);

            const businessEntity = new Entity(
                'business123',
                'BUSINESS',
                'business@example.com',
                'BUSINESS_OWNER',
                'ACTIVE',
                'bizuser',
            );
            expect(businessEntity.isBusiness()).toBe(true);
        });

        test('isUser should return correct boolean value', () => {
            const userEntity = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser');
            expect(userEntity.isUser()).toBe(true);

            const businessEntity = new Entity(
                'business123',
                'BUSINESS',
                'business@example.com',
                'BUSINESS_OWNER',
                'ACTIVE',
                'bizuser',
            );
            expect(businessEntity.isUser()).toBe(false);
        });

        test('hasAdminRole should return correct boolean value', () => {
            // Regular user
            const userEntity = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser');
            expect(userEntity.hasAdminRole()).toBe(false);

            // Admin user
            const adminEntity = new Entity('admin123', 'USER', 'admin@example.com', 'ADMIN', 'ACTIVE', 'adminuser');
            expect(adminEntity.hasAdminRole()).toBe(true);

            // Business owner
            const businessOwnerEntity = new Entity(
                'owner123',
                'BUSINESS',
                'owner@example.com',
                'BUSINESS_OWNER',
                'ACTIVE',
                'owneruser',
            );
            expect(businessOwnerEntity.hasAdminRole()).toBe(true);

            // Business staff
            const staffEntity = new Entity(
                'staff123',
                'BUSINESS',
                'staff@example.com',
                'BUSINESS_STAFF',
                'ACTIVE',
                'staffuser',
            );
            expect(staffEntity.hasAdminRole()).toBe(false);
        });

        test('phoneNumber should return the correct phone number', () => {
            // User with phone number
            const userEntity = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser', {
                userInfo: {
                    phoneNumber: '1234567890',
                },
            });
            expect(userEntity.phoneNumber).toBe('1234567890');

            // Business with phone number
            const businessEntity = new Entity(
                'business123',
                'BUSINESS',
                'business@example.com',
                'BUSINESS_OWNER',
                'ACTIVE',
                'bizuser',
                {
                    businessInfo: {
                        businessName: 'Test Business',
                        phoneNumber: '9876543210',
                    },
                },
            );
            expect(businessEntity.phoneNumber).toBe('9876543210');

            // Entity without phone number
            const entityWithoutPhone = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser');
            expect(entityWithoutPhone.phoneNumber).toBeUndefined();
        });
    });

    describe('DynamoDB Item Conversion', () => {
        test('toItem should convert entity to DynamoDB item format', () => {
            const userData = createSampleUser();
            // Ensure userInfo exists for the test
            expect(userData.userInfo).toBeDefined();

            const entity = new Entity(
                userData.id,
                userData.type,
                userData.email,
                userData.role,
                userData.status,
                userData.username,
                {
                    userInfo: userData.userInfo,
                    createdAt: userData.createdAt,
                    updatedAt: userData.updatedAt,
                },
            );

            const item = entity.toItem();

            // Check basic attributes
            expect(item.PK.S).toBe(`USER#${userData.id}`);
            expect(item.SK.S).toBe('PROFILE');
            expect(item.GSI1PK.S).toBe('ENTITY_TYPE#USER');
            expect(item.GSI2PK.S).toBe('EMAIL');
            expect(item.GSI2SK.S).toBe(userData.email);
            expect(item.id.S).toBe(userData.id);
            expect(item.type.S).toBe(userData.type);
            expect(item.email.S).toBe(userData.email);
            expect(item.role.S).toBe(userData.role);
            expect(item.status.S).toBe(userData.status);

            // Check userInfo is properly marshalled
            // Use safe navigation with optional chaining
            const firstName = userData.userInfo?.firstName;
            const lastName = userData.userInfo?.lastName;
            const phoneNumber = userData.userInfo?.phoneNumber;

            if (firstName) {
                expect(item.userInfo?.M?.firstName?.S).toBe(firstName);
            }
            if (lastName) {
                expect(item.userInfo?.M?.lastName?.S).toBe(lastName);
            }
            if (phoneNumber) {
                expect(item.userInfo?.M?.phoneNumber?.S).toBe(phoneNumber);
            }
        });

        test('toPhoneLookupItem should create correct lookup item', () => {
            // Entity with phone number
            const userEntity = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser', {
                userInfo: {
                    phoneNumber: '1234567890',
                },
            });

            const phoneLookup = userEntity.toPhoneLookupItem();
            expect(phoneLookup).not.toBeNull();
            if (phoneLookup) {
                expect(phoneLookup.PK.S).toBe('PHONE#1234567890');
                expect(phoneLookup.SK.S).toBe('USER#user123');
                expect(phoneLookup.GSI3PK.S).toBe('PHONE');
                expect(phoneLookup.GSI3SK.S).toBe('1234567890');
                expect(phoneLookup.id.S).toBe('user123');
                expect(phoneLookup.type.S).toBe('USER');
                expect(phoneLookup.phone.S).toBe('1234567890');
            }

            // Entity without phone number
            const entityWithoutPhone = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser');

            const emptyPhoneLookup = entityWithoutPhone.toPhoneLookupItem();
            expect(emptyPhoneLookup).toBeNull();
        });

        test('toEmailLookupItem should create correct lookup item', () => {
            const userEntity = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testuser');

            const emailLookup = userEntity.toEmailLookupItem();
            expect(emailLookup.PK.S).toBe('EMAIL#test@example.com');
            expect(emailLookup.SK.S).toBe('USER#user123');
            expect(emailLookup.GSI1PK.S).toBe('EMAIL');
            expect(emailLookup.GSI1SK.S).toBe('test@example.com');
            expect(emailLookup.id.S).toBe('user123');
            expect(emailLookup.type.S).toBe('USER');
            expect(emailLookup.email.S).toBe('test@example.com');
        });

        test('toUsernameLookupItem should create correct lookup item', () => {
            const userEntity = new Entity('user123', 'USER', 'test@example.com', 'USER', 'ACTIVE', 'testUser', {
                displayName: 'Test Display Name',
            });

            const usernameLookup = userEntity.toUsernameLookupItem();
            expect(usernameLookup.PK.S).toBe('USERNAME#testuser');
            expect(usernameLookup.SK.S).toBe('USER#user123');
            expect(usernameLookup.GSI1PK.S).toBe('USERNAME');
            expect(usernameLookup.GSI1SK.S).toBe('testuser');
            expect(usernameLookup.id.S).toBe('user123');
            expect(usernameLookup.type.S).toBe('USER');
            expect(usernameLookup.username.S).toBe('testuser');
            expect(usernameLookup.displayName.S).toBe('Test Display Name');
        });
    });

    describe('fromItem Static Method', () => {
        test('should create Entity from DynamoDB item', () => {
            const userData = createSampleUser();
            // Ensure userInfo exists for the test
            expect(userData.userInfo).toBeDefined();

            const dynamoDBItem = userToDynamoDBItem(userData);

            const entity = Entity.fromItem(dynamoDBItem);

            expect(entity.id).toBe(userData.id);
            expect(entity.type).toBe(userData.type);
            expect(entity.email).toBe(userData.email);
            expect(entity.role).toBe(userData.role);
            expect(entity.status).toBe(userData.status);
            expect(entity.username).toBe(userData.username);

            // Safe access with optional chaining
            if (userData.userInfo) {
                expect(entity.userInfo?.firstName).toBe(userData.userInfo.firstName);
                expect(entity.userInfo?.lastName).toBe(userData.userInfo.lastName);
                expect(entity.userInfo?.phoneNumber).toBe(userData.userInfo.phoneNumber);
            }

            expect(entity.createdAt).toBe(userData.createdAt);
            expect(entity.updatedAt).toBe(userData.updatedAt);
        });

        test('should throw error if item is undefined', () => {
            expect(() => Entity.fromItem(undefined)).toThrow('No entity item found!');
        });
    });

    describe('Database Operations', () => {
        test('create method should put items in DynamoDB', async () => {
            const userData = createSampleUser();
            // Ensure userInfo exists for the test
            expect(userData.userInfo).toBeDefined();

            const entity = new Entity(
                userData.id,
                userData.type,
                userData.email,
                userData.role,
                userData.status,
                userData.username,
                {
                    userInfo: userData.userInfo,
                    createdAt: userData.createdAt,
                    updatedAt: userData.updatedAt,
                },
            );

            mockDynamoClient.on(TransactWriteItemsCommand).resolves({});

            await entity.create();

            // Verify the TransactWriteItemsCommand was called with correct parameters
            const calls = mockDynamoClient.commandCalls(TransactWriteItemsCommand);
            expect(calls).toHaveLength(1);

            // Add type safety with optional chaining and non-null assertions for test context
            const transactItems = calls[0]?.args[0]?.input?.TransactItems;
            expect(transactItems).toHaveLength(4); // Main item, email lookup, username lookup, phone lookup

            // Check main item
            expect(transactItems?.[0]?.Put?.Item?.PK?.S).toBe(`USER#${userData.id}`);
            expect(transactItems?.[0]?.Put?.Item?.SK?.S).toBe('PROFILE');

            // Check email lookup
            expect(transactItems?.[1]?.Put?.Item?.PK?.S).toBe(`EMAIL#${userData.email}`);

            // Check username lookup
            expect(transactItems?.[2]?.Put?.Item?.PK?.S).toBe(`USERNAME#${userData.username}`);

            // Check phone lookup
            const phoneNumber = userData.userInfo?.phoneNumber;
            if (phoneNumber) {
                expect(transactItems?.[3]?.Put?.Item?.PK?.S).toBe(`PHONE#${phoneNumber}`);
            }
        });

        test('update method should update items in DynamoDB', async () => {
            const userData = createSampleUser();
            const entity = new Entity(
                userData.id,
                userData.type,
                userData.email,
                userData.role,
                userData.status,
                userData.username,
                {
                    userInfo: userData.userInfo,
                    createdAt: userData.createdAt,
                    updatedAt: userData.updatedAt,
                },
            );

            mockDynamoClient.on(TransactWriteItemsCommand).resolves({});

            await entity.update();

            // Verify the TransactWriteItemsCommand was called with correct parameters
            const calls = mockDynamoClient.commandCalls(TransactWriteItemsCommand);
            expect(calls).toHaveLength(1);

            // Add type safety with non-null assertions for test context
            const transactItems = calls[0]?.args[0]?.input?.TransactItems;
            if (!transactItems) {
                fail('TransactItems should be defined');
                return;
            }

            expect(transactItems).toHaveLength(3); // Main item, email lookup, phone lookup

            // Check main item with safe navigation
            expect(transactItems?.[0]?.Put?.Item?.PK?.S).toBe(`USER#${userData.id}`);
            expect(transactItems?.[0]?.Put?.Item?.SK?.S).toBe('PROFILE');

            // Check that updatedAt was updated
            expect(transactItems?.[0]?.Put?.Item?.updatedAt?.S).not.toBe(userData.updatedAt);
        });

        test('getById should retrieve entity by ID', async () => {
            const userData = createSampleUser();
            const dynamoDBItem = userToDynamoDBItem(userData);

            mockDynamoClient.on(GetItemCommand).resolves({
                Item: dynamoDBItem,
            });

            const entity = await Entity.getById(userData.id, userData.type);

            // Verify GetItemCommand was called with correct parameters
            const calls = mockDynamoClient.commandCalls(GetItemCommand);
            expect(calls).toHaveLength(1);
            expect(calls[0].args[0].input.Key?.PK?.S).toBe(`USER#${userData.id}`);
            expect(calls[0].args[0].input.Key?.SK?.S).toBe('PROFILE');

            // Verify entity was properly created
            expect(entity).toBeInstanceOf(Entity);
            expect(entity?.id).toBe(userData.id);
            expect(entity?.type).toBe(userData.type);
            expect(entity?.email).toBe(userData.email);
        });

        test('getById should return null if entity not found', async () => {
            mockDynamoClient.on(GetItemCommand).resolves({
                Item: undefined,
            });

            const entity = await Entity.getById('nonexistent-id', 'USER');

            expect(entity).toBeNull();
        });

        test('getByEmail should retrieve entity by email', async () => {
            const userData = createSampleUser();

            // First mock the lookup query
            mockDynamoClient.on(GetItemCommand).resolves({
                Item: {
                    id: { S: userData.id },
                    type: { S: userData.type },
                    email: { S: userData.email },
                },
            });

            // Then mock the getById call that will follow
            mockDynamoClient.on(GetItemCommand).resolves({
                Item: userToDynamoDBItem(userData),
            });

            const entity = await Entity.getByEmail(userData.email);

            expect(entity).toBeInstanceOf(Entity);
            expect(entity?.id).toBe(userData.id);
            expect(entity?.email).toBe(userData.email);
        });

        test('getByEmail should use GSI2 as fallback if direct lookup fails', async () => {
            const userData = createSampleUser();

            // First mock the lookup query failing
            mockDynamoClient.on(GetItemCommand).resolves({
                Item: undefined,
            });

            // Then mock the fallback to GSI2
            mockDynamoClient.on(QueryCommand).resolves({
                Items: [userToDynamoDBItem(userData)],
            });

            const entity = await Entity.getByEmail(userData.email);

            expect(entity).toBeInstanceOf(Entity);
            expect(entity?.id).toBe(userData.id);
            expect(entity?.email).toBe(userData.email);
        });

        test('listByType should list entities of a given type', async () => {
            const userData1 = createSampleUser();
            userData1.id = 'user1';

            const userData2 = createSampleUser();
            userData2.id = 'user2';

            mockDynamoClient.on(QueryCommand).resolves({
                Items: [userToDynamoDBItem(userData1), userToDynamoDBItem(userData2)],
            });

            const result = await Entity.listByType('USER');

            // Verify QueryCommand was called with correct parameters
            const calls = mockDynamoClient.commandCalls(QueryCommand);
            expect(calls).toHaveLength(1);
            expect(calls[0]?.args[0]?.input?.IndexName).toBe('GSI1');
            expect(calls[0]?.args[0]?.input?.KeyConditionExpression).toBe('GSI1PK = :gsi1pk');

            const gsiValue = calls[0]?.args[0]?.input?.ExpressionAttributeValues?.[':gsi1pk']?.S;
            expect(gsiValue).toBe('ENTITY_TYPE#USER');

            // Verify result
            expect(result.entities).toHaveLength(2);
            expect(result.entities[0].id).toBe('user1');
            expect(result.entities[1].id).toBe('user2');
        });

        test('listByType should filter by status if provided', async () => {
            mockDynamoClient.on(QueryCommand).resolves({
                Items: [userToDynamoDBItem(createSampleUser())],
            });

            await Entity.listByType('USER', { status: 'ACTIVE' });

            // Verify QueryCommand was called with correct parameters
            const calls = mockDynamoClient.commandCalls(QueryCommand);
            expect(calls).toHaveLength(1);
            expect(calls[0]?.args[0]?.input?.KeyConditionExpression).toBe(
                'GSI1PK = :gsi1pk AND begins_with(GSI1SK, :statusPrefix)',
            );

            const statusValue = calls[0]?.args[0]?.input?.ExpressionAttributeValues?.[':statusPrefix']?.S;
            expect(statusValue).toBe('STATUS#ACTIVE');
        });

        test('listByType should filter by role if provided', async () => {
            mockDynamoClient.on(QueryCommand).resolves({
                Items: [userToDynamoDBItem(createSampleUser())],
            });

            await Entity.listByType('USER', { role: 'ADMIN' });

            // Verify QueryCommand was called with correct parameters
            const calls = mockDynamoClient.commandCalls(QueryCommand);
            expect(calls).toHaveLength(1);
            expect(calls[0]?.args[0]?.input?.FilterExpression).toBe('contains(GSI1SK, :roleFilter)');

            const roleValue = calls[0]?.args[0]?.input?.ExpressionAttributeValues?.[':roleFilter']?.S;
            expect(roleValue).toBe('ROLE#ADMIN');
        });
    });

    describe('Factory Methods', () => {
        test('createUser should create a user entity', () => {
            const entity = Entity.createUser('test@example.com', 'testuser', {
                firstName: 'Test',
                lastName: 'User',
                phoneNumber: '1234567890',
            });

            expect(entity).toBeInstanceOf(Entity);
            expect(entity.type).toBe('USER');
            expect(entity.email).toBe('test@example.com');
            expect(entity.role).toBe('USER');
            expect(entity.status).toBe('PENDING');
            expect(entity.username).toBe('testuser');
            expect(entity.userInfo?.firstName).toBe('Test');
            expect(entity.userInfo?.lastName).toBe('User');
            expect(entity.userInfo?.phoneNumber).toBe('1234567890');
        });

        test('createBusiness should create a business entity', () => {
            const entity = Entity.createBusiness('business@example.com', 'Test Business', 'businessuser', {
                businessType: 'LLC',
                phoneNumber: '9876543210',
                website: 'https://example.com',
            });

            expect(entity).toBeInstanceOf(Entity);
            expect(entity.type).toBe('BUSINESS');
            expect(entity.email).toBe('business@example.com');
            expect(entity.role).toBe('BUSINESS_OWNER');
            expect(entity.status).toBe('PENDING');
            expect(entity.username).toBe('businessuser');
            expect(entity.displayName).toBe('Test Business');
            expect(entity.businessInfo?.businessName).toBe('Test Business');
            expect(entity.businessInfo?.businessType).toBe('LLC');
            expect(entity.businessInfo?.phoneNumber).toBe('9876543210');
            expect(entity.businessInfo?.website).toBe('https://example.com');
        });
    });
});
</file>

<file path="layers/commons/data/entities/__tests__/money.test.ts">
import { Money } from '../money';

describe('Money', () => {
    it('should properly handle decimal arithmetic', () => {
        // This would fail with regular JS arithmetic (0.1 + 0.2 !== 0.3)
        const money1 = new Money(0.1, 'USD');
        const money2 = new Money(0.2, 'USD');
        const result = money1.add(money2);

        expect(result.toString()).toBe('0.30');
        expect(result.equals(new Money(0.3, 'USD'))).toBe(true);
    });

    it('should handle wallet scenario correctly', () => {
        // Initial balance
        const initialBalance = new Money(100, 'USD');

        // Multiple transactions with small amounts
        const transaction1 = new Money(0.1, 'USD');
        const transaction2 = new Money(0.2, 'USD');
        const transaction3 = new Money(0.3, 'USD');

        // Multiple additions should be precise
        let balance = initialBalance.add(transaction1).add(transaction2).add(transaction3);

        expect(balance.toString()).toBe('100.60');

        // Take away the exact amount we added
        balance = balance.subtract(transaction1).subtract(transaction2).subtract(transaction3);

        // Should get back exactly to our starting amount
        expect(balance.toString()).toBe('100.00');
        expect(balance.equals(initialBalance)).toBe(true);
    });
});
</file>

<file path="layers/commons/data/entities/balance-ledger.test.ts">
import { BalanceLedger } from './balance-ledger';
import { Money } from './money';

// Mock the AWS SDK client
jest.mock('../client', () => ({
    getClient: jest.fn().mockReturnValue({
        send: jest.fn(),
    }),
}));

// Import mocked module
import { getClient } from '../client';
const mockedGetClient = getClient as jest.MockedFunction<typeof getClient>;
const mockedSend = mockedGetClient().send as jest.MockedFunction<any>;

describe('BalanceLedger', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    // Constructor tests
    describe('constructor', () => {
        it('should create a new BalanceLedger instance with default values', () => {
            const ledger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'CREDIT',
                '100.00',
                '150.00',
                'Test credit',
            );

            expect(ledger.entityId).toBe('user123');
            expect(ledger.entityType).toBe('USER');
            expect(ledger.transactionId).toBe('txn123');
            expect(ledger.walletId).toBe('wallet123');
            expect(ledger.amount).toBe('50.00');
            expect(ledger.type).toBe('CREDIT');
            expect(ledger.balanceBefore).toBe('100.00');
            expect(ledger.balanceAfter).toBe('150.00');
            expect(ledger.description).toBe('Test credit');
            expect(ledger.ledgerId).toMatch(/^ledger_[0-9a-f-]+$/);
            expect(ledger.createdAt).toBeDefined();
        });

        it('should create a BalanceLedger instance with custom options', () => {
            const customLedgerId = 'custom_ledger_id';
            const customCreatedAt = '2023-01-01T00:00:00Z';

            const ledger = new BalanceLedger(
                'business123',
                'BUSINESS',
                'txn456',
                'wallet456',
                '25.00',
                'DEBIT',
                '150.00',
                '125.00',
                'Test debit',
                {
                    ledgerId: customLedgerId,
                    createdAt: customCreatedAt,
                },
            );

            expect(ledger.entityId).toBe('business123');
            expect(ledger.entityType).toBe('BUSINESS');
            expect(ledger.transactionId).toBe('txn456');
            expect(ledger.walletId).toBe('wallet456');
            expect(ledger.amount).toBe('25.00');
            expect(ledger.type).toBe('DEBIT');
            expect(ledger.balanceBefore).toBe('150.00');
            expect(ledger.balanceAfter).toBe('125.00');
            expect(ledger.description).toBe('Test debit');
            expect(ledger.ledgerId).toBe(customLedgerId);
            expect(ledger.createdAt).toBe(customCreatedAt);
        });
    });

    // Getter tests
    describe('getters', () => {
        it('should return the correct PK and SK values', () => {
            const ledger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'CREDIT',
                '100.00',
                '150.00',
                'Test credit',
                {
                    createdAt: '2023-01-01T00:00:00Z',
                },
            );

            expect(ledger.pk).toBe('USER#user123');
            expect(ledger.sk).toBe('LEDGER#2023-01-01T00:00:00Z#txn123');
        });

        it('should convert amount to Money object', () => {
            const ledger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'CREDIT',
                '100.00',
                '150.00',
                'Test credit',
            );

            const amountMoney = ledger.getAmount();
            expect(amountMoney).toBeInstanceOf(Money);
            expect(amountMoney.toString()).toBe('50.00');
            expect(amountMoney.currency).toBe('USD');
        });

        it('should convert balanceBefore to Money object', () => {
            const ledger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'CREDIT',
                '100.00',
                '150.00',
                'Test credit',
            );

            const balanceBeforeMoney = ledger.getBalanceBefore();
            expect(balanceBeforeMoney).toBeInstanceOf(Money);
            expect(balanceBeforeMoney.toString()).toBe('100.00');
            expect(balanceBeforeMoney.currency).toBe('USD');
        });

        it('should convert balanceAfter to Money object', () => {
            const ledger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'CREDIT',
                '100.00',
                '150.00',
                'Test credit',
            );

            const balanceAfterMoney = ledger.getBalanceAfter();
            expect(balanceAfterMoney).toBeInstanceOf(Money);
            expect(balanceAfterMoney.toString()).toBe('150.00');
            expect(balanceAfterMoney.currency).toBe('USD');
        });

        it('should check if entry is a credit', () => {
            const creditLedger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'CREDIT',
                '100.00',
                '150.00',
                'Test credit',
            );

            const debitLedger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'DEBIT',
                '150.00',
                '100.00',
                'Test debit',
            );

            expect(creditLedger.isCredit()).toBe(true);
            expect(creditLedger.isDebit()).toBe(false);
            expect(debitLedger.isCredit()).toBe(false);
            expect(debitLedger.isDebit()).toBe(true);
        });
    });

    // DynamoDB conversion tests
    describe('toItem and fromItem', () => {
        it('should convert ledger to DynamoDB item', () => {
            const ledger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'CREDIT',
                '100.00',
                '150.00',
                'Test credit',
                {
                    ledgerId: 'ledger123',
                    createdAt: '2023-01-01T00:00:00Z',
                },
            );

            const item = ledger.toItem();

            expect(item.PK.S).toBe('USER#user123');
            expect(item.SK.S).toBe('LEDGER#2023-01-01T00:00:00Z#txn123');
            expect(item.GSI1PK.S).toBe('TXN#txn123');
            expect(item.GSI1SK.S).toBe('LEDGER#user123');
            expect(item.ledgerId.S).toBe('ledger123');
            expect(item.entityId.S).toBe('user123');
            expect(item.entityType.S).toBe('USER');
            expect(item.transactionId.S).toBe('txn123');
            expect(item.walletId.S).toBe('wallet123');
            expect(item.amount.S).toBe('50.00');
            expect(item.type.S).toBe('CREDIT');
            expect(item.balanceBefore.S).toBe('100.00');
            expect(item.balanceAfter.S).toBe('150.00');
            expect(item.description.S).toBe('Test credit');
            expect(item.createdAt.S).toBe('2023-01-01T00:00:00Z');
        });

        it('should convert DynamoDB item to ledger', () => {
            const item = {
                PK: { S: 'USER#user123' },
                SK: { S: 'LEDGER#2023-01-01T00:00:00Z#txn123' },
                GSI1PK: { S: 'TXN#txn123' },
                GSI1SK: { S: 'LEDGER#user123' },
                ledgerId: { S: 'ledger123' },
                entityId: { S: 'user123' },
                entityType: { S: 'USER' },
                transactionId: { S: 'txn123' },
                walletId: { S: 'wallet123' },
                amount: { S: '50.00' },
                type: { S: 'CREDIT' },
                balanceBefore: { S: '100.00' },
                balanceAfter: { S: '150.00' },
                description: { S: 'Test credit' },
                createdAt: { S: '2023-01-01T00:00:00Z' },
            };

            const ledger = BalanceLedger.fromItem(item);

            expect(ledger.ledgerId).toBe('ledger123');
            expect(ledger.entityId).toBe('user123');
            expect(ledger.entityType).toBe('USER');
            expect(ledger.transactionId).toBe('txn123');
            expect(ledger.walletId).toBe('wallet123');
            expect(ledger.amount).toBe('50.00');
            expect(ledger.type).toBe('CREDIT');
            expect(ledger.balanceBefore).toBe('100.00');
            expect(ledger.balanceAfter).toBe('150.00');
            expect(ledger.description).toBe('Test credit');
            expect(ledger.createdAt).toBe('2023-01-01T00:00:00Z');
        });

        it('should throw error when item is undefined', () => {
            expect(() => BalanceLedger.fromItem(undefined)).toThrow('No balance ledger item found!');
        });
    });

    // Database operation tests
    describe('database operations', () => {
        // Mock dates for consistent testing
        const mockDate = new Date('2023-01-01T00:00:00Z');
        let originalDate: DateConstructor;

        beforeEach(() => {
            originalDate = global.Date;
            global.Date = class extends Date {
                constructor() {
                    super();
                    return mockDate;
                }
                static now() {
                    return mockDate.getTime();
                }
            } as DateConstructor;

            // Set up environment variables
            process.env.TABLE_NAME = 'TestTable';
        });

        afterEach(() => {
            global.Date = originalDate;
            delete process.env.TABLE_NAME;
        });

        it('should create a ledger entry in the database', async () => {
            const ledger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'CREDIT',
                '100.00',
                '150.00',
                'Test credit',
            );

            mockedSend.mockResolvedValueOnce({});

            await ledger.create();

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Item: ledger.toItem(),
                        ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                    }),
                }),
            );
        });

        it('should throw error when create fails', async () => {
            const ledger = new BalanceLedger(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                'CREDIT',
                '100.00',
                '150.00',
                'Test credit',
            );

            const error = new Error('DynamoDB error');
            mockedSend.mockRejectedValueOnce(error);

            await expect(ledger.create()).rejects.toThrow(error);
            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should list ledger entries by entity', async () => {
            const mockItems = [
                {
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    transactionId: { S: 'txn123' },
                    walletId: { S: 'wallet123' },
                    amount: { S: '50.00' },
                    type: { S: 'CREDIT' },
                    balanceBefore: { S: '100.00' },
                    balanceAfter: { S: '150.00' },
                    description: { S: 'Test credit' },
                    ledgerId: { S: 'ledger123' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                },
                {
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    transactionId: { S: 'txn456' },
                    walletId: { S: 'wallet123' },
                    amount: { S: '25.00' },
                    type: { S: 'DEBIT' },
                    balanceBefore: { S: '150.00' },
                    balanceAfter: { S: '125.00' },
                    description: { S: 'Test debit' },
                    ledgerId: { S: 'ledger456' },
                    createdAt: { S: '2023-01-02T00:00:00Z' },
                },
            ];

            mockedSend.mockResolvedValueOnce({
                Items: mockItems,
                LastEvaluatedKey: { PK: { S: 'USER#user123' } },
            });

            const result = await BalanceLedger.listByEntity('user123', 'USER', {
                limit: 10,
                fromDate: '2023-01-01',
                toDate: '2023-01-03',
            });

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        KeyConditionExpression: 'PK = :pk AND SK BETWEEN :fromDate AND :toDate',
                        ExpressionAttributeValues: {
                            ':pk': { S: 'USER#user123' },
                            ':fromDate': { S: 'LEDGER#2023-01-01' },
                            ':toDate': { S: 'LEDGER#2023-01-03Z' },
                            ':ledger_prefix': { S: 'LEDGER#' },
                        },
                        Limit: 10,
                        ScanIndexForward: false,
                    }),
                }),
            );

            expect(result.ledgerEntries).toHaveLength(2);
            expect(result.ledgerEntries[0].transactionId).toBe('txn123');
            expect(result.ledgerEntries[1].transactionId).toBe('txn456');
            expect(result.lastEvaluatedKey).toEqual({ PK: { S: 'USER#user123' } });
        });

        it('should list ledger entries by transaction', async () => {
            const mockItems = [
                {
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    transactionId: { S: 'txn123' },
                    walletId: { S: 'wallet123' },
                    amount: { S: '50.00' },
                    type: { S: 'CREDIT' },
                    balanceBefore: { S: '100.00' },
                    balanceAfter: { S: '150.00' },
                    description: { S: 'Test credit' },
                    ledgerId: { S: 'ledger123' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                },
            ];

            mockedSend.mockResolvedValueOnce({
                Items: mockItems,
            });

            const result = await BalanceLedger.listByTransaction('txn123');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        IndexName: 'GSI1',
                        KeyConditionExpression: 'GSI1PK = :gsi1pk AND begins_with(GSI1SK, :ledger_prefix)',
                        ExpressionAttributeValues: {
                            ':gsi1pk': { S: 'TXN#txn123' },
                            ':ledger_prefix': { S: 'LEDGER#' },
                        },
                    }),
                }),
            );

            expect(result).toHaveLength(1);
            expect(result[0].transactionId).toBe('txn123');
        });

        it('should calculate sum by date range', async () => {
            // Mock the listByEntity function to return some ledger entries
            const mockLedgerEntries = [
                new BalanceLedger(
                    'user123',
                    'USER',
                    'txn1',
                    'wallet123',
                    '100.00',
                    'CREDIT',
                    '0.00',
                    '100.00',
                    'Deposit',
                ),
                new BalanceLedger(
                    'user123',
                    'USER',
                    'txn2',
                    'wallet123',
                    '50.00',
                    'DEBIT',
                    '100.00',
                    '50.00',
                    'Withdrawal',
                ),
                new BalanceLedger(
                    'user123',
                    'USER',
                    'txn3',
                    'wallet123',
                    '25.00',
                    'CREDIT',
                    '50.00',
                    '75.00',
                    'Transfer in',
                ),
            ];

            // We'll spy on the listByEntity method and make it return our mock data
            const listByEntitySpy = jest
                .spyOn(BalanceLedger, 'listByEntity')
                .mockResolvedValue({ ledgerEntries: mockLedgerEntries, lastEvaluatedKey: undefined });

            const result = await BalanceLedger.getSumByDateRange('user123', 'USER', '2023-01-01', '2023-01-31');

            // Verify listByEntity was called correctly
            expect(listByEntitySpy).toHaveBeenCalledWith('user123', 'USER', {
                fromDate: '2023-01-01',
                toDate: '2023-01-31',
                limit: 1000,
            });

            // Verify the results
            expect(result.totalCredit.toString()).toBe('125.00');
            expect(result.totalDebit.toString()).toBe('50.00');
            expect(result.netChange.toString()).toBe('75.00');
            expect(result.count).toBe(3);

            // Restore the spy
            listByEntitySpy.mockRestore();
        });
    });

    // Factory method tests
    describe('factory methods', () => {
        it('should create a credit entry using factory method', () => {
            const ledger = BalanceLedger.createCreditEntry(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                '100.00',
                '150.00',
                'Test credit',
            );

            expect(ledger).toBeInstanceOf(BalanceLedger);
            expect(ledger.entityId).toBe('user123');
            expect(ledger.entityType).toBe('USER');
            expect(ledger.transactionId).toBe('txn123');
            expect(ledger.type).toBe('CREDIT');
            expect(ledger.amount).toBe('50.00');
        });

        it('should create a debit entry using factory method', () => {
            const ledger = BalanceLedger.createDebitEntry(
                'user123',
                'USER',
                'txn123',
                'wallet123',
                '50.00',
                '150.00',
                '100.00',
                'Test debit',
            );

            expect(ledger).toBeInstanceOf(BalanceLedger);
            expect(ledger.entityId).toBe('user123');
            expect(ledger.entityType).toBe('USER');
            expect(ledger.transactionId).toBe('txn123');
            expect(ledger.type).toBe('DEBIT');
            expect(ledger.amount).toBe('50.00');
        });
    });
});
</file>

<file path="layers/commons/data/entities/balance-ledger.ts">
import { DynamoDBClient, QueryCommand, PutItemCommand, AttributeValue } from '@aws-sdk/client-dynamodb';
import { getClient } from '../client';
import { v4 as uuidv4 } from 'uuid';
import { Money } from './money';

export type LedgerEntryType = 'CREDIT' | 'DEBIT';

/**
 * BalanceLedger class for tracking wallet balance changes
 * Provides an audit trail for all balance adjustments
 */
export class BalanceLedger {
    ledgerId: string;
    entityId: string;
    entityType: string;
    transactionId: string;
    walletId: string;
    amount: string;
    type: LedgerEntryType;
    balanceBefore: string;
    balanceAfter: string;
    description: string;
    createdAt: string;

    /**
     * Create a new BalanceLedger instance
     */
    constructor(
        entityId: string,
        entityType: string,
        transactionId: string,
        walletId: string,
        amount: string,
        type: LedgerEntryType,
        balanceBefore: string,
        balanceAfter: string,
        description: string,
        options: {
            ledgerId?: string;
            createdAt?: string;
        } = {},
    ) {
        this.ledgerId = options.ledgerId || `ledger_${uuidv4()}`;
        this.entityId = entityId;
        this.entityType = entityType;
        this.transactionId = transactionId;
        this.walletId = walletId;
        this.amount = amount;
        this.type = type;
        this.balanceBefore = balanceBefore;
        this.balanceAfter = balanceAfter;
        this.description = description;
        this.createdAt = options.createdAt || new Date().toISOString();
    }

    get pk(): string {
        return `${this.entityType}#${this.entityId}`;
    }

    get sk(): string {
        return `LEDGER#${this.createdAt}#${this.transactionId}`;
    }

    /**
     * Get amount as Money object
     */
    getAmount(): Money {
        // This should be the currency from the wallet, but we default to USD
        return new Money(this.amount, 'USD');
    }

    /**
     * Get balance before as Money object
     */
    getBalanceBefore(): Money {
        return new Money(this.balanceBefore, 'USD');
    }

    /**
     * Get balance after as Money object
     */
    getBalanceAfter(): Money {
        return new Money(this.balanceAfter, 'USD');
    }

    /**
     * Check if this is a credit entry (adding money)
     */
    isCredit(): boolean {
        return this.type === 'CREDIT';
    }

    /**
     * Check if this is a debit entry (removing money)
     */
    isDebit(): boolean {
        return this.type === 'DEBIT';
    }

    toItem(): Record<string, AttributeValue> {
        return {
            PK: { S: this.pk },
            SK: { S: this.sk },
            GSI1PK: { S: `TXN#${this.transactionId}` },
            GSI1SK: { S: `LEDGER#${this.entityId}` },
            ledgerId: { S: this.ledgerId },
            entityId: { S: this.entityId },
            entityType: { S: this.entityType },
            transactionId: { S: this.transactionId },
            walletId: { S: this.walletId },
            amount: { S: this.amount },
            type: { S: this.type },
            balanceBefore: { S: this.balanceBefore },
            balanceAfter: { S: this.balanceAfter },
            description: { S: this.description },
            createdAt: { S: this.createdAt },
        };
    }

    static fromItem(item?: Record<string, AttributeValue>): BalanceLedger {
        if (!item) throw new Error('No balance ledger item found!');

        return new BalanceLedger(
            item.entityId.S!,
            item.entityType.S!,
            item.transactionId.S!,
            item.walletId.S!,
            item.amount.S!,
            item.type.S as LedgerEntryType,
            item.balanceBefore.S!,
            item.balanceAfter.S!,
            item.description.S!,
            {
                ledgerId: item.ledgerId.S!,
                createdAt: item.createdAt.S!,
            },
        );
    }

    /**
     * Create a new balance ledger entry in the database
     */
    async create(): Promise<BalanceLedger> {
        const client = getClient();

        try {
            await client.send(
                new PutItemCommand({
                    TableName: process.env.TABLE_NAME!,
                    Item: this.toItem(),
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                }),
            );

            return this;
        } catch (error) {
            console.error('Error creating balance ledger entry:', error);
            throw error;
        }
    }

    /**
     * Get all ledger entries for an entity
     */
    static async listByEntity(
        entityId: string,
        entityType: string,
        options: {
            limit?: number;
            startKey?: Record<string, AttributeValue>;
            fromDate?: string;
            toDate?: string;
        } = {},
    ): Promise<{
        ledgerEntries: BalanceLedger[];
        lastEvaluatedKey?: Record<string, AttributeValue>;
    }> {
        const client = getClient();
        const { limit = 50, startKey, fromDate, toDate } = options;

        try {
            let keyConditionExpression = 'PK = :pk AND begins_with(SK, :ledger_prefix)';
            const expressionAttributeValues: Record<string, AttributeValue> = {
                ':pk': { S: `${entityType}#${entityId}` },
                ':ledger_prefix': { S: 'LEDGER#' },
            };

            // Add date range condition if provided
            if (fromDate && toDate) {
                keyConditionExpression = 'PK = :pk AND SK BETWEEN :fromDate AND :toDate';
                expressionAttributeValues[':fromDate'] = { S: `LEDGER#${fromDate}` };
                expressionAttributeValues[':toDate'] = { S: `LEDGER#${toDate}Z` }; // Z to include all entries on that day
            } else if (fromDate) {
                keyConditionExpression = 'PK = :pk AND SK >= :fromDate';
                expressionAttributeValues[':fromDate'] = { S: `LEDGER#${fromDate}` };
            } else if (toDate) {
                keyConditionExpression = 'PK = :pk AND begins_with(SK, :ledger_prefix) AND SK <= :toDate';
                expressionAttributeValues[':toDate'] = { S: `LEDGER#${toDate}Z` };
            }

            const response = await client.send(
                new QueryCommand({
                    TableName: process.env.TABLE_NAME!,
                    KeyConditionExpression: keyConditionExpression,
                    ExpressionAttributeValues: expressionAttributeValues,
                    Limit: limit,
                    ScanIndexForward: false, // Most recent first
                }),
            );

            return {
                ledgerEntries: (response.Items || []).map((item) => BalanceLedger.fromItem(item)),
                lastEvaluatedKey: response.LastEvaluatedKey,
            };
        } catch (error) {
            console.error(`Error listing ledger entries for ${entityType} ${entityId}:`, error);
            throw error;
        }
    }

    /**
     * Get all ledger entries for a transaction
     */
    static async listByTransaction(transactionId: string): Promise<BalanceLedger[]> {
        const client = getClient();

        try {
            const response = await client.send(
                new QueryCommand({
                    TableName: process.env.TABLE_NAME!,
                    IndexName: 'GSI1',
                    KeyConditionExpression: 'GSI1PK = :gsi1pk AND begins_with(GSI1SK, :ledger_prefix)',
                    ExpressionAttributeValues: {
                        ':gsi1pk': { S: `TXN#${transactionId}` },
                        ':ledger_prefix': { S: 'LEDGER#' },
                    },
                }),
            );

            return (response.Items || []).map((item) => BalanceLedger.fromItem(item));
        } catch (error) {
            console.error(`Error listing ledger entries for transaction ${transactionId}:`, error);
            throw error;
        }
    }

    /**
     * Get the sum of all ledger entries for an entity within a date range
     * Useful for reporting and reconciliation
     */
    static async getSumByDateRange(
        entityId: string,
        entityType: string,
        fromDate: string,
        toDate: string,
    ): Promise<{
        totalCredit: Money;
        totalDebit: Money;
        netChange: Money;
        count: number;
    }> {
        // Get all ledger entries for the date range
        const { ledgerEntries } = await BalanceLedger.listByEntity(entityId, entityType, {
            fromDate,
            toDate,
            limit: 1000,
        });

        // Calculate totals
        let totalCredit = new Money('0.00');
        let totalDebit = new Money('0.00');

        ledgerEntries.forEach((entry) => {
            const amount = entry.getAmount();
            if (entry.isCredit()) {
                totalCredit = totalCredit.add(amount);
            } else {
                totalDebit = totalDebit.add(amount);
            }
        });

        // Net change is credits minus debits
        const netChange = totalCredit.subtract(totalDebit);

        return {
            totalCredit,
            totalDebit,
            netChange,
            count: ledgerEntries.length,
        };
    }

    /**
     * Factory method to create a credit ledger entry
     */
    static createCreditEntry(
        entityId: string,
        entityType: string,
        transactionId: string,
        walletId: string,
        amount: string,
        balanceBefore: string,
        balanceAfter: string,
        description: string,
    ): BalanceLedger {
        return new BalanceLedger(
            entityId,
            entityType,
            transactionId,
            walletId,
            amount,
            'CREDIT',
            balanceBefore,
            balanceAfter,
            description,
        );
    }

    /**
     * Factory method to create a debit ledger entry
     */
    static createDebitEntry(
        entityId: string,
        entityType: string,
        transactionId: string,
        walletId: string,
        amount: string,
        balanceBefore: string,
        balanceAfter: string,
        description: string,
    ): BalanceLedger {
        return new BalanceLedger(
            entityId,
            entityType,
            transactionId,
            walletId,
            amount,
            'DEBIT',
            balanceBefore,
            balanceAfter,
            description,
        );
    }
}

/**
 * Create a new credit ledger entry
 */
export const createCreditLedgerEntry = async (
    entityId: string,
    entityType: string,
    transactionId: string,
    walletId: string,
    amount: string,
    balanceBefore: string,
    balanceAfter: string,
    description: string,
): Promise<BalanceLedger> => {
    const ledgerEntry = BalanceLedger.createCreditEntry(
        entityId,
        entityType,
        transactionId,
        walletId,
        amount,
        balanceBefore,
        balanceAfter,
        description,
    );
    return ledgerEntry.create();
};

/**
 * Create a new debit ledger entry
 */
export const createDebitLedgerEntry = async (
    entityId: string,
    entityType: string,
    transactionId: string,
    walletId: string,
    amount: string,
    balanceBefore: string,
    balanceAfter: string,
    description: string,
): Promise<BalanceLedger> => {
    const ledgerEntry = BalanceLedger.createDebitEntry(
        entityId,
        entityType,
        transactionId,
        walletId,
        amount,
        balanceBefore,
        balanceAfter,
        description,
    );
    return ledgerEntry.create();
};

/**
 * Get ledger entries for an entity
 */
export const getLedgerEntries = async (
    entityId: string,
    entityType: string,
    options?: Parameters<typeof BalanceLedger.listByEntity>[2],
): Promise<ReturnType<typeof BalanceLedger.listByEntity>> => {
    return BalanceLedger.listByEntity(entityId, entityType, options);
};

/**
 * Get ledger entries for a transaction
 */
export const getLedgerEntriesByTransaction = async (transactionId: string): Promise<BalanceLedger[]> => {
    return BalanceLedger.listByTransaction(transactionId);
};

/**
 * Get ledger summary for a date range
 */
export const getLedgerSummary = async (
    entityId: string,
    entityType: string,
    fromDate: string,
    toDate: string,
): Promise<ReturnType<typeof BalanceLedger.getSumByDateRange>> => {
    return BalanceLedger.getSumByDateRange(entityId, entityType, fromDate, toDate);
};
</file>

<file path="layers/commons/data/entities/entity.ts">
import {
    DynamoDBClient,
    GetItemCommand,
    QueryCommand,
    PutItemCommand,
    UpdateItemCommand,
    AttributeValue,
    TransactWriteItemsCommand,
} from '@aws-sdk/client-dynamodb';
import { getClient } from '../client';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from '@aws-lambda-powertools/logger';

// Key prefixes and constants for DynamoDB
// Add constant for Checkbook Card sort key
export const CHECKBOOK_CARD_SK_PREFIX = 'CHECKBOOK#CARD#';

// Checkbook DynamoDB field names
export const CHECKBOOK_USER_DATA_SK = 'CHECKBOOK#DATA';
export const CHECKBOOK_PAYMENT_SK_PREFIX = 'CHECKBOOK#PAYMENT#';

export const CHECKBOOK_FIELDS = {
    // User data fields
    API_KEY: 'checkbookKey',
    API_SECRET: 'checkbookSecret',
    CHECKBOOK_ID: 'checkbookId',

    // Card fields
    CARD_ID: 'cardId',
    CARD_NUMBER: 'lastFourDigits',
    EXPIRATION_DATE: 'expirationDate',
    IS_DEFAULT: 'isDefault',

    // Payment fields
    PAYMENT_ID: 'paymentId',
    PAYMENT_TYPE: 'paymentType',
    PAYMENT_STATUS: 'status',
    PAYMENT_AMOUNT: 'amount',

    // Common fields
    CREATED_AT: 'createdAt',
    UPDATED_AT: 'updatedAt',
    USER_DATA_SK: CHECKBOOK_USER_DATA_SK,
};

export const EntityKeys = {
    // Primary key prefixes
    PROFILE_SK: 'PROFILE',
    EMAIL_PK_PREFIX: 'EMAIL#',
    USERNAME_PK_PREFIX: 'USERNAME#',
    PHONE_PK_PREFIX: 'PHONE#',

    // Entity type prefixes
    USER_PREFIX: 'USER#',
    BUSINESS_PREFIX: 'BUSINESS#',

    // GSI keys and prefixes
    ENTITY_TYPE_KEY_PREFIX: 'ENTITY_TYPE#',
    STATUS_PREFIX: 'STATUS#',
    ROLE_PREFIX: 'ROLE#',
    EMAIL_LOOKUP_KEY: 'EMAIL',
    EMAIL_VALUE_KEY: 'EmailValue',
    KYC_STATUS_KEY_PREFIX: 'KYCSTATUS#',
    USERNAME_INDEX_KEY: 'USERNAME',
    USERNAME_VALUE_KEY: 'UsernameIndexValue',
    PHONE_LOOKUP_KEY: 'PHONE',
    PHONE_VALUE_KEY: 'PhoneValue',

    // Entity status sort key components
    ENTITY_TYPE_STATUS_KEY: 'EntityTypeKey',
    ENTITY_STATUS_SORT_KEY: 'EntityStatusSortKey',

    // Email lookup keys
    EMAIL_LOOKUP_KEY_NAME: 'EmailLookupKey',
    EMAIL_VALUE_KEY_NAME: 'EmailValue',

    // Username lookup keys
    USERNAME_INDEX_KEY_NAME: 'UsernameIndexKey',
    USERNAME_INDEX_VALUE_NAME: 'UsernameIndexValue',

    // Phone lookup keys
    PHONE_LOOKUP_KEY_NAME: 'PhoneLookupKey',
    PHONE_VALUE_KEY_NAME: 'PhoneValue',

    // KYC status keys
    KYC_STATUS_KEY_NAME: 'KYCStatusKey',
    ENTITY_TYPE_ID_KEY_NAME: 'EntityTypeIdKey',

    // Field names
    FIELD_ID: 'id',
    FIELD_TYPE: 'type',
    FIELD_EMAIL: 'email',
    FIELD_ROLE: 'role',
    FIELD_STATUS: 'status',
    FIELD_DISPLAY_NAME: 'displayName',
    FIELD_USERNAME: 'username',
    FIELD_PHONE: 'phone',
    FIELD_CREATED_AT: 'createdAt',
    FIELD_UPDATED_AT: 'updatedAt',
    FIELD_LAST_LOGIN_AT: 'lastLoginAt',
    FIELD_VERIFIED_AT: 'verifiedAt',
    FIELD_KYC_STATUS: 'kycStatus',
    FIELD_KYC_INFO: 'kycInfo',
    FIELD_USER_INFO: 'userInfo',
    FIELD_BUSINESS_INFO: 'businessInfo',

    // Index names
    INDEX_ENTITY_TYPE: 'EntityTypeIndex',
    INDEX_KYC_STATUS: 'KYCStatusIndex',
    INDEX_USERNAME: 'UsernameIndex',

    // DynamoDB attribute keys
    ATTR_PK: 'PK',
    ATTR_SK: 'SK',
    ATTR_S: 'S',
    ATTR_N: 'N',
    ATTR_BOOL: 'BOOL',
    ATTR_M: 'M',
};

// Change from type to const object
export const EntityType = {
    USER: 'USER',
    BUSINESS: 'BUSINESS',
} as const;

// TypeScript type for type safety
export type EntityTypeString = keyof typeof EntityType;

export type EntityStatus = 'ACTIVE' | 'INACTIVE' | 'PENDING' | 'SUSPENDED';
export type EntityRole = 'USER' | 'ADMIN' | 'BUSINESS_OWNER' | 'BUSINESS_STAFF';
export type KYCStatus = 'PENDING' | 'VERIFIED' | 'REJECTED' | 'EXPIRED';

const logger = new Logger({ serviceName: 'entity-service' });
const TABLE_NAME = process.env.TABLE_NAME || 'clkk-app-table-dev';

export interface BusinessInfo {
    businessName: string;
    businessType?: string;
    registrationNumber?: string;
    taxId?: string;
    industry?: string;
    website?: string;
    foundedDate?: string;
    size?: string;
    phoneNumber?: string;
}

export interface UserInfo {
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    profilePictureUrl?: string;
    dateOfBirth?: string;
    preferredLanguage?: string;
}

export interface KYCInfo {
    provider: string;
    reference?: string;
    verificationDate?: string;
    expiryDate?: string;
    documentType?: string;
    documentId?: string;
}

// Helper function for normalizing phone numbers (remove non-numeric chars)
export const normalizePhoneNumber = (phone: string): string => {
    return phone.replace(/\D/g, '');
};

// Helper function for checking if email is valid
export const isValidEmail = (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
};

/**
 * Entity class for handling users and businesses in single-table design
 * This class follows DynamoDB single-table design principles with appropriate
 * access patterns
 */
export class Entity {
    id: string;
    type: EntityTypeString;
    email: string;
    role: EntityRole;
    status: EntityStatus;
    displayName?: string;
    username: string;

    // Type-specific information
    userInfo?: UserInfo;
    businessInfo?: BusinessInfo;

    // KYC information
    kycStatus?: KYCStatus;
    kycInfo?: KYCInfo;

    // Additional fields
    createdAt: string;
    updatedAt: string;
    lastLoginAt?: string;
    verifiedAt?: string;

    constructor(
        id: string,
        type: EntityTypeString,
        email: string,
        role: EntityRole,
        status: EntityStatus = 'ACTIVE',
        username: string,
        options: {
            displayName?: string;
            userInfo?: UserInfo;
            businessInfo?: BusinessInfo;
            lastLoginAt?: string;
            verifiedAt?: string;
            kycStatus?: KYCStatus;
            kycInfo?: KYCInfo;
            createdAt?: string;
            updatedAt?: string;
        } = {},
    ) {
        this.id = id || uuidv4();
        this.type = type;
        this.email = email.toLowerCase();
        this.role = role;
        this.status = status;
        this.username = username;
        this.displayName = options.displayName;

        // Set type-specific information
        if (type === 'USER') {
            this.userInfo = options.userInfo;
            // Normalize phone number if present
            if (this.userInfo?.phoneNumber) {
                this.userInfo.phoneNumber = normalizePhoneNumber(this.userInfo.phoneNumber);
            }
        } else if (type === 'BUSINESS') {
            this.businessInfo = options.businessInfo;
            // Normalize phone number if present
            if (this.businessInfo?.phoneNumber) {
                this.businessInfo.phoneNumber = normalizePhoneNumber(this.businessInfo.phoneNumber);
            }
        }

        this.lastLoginAt = options.lastLoginAt;
        this.verifiedAt = options.verifiedAt;
        this.kycStatus = options.kycStatus;
        this.kycInfo = options.kycInfo;

        const now = new Date().toISOString();
        this.createdAt = options.createdAt || now;
        this.updatedAt = options.updatedAt || now;
    }

    /**
     * Generate primary key for an entity
     * @param entityId Entity ID
     * @param entityType Entity type
     * @returns Formatted entity primary key
     */
    static getEntityPk(entityId: string, entityType: EntityTypeString): string {
        return `${entityType}#${entityId}`;
    }

    /**
     * Primary key for entity record
     */
    get pk(): string {
        return Entity.getEntityPk(this.id, this.type);
    }

    /**
     * Sort key for main entity record
     */
    get sk(): string {
        return EntityKeys.PROFILE_SK;
    }

    /**
     * Get the full name or display name
     */
    get fullName(): string {
        if (this.type === 'USER' && this.userInfo) {
            if (this.userInfo.firstName && this.userInfo.lastName) {
                return `${this.userInfo.firstName} ${this.userInfo.lastName}`;
            }
            if (this.userInfo.firstName) return this.userInfo.firstName;
            if (this.userInfo.lastName) return this.userInfo.lastName;
        } else if (this.type === 'BUSINESS' && this.businessInfo) {
            return this.businessInfo.businessName;
        }

        return this.displayName || this.email;
    }

    /**
     * Return whether this entity is a business
     */
    isBusiness(): boolean {
        return this.type === 'BUSINESS';
    }

    /**
     * Return whether this entity is a user
     */
    isUser(): boolean {
        return this.type === 'USER';
    }

    /**
     * Check if entity has admin privileges
     */
    hasAdminRole(): boolean {
        return this.role === 'ADMIN' || this.role === 'BUSINESS_OWNER';
    }

    /**
     * Get phone number from entity based on type
     */
    get phoneNumber(): string | undefined {
        if (this.type === 'USER' && this.userInfo?.phoneNumber) {
            return this.userInfo.phoneNumber;
        } else if (this.type === 'BUSINESS' && this.businessInfo?.phoneNumber) {
            return this.businessInfo.phoneNumber;
        }
        return undefined;
    }

    /**
     * Create phone number lookup item for phone access pattern
     * Includes additional fields for more efficient lookups
     */
    toPhoneLookupItem(): Record<string, AttributeValue> | null {
        const phone = this.phoneNumber;
        if (!phone) return null;

        const normalizedPhone = normalizePhoneNumber(phone);
        return {
            [EntityKeys.ATTR_PK]: { S: `${EntityKeys.PHONE_PK_PREFIX}${normalizedPhone}` },
            [EntityKeys.ATTR_SK]: { S: `${this.type}#${this.id}` },
            [EntityKeys.PHONE_LOOKUP_KEY_NAME]: { S: EntityKeys.PHONE_LOOKUP_KEY },
            [EntityKeys.PHONE_VALUE_KEY_NAME]: { S: `${normalizedPhone}` },
            [EntityKeys.FIELD_ID]: { S: this.id },
            [EntityKeys.FIELD_TYPE]: { S: this.type },
            [EntityKeys.FIELD_PHONE]: { S: normalizedPhone },
            [EntityKeys.FIELD_EMAIL]: { S: this.email.toLowerCase() },
            [EntityKeys.FIELD_USERNAME]: { S: this.username.toLowerCase() },
            [EntityKeys.FIELD_CREATED_AT]: { S: this.createdAt },
            ...(this.displayName && { [EntityKeys.FIELD_DISPLAY_NAME]: { S: this.displayName } }),
        };
    }

    /**
     * Convert entity to DynamoDB item for storage
     */
    toItem(): Record<string, AttributeValue> {
        const item: Record<string, AttributeValue> = {
            [EntityKeys.ATTR_PK]: { S: this.pk },
            [EntityKeys.ATTR_SK]: { S: this.sk },
            // GSI for entity type and status queries
            [EntityKeys.ENTITY_TYPE_STATUS_KEY]: { S: `${EntityKeys.ENTITY_TYPE_KEY_PREFIX}${this.type}` },
            [EntityKeys.ENTITY_STATUS_SORT_KEY]: {
                S: `${EntityKeys.STATUS_PREFIX}${this.status}#${EntityKeys.ROLE_PREFIX}${this.role}#${this.fullName || this.email}`,
            },
            // GSI for email lookups
            [EntityKeys.EMAIL_LOOKUP_KEY_NAME]: { S: EntityKeys.EMAIL_LOOKUP_KEY },
            [EntityKeys.EMAIL_VALUE_KEY_NAME]: { S: `${this.email}` },

            [EntityKeys.FIELD_ID]: { S: this.id },
            [EntityKeys.FIELD_TYPE]: { S: this.type },
            [EntityKeys.FIELD_EMAIL]: { S: this.email },
            [EntityKeys.FIELD_ROLE]: { S: this.role },
            [EntityKeys.FIELD_STATUS]: { S: this.status },
            ...(this.displayName && { [EntityKeys.FIELD_DISPLAY_NAME]: { S: this.displayName } }),
            [EntityKeys.FIELD_USERNAME]: { S: this.username },

            // Timestamps
            [EntityKeys.FIELD_CREATED_AT]: { S: this.createdAt },
            [EntityKeys.FIELD_UPDATED_AT]: { S: this.updatedAt },
            ...(this.lastLoginAt && { [EntityKeys.FIELD_LAST_LOGIN_AT]: { S: this.lastLoginAt } }),
            ...(this.verifiedAt && { [EntityKeys.FIELD_VERIFIED_AT]: { S: this.verifiedAt } }),
            ...(this.kycStatus && { [EntityKeys.FIELD_KYC_STATUS]: { S: this.kycStatus } }),
        };

        // Add type-specific information
        if (this.type === 'USER' && this.userInfo) {
            item[EntityKeys.FIELD_USER_INFO] = {
                M: this.marshallObject(this.userInfo),
            };
        } else if (this.type === 'BUSINESS' && this.businessInfo) {
            item[EntityKeys.FIELD_BUSINESS_INFO] = {
                M: this.marshallObject(this.businessInfo),
            };
        }

        // Add KYC information if available
        if (this.kycInfo) {
            item[EntityKeys.FIELD_KYC_INFO] = {
                M: this.marshallObject(this.kycInfo),
            };

            // Add GSI for KYC status lookups if KYC status is set
            if (this.kycStatus) {
                item[EntityKeys.KYC_STATUS_KEY_NAME] = { S: `${EntityKeys.KYC_STATUS_KEY_PREFIX}${this.kycStatus}` };
                item[EntityKeys.ENTITY_TYPE_ID_KEY_NAME] = { S: `${this.type}#${this.id}` };
            }
        }

        return item;
    }

    /**
     * Create email lookup item for email access pattern
     * Includes additional fields for more efficient lookups
     */
    toEmailLookupItem(): Record<string, AttributeValue> {
        const item: Record<string, AttributeValue> = {
            [EntityKeys.ATTR_PK]: { S: `${EntityKeys.EMAIL_PK_PREFIX}${this.email.toLowerCase()}` },
            [EntityKeys.ATTR_SK]: { S: `${this.type}#${this.id}` },
            EmailIndexKey: { S: EntityKeys.EMAIL_LOOKUP_KEY },
            EmailIndexValue: { S: `${this.email.toLowerCase()}` },
            [EntityKeys.FIELD_ID]: { S: this.id },
            [EntityKeys.FIELD_TYPE]: { S: this.type },
            [EntityKeys.FIELD_EMAIL]: { S: this.email.toLowerCase() },
            [EntityKeys.FIELD_USERNAME]: { S: this.username.toLowerCase() },
            [EntityKeys.FIELD_CREATED_AT]: { S: this.createdAt },
            ...(this.displayName && { [EntityKeys.FIELD_DISPLAY_NAME]: { S: this.displayName } }),
        };

        // Add phone number if available
        const phone = this.phoneNumber;
        if (phone) {
            item[EntityKeys.FIELD_PHONE] = { S: normalizePhoneNumber(phone) };
        }

        return item;
    }

    /**
     * Create username lookup item for username access pattern
     * Includes additional fields for more efficient lookups
     */
    toUsernameLookupItem(): Record<string, AttributeValue> {
        const item: Record<string, AttributeValue> = {
            [EntityKeys.ATTR_PK]: { S: `${EntityKeys.USERNAME_PK_PREFIX}${this.username.toLowerCase()}` },
            [EntityKeys.ATTR_SK]: { S: `${this.type}#${this.id}` },
            [EntityKeys.USERNAME_INDEX_KEY_NAME]: { S: EntityKeys.USERNAME_INDEX_KEY },
            [EntityKeys.USERNAME_INDEX_VALUE_NAME]: { S: `${this.username.toLowerCase()}` },
            [EntityKeys.FIELD_ID]: { S: this.id },
            [EntityKeys.FIELD_TYPE]: { S: this.type },
            [EntityKeys.FIELD_USERNAME]: { S: this.username.toLowerCase() },
            [EntityKeys.FIELD_EMAIL]: { S: this.email.toLowerCase() },
            [EntityKeys.FIELD_CREATED_AT]: { S: this.createdAt },
            ...(this.displayName && { [EntityKeys.FIELD_DISPLAY_NAME]: { S: this.displayName } }),
        };

        // Add phone number if available
        const phone = this.phoneNumber;
        if (phone) {
            item[EntityKeys.FIELD_PHONE] = { S: normalizePhoneNumber(phone) };
        }

        return item;
    }

    /**
     * Convert object to DynamoDB attribute map
     */
    private marshallObject(obj: Record<string, any>): Record<string, AttributeValue> {
        const result: Record<string, AttributeValue> = {};
        for (const [key, value] of Object.entries(obj)) {
            if (value !== undefined && value !== null) {
                if (typeof value === 'number') {
                    result[key] = { N: value.toString() };
                } else if (typeof value === 'boolean') {
                    result[key] = { BOOL: value };
                } else if (typeof value === 'object') {
                    result[key] = { S: JSON.stringify(value) };
                } else {
                    result[key] = { S: String(value) };
                }
            }
        }
        return result;
    }

    /**
     * Create Entity object from DynamoDB item
     */
    static fromItem(item?: Record<string, AttributeValue>): Entity {
        if (!item) throw new Error('No entity item found!');

        // Extract type-specific information
        let userInfo: UserInfo | undefined;
        let businessInfo: BusinessInfo | undefined;
        let kycInfo: KYCInfo | undefined;

        // Parse userInfo if it exists
        if (item[EntityKeys.FIELD_USER_INFO] && (item[EntityKeys.FIELD_USER_INFO] as AttributeValue).M) {
            userInfo = {};
            for (const [key, value] of Object.entries((item[EntityKeys.FIELD_USER_INFO] as AttributeValue).M || {})) {
                if (value.S) {
                    userInfo[key as keyof UserInfo] = value.S;
                } else if (value.N) {
                    userInfo[key as keyof UserInfo] = value.N;
                }
            }
        }

        // Parse businessInfo if it exists
        if (item[EntityKeys.FIELD_BUSINESS_INFO] && (item[EntityKeys.FIELD_BUSINESS_INFO] as AttributeValue).M) {
            businessInfo = {} as BusinessInfo;
            for (const [key, value] of Object.entries(
                (item[EntityKeys.FIELD_BUSINESS_INFO] as AttributeValue).M || {},
            )) {
                if (value.S) {
                    businessInfo[key as keyof BusinessInfo] = value.S;
                } else if (value.N) {
                    businessInfo[key as keyof BusinessInfo] = value.N;
                }
            }
        }

        // Parse KYC info if it exists
        if (item[EntityKeys.FIELD_KYC_INFO] && (item[EntityKeys.FIELD_KYC_INFO] as AttributeValue).M) {
            kycInfo = {} as KYCInfo;
            for (const [key, value] of Object.entries((item[EntityKeys.FIELD_KYC_INFO] as AttributeValue).M || {})) {
                if (value.S) {
                    kycInfo[key as keyof KYCInfo] = value.S;
                } else if (value.N) {
                    kycInfo[key as keyof KYCInfo] = value.N;
                }
            }
        }

        return new Entity(
            (item[EntityKeys.FIELD_ID] as AttributeValue).S!,
            (item[EntityKeys.FIELD_TYPE] as AttributeValue).S as EntityTypeString,
            (item[EntityKeys.FIELD_EMAIL] as AttributeValue).S!,
            (item[EntityKeys.FIELD_ROLE] as AttributeValue).S as EntityRole,
            (item[EntityKeys.FIELD_STATUS] as AttributeValue).S as EntityStatus,
            (item[EntityKeys.FIELD_USERNAME] as AttributeValue).S!,
            {
                displayName: (item[EntityKeys.FIELD_DISPLAY_NAME] as AttributeValue)?.S,
                userInfo,
                businessInfo,
                lastLoginAt: (item[EntityKeys.FIELD_LAST_LOGIN_AT] as AttributeValue)?.S,
                verifiedAt: (item[EntityKeys.FIELD_VERIFIED_AT] as AttributeValue)?.S,
                kycStatus: (item[EntityKeys.FIELD_KYC_STATUS] as AttributeValue)?.S as KYCStatus,
                kycInfo,
                createdAt: (item[EntityKeys.FIELD_CREATED_AT] as AttributeValue).S!,
                updatedAt: (item[EntityKeys.FIELD_UPDATED_AT] as AttributeValue).S!,
            },
        );
    }

    /**
     * Create a new entity with all necessary records
     */
    async create(): Promise<Entity> {
        const client = getClient();

        // Create transaction items for atomic write
        const transactItems = [
            {
                Put: {
                    TableName: TABLE_NAME,
                    Item: this.toItem(),
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                },
            },
            // Add email lookup
            {
                Put: {
                    TableName: TABLE_NAME,
                    Item: this.toEmailLookupItem(),
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                },
            },
            // Add username lookup
            {
                Put: {
                    TableName: TABLE_NAME,
                    Item: this.toUsernameLookupItem(),
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                },
            },
        ];

        // Add phone lookup if phone number exists
        const phoneLookupItem = this.toPhoneLookupItem();
        if (phoneLookupItem) {
            transactItems.push({
                Put: {
                    TableName: TABLE_NAME,
                    Item: phoneLookupItem,
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                },
            });
        }

        try {
            await client.send(
                new TransactWriteItemsCommand({
                    TransactItems: transactItems,
                }),
            );

            return this;
        } catch (error) {
            logger.error('Error creating entity:', { error, id: this.id, type: this.type, email: this.email });
            throw error;
        }
    }

    /**
     * Update an existing entity
     */
    async update(): Promise<Entity> {
        const client = getClient();
        this.updatedAt = new Date().toISOString();

        // Create transaction items for atomic update
        const transactItems = [
            {
                Put: {
                    TableName: TABLE_NAME,
                    Item: this.toItem(),
                },
            },
            // Update email lookup (in case email changed)
            {
                Put: {
                    TableName: TABLE_NAME,
                    Item: this.toEmailLookupItem(),
                },
            },
        ];

        // Update phone lookup if phone number exists
        const phoneLookupItem = this.toPhoneLookupItem();
        if (phoneLookupItem) {
            transactItems.push({
                Put: {
                    TableName: TABLE_NAME,
                    Item: phoneLookupItem,
                },
            });
        }

        try {
            await client.send(
                new TransactWriteItemsCommand({
                    TransactItems: transactItems,
                }),
            );

            return this;
        } catch (error) {
            logger.error('Error updating entity:', { error, id: this.id, type: this.type });
            throw error;
        }
    }

    /**
     * Update last login timestamp
     */
    async updateLastLogin(): Promise<Entity> {
        const timestamp = new Date().toISOString();
        this.lastLoginAt = timestamp;
        this.updatedAt = timestamp;
        return this.update();
    }

    /**
     * Mark entity as verified
     */
    async markVerified(): Promise<Entity> {
        this.verifiedAt = new Date().toISOString();
        this.status = 'ACTIVE';
        return this.update();
    }

    /**
     * Update KYC status
     */
    async updateKycStatus(status: KYCStatus, kycInfo?: KYCInfo): Promise<Entity> {
        this.kycStatus = status;
        if (kycInfo) {
            this.kycInfo = { ...kycInfo };
        }
        return this.update();
    }

    /**
     * Get entity by ID
     */
    static async getById(id: string, type: EntityTypeString): Promise<Entity | null> {
        const client = getClient();

        try {
            const response = await client.send(
                new GetItemCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: { S: `${type}#${id}` },
                        SK: { S: EntityKeys.PROFILE_SK },
                    },
                }),
            );

            if (!response.Item) {
                return null;
            }

            return Entity.fromItem(response.Item);
        } catch (error) {
            logger.error(`Error getting ${type} by ID:`, { error, id, type });
            throw error;
        }
    }

    /**
     * Get entity by email
     */
    static async getByEmail(email: string): Promise<Entity | null> {
        const client = getClient();
        const normalizedEmail = email.toLowerCase();

        try {
            // Check if the email lookup exists
            const lookupResponse = await client.send(
                new GetItemCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: { S: `${EntityKeys.EMAIL_PK_PREFIX}${normalizedEmail}` },
                        SK: { S: `${EntityKeys.USER_PREFIX}${normalizedEmail}` },
                    },
                }),
            );

            // If lookup exists, get the entity details
            if (lookupResponse.Item) {
                const entityId = lookupResponse.Item.id.S;
                const entityType = lookupResponse.Item.type.S as EntityTypeString;

                return Entity.getById(entityId!, entityType);
            }

            // If no lookup item exists, the entity doesn't exist
            return null;
        } catch (error) {
            logger.error('Error getting entity by email:', { error, email });
            throw error;
        }
    }

    /**
     * Get entity by username
     */
    static async getByUsername(username: string): Promise<Entity | null> {
        const client = getClient();
        const normalizedUsername = username.toLowerCase();

        try {
            // Direct lookup using the username lookup item
            const lookupResponse = await client.send(
                new GetItemCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: { S: `${EntityKeys.USERNAME_PK_PREFIX}${normalizedUsername}` },
                        SK: { S: `${EntityKeys.USER_PREFIX}${normalizedUsername}` },
                    },
                }),
            );

            // If lookup exists, get the entity details
            if (lookupResponse.Item) {
                const entityId = lookupResponse.Item.id.S;
                const entityType = lookupResponse.Item.type.S as EntityTypeString;

                return Entity.getById(entityId!, entityType);
            }

            // If no lookup item exists, the entity doesn't exist
            return null;
        } catch (error) {
            logger.error('Error getting entity by username:', { error, username });
            throw error;
        }
    }

    /**
     * List entities by type and status
     */
    static async listByType(
        type: EntityTypeString,
        options: {
            status?: EntityStatus;
            role?: EntityRole;
            limit?: number;
            startKey?: Record<string, AttributeValue>;
        } = {},
    ): Promise<{ entities: Entity[]; lastEvaluatedKey?: Record<string, AttributeValue> }> {
        const client = getClient();
        const { status, role, limit = 50, startKey } = options;

        try {
            let keyConditionExpression = `${EntityKeys.ENTITY_TYPE_STATUS_KEY} = :entityTypeKey`;
            const expressionAttributeValues: Record<string, AttributeValue> = {
                ':entityTypeKey': { S: `${EntityKeys.ENTITY_TYPE_KEY_PREFIX}${type}` },
            };

            // Add status filter if provided
            if (status) {
                keyConditionExpression += ` AND begins_with(${EntityKeys.ENTITY_STATUS_SORT_KEY}, :statusPrefix)`;
                expressionAttributeValues[':statusPrefix'] = { S: `${EntityKeys.STATUS_PREFIX}${status}` };
            }

            // Add role filter if provided
            let filterExpression: string | undefined;
            if (role) {
                filterExpression = `contains(${EntityKeys.ENTITY_STATUS_SORT_KEY}, :roleFilter)`;
                expressionAttributeValues[':roleFilter'] = { S: `${EntityKeys.ROLE_PREFIX}${role}` };
            }

            const queryParams: any = {
                TableName: TABLE_NAME,
                IndexName: EntityKeys.INDEX_ENTITY_TYPE,
                KeyConditionExpression: keyConditionExpression,
                ExpressionAttributeValues: expressionAttributeValues,
                Limit: limit,
            };

            if (startKey) {
                queryParams.ExclusiveStartKey = startKey;
            }

            if (filterExpression) {
                queryParams.FilterExpression = filterExpression;
            }

            const response = await client.send(new QueryCommand(queryParams));

            return {
                entities: (response.Items || []).map((item) => Entity.fromItem(item)),
                lastEvaluatedKey: response.LastEvaluatedKey,
            };
        } catch (error) {
            logger.error(`Error listing ${type}s:`, { error, type, options });
            throw error;
        }
    }

    /**
     * List entities by KYC status
     */
    static async listByKycStatus(
        status: KYCStatus,
        options: {
            type?: EntityTypeString;
            limit?: number;
            startKey?: Record<string, AttributeValue>;
        } = {},
    ): Promise<{ entities: Entity[]; lastEvaluatedKey?: Record<string, AttributeValue> }> {
        const client = getClient();
        const { type, limit = 50, startKey } = options;

        try {
            let keyConditionExpression = `${EntityKeys.KYC_STATUS_KEY_NAME} = :kycStatus`;
            const expressionAttributeValues: Record<string, AttributeValue> = {
                ':kycStatus': { S: `${EntityKeys.KYC_STATUS_KEY_PREFIX}${status}` },
            };

            // Add type filter if provided
            if (type) {
                keyConditionExpression += ` AND begins_with(${EntityKeys.ENTITY_TYPE_ID_KEY_NAME}, :typePrefix)`;
                expressionAttributeValues[':typePrefix'] = { S: `${type}#` };
            }

            const queryParams: any = {
                TableName: TABLE_NAME,
                IndexName: EntityKeys.INDEX_KYC_STATUS,
                KeyConditionExpression: keyConditionExpression,
                ExpressionAttributeValues: expressionAttributeValues,
                Limit: limit,
            };

            if (startKey) {
                queryParams.ExclusiveStartKey = startKey;
            }

            const response = await client.send(new QueryCommand(queryParams));

            return {
                entities: (response.Items || []).map((item) => Entity.fromItem(item)),
                lastEvaluatedKey: response.LastEvaluatedKey,
            };
        } catch (error) {
            logger.error(`Error listing entities by KYC status:`, { error, status, type });
            throw error;
        }
    }

    /**
     * Get entity by phone number
     */
    static async getByPhoneNumber(phoneNumber: string): Promise<Entity | null> {
        if (!phoneNumber) return null;

        const client = getClient();
        const normalizedPhone = normalizePhoneNumber(phoneNumber);

        try {
            // Use a query to find the phone lookup item
            const queryResponse = await client.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    KeyConditionExpression: `${EntityKeys.ATTR_PK} = :pk`,
                    ExpressionAttributeValues: {
                        ':pk': { S: `${EntityKeys.PHONE_PK_PREFIX}${normalizedPhone}` },
                    },
                    Limit: 1,
                }),
            );

            // If lookup exists, get the entity details
            if (queryResponse.Items && queryResponse.Items.length > 0) {
                const item = queryResponse.Items[0];
                const entityId = (item[EntityKeys.FIELD_ID] as AttributeValue).S;
                const entityType = (item[EntityKeys.FIELD_TYPE] as AttributeValue).S as EntityTypeString;

                return Entity.getById(entityId!, entityType);
            }

            // If no lookup item exists, the entity doesn't exist
            return null;
        } catch (error) {
            logger.error('Error getting entity by phone number:', { error, phoneNumber });
            throw error;
        }
    }

    /**
     * Search for entities by partial username match
     * This allows searching for usernames that contain the search string
     */
    static async searchByUsername(
        usernameSearch: string,
        options: {
            type?: EntityTypeString;
            limit?: number;
            startKey?: Record<string, AttributeValue>;
        } = {},
    ): Promise<{ entities: Entity[]; lastEvaluatedKey?: Record<string, AttributeValue> }> {
        if (!usernameSearch) {
            return { entities: [] };
        }

        const client = getClient();
        const normalizedSearch = usernameSearch.toLowerCase();
        const { type, limit = 20, startKey } = options;

        try {
            // Query UsernameIndex for all usernames
            const queryParams: any = {
                TableName: TABLE_NAME,
                IndexName: EntityKeys.INDEX_USERNAME,
                KeyConditionExpression: `${EntityKeys.USERNAME_INDEX_KEY_NAME} = :username`,
                ExpressionAttributeValues: {
                    ':username': { S: EntityKeys.USERNAME_INDEX_KEY },
                    ':searchTerm': { S: normalizedSearch },
                },
                FilterExpression: `contains(${EntityKeys.USERNAME_INDEX_VALUE_NAME}, :searchTerm)`,
                Limit: limit,
            };

            // Add type filter if provided
            if (type) {
                queryParams.FilterExpression += ` AND #type = :type`;
                queryParams.ExpressionAttributeValues[':type'] = { S: type };
                queryParams.ExpressionAttributeNames = {
                    '#type': EntityKeys.FIELD_TYPE,
                };
            }

            if (startKey) {
                queryParams.ExclusiveStartKey = startKey;
            }

            const response = await client.send(new QueryCommand(queryParams));

            // Get full entity details for each result
            const entities: Entity[] = [];
            for (const item of response.Items || []) {
                try {
                    const entityId = (item[EntityKeys.FIELD_ID] as AttributeValue).S!;
                    const entityType = (item[EntityKeys.FIELD_TYPE] as AttributeValue).S as EntityTypeString;
                    const entity = await Entity.getById(entityId, entityType);
                    if (entity) {
                        entities.push(entity);
                    }
                } catch (err) {
                    logger.warn('Error fetching entity details during username search', { err, item });
                }
            }

            return {
                entities,
                lastEvaluatedKey: response.LastEvaluatedKey,
            };
        } catch (error) {
            logger.error('Error searching entities by username:', { error, usernameSearch });
            throw error;
        }
    }

    /**
     * Factory method to create a new user
     */
    static createUser(
        email: string,
        username: string,
        options: {
            id?: string;
            role?: EntityRole;
            status?: EntityStatus;
            displayName?: string;
            firstName?: string;
            lastName?: string;
            phoneNumber?: string;
            profilePictureUrl?: string;
            dateOfBirth?: string;
            kycStatus?: KYCStatus;
            kycInfo?: KYCInfo;
        } = {},
    ): Entity {
        const userInfo: UserInfo = {
            firstName: options.firstName,
            lastName: options.lastName,
            phoneNumber: options.phoneNumber,
            profilePictureUrl: options.profilePictureUrl,
            dateOfBirth: options.dateOfBirth,
        };

        return new Entity(
            options.id || uuidv4(),
            'USER',
            email,
            options.role || 'USER',
            options.status || 'PENDING',
            username,
            {
                displayName: options.displayName,
                userInfo,
                kycStatus: options.kycStatus,
                kycInfo: options.kycInfo,
            },
        );
    }

    /**
     * Factory method to create a new business
     */
    static createBusiness(
        email: string,
        businessName: string,
        username: string,
        options: {
            id?: string;
            role?: EntityRole;
            status?: EntityStatus;
            businessType?: string;
            registrationNumber?: string;
            taxId?: string;
            industry?: string;
            website?: string;
            foundedDate?: string;
            size?: string;
            phoneNumber?: string;
            kycStatus?: KYCStatus;
            kycInfo?: KYCInfo;
        } = {},
    ): Entity {
        const businessInfo: BusinessInfo = {
            businessName,
            businessType: options.businessType,
            registrationNumber: options.registrationNumber,
            taxId: options.taxId,
            industry: options.industry,
            website: options.website,
            foundedDate: options.foundedDate,
            size: options.size,
            phoneNumber: options.phoneNumber,
        };

        return new Entity(
            options.id || uuidv4(),
            'BUSINESS',
            email,
            options.role || 'BUSINESS_OWNER',
            options.status || 'PENDING',
            username,
            {
                displayName: businessName,
                businessInfo,
                kycStatus: options.kycStatus,
                kycInfo: options.kycInfo,
            },
        );
    }
}

// Convenience functions

/**
 * Create a new user
 */
export const createUser = async (
    email: string,
    username: string,
    options: Parameters<typeof Entity.createUser>[2] = {},
): Promise<Entity> => {
    // Check uniqueness constraints
    const emailCheck = await getEntityByEmail(email);
    if (emailCheck) {
        throw new Error(`Email "${email}" is already in use`);
    }

    const usernameCheck = await getEntityByUsername(username);
    if (usernameCheck) {
        throw new Error(`Username "${username}" is already in use`);
    }

    if (options.phoneNumber) {
        const phoneCheck = await getEntityByPhoneNumber(options.phoneNumber);
        if (phoneCheck) {
            throw new Error(`Phone number "${options.phoneNumber}" is already in use`);
        }
    }

    const entity = Entity.createUser(email, username, options);
    return entity.create();
};

/**
 * Create a new business
 */
export const createBusiness = async (
    email: string,
    businessName: string,
    username: string,
    options: Parameters<typeof Entity.createBusiness>[3] = {},
): Promise<Entity> => {
    // Check uniqueness constraints
    const emailCheck = await getEntityByEmail(email);
    if (emailCheck) {
        throw new Error(`Email "${email}" is already in use`);
    }

    const usernameCheck = await getEntityByUsername(username);
    if (usernameCheck) {
        throw new Error(`Username "${username}" is already in use`);
    }

    if (options.phoneNumber) {
        const phoneCheck = await getEntityByPhoneNumber(options.phoneNumber);
        if (phoneCheck) {
            throw new Error(`Phone number "${options.phoneNumber}" is already in use`);
        }
    }

    const entity = Entity.createBusiness(email, businessName, username, options);
    return entity.create();
};

/**
 * Get an entity by ID
 */
export const getEntity = async (id: string, type: EntityTypeString): Promise<Entity | null> => {
    return Entity.getById(id, type);
};

/**
 * Get an entity by email
 */
export const getEntityByEmail = async (email: string): Promise<Entity | null> => {
    return Entity.getByEmail(email);
};

/**
 * Get an entity by username
 */
export const getEntityByUsername = async (username: string): Promise<Entity | null> => {
    return Entity.getByUsername(username);
};

/**
 * List users with filtering options
 */
export const listUsers = async (
    options: Parameters<typeof Entity.listByType>[1] = {},
): Promise<ReturnType<typeof Entity.listByType>> => {
    return Entity.listByType('USER', options);
};

/**
 * List businesses with filtering options
 */
export const listBusinesses = async (
    options: Parameters<typeof Entity.listByType>[1] = {},
): Promise<ReturnType<typeof Entity.listByType>> => {
    return Entity.listByType('BUSINESS', options);
};

/**
 * List entities by KYC status
 */
export const listEntitiesByKycStatus = async (
    status: KYCStatus,
    options: Parameters<typeof Entity.listByKycStatus>[1] = {},
): Promise<ReturnType<typeof Entity.listByKycStatus>> => {
    return Entity.listByKycStatus(status, options);
};

/**
 * Get an entity by phone number
 */
export const getEntityByPhoneNumber = async (phoneNumber: string): Promise<Entity | null> => {
    return Entity.getByPhoneNumber(phoneNumber);
};

/**
 * Search for entities by partial username match
 */
export const searchEntitiesByUsername = async (
    username: string,
    options: Parameters<typeof Entity.searchByUsername>[1] = {},
): Promise<ReturnType<typeof Entity.searchByUsername>> => {
    return Entity.searchByUsername(username, options);
};

/**
 * Verify that email, phone number, and username are unique
 * Returns result with isUnique=true if all are unique, otherwise details about the conflict
 */
export const verifyUniqueConstraints = async (
    email: string,
    username: string,
    phoneNumber?: string,
): Promise<{ isUnique: boolean; conflictingEntity?: Entity; field?: 'email' | 'phone' | 'username' }> => {
    // Check email uniqueness
    const existingEmail = await getEntityByEmail(email);
    if (existingEmail) {
        return { isUnique: false, conflictingEntity: existingEmail, field: 'email' };
    }

    // Check username uniqueness
    const existingUsername = await getEntityByUsername(username);
    if (existingUsername) {
        return { isUnique: false, conflictingEntity: existingUsername, field: 'username' };
    }

    // Check phone uniqueness if provided
    if (phoneNumber) {
        const existingPhone = await getEntityByPhoneNumber(phoneNumber);
        if (existingPhone) {
            return { isUnique: false, conflictingEntity: existingPhone, field: 'phone' };
        }
    }

    // All are unique
    return { isUnique: true };
};
</file>

<file path="layers/commons/data/entities/fee.test.ts">
import { Fee } from './fee';
import { Money } from './money';

// Mock the AWS SDK client
jest.mock('../client', () => ({
    getClient: jest.fn().mockReturnValue({
        send: jest.fn(),
    }),
}));

// Import mocked module
import { getClient } from '../client';
const mockedGetClient = getClient as jest.MockedFunction<typeof getClient>;
const mockedSend = mockedGetClient().send as jest.MockedFunction<any>;

describe('Fee', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    // Constructor tests
    describe('constructor', () => {
        it('should create a new Fee instance with default values', () => {
            const fee = new Fee('business123', 'txn123', '10.00', 'FLAT', '10.00', 'Platform fee');

            expect(fee.businessId).toBe('business123');
            expect(fee.transactionId).toBe('txn123');
            expect(fee.amount).toBe('10.00');
            expect(fee.feeType).toBe('FLAT');
            expect(fee.feeRate).toBe('10.00');
            expect(fee.description).toBe('Platform fee');
            expect(fee.currency).toBe('USD');
            expect(fee.feeId).toMatch(/^fee_[0-9a-f-]+$/);
            expect(fee.createdAt).toBeDefined();
        });

        it('should create a Fee instance with custom options', () => {
            const customFeeId = 'custom_fee_id';
            const customCreatedAt = '2023-01-01T00:00:00Z';

            const fee = new Fee('business123', 'txn123', '10.00', 'PERCENTAGE', '2.5', 'Percentage fee', {
                feeId: customFeeId,
                currency: 'EUR',
                createdAt: customCreatedAt,
            });

            expect(fee.businessId).toBe('business123');
            expect(fee.transactionId).toBe('txn123');
            expect(fee.amount).toBe('10.00');
            expect(fee.feeType).toBe('PERCENTAGE');
            expect(fee.feeRate).toBe('2.5');
            expect(fee.description).toBe('Percentage fee');
            expect(fee.currency).toBe('EUR');
            expect(fee.feeId).toBe(customFeeId);
            expect(fee.createdAt).toBe(customCreatedAt);
        });
    });

    // Getter tests
    describe('getters', () => {
        it('should return the correct PK and SK values', () => {
            const fee = new Fee('business123', 'txn123', '10.00', 'FLAT', '10.00', 'Platform fee', {
                createdAt: '2023-01-01T00:00:00Z',
                feeId: 'fee123',
            });

            expect(fee.pk).toBe('BUSINESS#business123');
            expect(fee.sk).toBe('FEE#2023-01-01T00:00:00Z#fee123');
        });

        it('should convert amount to Money object', () => {
            const fee = new Fee('business123', 'txn123', '10.00', 'FLAT', '10.00', 'Platform fee', {
                currency: 'EUR',
            });

            const amountMoney = fee.getAmount();
            expect(amountMoney).toBeInstanceOf(Money);
            expect(amountMoney.toString()).toBe('10.00');
            expect(amountMoney.currency).toBe('EUR');
        });
    });

    // DynamoDB conversion tests
    describe('toItem and fromItem', () => {
        it('should convert fee to DynamoDB item', () => {
            const fee = new Fee('business123', 'txn123', '10.00', 'FLAT', '10.00', 'Platform fee', {
                feeId: 'fee123',
                currency: 'USD',
                createdAt: '2023-01-01T00:00:00Z',
            });

            const item = fee.toItem();

            expect(item.PK.S).toBe('BUSINESS#business123');
            expect(item.SK.S).toBe('FEE#2023-01-01T00:00:00Z#fee123');
            expect(item.GSI1PK.S).toBe('FEE#fee123');
            expect(item.GSI1SK.S).toBe('BUSINESS#business123');
            expect(item.GSI2PK.S).toBe('TXN#txn123');
            expect(item.GSI2SK.S).toBe('FEE#fee123');
            expect(item.feeId.S).toBe('fee123');
            expect(item.businessId.S).toBe('business123');
            expect(item.transactionId.S).toBe('txn123');
            expect(item.amount.S).toBe('10.00');
            expect(item.feeType.S).toBe('FLAT');
            expect(item.feeRate.S).toBe('10.00');
            expect(item.currency.S).toBe('USD');
            expect(item.description.S).toBe('Platform fee');
            expect(item.createdAt.S).toBe('2023-01-01T00:00:00Z');
        });

        it('should convert DynamoDB item to fee', () => {
            const item = {
                PK: { S: 'BUSINESS#business123' },
                SK: { S: 'FEE#2023-01-01T00:00:00Z#fee123' },
                GSI1PK: { S: 'FEE#fee123' },
                GSI1SK: { S: 'BUSINESS#business123' },
                GSI2PK: { S: 'TXN#txn123' },
                GSI2SK: { S: 'FEE#fee123' },
                feeId: { S: 'fee123' },
                businessId: { S: 'business123' },
                transactionId: { S: 'txn123' },
                amount: { S: '10.00' },
                feeType: { S: 'FLAT' },
                feeRate: { S: '10.00' },
                currency: { S: 'USD' },
                description: { S: 'Platform fee' },
                createdAt: { S: '2023-01-01T00:00:00Z' },
            };

            const fee = Fee.fromItem(item);

            expect(fee.feeId).toBe('fee123');
            expect(fee.businessId).toBe('business123');
            expect(fee.transactionId).toBe('txn123');
            expect(fee.amount).toBe('10.00');
            expect(fee.feeType).toBe('FLAT');
            expect(fee.feeRate).toBe('10.00');
            expect(fee.currency).toBe('USD');
            expect(fee.description).toBe('Platform fee');
            expect(fee.createdAt).toBe('2023-01-01T00:00:00Z');
        });

        it('should throw error when item is undefined', () => {
            expect(() => Fee.fromItem(undefined)).toThrow('No fee item found!');
        });
    });

    // Database operation tests
    describe('database operations', () => {
        // Mock dates for consistent testing
        const mockDate = new Date('2023-01-01T00:00:00Z');
        let originalDate: DateConstructor;

        beforeEach(() => {
            originalDate = global.Date;
            global.Date = class extends Date {
                constructor() {
                    super();
                    return mockDate;
                }
                static now() {
                    return mockDate.getTime();
                }
            } as DateConstructor;

            // Set up environment variables
            process.env.TABLE_NAME = 'TestTable';
        });

        afterEach(() => {
            global.Date = originalDate;
            delete process.env.TABLE_NAME;
        });

        it('should create a fee in the database', async () => {
            const fee = new Fee('business123', 'txn123', '10.00', 'FLAT', '10.00', 'Platform fee');

            mockedSend.mockResolvedValueOnce({});

            await fee.create();

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Item: fee.toItem(),
                        ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                    }),
                }),
            );
        });

        it('should throw error when create fails', async () => {
            const fee = new Fee('business123', 'txn123', '10.00', 'FLAT', '10.00', 'Platform fee');

            const error = new Error('DynamoDB error');
            mockedSend.mockRejectedValueOnce(error);

            await expect(fee.create()).rejects.toThrow(error);
            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should get fee by ID', async () => {
            const mockItem = {
                feeId: { S: 'fee123' },
                businessId: { S: 'business123' },
                transactionId: { S: 'txn123' },
                amount: { S: '10.00' },
                feeType: { S: 'FLAT' },
                feeRate: { S: '10.00' },
                currency: { S: 'USD' },
                description: { S: 'Platform fee' },
                createdAt: { S: '2023-01-01T00:00:00Z' },
            };

            mockedSend.mockResolvedValueOnce({
                Items: [mockItem],
            });

            const fee = await Fee.getById('business123', 'fee123');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        IndexName: 'GSI1',
                        KeyConditionExpression: 'GSI1PK = :gsi1pk AND GSI1SK = :gsi1sk',
                        ExpressionAttributeValues: {
                            ':gsi1pk': { S: 'FEE#fee123' },
                            ':gsi1sk': { S: 'BUSINESS#business123' },
                        },
                        Limit: 1,
                    }),
                }),
            );
            expect(fee.feeId).toBe('fee123');
            expect(fee.businessId).toBe('business123');
        });

        it('should throw error when fee is not found', async () => {
            mockedSend.mockResolvedValueOnce({
                Items: [],
            });

            await expect(Fee.getById('business123', 'fee123')).rejects.toThrow(
                'Fee fee123 not found for business business123',
            );

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should list fees by business', async () => {
            const mockItems = [
                {
                    feeId: { S: 'fee123' },
                    businessId: { S: 'business123' },
                    transactionId: { S: 'txn123' },
                    amount: { S: '10.00' },
                    feeType: { S: 'FLAT' },
                    feeRate: { S: '10.00' },
                    currency: { S: 'USD' },
                    description: { S: 'Platform fee' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                },
                {
                    feeId: { S: 'fee456' },
                    businessId: { S: 'business123' },
                    transactionId: { S: 'txn456' },
                    amount: { S: '5.00' },
                    feeType: { S: 'PERCENTAGE' },
                    feeRate: { S: '2.5' },
                    currency: { S: 'USD' },
                    description: { S: 'Transaction fee' },
                    createdAt: { S: '2023-01-02T00:00:00Z' },
                },
            ];

            mockedSend.mockResolvedValueOnce({
                Items: mockItems,
                LastEvaluatedKey: { PK: { S: 'BUSINESS#business123' } },
            });

            const result = await Fee.listByBusiness('business123', {
                limit: 10,
                fromDate: '2023-01-01',
                toDate: '2023-01-03',
            });

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        KeyConditionExpression: 'PK = :pk AND SK BETWEEN :fromDate AND :toDate',
                        ExpressionAttributeValues: {
                            ':pk': { S: 'BUSINESS#business123' },
                            ':fromDate': { S: 'FEE#2023-01-01' },
                            ':toDate': { S: 'FEE#2023-01-03Z' },
                            ':fee_prefix': { S: 'FEE#' },
                        },
                        Limit: 10,
                        ScanIndexForward: false,
                    }),
                }),
            );

            expect(result.fees).toHaveLength(2);
            expect(result.fees[0].feeId).toBe('fee123');
            expect(result.fees[1].feeId).toBe('fee456');
            expect(result.lastEvaluatedKey).toEqual({ PK: { S: 'BUSINESS#business123' } });
        });

        it('should list fees by transaction', async () => {
            const mockItems = [
                {
                    feeId: { S: 'fee123' },
                    businessId: { S: 'business123' },
                    transactionId: { S: 'txn123' },
                    amount: { S: '10.00' },
                    feeType: { S: 'FLAT' },
                    feeRate: { S: '10.00' },
                    currency: { S: 'USD' },
                    description: { S: 'Platform fee' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                },
            ];

            mockedSend.mockResolvedValueOnce({
                Items: mockItems,
            });

            const result = await Fee.listByTransaction('txn123');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        IndexName: 'GSI2',
                        KeyConditionExpression: 'GSI2PK = :gsi2pk AND begins_with(GSI2SK, :fee_prefix)',
                        ExpressionAttributeValues: {
                            ':gsi2pk': { S: 'TXN#txn123' },
                            ':fee_prefix': { S: 'FEE#' },
                        },
                    }),
                }),
            );

            expect(result).toHaveLength(1);
            expect(result[0].transactionId).toBe('txn123');
        });

        it('should calculate total fees by date range', async () => {
            // Mock the listByBusiness function to return some fee entries
            const mockFees = [
                new Fee('business123', 'txn1', '10.00', 'FLAT', '10.00', 'Platform fee', { currency: 'USD' }),
                new Fee('business123', 'txn2', '5.00', 'FLAT', '5.00', 'Transaction fee', { currency: 'USD' }),
                new Fee('business123', 'txn3', '7.50', 'PERCENTAGE', '2.5', 'Percentage fee', { currency: 'USD' }),
            ];

            const listByBusinessSpy = jest
                .spyOn(Fee, 'listByBusiness')
                .mockResolvedValue({ fees: mockFees, lastEvaluatedKey: undefined });

            const result = await Fee.getTotalByDateRange('business123', '2023-01-01', '2023-01-31', 'USD');

            // Verify listByBusiness was called correctly
            expect(listByBusinessSpy).toHaveBeenCalledWith('business123', {
                fromDate: '2023-01-01',
                toDate: '2023-01-31',
                limit: 1000,
            });

            // Verify the results
            expect(result).toBeInstanceOf(Money);
            expect(result.toString()).toBe('22.50');
            expect(result.currency).toBe('USD');

            // Restore the spy
            listByBusinessSpy.mockRestore();
        });
    });

    // Factory method tests
    describe('factory methods', () => {
        it('should create a flat fee using factory method', () => {
            const fee = Fee.createFlatFee('business123', 'txn123', '10.00', 'Platform fee', 'EUR');

            expect(fee).toBeInstanceOf(Fee);
            expect(fee.businessId).toBe('business123');
            expect(fee.transactionId).toBe('txn123');
            expect(fee.amount).toBe('10.00');
            expect(fee.feeType).toBe('FLAT');
            expect(fee.feeRate).toBe('10.00');
            expect(fee.description).toBe('Platform fee');
            expect(fee.currency).toBe('EUR');
        });

        it('should create a percentage fee using factory method', () => {
            const fee = Fee.createPercentageFee('business123', 'txn123', '100.00', '2.5', 'Percentage fee', 'USD');

            expect(fee).toBeInstanceOf(Fee);
            expect(fee.businessId).toBe('business123');
            expect(fee.transactionId).toBe('txn123');
            expect(fee.feeType).toBe('PERCENTAGE');
            expect(fee.feeRate).toBe('2.5');
            expect(fee.description).toBe('Percentage fee');
            expect(fee.currency).toBe('USD');

            // Check that the amount was calculated correctly (2.5% of 100.00 = 2.50)
            expect(fee.amount).toBe('2.50');
        });
    });
});
</file>

<file path="layers/commons/data/entities/fee.ts">
import { 
  DynamoDBClient, 
  GetItemCommand, 
  QueryCommand, 
  PutItemCommand,
  AttributeValue 
} from "@aws-sdk/client-dynamodb";
import { getClient } from "../client";
import { v4 as uuidv4 } from "uuid";
import { Money } from "./money";

export type FeeType = "FLAT" | "PERCENTAGE" | "TIERED";

/**
 * Fee class for tracking fees applied to business transactions
 */
export class Fee {
  feeId: string;
  businessId: string;
  transactionId: string;
  amount: string;
  feeType: FeeType;
  feeRate: string;
  currency: string;
  description: string;
  createdAt: string;

  /**
   * Create a new Fee instance
   */
  constructor(
    businessId: string,
    transactionId: string,
    amount: string,
    feeType: FeeType,
    feeRate: string,
    description: string,
    options: {
      feeId?: string;
      currency?: string;
      createdAt?: string;
    } = {}
  ) {
    this.feeId = options.feeId || `fee_${uuidv4()}`;
    this.businessId = businessId;
    this.transactionId = transactionId;
    this.amount = amount;
    this.feeType = feeType;
    this.feeRate = feeRate;
    this.currency = options.currency || "USD";
    this.description = description;
    this.createdAt = options.createdAt || new Date().toISOString();
  }

  get pk(): string {
    return `BUSINESS#${this.businessId}`;
  }

  get sk(): string {
    return `FEE#${this.createdAt}#${this.feeId}`;
  }

  /**
   * Get fee amount as Money object
   */
  getAmount(): Money {
    return new Money(this.amount, this.currency);
  }

  toItem(): Record<string, AttributeValue> {
    return {
      PK: { S: this.pk },
      SK: { S: this.sk },
      GSI1PK: { S: `FEE#${this.feeId}` },
      GSI1SK: { S: `BUSINESS#${this.businessId}` },
      GSI2PK: { S: `TXN#${this.transactionId}` },
      GSI2SK: { S: `FEE#${this.feeId}` },
      feeId: { S: this.feeId },
      businessId: { S: this.businessId },
      transactionId: { S: this.transactionId },
      amount: { S: this.amount },
      feeType: { S: this.feeType },
      feeRate: { S: this.feeRate },
      currency: { S: this.currency },
      description: { S: this.description },
      createdAt: { S: this.createdAt }
    };
  }

  static fromItem(item?: Record<string, AttributeValue>): Fee {
    if (!item) throw new Error("No fee item found!");

    return new Fee(
      item.businessId.S!,
      item.transactionId.S!,
      item.amount.S!,
      item.feeType.S as FeeType,
      item.feeRate.S!,
      item.description.S!,
      {
        feeId: item.feeId.S!,
        currency: item.currency.S!,
        createdAt: item.createdAt.S!
      }
    );
  }

  /**
   * Create a new fee in the database
   */
  async create(): Promise<Fee> {
    const client = getClient();

    try {
      await client.send(new PutItemCommand({
        TableName: process.env.TABLE_NAME!,
        Item: this.toItem(),
        ConditionExpression: "attribute_not_exists(PK) AND attribute_not_exists(SK)"
      }));

      return this;
    } catch (error) {
      console.error("Error creating fee:", error);
      throw error;
    }
  }

  /**
   * Get fee by ID
   */
  static async getById(businessId: string, feeId: string): Promise<Fee> {
    const client = getClient();
    
    try {
      const response = await client.send(new QueryCommand({
        TableName: process.env.TABLE_NAME!,
        IndexName: "GSI1",
        KeyConditionExpression: "GSI1PK = :gsi1pk AND GSI1SK = :gsi1sk",
        ExpressionAttributeValues: {
          ":gsi1pk": { S: `FEE#${feeId}` },
          ":gsi1sk": { S: `BUSINESS#${businessId}` }
        },
        Limit: 1
      }));

      if (!response.Items || response.Items.length === 0) {
        throw new Error(`Fee ${feeId} not found for business ${businessId}`);
      }

      return Fee.fromItem(response.Items[0]);
    } catch (error) {
      console.error("Error getting fee by ID:", error);
      throw error;
    }
  }

  /**
   * List fees for a business
   */
  static async listByBusiness(
    businessId: string,
    options: {
      limit?: number;
      startKey?: Record<string, AttributeValue>;
      fromDate?: string;
      toDate?: string;
    } = {}
  ): Promise<{ 
    fees: Fee[], 
    lastEvaluatedKey?: Record<string, AttributeValue> 
  }> {
    const client = getClient();
    const { limit = 50, startKey, fromDate, toDate } = options;
    
    try {
      let keyConditionExpression = "PK = :pk AND begins_with(SK, :fee_prefix)";
      const expressionAttributeValues: Record<string, AttributeValue> = {
        ":pk": { S: `BUSINESS#${businessId}` },
        ":fee_prefix": { S: "FEE#" }
      };

      // Add date range condition if provided
      if (fromDate && toDate) {
        keyConditionExpression = "PK = :pk AND SK BETWEEN :fromDate AND :toDate";
        expressionAttributeValues[":fromDate"] = { S: `FEE#${fromDate}` };
        expressionAttributeValues[":toDate"] = { S: `FEE#${toDate}Z` };
      } else if (fromDate) {
        keyConditionExpression = "PK = :pk AND SK >= :fromDate";
        expressionAttributeValues[":fromDate"] = { S: `FEE#${fromDate}` };
      } else if (toDate) {
        keyConditionExpression = "PK = :pk AND begins_with(SK, :fee_prefix) AND SK <= :toDate";
        expressionAttributeValues[":toDate"] = { S: `FEE#${toDate}Z` };
      }

      const response = await client.send(new QueryCommand({
        TableName: process.env.TABLE_NAME!,
        KeyConditionExpression: keyConditionExpression,
        ExpressionAttributeValues: expressionAttributeValues,
        Limit: limit,
        ScanIndexForward: false // Most recent first
      }));

      return {
        fees: (response.Items || []).map(item => Fee.fromItem(item)),
        lastEvaluatedKey: response.LastEvaluatedKey
      };
    } catch (error) {
      console.error(`Error listing fees for business ${businessId}:`, error);
      throw error;
    }
  }

  /**
   * List fees for a transaction
   */
  static async listByTransaction(
    transactionId: string
  ): Promise<Fee[]> {
    const client = getClient();
    
    try {
      const response = await client.send(new QueryCommand({
        TableName: process.env.TABLE_NAME!,
        IndexName: "GSI2",
        KeyConditionExpression: "GSI2PK = :gsi2pk AND begins_with(GSI2SK, :fee_prefix)",
        ExpressionAttributeValues: {
          ":gsi2pk": { S: `TXN#${transactionId}` },
          ":fee_prefix": { S: "FEE#" }
        }
      }));

      return (response.Items || []).map(item => Fee.fromItem(item));
    } catch (error) {
      console.error(`Error listing fees for transaction ${transactionId}:`, error);
      throw error;
    }
  }

  /**
   * Get total fees for a business within a date range
   */
  static async getTotalByDateRange(
    businessId: string,
    fromDate: string,
    toDate: string,
    currency: string = "USD"
  ): Promise<Money> {
    const { fees } = await Fee.listByBusiness(businessId, {
      fromDate,
      toDate,
      limit: 1000 // Should be paginated in production for high volume
    });

    // Calculate total fees
    let total = new Money("0.00", currency);
    
    fees.forEach(fee => {
      if (fee.currency === currency) {
        total = total.add(fee.getAmount());
      }
      // Note: Currency conversion would be needed for mixed currencies
    });

    return total;
  }

  /**
   * Factory method to create a flat fee
   */
  static createFlatFee(
    businessId: string,
    transactionId: string,
    amount: string,
    description: string,
    currency: string = "USD"
  ): Fee {
    return new Fee(
      businessId,
      transactionId,
      amount,
      "FLAT",
      amount, // Rate is the same as amount for flat fees
      description,
      { currency }
    );
  }

  /**
   * Factory method to create a percentage fee
   * @param rate Percentage rate (e.g., "2.9" for 2.9%)
   */
  static createPercentageFee(
    businessId: string,
    transactionId: string,
    transactionAmount: string,
    rate: string,
    description: string,
    currency: string = "USD"
  ): Fee {
    // Calculate fee amount based on rate
    const transactionMoney = new Money(transactionAmount, currency);
    const percentage = parseFloat(rate) / 100;
    const feeAmount = transactionMoney.multiply(percentage);
    
    return new Fee(
      businessId,
      transactionId,
      feeAmount.toString(),
      "PERCENTAGE",
      rate,
      description,
      { currency }
    );
  }
}

// Convenience functions

/**
 * Create a new flat fee
 */
export const createFlatFee = async (
  businessId: string,
  transactionId: string,
  amount: string,
  description: string,
  currency: string = "USD"
): Promise<Fee> => {
  const fee = Fee.createFlatFee(businessId, transactionId, amount, description, currency);
  return fee.create();
};

/**
 * Create a new percentage fee
 */
export const createPercentageFee = async (
  businessId: string,
  transactionId: string,
  transactionAmount: string,
  rate: string,
  description: string,
  currency: string = "USD"
): Promise<Fee> => {
  const fee = Fee.createPercentageFee(
    businessId,
    transactionId,
    transactionAmount,
    rate,
    description,
    currency
  );
  return fee.create();
};

/**
 * Get a fee by ID
 */
export const getFee = async (
  businessId: string,
  feeId: string
): Promise<Fee> => {
  return Fee.getById(businessId, feeId);
};

/**
 * Get fees for a business
 */
export const getBusinessFees = async (
  businessId: string,
  options?: Parameters<typeof Fee.listByBusiness>[1]
): Promise<ReturnType<typeof Fee.listByBusiness>> => {
  return Fee.listByBusiness(businessId, options);
};

/**
 * Get total fees for a business within a date range
 */
export const getBusinessTotalFees = async (
  businessId: string,
  fromDate: string,
  toDate: string,
  currency: string = "USD"
): Promise<Money> => {
  return Fee.getTotalByDateRange(businessId, fromDate, toDate, currency);
};
</file>

<file path="layers/commons/data/entities/money.test.ts">
import { Money } from './money';
import Decimal from 'decimal.js';

/**
 * Tests for the Money class
 *
 * The Money class follows best practices for financial calculations:
 * 1.Uses floating-point numbers for monetary values
 * 2. Uses decimal.js for precise decimal arithmetic
 * 3. Supports working with smallest currency units (cents)
 * 4. Includes BigInt support for large amounts
 */
describe('Money', () => {
    // Constructor tests
    describe('constructor', () => {
        it('should create a Money instance with string amount', () => {
            const money = new Money('10.50');
            expect(money.amount.toString()).toBe('10.5');
            expect(money.currency).toBe('USD');
        });

        it('should create a Money instance with number amount', () => {
            const money = new Money(10.5);
            expect(money.amount.toString()).toBe('10.5');
            expect(money.currency).toBe('USD');
        });

        it('should create a Money instance with Decimal amount', () => {
            const decimal = new Decimal('10.50');
            const money = new Money(decimal);
            expect(money.amount.equals(decimal)).toBe(true);
            expect(money.currency).toBe('USD');
        });

        it('should create a Money instance with specified currency', () => {
            const money = new Money('10.50', 'EUR');
            expect(money.amount.toString()).toBe('10.5');
            expect(money.currency).toBe('EUR');
        });
    });

    // Static factory methods
    describe('fromCents', () => {
        it('should create a Money instance from cents as number', () => {
            const money = Money.fromCents(1050); // $10.50
            expect(money.toString()).toBe('10.50');
            expect(money.currency).toBe('USD');
        });

        it('should create a Money instance from cents as string', () => {
            const money = Money.fromCents('1050'); // $10.50
            expect(money.toString()).toBe('10.50');
            expect(money.currency).toBe('USD');
        });

        it('should create a Money instance from cents as bigint', () => {
            const money = Money.fromCents(BigInt(1050)); // $10.50
            expect(money.toString()).toBe('10.50');
            expect(money.currency).toBe('USD');
        });

        it('should create a Money instance from cents with specified currency', () => {
            const money = Money.fromCents(1050, 'EUR'); // â‚¬10.50
            expect(money.toString()).toBe('10.50');
            expect(money.currency).toBe('EUR');
        });

        it('should handle very large cent values using bigint', () => {
            const largeCents = BigInt('9007199254740991'); // Max safe integer in JS + 1
            const money = Money.fromCents(largeCents);
            expect(money.toString()).toBe('90071992547409.91');
            expect(money.currency).toBe('USD');
        });
    });

    // String representation tests
    describe('toString/toFormattedString', () => {
        it('should convert to string with default 2 decimal places', () => {
            const money = new Money('10.5');
            expect(money.toString()).toBe('10.50');
        });

        it('should convert to string with specified decimal places', () => {
            const money = new Money('10.5');
            expect(money.toString(4)).toBe('10.5000');
        });

        it('should format as USD currency string', () => {
            const money = new Money('1234.5');
            expect(money.toFormattedString()).toBe('$1,234.50');
        });

        it('should format as EUR currency string', () => {
            const money = new Money('1234.5', 'EUR');
            // Note: actual format depends on the locale used by Intl.NumberFormat
            const result = money.toFormattedString();
            expect(result).toContain('1,234.50');
            expect(result).toContain('â‚¬');
        });
    });

    // Cents conversion tests
    describe('toCents/toCentsBigInt', () => {
        it('should convert money to cents as number', () => {
            const money = new Money('10.50');
            expect(money.toCents()).toBe(1050);
        });

        it('should convert money to cents as bigint', () => {
            const money = new Money('10.50');
            expect(money.toCentsBigInt()).toBe(BigInt(1050));
        });

        it('should handle fractional cents when converting to cents', () => {
            const money = new Money('10.505');
            expect(money.toCents()).toBe(1051); // Rounds to nearest cent
        });

        it('should handle large amounts when converting to cents as bigint', () => {
            const money = new Money('90071992547409.91'); // Beyond JS safe integer limit
            // This would overflow a regular number but works with BigInt
            expect(money.toCentsBigInt()).toBe(BigInt('9007199254740991'));
        });
    });

    // Addition tests
    describe('add', () => {
        it('should add two Money instances of same currency', () => {
            const money1 = new Money('10.50');
            const money2 = new Money('5.25');
            const result = money1.add(money2);
            expect(result.toString()).toBe('15.75');
            expect(result.currency).toBe('USD');
            // Original objects should remain unchanged
            expect(money1.toString()).toBe('10.50');
            expect(money2.toString()).toBe('5.25');
        });

        it('should add a number to a Money instance', () => {
            const money = new Money('10.50');
            const result = money.add(5.25);
            expect(result.toString()).toBe('15.75');
        });

        it('should add a string amount to a Money instance', () => {
            const money = new Money('10.50');
            const result = money.add('5.25');
            expect(result.toString()).toBe('15.75');
        });

        it('should throw error when adding money of different currencies', () => {
            const money1 = new Money('10.50', 'USD');
            const money2 = new Money('5.25', 'EUR');
            expect(() => money1.add(money2)).toThrow();
        });
    });

    // Subtraction tests
    describe('subtract', () => {
        it('should subtract another Money instance of same currency', () => {
            const money1 = new Money('10.50');
            const money2 = new Money('5.25');
            const result = money1.subtract(money2);
            expect(result.toString()).toBe('5.25');
            expect(result.currency).toBe('USD');
        });

        it('should subtract a number from a Money instance', () => {
            const money = new Money('10.50');
            const result = money.subtract(5.25);
            expect(result.toString()).toBe('5.25');
        });

        it('should subtract a string amount from a Money instance', () => {
            const money = new Money('10.50');
            const result = money.subtract('5.25');
            expect(result.toString()).toBe('5.25');
        });

        it('should throw error when subtracting money of different currencies', () => {
            const money1 = new Money('10.50', 'USD');
            const money2 = new Money('5.25', 'EUR');
            expect(() => money1.subtract(money2)).toThrow();
        });
    });

    // Multiplication tests
    describe('multiply', () => {
        it('should multiply by a number factor', () => {
            const money = new Money('10.50');
            const result = money.multiply(2);
            expect(result.toString()).toBe('21.00');
        });

        it('should multiply by a string factor', () => {
            const money = new Money('10.50');
            const result = money.multiply('2.5');
            expect(result.toString()).toBe('26.25');
        });

        it('should multiply by a Decimal factor', () => {
            const money = new Money('10.50');
            const result = money.multiply(new Decimal('2.5'));
            expect(result.toString()).toBe('26.25');
        });

        it('should round to 2 decimal places by default', () => {
            const money = new Money('10.00');
            const result = money.multiply(0.333333);
            expect(result.toString()).toBe('3.33');
        });

        it('should handle different rounding modes', () => {
            const money = new Money('10.00');
            const resultUp = money.multiply(0.666666, 0); // ROUND_UP = 0
            const resultDown = money.multiply(0.666666, 1); // ROUND_DOWN = 1
            expect(resultUp.toString()).toBe('6.67');
            expect(resultDown.toString()).toBe('6.66');
        });
    });

    // Division tests
    describe('divide', () => {
        it('should divide by a number divisor', () => {
            const money = new Money('10.50');
            const result = money.divide(2);
            expect(result.toString()).toBe('5.25');
        });

        it('should divide by a string divisor', () => {
            const money = new Money('10.50');
            const result = money.divide('2.5');
            expect(result.toString()).toBe('4.20');
        });

        it('should divide by a Decimal divisor', () => {
            const money = new Money('10.50');
            const result = money.divide(new Decimal('2.5'));
            expect(result.toString()).toBe('4.20');
        });

        it('should throw error when dividing by zero', () => {
            const money = new Money('10.50');
            expect(() => money.divide(0)).toThrow();
            expect(() => money.divide('0')).toThrow();
            expect(() => money.divide(new Decimal(0))).toThrow();
        });

        it('should round to 2 decimal places by default', () => {
            const money = new Money('10.00');
            const result = money.divide(3);
            expect(result.toString()).toBe('3.33');
        });

        it('should handle different rounding modes', () => {
            const money = new Money('10.00');
            const resultUp = money.divide(3, 0); // ROUND_UP = 0
            const resultDown = money.divide(3, 1); // ROUND_DOWN = 1
            expect(resultUp.toString()).toBe('3.34');
            expect(resultDown.toString()).toBe('3.33');
        });
    });

    // Percentage calculation tests
    describe('percentage', () => {
        it('should calculate a percentage of the money amount', () => {
            const money = new Money('100.00');
            const result = money.percentage(5); // 5% of 100
            expect(result.toString()).toBe('5.00');
        });

        it('should handle string percentage values', () => {
            const money = new Money('100.00');
            const result = money.percentage('5.5'); // 5.5% of 100
            expect(result.toString()).toBe('5.50');
        });

        it('should handle Decimal percentage values', () => {
            const money = new Money('100.00');
            const result = money.percentage(new Decimal('5.5'));
            expect(result.toString()).toBe('5.50');
        });
    });

    // Comparison and state tests
    describe('comparison and state methods', () => {
        it('should check if amount is positive', () => {
            expect(new Money('10.50').isPositive()).toBe(true);
            expect(new Money('0').isPositive()).toBe(false); // Decimal.js considers 0 as positive=false
            expect(new Money('-10.50').isPositive()).toBe(false);
        });

        it('should check if amount is negative', () => {
            expect(new Money('-10.50').isNegative()).toBe(true);
            expect(new Money('0').isNegative()).toBe(false);
            expect(new Money('10.50').isNegative()).toBe(false);
        });

        it('should check if amount is zero', () => {
            expect(new Money('0').isZero()).toBe(true);
            expect(new Money('0.00').isZero()).toBe(true);
            expect(new Money('10.50').isZero()).toBe(false);
        });

        it('should check equality with another Money instance', () => {
            const money1 = new Money('10.50');
            const money2 = new Money('10.50');
            const money3 = new Money('10.50', 'EUR');
            expect(money1.equals(money2)).toBe(true);
            expect(money1.equals(money3)).toBe(false); // Different currency
        });

        it('should check equality with a number', () => {
            const money = new Money('10.50');
            expect(money.equals(10.5)).toBe(true);
            expect(money.equals(10.51)).toBe(false);
        });

        it('should check equality with a string', () => {
            const money = new Money('10.50');
            expect(money.equals('10.5')).toBe(true);
            expect(money.equals('10.51')).toBe(false);
        });

        it('should compare greater than', () => {
            const money1 = new Money('10.50');
            const money2 = new Money('5.25');
            expect(money1.greaterThan(money2)).toBe(true);
            expect(money2.greaterThan(money1)).toBe(false);
            expect(money1.greaterThan(5.25)).toBe(true);
            expect(money1.greaterThan('5.25')).toBe(true);
        });

        it('should throw error when comparing greater than with different currencies', () => {
            const money1 = new Money('10.50', 'USD');
            const money2 = new Money('5.25', 'EUR');
            expect(() => money1.greaterThan(money2)).toThrow();
        });

        it('should compare less than', () => {
            const money1 = new Money('5.25');
            const money2 = new Money('10.50');
            expect(money1.lessThan(money2)).toBe(true);
            expect(money2.lessThan(money1)).toBe(false);
            expect(money1.lessThan(10.5)).toBe(true);
            expect(money1.lessThan('10.50')).toBe(true);
        });

        it('should throw error when comparing less than with different currencies', () => {
            const money1 = new Money('5.25', 'USD');
            const money2 = new Money('10.50', 'EUR');
            expect(() => money1.lessThan(money2)).toThrow();
        });
    });

    // Additional operations
    describe('additional operations', () => {
        it('should get absolute value', () => {
            const money = new Money('-10.50');
            const result = money.abs();
            expect(result.toString()).toBe('10.50');
            expect(money.toString()).toBe('-10.50'); // Original unchanged
        });

        it('should negate the value', () => {
            const money1 = new Money('10.50');
            const money2 = new Money('-10.50');
            expect(money1.negate().toString()).toBe('-10.50');
            expect(money2.negate().toString()).toBe('10.50');
        });
    });

    // Integration/usage pattern tests
    describe('integration and usage patterns', () => {
        it('should demonstrate dollars/cents conversion', () => {
            // Start with cents (e.g., from database or API)
            const cents = 1299; // $12.99

            // Create Money from cents
            const money = Money.fromCents(cents);
            expect(money.toString()).toBe('12.99');

            // Do some calculations (e.g., add tax)
            const withTax = money.multiply(1.08); // 8% tax
            expect(withTax.toString()).toBe('14.03');

            // Convert back to cents for storage or API call
            expect(withTax.toCents()).toBe(1403);
        });

        it('should handle fractional cents correctly', () => {
            // When doing calculations, we may get fractional cents
            const money = new Money('10.00');
            const dividedByThree = money.divide(3); // $3.33333...

            // Should be rounded to 2 decimal places ($3.33)
            expect(dividedByThree.toString()).toBe('3.33');

            // When converting to cents, we get whole cents
            expect(dividedByThree.toCents()).toBe(333);

            // If we multiply the original money by three parts
            const threeParts = dividedByThree.multiply(3);

            // Due to rounding, we might not get exactly the original amount
            // $3.33 * 3 = $9.99, not $10.00
            expect(threeParts.toString()).toBe('9.99');

            // This demonstrates why precise handling of money is important
        });
    });
});
</file>

<file path="layers/commons/data/entities/money.ts">
import Decimal from 'decimal.js';

// Type for Decimal.js rounding modes
type Rounding = Decimal.Rounding;

/**
 * Money class for safely handling financial calculations with proper decimal precision.
 * Uses decimal.js to avoid floating-point errors common in JavaScript.
 */
export class Money {
    private _amount: Decimal;
    private _currency: string;

    /**
     * Create a new Money instance
     * @param amount - String, number, or Decimal representing the monetary amount in the standard unit (dollars, euros, etc.)
     * @param currency - Currency code (default: USD)
     */
    constructor(amount: string | number | Decimal, currency: string = 'USD') {
        // Ensure we're using Decimal for all calculations
        this._amount = amount instanceof Decimal ? amount : new Decimal(amount);
        this._currency = currency;
    }

    /**
     * Create a Money instance from a cents value (smallest currency unit)
     * @param cents - Integer value in smallest currency unit (cents, pence, etc.)
     * @param currency - Currency code (default: USD)
     * @returns A new Money instance
     */
    static fromCents(cents: number | string | bigint, currency: string = 'USD'): Money {
        let decimalValue: Decimal;

        if (typeof cents === 'bigint') {
            // Convert BigInt to string to preserve precision
            decimalValue = new Decimal(cents.toString());
        } else {
            decimalValue = new Decimal(cents);
        }

        // Divide by 100 to convert from cents to dollars
        return new Money(decimalValue.dividedBy(100), currency);
    }

    /**
     * Get the amount as a Decimal object
     */
    get amount(): Decimal {
        return this._amount;
    }

    /**
     * Get the currency code
     */
    get currency(): string {
        return this._currency;
    }

    /**
     * Get the amount as a string with specified decimal places
     * @param decimalPlaces - Number of decimal places (default: 2)
     */
    toString(decimalPlaces: number = 2): string {
        return this._amount.toFixed(decimalPlaces);
    }

    /**
     * Get the amount as a formatted currency string
     */
    toFormattedString(): string {
        // Format as currency with 2 decimal places
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: this._currency,
        }).format(this._amount.toNumber());
    }

    /**
     * Get the amount as cents (smallest currency unit)
     * @returns Integer representing the amount in cents
     */
    toCents(): number {
        // Multiply by 100 and round to avoid floating point errors
        return this._amount.times(100).toDecimalPlaces(0).toNumber();
    }

    /**
     * Get the amount as cents in BigInt format for large values
     * @returns BigInt representing the amount in cents
     */
    toCentsBigInt(): bigint {
        // Multiply by 100, round, and convert to BigInt
        const centsString = this._amount.times(100).toDecimalPlaces(0).toString();
        return BigInt(centsString);
    }

    /**
     * Get the amount as a number
     * @returns The monetary amount as a JavaScript number
     */
    getNumericAmount(): number {
        return this._amount.toNumber();
    }

    /**
     * Add another money value to this one
     * @param other - Money instance or number/string to add
     * @returns A new Money instance with the result
     */
    add(other: Money | string | number): Money {
        if (other instanceof Money) {
            if (other.currency !== this._currency) {
                throw new Error(`Cannot add money with different currencies: ${this._currency} and ${other.currency}`);
            }
            return new Money(this._amount.plus(other.amount), this._currency);
        }
        return new Money(this._amount.plus(new Decimal(other)), this._currency);
    }

    /**
     * Subtract another money value from this one
     * @param other - Money instance or number/string to subtract
     * @returns A new Money instance with the result
     */
    subtract(other: Money | string | number): Money {
        if (other instanceof Money) {
            if (other.currency !== this._currency) {
                throw new Error(
                    `Cannot subtract money with different currencies: ${this._currency} and ${other.currency}`,
                );
            }
            return new Money(this._amount.minus(other.amount), this._currency);
        }
        return new Money(this._amount.minus(new Decimal(other)), this._currency);
    }

    /**
     * Multiply the money by a factor
     * @param factor - Multiplication factor
     * @param roundingMode - Decimal rounding mode (default: Decimal.ROUND_HALF_UP)
     * @returns A new Money instance with the result
     */
    multiply(factor: number | string | Decimal, roundingMode: Rounding = Decimal.ROUND_HALF_UP): Money {
        const result = this._amount.times(new Decimal(factor));
        // Round to avoid tiny fractional amounts due to binary floating point
        return new Money(result.toDecimalPlaces(2, roundingMode), this._currency);
    }

    /**
     * Divide the money by a divisor
     * @param divisor - Division factor
     * @param roundingMode - Decimal rounding mode (default: Decimal.ROUND_HALF_UP)
     * @returns A new Money instance with the result
     */
    divide(divisor: number | string | Decimal, roundingMode: Rounding = Decimal.ROUND_HALF_UP): Money {
        if (new Decimal(divisor).isZero()) {
            throw new Error('Cannot divide by zero');
        }
        const result = this._amount.dividedBy(new Decimal(divisor));
        // Round to avoid tiny fractional amounts due to binary floating point
        return new Money(result.toDecimalPlaces(2, roundingMode), this._currency);
    }

    /**
     * Calculate a percentage of this money amount
     * @param percentage - The percentage to calculate (e.g., 5 for 5%)
     * @returns A new Money instance with the resulting percentage amount
     */
    percentage(percentage: number | string | Decimal): Money {
        const factor = new Decimal(percentage).dividedBy(100);
        return this.multiply(factor);
    }

    /**
     * Check if this money amount is positive
     */
    isPositive(): boolean {
        return this._amount.isPositive() && !this._amount.isZero();
    }

    /**
     * Check if this money amount is negative
     */
    isNegative(): boolean {
        return this._amount.isNegative();
    }

    /**
     * Check if this money amount is zero
     */
    isZero(): boolean {
        return this._amount.isZero();
    }

    /**
     * Check if this money amount is equal to another
     */
    equals(other: Money | string | number): boolean {
        if (other instanceof Money) {
            return this._currency === other.currency && this._amount.equals(other.amount);
        }
        return this._amount.equals(new Decimal(other));
    }

    /**
     * Check if this money amount is greater than another
     */
    greaterThan(other: Money | string | number): boolean {
        if (other instanceof Money) {
            if (other.currency !== this._currency) {
                throw new Error(
                    `Cannot compare money with different currencies: ${this._currency} and ${other.currency}`,
                );
            }
            return this._amount.greaterThan(other.amount);
        }
        return this._amount.greaterThan(new Decimal(other));
    }

    /**
     * Check if this money amount is less than another
     */
    lessThan(other: Money | string | number): boolean {
        if (other instanceof Money) {
            if (other.currency !== this._currency) {
                throw new Error(
                    `Cannot compare money with different currencies: ${this._currency} and ${other.currency}`,
                );
            }
            return this._amount.lessThan(other.amount);
        }
        return this._amount.lessThan(new Decimal(other));
    }

    /**
     * Get the absolute value of this money amount
     */
    abs(): Money {
        return new Money(this._amount.abs(), this._currency);
    }

    /**
     * Get the negative value of this money amount
     */
    negate(): Money {
        return new Money(this._amount.negated(), this._currency);
    }
}
</file>

<file path="layers/commons/data/entities/provider-transaction.test.ts">
import { Money } from './money';
import {
    ProviderTransaction,
    ProviderType,
    ProviderDirection,
    ProviderTransactionStatus,
} from './provider-transaction';
import { expect, describe, it, beforeEach, jest, afterEach } from '@jest/globals';

// Mock the AWS SDK client
jest.mock('../client', () => ({
    getClient: jest.fn().mockReturnValue({
        send: jest.fn(),
    }),
}));

// Import mocked module
import { getClient } from '../client';
const mockedGetClient = getClient as jest.MockedFunction<typeof getClient>;
const mockedSend = mockedGetClient().send as jest.MockedFunction<any>;

describe('ProviderTransaction', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    // Constructor tests
    describe('constructor', () => {
        it('should create a new ProviderTransaction instance with default values', () => {
            const providerTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
            );

            expect(providerTxn.providerId).toBe('stripe');
            expect(providerTxn.providerType).toBe('CARD_PROVIDER');
            expect(providerTxn.transactionId).toBe('txn123');
            expect(providerTxn.entityId).toBe('user123');
            expect(providerTxn.entityType).toBe('USER');
            expect(providerTxn.amount).toBe('100.00');
            expect(providerTxn.status).toBe('INITIATED');
            expect(providerTxn.direction).toBe('IN');
            expect(providerTxn.currency).toBe('USD');
            expect(providerTxn.providerTransactionId).toBeDefined();
            expect(providerTxn.createdAt).toBeDefined();
            expect(providerTxn.updatedAt).toBeDefined();
        });

        it('should create a ProviderTransaction instance with custom options', () => {
            const customProviderTxnId = 'custom_provider_txn_id';
            const customCreatedAt = '2023-01-01T00:00:00Z';
            const customUpdatedAt = '2023-01-02T00:00:00Z';

            const providerTxn = new ProviderTransaction(
                'stripe',
                'WITHDRAWAL_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'OUT',
                {
                    providerTransactionId: customProviderTxnId,
                    status: 'COMPLETED',
                    currency: 'EUR',
                    rawResponse: '{"status": "succeeded"}',
                    metadata: {
                        paymentMethod: 'bank_transfer',
                        externalReference: 'ext_123',
                    },
                    completedAt: '2023-01-02T00:00:00Z',
                    createdAt: customCreatedAt,
                    updatedAt: customUpdatedAt,
                },
            );

            expect(providerTxn.providerId).toBe('stripe');
            expect(providerTxn.providerType).toBe('WITHDRAWAL_PROVIDER');
            expect(providerTxn.transactionId).toBe('txn123');
            expect(providerTxn.entityId).toBe('user123');
            expect(providerTxn.entityType).toBe('USER');
            expect(providerTxn.amount).toBe('100.00');
            expect(providerTxn.currency).toBe('EUR');
            expect(providerTxn.status).toBe('COMPLETED');
            expect(providerTxn.direction).toBe('OUT');
            expect(providerTxn.providerTransactionId).toBe(customProviderTxnId);
            expect(providerTxn.rawResponse).toBe('{"status": "succeeded"}');
            expect(providerTxn.metadata).toEqual({
                paymentMethod: 'bank_transfer',
                externalReference: 'ext_123',
            });
            expect(providerTxn.completedAt).toBe('2023-01-02T00:00:00Z');
            expect(providerTxn.createdAt).toBe(customCreatedAt);
            expect(providerTxn.updatedAt).toBe(customUpdatedAt);
        });
    });

    // Getter tests
    describe('getters', () => {
        it('should return the correct PK and SK values', () => {
            const providerTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
                {
                    providerTransactionId: 'prov_123',
                },
            );

            expect(providerTxn.pk).toBe('PROVIDER#stripe');
            expect(providerTxn.sk).toBe('PTXN#prov_123');
        });

        it('should convert amount to Money object', () => {
            const providerTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
                {
                    currency: 'EUR',
                },
            );

            const amountMoney = providerTxn.getAmount();
            expect(amountMoney).toBeInstanceOf(Money);
            expect(amountMoney.toString()).toBe('100.00');
            expect(amountMoney.currency).toBe('EUR');
        });
    });

    // Status checks
    describe('status checks', () => {
        it('should check status correctly', () => {
            const pendingTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
                {
                    status: 'INITIATED',
                },
            );

            const completedTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
                {
                    status: 'COMPLETED',
                },
            );

            const failedTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
                {
                    status: 'FAILED',
                },
            );

            expect(pendingTxn.isInProgress()).toBe(true);
            expect(pendingTxn.isCompleted()).toBe(false);
            expect(pendingTxn.isFailed()).toBe(false);

            expect(completedTxn.isInProgress()).toBe(false);
            expect(completedTxn.isCompleted()).toBe(true);
            expect(completedTxn.isFailed()).toBe(false);

            expect(failedTxn.isInProgress()).toBe(false);
            expect(failedTxn.isCompleted()).toBe(false);
            expect(failedTxn.isFailed()).toBe(true);
        });
    });

    // DynamoDB conversion tests
    describe('toItem and fromItem', () => {
        it('should convert providerTransaction to DynamoDB item', () => {
            const providerTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
                {
                    providerTransactionId: 'prov_123',
                    status: 'INITIATED',
                    rawResponse: '{"status": "processing"}',
                    metadata: {
                        paymentMethod: 'card',
                        externalReference: 'ext_123',
                    },
                    createdAt: '2023-01-01T00:00:00Z',
                    updatedAt: '2023-01-01T00:00:00Z',
                },
            );

            const item = providerTxn.toItem();

            expect(item.PK.S).toBe('PROVIDER#stripe');
            expect(item.SK.S).toBe('PTXN#prov_123');
            expect(item.GSI1PK.S).toBe('TXN#txn123');
            expect(item.GSI1SK.S).toBe('PROVIDER#stripe');
            expect(item.GSI2PK.S).toBe('PROVIDER#stripe');
            expect(item.GSI2SK.S).toBe('PTXN#2023-01-01T00:00:00Z');
            expect(item.providerTransactionId.S).toBe('prov_123');
            expect(item.providerType.S).toBe('CARD_PROVIDER');
            expect(item.providerId.S).toBe('stripe');
            expect(item.transactionId.S).toBe('txn123');
            expect(item.entityId.S).toBe('user123');
            expect(item.entityType.S).toBe('USER');
            expect(item.amount.S).toBe('100.00');
            expect(item.currency.S).toBe('USD');
            expect(item.status.S).toBe('INITIATED');
            expect(item.direction.S).toBe('IN');
            expect(item.rawResponse.S).toBe('{"status": "processing"}');
            expect(item.metadata.M?.paymentMethod.S).toBe('card');
            expect(item.metadata.M?.externalReference.S).toBe('ext_123');
            expect(item.createdAt.S).toBe('2023-01-01T00:00:00Z');
            expect(item.updatedAt.S).toBe('2023-01-01T00:00:00Z');
        });

        it('should convert DynamoDB item to providerTransaction', () => {
            const item = {
                PK: { S: 'PROVIDER#stripe' },
                SK: { S: 'PTXN#prov_123' },
                GSI1PK: { S: 'TXN#txn123' },
                GSI1SK: { S: 'PROVIDER#stripe' },
                GSI2PK: { S: 'PROVIDER#stripe' },
                GSI2SK: { S: 'PTXN#2023-01-01T00:00:00Z' },
                providerTransactionId: { S: 'prov_123' },
                providerId: { S: 'stripe' },
                providerType: { S: 'CARD_PROVIDER' },
                transactionId: { S: 'txn123' },
                entityId: { S: 'user123' },
                entityType: { S: 'USER' },
                amount: { S: '100.00' },
                currency: { S: 'USD' },
                status: { S: 'INITIATED' },
                direction: { S: 'IN' },
                rawResponse: { S: '{"status": "processing"}' },
                metadata: {
                    M: {
                        paymentMethod: { S: 'card' },
                        externalReference: { S: 'ext_123' },
                    },
                },
                createdAt: { S: '2023-01-01T00:00:00Z' },
                updatedAt: { S: '2023-01-01T00:00:00Z' },
            };

            const providerTxn = ProviderTransaction.fromItem(item);

            expect(providerTxn.providerTransactionId).toBe('prov_123');
            expect(providerTxn.providerId).toBe('stripe');
            expect(providerTxn.providerType).toBe('CARD_PROVIDER');
            expect(providerTxn.transactionId).toBe('txn123');
            expect(providerTxn.entityId).toBe('user123');
            expect(providerTxn.entityType).toBe('USER');
            expect(providerTxn.amount).toBe('100.00');
            expect(providerTxn.currency).toBe('USD');
            expect(providerTxn.status).toBe('INITIATED');
            expect(providerTxn.direction).toBe('IN');
            expect(providerTxn.rawResponse).toBe('{"status": "processing"}');
            expect(providerTxn.metadata).toEqual({
                paymentMethod: 'card',
                externalReference: 'ext_123',
            });
            expect(providerTxn.createdAt).toBe('2023-01-01T00:00:00Z');
            expect(providerTxn.updatedAt).toBe('2023-01-01T00:00:00Z');
        });

        it('should throw error when item is undefined', () => {
            expect(() => ProviderTransaction.fromItem(undefined)).toThrow('No provider transaction item found!');
        });
    });

    // Database operation tests
    describe('database operations', () => {
        // Mock dates for consistent testing
        const mockDate = new Date('2023-01-01T00:00:00Z');
        let originalDate: DateConstructor;

        beforeEach(() => {
            originalDate = global.Date;
            global.Date = class extends Date {
                constructor() {
                    super();
                    return mockDate;
                }
                static now() {
                    return mockDate.getTime();
                }
            } as DateConstructor;

            // Set up environment variables
            process.env.TABLE_NAME = 'TestTable';
        });

        afterEach(() => {
            global.Date = originalDate;
            delete process.env.TABLE_NAME;
        });

        it('should create a provider transaction in the database', async () => {
            const providerTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
            );

            mockedSend.mockResolvedValueOnce({});

            await providerTxn.create();

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Item: providerTxn.toItem(),
                        ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                    }),
                }),
            );
        });

        it('should throw error when create fails', async () => {
            const providerTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
            );

            const error = new Error('DynamoDB error');
            mockedSend.mockRejectedValueOnce(error);

            await expect(providerTxn.create()).rejects.toThrow(error);
            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should update a provider transaction', async () => {
            const providerTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
                {
                    providerTransactionId: 'prov_123',
                    status: 'INITIATED',
                },
            );

            // Simulate updating the status
            providerTxn.status = 'PROCESSING';

            mockedSend.mockResolvedValueOnce({});

            await providerTxn.update();

            // Should have updated the updatedAt timestamp
            expect(providerTxn.updatedAt).toBe(mockDate.toISOString());

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Item: providerTxn.toItem(),
                    }),
                }),
            );
        });

        it('should mark a transaction as completed', async () => {
            const providerTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
                {
                    providerTransactionId: 'prov_123',
                    status: 'INITIATED',
                },
            );

            mockedSend.mockResolvedValueOnce({});

            await providerTxn.markCompleted('{"status": "succeeded"}', { externalReference: 'ext_123' });

            expect(providerTxn.status).toBe('COMPLETED');
            expect(providerTxn.completedAt).toBe(mockDate.toISOString());
            expect(providerTxn.rawResponse).toBe('{"status": "succeeded"}');
            expect(providerTxn.metadata?.externalReference).toBe('ext_123');
            expect(providerTxn.updatedAt).toBe(mockDate.toISOString());

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should mark a transaction as failed', async () => {
            const providerTxn = new ProviderTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                'IN',
                {
                    providerTransactionId: 'prov_123',
                    status: 'INITIATED',
                },
            );

            mockedSend.mockResolvedValueOnce({});

            await providerTxn.markFailed('payment_failed', 'Card declined', '{"error": "payment_failed"}');

            expect(providerTxn.status).toBe('FAILED');
            expect(providerTxn.rawResponse).toBe('{"error": "payment_failed"}');
            expect(providerTxn.metadata?.errorCode).toBe('payment_failed');
            expect(providerTxn.metadata?.errorMessage).toBe('Card declined');
            expect(providerTxn.updatedAt).toBe(mockDate.toISOString());

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should get a provider transaction by ID', async () => {
            const mockItem = {
                providerTransactionId: { S: 'prov_123' },
                providerId: { S: 'stripe' },
                providerType: { S: 'CARD_PROVIDER' },
                transactionId: { S: 'txn123' },
                entityId: { S: 'user123' },
                entityType: { S: 'USER' },
                amount: { S: '100.00' },
                currency: { S: 'USD' },
                status: { S: 'COMPLETED' },
                direction: { S: 'IN' },
                createdAt: { S: '2023-01-01T00:00:00Z' },
                updatedAt: { S: '2023-01-01T00:00:00Z' },
            };

            mockedSend.mockResolvedValueOnce({
                Item: mockItem,
            });

            const providerTxn = await ProviderTransaction.getById('stripe', 'prov_123');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Key: {
                            PK: { S: 'PROVIDER#stripe' },
                            SK: { S: 'PTXN#prov_123' },
                        },
                    }),
                }),
            );
            expect(providerTxn).toBeInstanceOf(ProviderTransaction);
            expect(providerTxn.providerTransactionId).toBe('prov_123');
        });

        it('should throw error when provider transaction is not found', async () => {
            mockedSend.mockResolvedValueOnce({
                Item: undefined,
            });

            await expect(ProviderTransaction.getById('stripe', 'prov_123')).rejects.toThrow(
                'Provider transaction prov_123 not found for provider stripe',
            );

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should list provider transactions by entity', async () => {
            const mockItems = [
                {
                    providerTransactionId: { S: 'prov_123' },
                    providerId: { S: 'stripe' },
                    providerType: { S: 'CARD_PROVIDER' },
                    transactionId: { S: 'txn123' },
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    amount: { S: '100.00' },
                    currency: { S: 'USD' },
                    status: { S: 'COMPLETED' },
                    direction: { S: 'IN' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                    updatedAt: { S: '2023-01-01T00:00:00Z' },
                },
                {
                    providerTransactionId: { S: 'prov_124' },
                    providerId: { S: 'stripe' },
                    providerType: { S: 'CARD_PROVIDER' },
                    transactionId: { S: 'txn124' },
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    amount: { S: '50.00' },
                    currency: { S: 'USD' },
                    status: { S: 'FAILED' },
                    direction: { S: 'IN' },
                    createdAt: { S: '2023-01-02T00:00:00Z' },
                    updatedAt: { S: '2023-01-02T00:00:00Z' },
                },
            ];

            mockedSend.mockResolvedValueOnce({
                Items: mockItems,
            });

            const result = await ProviderTransaction.getByTransactionId('txn123');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        IndexName: 'GSI1',
                        KeyConditionExpression: 'GSI1PK = :gsi1pk',
                        ExpressionAttributeValues: {
                            ':gsi1pk': { S: 'TXN#txn123' },
                        },
                    }),
                }),
            );
            expect(result).toHaveLength(2);
            expect(result[0]).toBeInstanceOf(ProviderTransaction);
            expect(result[1]).toBeInstanceOf(ProviderTransaction);
            expect(result[0].providerTransactionId).toBe('prov_123');
            expect(result[1].providerTransactionId).toBe('prov_124');
        });

        it('should list provider transactions by date range', async () => {
            const mockItems = [
                {
                    providerTransactionId: { S: 'prov_123' },
                    providerId: { S: 'stripe' },
                    providerType: { S: 'CARD_PROVIDER' },
                    transactionId: { S: 'txn123' },
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    amount: { S: '100.00' },
                    currency: { S: 'USD' },
                    status: { S: 'COMPLETED' },
                    direction: { S: 'IN' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                    updatedAt: { S: '2023-01-01T00:00:00Z' },
                },
                {
                    providerTransactionId: { S: 'prov_124' },
                    providerId: { S: 'stripe' },
                    providerType: { S: 'CARD_PROVIDER' },
                    transactionId: { S: 'txn124' },
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    amount: { S: '50.00' },
                    currency: { S: 'USD' },
                    status: { S: 'FAILED' },
                    direction: { S: 'IN' },
                    createdAt: { S: '2023-01-02T00:00:00Z' },
                    updatedAt: { S: '2023-01-02T00:00:00Z' },
                },
            ];

            mockedSend.mockResolvedValueOnce({
                Items: mockItems,
            });

            const result = await ProviderTransaction.listByProvider('stripe', {
                fromDate: '2023-01-01T00:00:00Z',
                toDate: '2023-01-03T00:00:00Z',
            });

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        IndexName: 'GSI2',
                        KeyConditionExpression: expect.stringContaining('GSI2PK = :gsi2pk'),
                    }),
                }),
            );
            expect(result.providerTransactions).toHaveLength(2);
            expect(result.providerTransactions[0]).toBeInstanceOf(ProviderTransaction);
            expect(result.providerTransactions[1]).toBeInstanceOf(ProviderTransaction);
        });
    });

    // Factory method tests
    describe('factory methods', () => {
        it('should create a deposit provider transaction using factory method', () => {
            const providerTxn = ProviderTransaction.createDepositTransaction(
                'stripe',
                'CARD_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                {
                    currency: 'USD',
                    metadata: {
                        paymentMethod: 'card',
                        cardLast4: '4242',
                    },
                },
            );

            expect(providerTxn).toBeInstanceOf(ProviderTransaction);
            expect(providerTxn.providerId).toBe('stripe');
            expect(providerTxn.providerType).toBe('CARD_PROVIDER');
            expect(providerTxn.amount).toBe('100.00');
            expect(providerTxn.direction).toBe('IN');
            expect(providerTxn.metadata?.paymentMethod).toBe('card');
            expect(providerTxn.metadata?.cardLast4).toBe('4242');
        });

        it('should create a withdrawal provider transaction using factory method', () => {
            const providerTxn = ProviderTransaction.createWithdrawalTransaction(
                'stripe',
                'WITHDRAWAL_PROVIDER',
                'txn123',
                'user123',
                'USER',
                '100.00',
                {
                    currency: 'USD',
                    metadata: {
                        paymentMethod: 'bank_transfer',
                        bankAccountLast4: '9876',
                    },
                },
            );

            expect(providerTxn).toBeInstanceOf(ProviderTransaction);
            expect(providerTxn.providerId).toBe('stripe');
            expect(providerTxn.providerType).toBe('WITHDRAWAL_PROVIDER');
            expect(providerTxn.amount).toBe('100.00');
            expect(providerTxn.direction).toBe('OUT');
            expect(providerTxn.metadata?.paymentMethod).toBe('bank_transfer');
            expect(providerTxn.metadata?.bankAccountLast4).toBe('9876');
        });
    });
});
</file>

<file path="layers/commons/data/entities/provider-transaction.ts">
import { 
  DynamoDBClient, 
  GetItemCommand, 
  QueryCommand, 
  PutItemCommand,
  UpdateItemCommand,
  AttributeValue 
} from "@aws-sdk/client-dynamodb";
import { getClient } from "../client";
import { v4 as uuidv4 } from "uuid";
import { Money } from "./money";

export type ProviderType = "CARD_PROVIDER" | "WITHDRAWAL_PROVIDER" | "INTERNAL";
export type ProviderTransactionStatus = "INITIATED" | "PROCESSING" | "COMPLETED" | "FAILED";
export type ProviderDirection = "IN" | "OUT";

export interface ProviderMetadata {
  cardLast4?: string;
  cardType?: string;
  cardExpiryMonth?: string;
  cardExpiryYear?: string;
  bankName?: string;
  bankAccountLast4?: string;
  errorCode?: string;
  errorMessage?: string;
  externalReference?: string;
  [key: string]: any;
}

/**
 * ProviderTransaction class for tracking transactions with external payment providers
 */
export class ProviderTransaction {
  providerTransactionId: string;
  providerId: string;
  providerType: ProviderType;
  transactionId: string;
  entityId: string;
  entityType: string;
  status: ProviderTransactionStatus;
  amount: string;
  currency: string;
  direction: ProviderDirection;
  rawResponse?: string;
  metadata?: ProviderMetadata;
  createdAt: string;
  updatedAt: string;
  completedAt?: string;

  /**
   * Create a new ProviderTransaction instance
   */
  constructor(
    providerId: string,
    providerType: ProviderType,
    transactionId: string,
    entityId: string,
    entityType: string,
    amount: string,
    direction: ProviderDirection,
    options: {
      providerTransactionId?: string;
      status?: ProviderTransactionStatus;
      currency?: string;
      rawResponse?: string;
      metadata?: ProviderMetadata;
      completedAt?: string;
      createdAt?: string;
      updatedAt?: string;
    } = {}
  ) {
    this.providerTransactionId = options.providerTransactionId || uuidv4();
    this.providerId = providerId;
    this.providerType = providerType;
    this.transactionId = transactionId;
    this.entityId = entityId;
    this.entityType = entityType;
    this.status = options.status || "INITIATED";
    this.amount = amount;
    this.currency = options.currency || "USD";
    this.direction = direction;
    this.rawResponse = options.rawResponse;
    this.metadata = options.metadata;
    this.completedAt = options.completedAt;
    
    const now = new Date().toISOString();
    this.createdAt = options.createdAt || now;
    this.updatedAt = options.updatedAt || now;
  }

  get pk(): string {
    return `PROVIDER#${this.providerId}`;
  }

  get sk(): string {
    return `PTXN#${this.providerTransactionId}`;
  }

  /**
   * Get amount as Money object
   */
  getAmount(): Money {
    return new Money(this.amount, this.currency);
  }

  /**
   * Check if transaction is successful/completed
   */
  isCompleted(): boolean {
    return this.status === "COMPLETED";
  }

  /**
   * Check if transaction is failed
   */
  isFailed(): boolean {
    return this.status === "FAILED";
  }

  /**
   * Check if transaction is still in progress
   */
  isInProgress(): boolean {
    return this.status === "INITIATED" || this.status === "PROCESSING";
  }

  /**
   * Check if transaction is for depositing funds (money coming in)
   */
  isDeposit(): boolean {
    return this.direction === "IN";
  }

  /**
   * Check if transaction is for withdrawing funds (money going out)
   */
  isWithdrawal(): boolean {
    return this.direction === "OUT";
  }

  toItem(): Record<string, AttributeValue> {
    const item: Record<string, AttributeValue> = {
      PK: { S: this.pk },
      SK: { S: this.sk },
      GSI1PK: { S: `TXN#${this.transactionId}` },
      GSI1SK: { S: `PROVIDER#${this.providerId}` },
      GSI2PK: { S: `PROVIDER#${this.providerId}` },
      GSI2SK: { S: `PTXN#${this.createdAt}` },
      providerTransactionId: { S: this.providerTransactionId },
      providerId: { S: this.providerId },
      providerType: { S: this.providerType },
      transactionId: { S: this.transactionId },
      entityId: { S: this.entityId },
      entityType: { S: this.entityType },
      status: { S: this.status },
      amount: { S: this.amount },
      currency: { S: this.currency },
      direction: { S: this.direction },
      createdAt: { S: this.createdAt },
      updatedAt: { S: this.updatedAt }
    };

    // Add optional fields if they exist
    if (this.rawResponse) {
      item.rawResponse = { S: this.rawResponse };
    }

    if (this.completedAt) {
      item.completedAt = { S: this.completedAt };
    }

    // Add metadata as a map attribute
    if (this.metadata) {
      item.metadata = { 
        M: this.marshallMetadata(this.metadata)
      };
    }

    return item;
  }

  private marshallMetadata(metadata: ProviderMetadata): Record<string, AttributeValue> {
    const result: Record<string, AttributeValue> = {};
    for (const [key, value] of Object.entries(metadata)) {
      if (value !== undefined && value !== null) {
        result[key] = { S: String(value) };
      }
    }
    return result;
  }

  static fromItem(item?: Record<string, AttributeValue>): ProviderTransaction {
    if (!item) throw new Error("No provider transaction item found!");

    // Extract metadata
    let metadata: ProviderMetadata | undefined;
    
    if (item.metadata && item.metadata.M) {
      metadata = {};
      for (const [key, value] of Object.entries(item.metadata.M)) {
        if (value.S) {
          metadata[key] = value.S;
        }
      }
    }

    return new ProviderTransaction(
      item.providerId.S!,
      item.providerType.S as ProviderType,
      item.transactionId.S!,
      item.entityId.S!,
      item.entityType.S!,
      item.amount.S!,
      item.direction.S as ProviderDirection,
      {
        providerTransactionId: item.providerTransactionId.S!,
        status: item.status.S as ProviderTransactionStatus,
        currency: item.currency.S!,
        rawResponse: item.rawResponse?.S,
        metadata,
        completedAt: item.completedAt?.S,
        createdAt: item.createdAt.S!,
        updatedAt: item.updatedAt.S!
      }
    );
  }

  /**
   * Create a new provider transaction in the database
   */
  async create(): Promise<ProviderTransaction> {
    const client = getClient();

    try {
      await client.send(new PutItemCommand({
        TableName: process.env.TABLE_NAME!,
        Item: this.toItem(),
        ConditionExpression: "attribute_not_exists(PK) AND attribute_not_exists(SK)"
      }));

      return this;
    } catch (error) {
      console.error("Error creating provider transaction:", error);
      throw error;
    }
  }

  /**
   * Update a provider transaction in the database
   */
  async update(): Promise<ProviderTransaction> {
    const client = getClient();
    this.updatedAt = new Date().toISOString();

    try {
      await client.send(new PutItemCommand({
        TableName: process.env.TABLE_NAME!,
        Item: this.toItem()
      }));

      return this;
    } catch (error) {
      console.error("Error updating provider transaction:", error);
      throw error;
    }
  }

  /**
   * Mark a provider transaction as completed
   */
  async markCompleted(rawResponse?: string, metadata?: ProviderMetadata): Promise<ProviderTransaction> {
    this.status = "COMPLETED";
    this.completedAt = new Date().toISOString();
    
    if (rawResponse) {
      this.rawResponse = rawResponse;
    }
    
    if (metadata) {
      this.metadata = {
        ...this.metadata,
        ...metadata
      };
    }
    
    return this.update();
  }

  /**
   * Mark a provider transaction as failed
   */
  async markFailed(errorCode: string, errorMessage: string, rawResponse?: string): Promise<ProviderTransaction> {
    this.status = "FAILED";
    
    if (rawResponse) {
      this.rawResponse = rawResponse;
    }
    
    // Ensure metadata exists
    if (!this.metadata) {
      this.metadata = {};
    }
    
    this.metadata.errorCode = errorCode;
    this.metadata.errorMessage = errorMessage;
    
    return this.update();
  }

  /**
   * Mark a provider transaction as processing
   */
  async markProcessing(externalReference?: string, rawResponse?: string): Promise<ProviderTransaction> {
    this.status = "PROCESSING";
    
    if (rawResponse) {
      this.rawResponse = rawResponse;
    }
    
    if (externalReference) {
      if (!this.metadata) {
        this.metadata = {};
      }
      this.metadata.externalReference = externalReference;
    }
    
    return this.update();
  }

  /**
   * Get provider transaction by ID
   */
  static async getById(
    providerId: string, 
    providerTransactionId: string
  ): Promise<ProviderTransaction> {
    const client = getClient();
    
    try {
      const response = await client.send(new GetItemCommand({
        TableName: process.env.TABLE_NAME!,
        Key: {
          PK: { S: `PROVIDER#${providerId}` },
          SK: { S: `PTXN#${providerTransactionId}` }
        }
      }));

      if (!response.Item) {
        throw new Error(`Provider transaction ${providerTransactionId} not found for provider ${providerId}`);
      }

      return ProviderTransaction.fromItem(response.Item);
    } catch (error) {
      console.error("Error getting provider transaction by ID:", error);
      throw error;
    }
  }

  /**
   * Get provider transaction by transaction ID
   */
  static async getByTransactionId(transactionId: string): Promise<ProviderTransaction[]> {
    const client = getClient();
    
    try {
      const response = await client.send(new QueryCommand({
        TableName: process.env.TABLE_NAME!,
        IndexName: "GSI1",
        KeyConditionExpression: "GSI1PK = :gsi1pk",
        ExpressionAttributeValues: {
          ":gsi1pk": { S: `TXN#${transactionId}` }
        }
      }));

      return (response.Items || []).map(item => ProviderTransaction.fromItem(item));
    } catch (error) {
      console.error("Error getting provider transactions by transaction ID:", error);
      throw error;
    }
  }

  /**
   * List transactions for a provider
   */
  static async listByProvider(
    providerId: string,
    options: {
      status?: ProviderTransactionStatus;
      limit?: number;
      startKey?: Record<string, AttributeValue>;
      fromDate?: string;
      toDate?: string;
    } = {}
  ): Promise<{ 
    providerTransactions: ProviderTransaction[], 
    lastEvaluatedKey?: Record<string, AttributeValue> 
  }> {
    const client = getClient();
    const { status, limit = 50, startKey, fromDate, toDate } = options;
    
    try {
      let keyConditionExpression = "GSI2PK = :gsi2pk";
      const expressionAttributeValues: Record<string, AttributeValue> = {
        ":gsi2pk": { S: `PROVIDER#${providerId}` }
      };

      // Add date range condition if provided
      if (fromDate && toDate) {
        keyConditionExpression += " AND GSI2SK BETWEEN :fromDate AND :toDate";
        expressionAttributeValues[":fromDate"] = { S: `PTXN#${fromDate}` };
        expressionAttributeValues[":toDate"] = { S: `PTXN#${toDate}` };
      } else if (fromDate) {
        keyConditionExpression += " AND GSI2SK >= :fromDate";
        expressionAttributeValues[":fromDate"] = { S: `PTXN#${fromDate}` };
      } else if (toDate) {
        keyConditionExpression += " AND GSI2SK <= :toDate";
        expressionAttributeValues[":toDate"] = { S: `PTXN#${toDate}` };
      }

      // Add status filter if provided
      let filterExpression: string | undefined;
      if (status) {
        filterExpression = "status = :status";
        expressionAttributeValues[":status"] = { S: status };
      }

      const queryParams: any = {
        TableName: process.env.TABLE_NAME!,
        IndexName: "GSI2",
        KeyConditionExpression: keyConditionExpression,
        ExpressionAttributeValues: expressionAttributeValues,
        Limit: limit,
        ScanIndexForward: false // Most recent first
      };

      if (startKey) {
        queryParams.ExclusiveStartKey = startKey;
      }

      if (filterExpression) {
        queryParams.FilterExpression = filterExpression;
      }

      const response = await client.send(new QueryCommand(queryParams));

      return {
        providerTransactions: (response.Items || []).map(item => ProviderTransaction.fromItem(item)),
        lastEvaluatedKey: response.LastEvaluatedKey
      };
    } catch (error) {
      console.error(`Error listing transactions for provider ${providerId}:`, error);
      throw error;
    }
  }

  /**
   * Factory method to create a provider transaction for deposits
   */
  static createDepositTransaction(
    providerId: string,
    providerType: ProviderType,
    transactionId: string,
    entityId: string,
    entityType: string,
    amount: string,
    options: {
      metadata?: ProviderMetadata;
      currency?: string;
    } = {}
  ): ProviderTransaction {
    return new ProviderTransaction(
      providerId,
      providerType,
      transactionId,
      entityId,
      entityType,
      amount,
      "IN",
      {
        currency: options.currency || "USD",
        metadata: options.metadata
      }
    );
  }

  /**
   * Factory method to create a provider transaction for withdrawals
   */
  static createWithdrawalTransaction(
    providerId: string,
    providerType: ProviderType,
    transactionId: string,
    entityId: string,
    entityType: string,
    amount: string,
    options: {
      metadata?: ProviderMetadata;
      currency?: string;
    } = {}
  ): ProviderTransaction {
    return new ProviderTransaction(
      providerId,
      providerType,
      transactionId,
      entityId,
      entityType,
      amount,
      "OUT",
      {
        currency: options.currency || "USD",
        metadata: options.metadata
      }
    );
  }
}

// Convenience functions

/**
 * Create a new provider transaction for a deposit
 */
export const createProviderDepositTransaction = async (
  providerId: string,
  providerType: ProviderType,
  transactionId: string,
  entityId: string,
  entityType: string,
  amount: string,
  options?: Parameters<typeof ProviderTransaction.createDepositTransaction>[6]
): Promise<ProviderTransaction> => {
  const providerTxn = ProviderTransaction.createDepositTransaction(
    providerId, 
    providerType, 
    transactionId, 
    entityId, 
    entityType, 
    amount, 
    options
  );
  return providerTxn.create();
};

/**
 * Create a new provider transaction for a withdrawal
 */
export const createProviderWithdrawalTransaction = async (
  providerId: string,
  providerType: ProviderType,
  transactionId: string,
  entityId: string,
  entityType: string,
  amount: string,
  options?: Parameters<typeof ProviderTransaction.createWithdrawalTransaction>[6]
): Promise<ProviderTransaction> => {
  const providerTxn = ProviderTransaction.createWithdrawalTransaction(
    providerId, 
    providerType, 
    transactionId, 
    entityId, 
    entityType, 
    amount, 
    options
  );
  return providerTxn.create();
};

/**
 * Get a provider transaction by ID
 */
export const getProviderTransaction = async (
  providerId: string,
  providerTransactionId: string
): Promise<ProviderTransaction> => {
  return ProviderTransaction.getById(providerId, providerTransactionId);
};

/**
 * Get provider transactions by transaction ID
 */
export const getProviderTransactionsByTransactionId = async (
  transactionId: string
): Promise<ProviderTransaction[]> => {
  return ProviderTransaction.getByTransactionId(transactionId);
};
</file>

<file path="layers/commons/data/entities/provider.ts">
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'provider-service' });

/**
 * Supported payment provider types in the system
 */
export enum ProviderType {
    CARD_PROVIDER = 'CARD_PROVIDER',
    WITHDRAWAL_PROVIDER = 'WITHDRAWAL_PROVIDER',
    DEPOSIT_PROVIDER = 'DEPOSIT_PROVIDER',
    INTERNAL = 'INTERNAL',
}

/**
 * Available payment providers in the system
 */
export enum ProviderName {
    CHECKBOOK = 'CHECKBOOK',
    STRIPE = 'STRIPE',
    PAYPAL = 'PAYPAL',
    INTERNAL = 'INTERNAL',
}

/**
 * Configuration constants for providers
 */
export const PROVIDER_CONSTANTS = {
    WITHDRAWAL_FEE_PERCENTAGE: 1.5, // 1.5% fee for withdrawals
    DEPOSIT_FEE_PERCENTAGE: 0, // 0% fee for deposits (can be changed later)
    DEFAULT_CURRENCY: 'USD',
};

/**
 * Provider information interface for tracking providers and their capabilities
 */
export interface ProviderInfo {
    id: string;
    type: ProviderType;
    name: ProviderName;
    capabilities: string[];
    isActive: boolean;
    metadata?: Record<string, any>;
}

/**
 * Map of provider names to default provider types
 */
export const PROVIDER_TYPE_MAP: Record<ProviderName, ProviderType> = {
    [ProviderName.CHECKBOOK]: ProviderType.WITHDRAWAL_PROVIDER,
    [ProviderName.STRIPE]: ProviderType.CARD_PROVIDER,
    [ProviderName.PAYPAL]: ProviderType.WITHDRAWAL_PROVIDER,
    [ProviderName.INTERNAL]: ProviderType.INTERNAL,
};

/**
 * Provider configuration registry to manage available payment providers
 */
export class ProviderRegistry {
    private static providers: Map<string, ProviderInfo> = new Map();

    /**
     * Initialize the provider registry with default providers
     */
    static initialize(): void {
        // Register default providers
        this.registerProvider({
            id: ProviderName.CHECKBOOK,
            name: ProviderName.CHECKBOOK,
            type: ProviderType.WITHDRAWAL_PROVIDER,
            capabilities: ['withdrawal', 'deposit'],
            isActive: true,
            metadata: {
                description: 'Checkbook.io payment provider for digital checks',
                withdrawalFeePercentage: PROVIDER_CONSTANTS.WITHDRAWAL_FEE_PERCENTAGE,
            },
        });

        this.registerProvider({
            id: ProviderName.INTERNAL,
            name: ProviderName.INTERNAL,
            type: ProviderType.INTERNAL,
            capabilities: ['transfer'],
            isActive: true,
        });

        logger.info('Provider registry initialized', {
            providerCount: this.providers.size,
            providers: Array.from(this.providers.keys()),
        });
    }

    /**
     * Register a new provider
     * @param provider Provider information
     */
    static registerProvider(provider: ProviderInfo): void {
        this.providers.set(provider.id, provider);
        logger.info('Provider registered', {
            providerId: provider.id,
            providerName: provider.name,
            providerType: provider.type,
        });
    }

    /**
     * Get a provider by ID
     * @param providerId Provider ID
     * @returns Provider information or undefined if not found
     */
    static getProvider(providerId: string): ProviderInfo | undefined {
        return this.providers.get(providerId);
    }

    /**
     * Get a provider by name
     * @param providerName Provider name
     * @returns Provider information or undefined if not found
     */
    static getProviderByName(providerName: ProviderName): ProviderInfo | undefined {
        for (const provider of this.providers.values()) {
            if (provider.name === providerName) {
                return provider;
            }
        }
        return undefined;
    }

    /**
     * Check if a provider supports a specific capability
     * @param providerId Provider ID
     * @param capability Capability to check
     * @returns True if the provider supports the capability
     */
    static supportsCapability(providerId: string, capability: string): boolean {
        const provider = this.getProvider(providerId);
        if (!provider) {
            return false;
        }
        return provider.isActive && provider.capabilities.includes(capability);
    }

    /**
     * Get all providers
     * @returns Array of all registered providers
     */
    static getAllProviders(): ProviderInfo[] {
        return Array.from(this.providers.values());
    }

    /**
     * Get providers by type
     * @param type Provider type
     * @returns Array of providers of the specified type
     */
    static getProvidersByType(type: ProviderType): ProviderInfo[] {
        return Array.from(this.providers.values()).filter((provider) => provider.type === type);
    }
}

// Initialize the provider registry when this module is imported
ProviderRegistry.initialize();
</file>

<file path="layers/commons/data/entities/revenue.ts">
import { AttributeValue, GetItemCommand, QueryCommand, TransactWriteItemsCommand } from '@aws-sdk/client-dynamodb';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from '@aws-lambda-powertools/logger';
import { getClient } from '../client';
import { Money } from './money';
import { EntityTypeString as EntityType } from './entity';
import { ProviderName, ProviderType } from './provider';

const logger = new Logger({ serviceName: 'revenue-service' });
const TABLE_NAME = process.env.TABLE_NAME || 'clkk-app-table-dev';

/**
 * Type of revenue collected
 */
export enum RevenueType {
    WITHDRAWAL_FEE = 'withdrawal_fee',
    DEPOSIT_FEE = 'deposit_fee',
    TRANSFER_FEE = 'transfer_fee',
    SUBSCRIPTION_FEE = 'subscription_fee',
    OTHER = 'other',
}

/**
 * Revenue class for tracking fees collected from transactions
 */
export class Revenue {
    revenueId: string;

    // Source of revenue
    sourceTransactionId?: string;
    sourceEntityId?: string;
    sourceEntityType?: EntityType;

    // Revenue details
    type: RevenueType;
    amount: Money;
    currency: string;
    description?: string;

    // Provider information
    providerName?: ProviderName;
    providerType?: ProviderType;
    providerTransactionId?: string;

    // Metadata
    metadata?: Record<string, any>;
    createdAt: string;
    updatedAt: string;

    /**
     * Create a new Revenue instance
     * @param type Type of revenue
     * @param amount Revenue amount
     * @param currency Currency code
     * @param options Additional options
     */
    constructor(
        type: RevenueType,
        amount: string | number | Money,
        currency = 'USD',
        options: {
            revenueId?: string;
            sourceTransactionId?: string;
            sourceEntityId?: string;
            sourceEntityType?: EntityType;
            description?: string;
            providerName?: ProviderName;
            providerType?: ProviderType;
            providerTransactionId?: string;
            metadata?: Record<string, any>;
            createdAt?: string;
            updatedAt?: string;
        } = {},
    ) {
        this.revenueId = options.revenueId || uuidv4();
        this.type = type;
        this.amount = amount instanceof Money ? amount : new Money(amount, currency);
        this.currency = this.amount.currency;

        // Source information
        this.sourceTransactionId = options.sourceTransactionId;
        this.sourceEntityId = options.sourceEntityId;
        this.sourceEntityType = options.sourceEntityType;

        // Additional details
        this.description = options.description;
        this.providerName = options.providerName;
        this.providerType = options.providerType;
        this.providerTransactionId = options.providerTransactionId;
        this.metadata = options.metadata;

        // Timestamps
        const now = new Date().toISOString();
        this.createdAt = options.createdAt || now;
        this.updatedAt = options.updatedAt || now;
    }

    /**
     * Primary key for main revenue record
     */
    get pk(): string {
        return `REVENUE#${this.revenueId}`;
    }

    /**
     * Sort key for main revenue record
     */
    get sk(): string {
        return 'DETAILS';
    }

    /**
     * Returns a sortable string representation of the creation timestamp
     * Format is YYYY-MM-DD-HH-MM-SS-SSS for chronological sorting
     */
    get dateString(): string {
        // Parse the ISO string into sortable components
        const date = new Date(this.createdAt);

        // Format as YYYY-MM-DD-HH-MM-SS-MMM
        return [
            date.getUTCFullYear().toString().padStart(4, '0'),
            (date.getUTCMonth() + 1).toString().padStart(2, '0'),
            date.getUTCDate().toString().padStart(2, '0'),
            date.getUTCHours().toString().padStart(2, '0'),
            date.getUTCMinutes().toString().padStart(2, '0'),
            date.getUTCSeconds().toString().padStart(2, '0'),
            date.getUTCMilliseconds().toString().padStart(3, '0'),
        ].join('-');
    }

    /**
     * Convert revenue to DynamoDB item format
     */
    toItem(): Record<string, AttributeValue> {
        return {
            PK: { S: this.pk },
            SK: { S: this.sk },

            // Revenue type and time indexes
            RevenueTypeKey: { S: `REVENUE_TYPE#${this.type}` },
            TimeSortKey: { S: `DATE#${this.dateString}#REVENUE#${this.revenueId}` },

            // Transaction reference if applicable
            ...(this.sourceTransactionId && {
                SourceTransactionKey: { S: `TRANSACTION#${this.sourceTransactionId}` },
            }),

            // Source entity reference if applicable
            ...(this.sourceEntityId &&
                this.sourceEntityType && {
                    SourceEntityKey: { S: `${this.sourceEntityType}#${this.sourceEntityId}` },
                    EntitySortKey: { S: `REVENUE#${this.revenueId}` },
                }),

            // Provider reference if applicable
            ...(this.providerName && {
                ProviderKey: { S: `PROVIDER#${this.providerName}` },
                ProviderSortKey: { S: `DATE#${this.dateString}#REVENUE#${this.revenueId}` },
            }),

            // Core attributes
            revenueId: { S: this.revenueId },
            type: { S: this.type },
            amount: { S: this.amount.toString() },
            currency: { S: this.currency },

            // Source attributes
            ...(this.sourceTransactionId && { sourceTransactionId: { S: this.sourceTransactionId } }),
            ...(this.sourceEntityId && { sourceEntityId: { S: this.sourceEntityId } }),
            ...(this.sourceEntityType && { sourceEntityType: { S: this.sourceEntityType } }),

            // Additional attributes
            ...(this.description && { description: { S: this.description } }),
            ...(this.providerName && { providerName: { S: this.providerName } }),
            ...(this.providerType && { providerType: { S: this.providerType } }),
            ...(this.providerTransactionId && { providerTransactionId: { S: this.providerTransactionId } }),

            // Metadata
            ...(this.metadata && { metadata: { M: this.marshallMetadata(this.metadata) } }),

            // Timestamps
            createdAt: { S: this.createdAt },
            updatedAt: { S: this.updatedAt },
        };
    }

    /**
     * Create source transaction reference item
     */
    toTransactionReferenceItem(): Record<string, AttributeValue> | null {
        if (!this.sourceTransactionId) return null;

        return {
            PK: { S: `TRANSACTION#${this.sourceTransactionId}` },
            SK: { S: `REVENUE#${this.revenueId}` },

            // Core attributes
            revenueId: { S: this.revenueId },
            type: { S: this.type },
            amount: { S: this.amount.toString() },
            currency: { S: this.currency },
            createdAt: { S: this.createdAt },
        };
    }

    /**
     * Helper method to marshall metadata to DynamoDB format
     */
    private marshallMetadata(metadata: Record<string, any>): Record<string, AttributeValue> {
        const result: Record<string, AttributeValue> = {};
        for (const [key, value] of Object.entries(metadata)) {
            if (value !== undefined && value !== null) {
                if (typeof value === 'number') {
                    result[key] = { N: value.toString() };
                } else if (typeof value === 'boolean') {
                    result[key] = { BOOL: value };
                } else if (typeof value === 'object') {
                    result[key] = { S: JSON.stringify(value) };
                } else {
                    result[key] = { S: String(value) };
                }
            }
        }
        return result;
    }

    /**
     * Create a Revenue object from a DynamoDB item
     */
    static fromItem(item?: Record<string, AttributeValue>): Revenue {
        if (!item) throw new Error('No revenue item found!');

        // Extract metadata if present
        const metadata: Record<string, any> = {};
        if (item.metadata && item.metadata.M) {
            for (const [key, value] of Object.entries(item.metadata.M)) {
                if (value.S) {
                    metadata[key] = value.S;
                } else if (value.N) {
                    metadata[key] = parseFloat(value.N);
                } else if (value.BOOL !== undefined) {
                    metadata[key] = value.BOOL;
                }
            }
        }

        return new Revenue(item.type.S as RevenueType, item.amount.S || '0', item.currency.S, {
            revenueId: item.revenueId.S,
            sourceTransactionId: item.sourceTransactionId?.S,
            sourceEntityId: item.sourceEntityId?.S,
            sourceEntityType: item.sourceEntityType?.S as EntityType,
            description: item.description?.S,
            providerName: item.providerName?.S as ProviderName,
            providerType: item.providerType?.S as ProviderType,
            providerTransactionId: item.providerTransactionId?.S,
            metadata: Object.keys(metadata).length > 0 ? metadata : undefined,
            createdAt: item.createdAt.S,
            updatedAt: item.updatedAt.S,
        });
    }

    /**
     * Create a new revenue record
     */
    async create(): Promise<Revenue> {
        const client = getClient();

        // Create transaction items for atomic write
        const transactItems = [
            {
                Put: {
                    TableName: TABLE_NAME,
                    Item: this.toItem(),
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                },
            },
        ];

        // Add transaction reference if applicable
        const transactionItem = this.toTransactionReferenceItem();
        if (transactionItem) {
            transactItems.push({
                Put: {
                    TableName: TABLE_NAME,
                    Item: transactionItem,
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                },
            });
        }

        try {
            await client.send(
                new TransactWriteItemsCommand({
                    TransactItems: transactItems,
                }),
            );

            logger.info('Created revenue record', {
                revenueId: this.revenueId,
                type: this.type,
                amount: this.amount.toString(),
                sourceTransactionId: this.sourceTransactionId,
            });

            return this;
        } catch (error) {
            logger.error('Error creating revenue record:', {
                error,
                revenueId: this.revenueId,
                sourceTransactionId: this.sourceTransactionId,
            });
            throw error;
        }
    }

    /**
     * Get a revenue record by ID
     */
    static async getById(revenueId: string): Promise<Revenue | null> {
        const client = getClient();

        try {
            const response = await client.send(
                new GetItemCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: { S: `REVENUE#${revenueId}` },
                        SK: { S: 'DETAILS' },
                    },
                }),
            );

            if (!response.Item) {
                return null;
            }

            return Revenue.fromItem(response.Item);
        } catch (error) {
            logger.error('Error getting revenue by ID:', { error, revenueId });
            throw error;
        }
    }

    /**
     * Get revenue records by source transaction ID
     */
    static async getByTransactionId(transactionId: string): Promise<Revenue[]> {
        const client = getClient();

        try {
            const response = await client.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk_prefix)',
                    ExpressionAttributeValues: {
                        ':pk': { S: `TRANSACTION#${transactionId}` },
                        ':sk_prefix': { S: 'REVENUE#' },
                    },
                }),
            );

            if (!response.Items || response.Items.length === 0) {
                return [];
            }

            // For each revenue reference, get the full revenue details
            const revenueIds = response.Items.map((item) => {
                // Extract the revenue ID from the SK
                const match = item.SK.S?.match(/REVENUE#(.+)$/);
                return match ? match[1] : null;
            }).filter(Boolean) as string[];

            const revenues: Revenue[] = [];
            for (const id of revenueIds) {
                const revenue = await Revenue.getById(id);
                if (revenue) {
                    revenues.push(revenue);
                }
            }

            return revenues;
        } catch (error) {
            logger.error('Error getting revenue by transaction ID:', { error, transactionId });
            throw error;
        }
    }

    /**
     * Get all revenue records of a specific type
     */
    static async getByType(
        type: RevenueType,
        options: {
            limit?: number;
            startKey?: Record<string, AttributeValue>;
            startDate?: string;
            endDate?: string;
        } = {},
    ): Promise<{ revenues: Revenue[]; lastEvaluatedKey?: Record<string, AttributeValue> }> {
        const client = getClient();
        const { limit = 50, startKey, startDate, endDate } = options;

        try {
            let keyConditionExpression = 'RevenueTypeKey = :typeKey';
            const expressionAttributeValues: Record<string, AttributeValue> = {
                ':typeKey': { S: `REVENUE_TYPE#${type}` },
            };

            // Add date range condition if specified
            if (startDate && endDate) {
                keyConditionExpression += ' AND TimeSortKey BETWEEN :startDate AND :endDate';
                expressionAttributeValues[':startDate'] = { S: `DATE#${startDate}` };
                expressionAttributeValues[':endDate'] = { S: `DATE#${endDate}#REVENUE#zzzzzzzzzzzzzzzz` };
            }

            const queryParams = {
                TableName: TABLE_NAME,
                IndexName: 'RevenueTypeIndex',
                KeyConditionExpression: keyConditionExpression,
                ExpressionAttributeValues: expressionAttributeValues,
                ScanIndexForward: false, // Most recent first
                Limit: limit,
                ...(startKey && { ExclusiveStartKey: startKey }),
            };

            const response = await client.send(new QueryCommand(queryParams));

            if (!response.Items || response.Items.length === 0) {
                return { revenues: [] };
            }

            const revenues = response.Items.map((item) => Revenue.fromItem(item));

            return {
                revenues,
                lastEvaluatedKey: response.LastEvaluatedKey,
            };
        } catch (error) {
            logger.error('Error getting revenue by type:', { error, type });
            throw error;
        }
    }

    /**
     * Calculate total revenue in a date range
     */
    static async calculateTotal(
        options: {
            type?: RevenueType;
            startDate?: string;
            endDate?: string;
            currency?: string;
        } = {},
    ): Promise<Money> {
        const { type, startDate, endDate, currency = 'USD' } = options;

        // Initialize with zero amount
        let totalRevenue = new Money(0, currency);
        let lastEvaluatedKey: Record<string, AttributeValue> | undefined;

        try {
            do {
                // Get a batch of revenue records
                const result = await Revenue.getByType(type || RevenueType.WITHDRAWAL_FEE, {
                    limit: 100, // Process in larger batches for efficiency
                    startKey: lastEvaluatedKey,
                    startDate,
                    endDate,
                });

                // Sum up the amounts
                for (const revenue of result.revenues) {
                    if (revenue.currency === currency) {
                        totalRevenue = totalRevenue.add(revenue.amount);
                    }
                }

                lastEvaluatedKey = result.lastEvaluatedKey;
            } while (lastEvaluatedKey);

            return totalRevenue;
        } catch (error) {
            logger.error('Error calculating total revenue:', { error, type, startDate, endDate });
            throw error;
        }
    }
}

/**
 * Convenience function to create a new revenue record
 */
export const createRevenue = async (
    type: RevenueType,
    amount: string | number | Money,
    options: {
        sourceTransactionId?: string;
        sourceEntityId?: string;
        sourceEntityType?: EntityType;
        description?: string;
        providerName?: ProviderName;
        providerType?: ProviderType;
        currency?: string;
    } = {},
): Promise<Revenue> => {
    const revenue = new Revenue(type, amount, options.currency || 'USD', {
        sourceTransactionId: options.sourceTransactionId,
        sourceEntityId: options.sourceEntityId,
        sourceEntityType: options.sourceEntityType,
        description: options.description,
        providerName: options.providerName,
        providerType: options.providerType,
    });

    return revenue.create();
};

/**
 * Calculate and record fees for a transaction
 * @param transactionId Transaction ID
 * @param amount Transaction amount
 * @param entityId Entity ID (source of fees)
 * @param entityType Entity type
 * @param options Additional options
 * @returns The fee amount and revenue record
 */
export const calculateAndRecordFee = async (
    transactionId: string,
    amount: string | number | Money,
    entityId: string,
    entityType: EntityType,
    options: {
        type: RevenueType;
        feePercentage?: number;
        providerName?: ProviderName;
        providerType?: ProviderType;
        providerTransactionId?: string;
        description?: string;
        currency?: string;
    },
): Promise<{ fee: Money; revenue: Revenue }> => {
    // Default to withdrawal fee if not specified
    const {
        type = RevenueType.WITHDRAWAL_FEE,
        feePercentage,
        providerName,
        providerType,
        providerTransactionId,
        description,
        currency = 'USD',
    } = options;

    // Convert amount to Money object if it's not already
    const amountMoney = amount instanceof Money ? amount : new Money(amount, currency);

    // Use specified percentage or default based on type
    let actualFeePercentage = feePercentage;
    if (actualFeePercentage === undefined) {
        switch (type) {
            case RevenueType.WITHDRAWAL_FEE:
                actualFeePercentage = 1.5; // Default withdrawal fee
                break;
            case RevenueType.DEPOSIT_FEE:
                actualFeePercentage = 0; // No fee for deposits by default
                break;
            case RevenueType.TRANSFER_FEE:
                actualFeePercentage = 0; // No fee for transfers by default
                break;
            default:
                actualFeePercentage = 0;
        }
    }

    // Calculate fee amount
    const feeAmount = amountMoney.percentage(actualFeePercentage);

    // Create description based on fee type if not provided
    let feeDescription = description;
    if (!feeDescription) {
        switch (type) {
            case RevenueType.WITHDRAWAL_FEE:
                feeDescription = `${actualFeePercentage}% withdrawal fee`;
                break;
            case RevenueType.DEPOSIT_FEE:
                feeDescription = `${actualFeePercentage}% deposit fee`;
                break;
            case RevenueType.TRANSFER_FEE:
                feeDescription = `${actualFeePercentage}% transfer fee`;
                break;
            default:
                feeDescription = `${actualFeePercentage}% service fee`;
        }
    }

    // Record fee as revenue
    const revenue = await createRevenue(type, feeAmount, {
        sourceTransactionId: transactionId,
        sourceEntityId: entityId,
        sourceEntityType: entityType,
        description: feeDescription,
        providerName,
        providerType,
        currency,
    });

    return { fee: feeAmount, revenue };
};
</file>

<file path="layers/commons/data/entities/transaction.test.ts">
import { Transaction } from './transaction';
import { Money } from './money';

// Mock the AWS SDK client
jest.mock('../client', () => ({
    getClient: jest.fn().mockReturnValue({
        send: jest.fn(),
    }),
}));

// Import mocked module
import { getClient } from '../client';
const mockedGetClient = getClient as jest.MockedFunction<typeof getClient>;
const mockedSend = mockedGetClient().send as jest.MockedFunction<any>;

describe('Transaction', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    // Constructor tests
    describe('constructor', () => {
        it('should create a new Transaction instance with default values', () => {
            const transaction = new Transaction('DEPOSIT', '100.00', 'USD', 'PENDING', {
                receiver: {
                    id: 'user123',
                    type: 'USER',
                    name: 'John Doe',
                },
            });

            expect(transaction.type).toBe('DEPOSIT');
            expect(transaction.amount).toBe('100.00');
            expect(transaction.currency).toBe('USD');
            expect(transaction.status).toBe('PENDING');
            expect(transaction.receiverId).toBe('user123');
            expect(transaction.receiverType).toBe('USER');
            expect(transaction.receiverName).toBe('John Doe');
            expect(transaction.transactionId).toMatch(/^[0-9a-f-]+$/);
            expect(transaction.createdAt).toBeDefined();
            expect(transaction.updatedAt).toBeDefined();
        });

        it('should create a Transaction instance with custom options', () => {
            const customTransactionId = 'txn_123';
            const customCreatedAt = '2023-01-01T00:00:00Z';
            const customUpdatedAt = '2023-01-02T00:00:00Z';

            const transaction = new Transaction('TRANSFER_OUT', '50.00', 'EUR', 'COMPLETED', {
                transactionId: customTransactionId,
                sender: {
                    id: 'user123',
                    type: 'USER',
                    name: 'John Doe',
                },
                receiver: {
                    id: 'user456',
                    type: 'USER',
                    name: 'Jane Smith',
                },
                balanceBefore: '100.00',
                balanceAfter: '50.00',
                providerType: 'INTERNAL',
                metadata: {
                    description: 'Test transfer',
                    category: 'Transfer',
                },
                completedAt: '2023-01-02T00:00:00Z',
                createdAt: customCreatedAt,
                updatedAt: customUpdatedAt,
            });

            expect(transaction.transactionId).toBe(customTransactionId);
            expect(transaction.type).toBe('TRANSFER_OUT');
            expect(transaction.amount).toBe('50.00');
            expect(transaction.currency).toBe('EUR');
            expect(transaction.status).toBe('COMPLETED');
            expect(transaction.senderId).toBe('user123');
            expect(transaction.senderType).toBe('USER');
            expect(transaction.senderName).toBe('John Doe');
            expect(transaction.receiverId).toBe('user456');
            expect(transaction.receiverType).toBe('USER');
            expect(transaction.receiverName).toBe('Jane Smith');
            expect(transaction.balanceBefore).toBe('100.00');
            expect(transaction.balanceAfter).toBe('50.00');
            expect(transaction.providerType).toBe('INTERNAL');
            expect(transaction.metadata).toEqual({
                description: 'Test transfer',
                category: 'Transfer',
            });
            expect(transaction.completedAt).toBe('2023-01-02T00:00:00Z');
            expect(transaction.createdAt).toBe(customCreatedAt);
            expect(transaction.updatedAt).toBe(customUpdatedAt);
        });
    });

    // Getter tests
    describe('getters', () => {
        it('should return the correct primaryEntityId and primaryEntityType', () => {
            // For deposit, the primary entity is the receiver
            const depositTxn = new Transaction('DEPOSIT', '100.00', 'USD', 'PENDING', {
                receiver: {
                    id: 'user123',
                    type: 'USER',
                },
            });

            expect(depositTxn.primaryEntityId).toBe('user123');
            expect(depositTxn.primaryEntityType).toBe('USER');

            // For withdrawal, the primary entity is the sender
            const withdrawalTxn = new Transaction('WITHDRAWAL', '100.00', 'USD', 'PENDING', {
                sender: {
                    id: 'user123',
                    type: 'USER',
                },
            });

            expect(withdrawalTxn.primaryEntityId).toBe('user123');
            expect(withdrawalTxn.primaryEntityType).toBe('USER');

            // For transfer_out, the primary entity is the sender
            const transferOutTxn = new Transaction('TRANSFER_OUT', '100.00', 'USD', 'PENDING', {
                sender: {
                    id: 'user123',
                    type: 'USER',
                },
                receiver: {
                    id: 'user456',
                    type: 'USER',
                },
            });

            expect(transferOutTxn.primaryEntityId).toBe('user123');
            expect(transferOutTxn.primaryEntityType).toBe('USER');

            // For transfer_in, the primary entity is the receiver
            const transferInTxn = new Transaction('TRANSFER_IN', '100.00', 'USD', 'PENDING', {
                sender: {
                    id: 'user123',
                    type: 'USER',
                },
                receiver: {
                    id: 'user456',
                    type: 'USER',
                },
            });

            expect(transferInTxn.primaryEntityId).toBe('user456');
            expect(transferInTxn.primaryEntityType).toBe('USER');
        });

        it('should return the correct PK and SK values', () => {
            const transaction = new Transaction('DEPOSIT', '100.00', 'USD', 'PENDING', {
                transactionId: 'txn_123',
                receiver: {
                    id: 'user123',
                    type: 'USER',
                },
            });

            expect(transaction.pk).toBe('USER#user123');
            expect(transaction.sk).toBe('TXN#txn_123');
        });
    });

    // Entity-specific operation tests
    describe('entity-specific operations', () => {
        it('should check if a transaction involves an entity', () => {
            const transaction = new Transaction('TRANSFER_OUT', '100.00', 'USD', 'PENDING', {
                sender: {
                    id: 'user123',
                    type: 'USER',
                },
                receiver: {
                    id: 'user456',
                    type: 'USER',
                },
            });

            expect(transaction.involvesEntity('user123', 'USER')).toBe(true);
            expect(transaction.involvesEntity('user456', 'USER')).toBe(true);
            expect(transaction.involvesEntity('user789', 'USER')).toBe(false);
        });

        it('should check if an entity is the sender or receiver', () => {
            const transaction = new Transaction('TRANSFER_OUT', '100.00', 'USD', 'PENDING', {
                sender: {
                    id: 'user123',
                    type: 'USER',
                },
                receiver: {
                    id: 'user456',
                    type: 'USER',
                },
            });

            expect(transaction.isEntitySender('user123', 'USER')).toBe(true);
            expect(transaction.isEntitySender('user456', 'USER')).toBe(false);

            expect(transaction.isEntityReceiver('user456', 'USER')).toBe(true);
            expect(transaction.isEntityReceiver('user123', 'USER')).toBe(false);
        });

        it('should get the counterparty for an entity', () => {
            const transaction = new Transaction('TRANSFER_OUT', '100.00', 'USD', 'PENDING', {
                sender: {
                    id: 'user123',
                    type: 'USER',
                    name: 'John Doe',
                },
                receiver: {
                    id: 'user456',
                    type: 'USER',
                    name: 'Jane Smith',
                },
            });

            const counterpartyForSender = transaction.getCounterparty('user123', 'USER');
            expect(counterpartyForSender).toEqual({
                id: 'user456',
                type: 'USER',
                name: 'Jane Smith',
            });

            const counterpartyForReceiver = transaction.getCounterparty('user456', 'USER');
            expect(counterpartyForReceiver).toEqual({
                id: 'user123',
                type: 'USER',
                name: 'John Doe',
            });

            const counterpartyForNonEntity = transaction.getCounterparty('user789', 'USER');
            expect(counterpartyForNonEntity).toBeNull();
        });
    });

    // DynamoDB conversion tests
    describe('toItem and fromItem', () => {
        it('should convert transaction to DynamoDB item', () => {
            const transaction = new Transaction('DEPOSIT', '100.00', 'USD', 'PENDING', {
                transactionId: 'txn_123',
                receiver: {
                    id: 'user123',
                    type: 'USER',
                    name: 'John Doe',
                },
                createdAt: '2023-01-01T00:00:00Z',
                updatedAt: '2023-01-01T00:00:00Z',
            });

            const item = transaction.toItem();

            expect(item.PK.S).toBe('USER#user123');
            expect(item.SK.S).toBe('TXN#txn_123');
            expect(item.GSI1PK.S).toBe('TXN#txn_123');
            expect(item.GSI1SK.S).toBe('USER#user123');
            expect(item.GSI2PK.S).toBe('USER#user123');
            expect(item.GSI2SK.S).toBe('TXN#2023-01-01T00:00:00Z');
            expect(item.transactionId.S).toBe('txn_123');
            expect(item.type.S).toBe('DEPOSIT');
            expect(item.status.S).toBe('PENDING');
            expect(item.amount.S).toBe('100.00');
            expect(item.currency.S).toBe('USD');
            expect(item.receiverId.S).toBe('user123');
            expect(item.receiverType.S).toBe('USER');
            expect(item.receiverName.S).toBe('John Doe');
            expect(item.createdAt.S).toBe('2023-01-01T00:00:00Z');
            expect(item.updatedAt.S).toBe('2023-01-01T00:00:00Z');
        });

        it('should convert DynamoDB item to transaction', () => {
            const item = {
                PK: { S: 'USER#user123' },
                SK: { S: 'TXN#txn_123' },
                GSI1PK: { S: 'TXN#txn_123' },
                GSI1SK: { S: 'USER#user123' },
                GSI2PK: { S: 'USER#user123' },
                GSI2SK: { S: 'TXN#2023-01-01T00:00:00Z' },
                transactionId: { S: 'txn_123' },
                type: { S: 'DEPOSIT' },
                status: { S: 'PENDING' },
                amount: { S: '100.00' },
                currency: { S: 'USD' },
                receiverId: { S: 'user123' },
                receiverType: { S: 'USER' },
                receiverName: { S: 'John Doe' },
                createdAt: { S: '2023-01-01T00:00:00Z' },
                updatedAt: { S: '2023-01-01T00:00:00Z' },
                metadata: {
                    M: {
                        description: { S: 'Test deposit' },
                        category: { S: 'Deposit' },
                    },
                },
            };

            const transaction = Transaction.fromItem(item);

            expect(transaction.transactionId).toBe('txn_123');
            expect(transaction.type).toBe('DEPOSIT');
            expect(transaction.status).toBe('PENDING');
            expect(transaction.amount).toBe('100.00');
            expect(transaction.currency).toBe('USD');
            expect(transaction.receiverId).toBe('user123');
            expect(transaction.receiverType).toBe('USER');
            expect(transaction.receiverName).toBe('John Doe');
            expect(transaction.metadata).toEqual({
                description: 'Test deposit',
                category: 'Deposit',
            });
            expect(transaction.createdAt).toBe('2023-01-01T00:00:00Z');
            expect(transaction.updatedAt).toBe('2023-01-01T00:00:00Z');
        });

        it('should throw error when item is undefined', () => {
            expect(() => Transaction.fromItem(undefined)).toThrow('No transaction item found!');
        });
    });

    // Database operation tests
    describe('database operations', () => {
        // Mock dates for consistent testing
        const mockDate = new Date('2023-01-01T00:00:00Z');
        let originalDate: DateConstructor;

        beforeEach(() => {
            originalDate = global.Date;
            global.Date = class extends Date {
                constructor() {
                    super();
                    return mockDate;
                }
                static now() {
                    return mockDate.getTime();
                }
            } as DateConstructor;

            // Set up environment variables
            process.env.TABLE_NAME = 'TestTable';
        });

        afterEach(() => {
            global.Date = originalDate;
            delete process.env.TABLE_NAME;
        });

        it('should create a transaction in the database', async () => {
            const transaction = new Transaction('DEPOSIT', '100.00', 'USD', 'PENDING', {
                receiver: {
                    id: 'user123',
                    type: 'USER',
                },
            });

            mockedSend.mockResolvedValueOnce({});

            await transaction.create();

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Item: transaction.toItem(),
                        ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                    }),
                }),
            );
        });

        it('should update a transaction', async () => {
            const transaction = new Transaction('DEPOSIT', '100.00', 'USD', 'PENDING', {
                transactionId: 'txn_123',
                receiver: {
                    id: 'user123',
                    type: 'USER',
                },
            });

            mockedSend.mockResolvedValueOnce({});

            // Update the status
            transaction.status = 'COMPLETED';

            await transaction.update();

            // Should have updated the updatedAt timestamp
            expect(transaction.updatedAt).toBe(mockDate.toISOString());

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Item: transaction.toItem(),
                    }),
                }),
            );
        });

        it('should complete a transaction', async () => {
            const transaction = new Transaction('DEPOSIT', '100.00', 'USD', 'PENDING', {
                transactionId: 'txn_123',
                receiver: {
                    id: 'user123',
                    type: 'USER',
                },
            });

            mockedSend.mockResolvedValueOnce({});

            await transaction.complete('150.00');

            expect(transaction.status).toBe('COMPLETED');
            expect(transaction.balanceAfter).toBe('150.00');
            expect(transaction.completedAt).toBe(mockDate.toISOString());

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should fail a transaction', async () => {
            const transaction = new Transaction('DEPOSIT', '100.00', 'USD', 'PENDING', {
                transactionId: 'txn_123',
                receiver: {
                    id: 'user123',
                    type: 'USER',
                },
            });

            mockedSend.mockResolvedValueOnce({});

            await transaction.fail('Insufficient funds');

            expect(transaction.status).toBe('FAILED');
            expect(transaction.metadata).toEqual({
                failureReason: 'Insufficient funds',
            });

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should retrieve a transaction by ID', async () => {
            const mockItem = {
                transactionId: { S: 'txn_123' },
                type: { S: 'DEPOSIT' },
                status: { S: 'COMPLETED' },
                amount: { S: '100.00' },
                currency: { S: 'USD' },
                receiverId: { S: 'user123' },
                receiverType: { S: 'USER' },
                createdAt: { S: '2023-01-01T00:00:00Z' },
                updatedAt: { S: '2023-01-02T00:00:00Z' },
            };

            mockedSend.mockResolvedValueOnce({
                Item: mockItem,
            });

            const transaction = await Transaction.getById('user123', 'USER', 'txn_123');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Key: {
                            PK: { S: 'USER#user123' },
                            SK: { S: 'TXN#txn_123' },
                        },
                    }),
                }),
            );

            expect(transaction.transactionId).toBe('txn_123');
            expect(transaction.type).toBe('DEPOSIT');
            expect(transaction.status).toBe('COMPLETED');
        });
    });
});
</file>

<file path="layers/commons/data/entities/transaction.ts">
import {
    AttributeValue,
    DynamoDB,
    GetItemCommand,
    QueryCommand,
    TransactWriteItemsCommand,
} from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from '@aws-lambda-powertools/logger';
import { getClient } from '../client';
import { Money } from './money';
import { CurrencyCode, WalletService } from './wallet';
import { ProviderType } from './provider';
import { EntityTypeString as EntityType } from './entity';
const logger = new Logger({ serviceName: 'transaction-service' });
const dynamoDb = DynamoDBDocument.from(new DynamoDB());
const TABLE_NAME = process.env.TABLE_NAME || 'clkk-app-table-dev';

export enum TransactionType {
    DEPOSIT = 'deposit',
    WITHDRAWAL = 'withdrawal',
    P2P = 'p2p_transfer',
    P2B = 'p2b_transfer',
    TRADE = 'trade',
}

export enum TransactionStatus {
    PENDING = 'pending',
    COMPLETED = 'completed',
    FAILED = 'failed',
    CANCELLED = 'cancelled',
    REVERSED = 'reversed',
}

export interface TransactionMetadata {
    description?: string;
    counterpartyId?: string;
    counterpartyName?: string;
    category?: string;
    counterTransactionId?: string;
    [key: string]: any;
}

export interface EntityReference {
    id: string;
    type: EntityType;
    name?: string;
}

/**
 * Transaction class for handling financial transactions in the single-table design
 * This class follows DynamoDB single-table design principles with appropriate
 * keys for efficient access patterns
 */
export class Transaction {
    transactionId: string;

    // Sender and receiver information
    senderId?: string;
    senderType?: EntityType;
    senderName?: string;
    // Backward compatibility fields
    senderEntityId?: string;

    receiverId?: string;
    receiverType?: EntityType;
    receiverName?: string;
    // Backward compatibility fields
    recipientEntityId?: string;

    // Core transaction data
    type: TransactionType;
    status: TransactionStatus;
    amount: Money;
    currency: string;
    balanceBefore?: string;
    balanceAfter?: string;

    // External provider information
    providerType?: ProviderType;
    providerId?: string;
    providerName?: string;
    providerTransactionId?: string;
    providerReference?: string;

    // Additional fields
    metadata?: TransactionMetadata;
    createdAt: string;
    updatedAt: string;
    completedAt?: string;

    constructor(
        type: TransactionType,
        amount: string | number | Money,
        currency = 'USD',
        status: TransactionStatus = TransactionStatus.PENDING,
        options: {
            transactionId?: string;
            sender?: EntityReference;
            receiver?: EntityReference;
            balanceBefore?: string;
            balanceAfter?: string;
            providerType?: ProviderType;
            providerId?: string;
            providerTransactionId?: string;
            providerReference?: string;
            metadata?: TransactionMetadata;
            completedAt?: string;
            createdAt?: string;
            updatedAt?: string;
        } = {},
    ) {
        this.transactionId = options.transactionId || uuidv4();

        // Set sender information if provided
        if (options.sender) {
            this.senderId = options.sender.id;
            this.senderType = options.sender.type;
            this.senderName = options.sender.name;
            // Set compatibility field
            this.senderEntityId = options.sender.id;
        }

        // Set receiver information if provided
        if (options.receiver) {
            this.receiverId = options.receiver.id;
            this.receiverType = options.receiver.type;
            this.receiverName = options.receiver.name;
            // Set compatibility field
            this.recipientEntityId = options.receiver.id;
        }

        this.type = type;
        this.status = status;
        this.amount = amount instanceof Money ? amount : new Money(amount, currency);
        this.currency = this.amount.currency;
        this.balanceBefore = options.balanceBefore;
        this.balanceAfter = options.balanceAfter;
        this.providerType = options.providerType;
        this.providerId = options.providerId;
        this.providerTransactionId = options.providerTransactionId;
        this.providerReference = options.providerReference;
        this.metadata = options.metadata;
        this.completedAt = options.completedAt;

        const now = new Date().toISOString();
        this.createdAt = options.createdAt || now;
        this.updatedAt = options.updatedAt || now;
    }

    /**
     * Primary key for main transaction record
     */
    get pk(): string {
        return `TRANSACTION#${this.transactionId}`;
    }

    /**
     * Sort key for main transaction record
     */
    get sk(): string {
        return 'DETAILS';
    }

    /**
     * Get date string from timestamp for GSI keys
     */
    /**
     * Returns a sortable string representation of the creation timestamp
     * Format is YYYY-MM-DD-HH-MM-SS-SSS which ensures correct chronological sorting
     */
    get dateString(): string {
        // Parse the ISO string into sortable components
        const date = new Date(this.createdAt);

        // Format: YYYY-MM-DD-HH-MM-SS-MMM
        // This ensures chronological sorting even within the same second
        return [
            date.getUTCFullYear().toString().padStart(4, '0'),
            (date.getUTCMonth() + 1).toString().padStart(2, '0'),
            date.getUTCDate().toString().padStart(2, '0'),
            date.getUTCHours().toString().padStart(2, '0'),
            date.getUTCMinutes().toString().padStart(2, '0'),
            date.getUTCSeconds().toString().padStart(2, '0'),
            date.getUTCMilliseconds().toString().padStart(3, '0'),
        ].join('-');
    }

    /**
     * Helper methods for entity-specific operations
     */

    /**
     * Check if this transaction involves a specific entity
     */
    involvesEntity(entityId: string, entityType: EntityType): boolean {
        return (
            (this.senderId === entityId && this.senderType === entityType) ||
            (this.receiverId === entityId && this.receiverType === entityType)
        );
    }

    /**
     * Check if entity is the sender
     */
    isEntitySender(entityId: string, entityType: EntityType): boolean {
        return this.senderId === entityId && this.senderType === entityType;
    }

    /**
     * Check if entity is the receiver
     */
    isEntityReceiver(entityId: string, entityType: EntityType): boolean {
        return this.receiverId === entityId && this.receiverType === entityType;
    }

    /**
     * Get the counterparty for a specific entity
     */
    getCounterparty(entityId: string, entityType: EntityType): EntityReference | null {
        if (this.isEntitySender(entityId, entityType) && this.receiverId) {
            return {
                id: this.receiverId,
                type: this.receiverType!,
                name: this.receiverName,
            };
        } else if (this.isEntityReceiver(entityId, entityType) && this.senderId) {
            return {
                id: this.senderId,
                type: this.senderType!,
                name: this.senderName,
            };
        }
        return null;
    }

    /**
     * Convert transaction to DynamoDB item format for the main transaction record
     */
    toItem(): Record<string, AttributeValue> {
        // Determine which entity will be used for the history GSI keys
        // For transfers, prioritize sender for outgoing and receiver for incoming
        // For deposits/withdrawals, use the relevant entity
        let entityType: string | undefined;
        let entityId: string | undefined;

        if (this.senderId && this.senderType) {
            entityType = this.senderType;
            entityId = this.senderId;
        }

        if (this.receiverId && this.receiverType) {
            // For deposits or if sender isn't set, use receiver
            if (this.type === TransactionType.DEPOSIT || (!this.senderId && !this.senderType)) {
                entityType = this.receiverType;
                entityId = this.receiverId;
            }
        }

        return {
            PK: { S: this.pk },
            SK: { S: this.sk },
            // TransactionLookupKey for looking up transaction details
            TransactionLookupKey: { S: `TXN#${this.transactionId}` },
            TransactionDetailsKey: { S: `DETAILS` },

            // Add GSI keys for entity history lookups (avoid separate reference items)
            ...(entityType &&
                entityId && {
                    EntityTimeKey: { S: `${entityType}#${entityId}` },
                    TimeSortKey: { S: `DATE#${this.dateString}#TRANSACTION#${this.transactionId}` },
                }),

            // If this is a sender's transaction, add direction information
            ...(this.senderId &&
                this.senderType &&
                entityType === this.senderType &&
                entityId === this.senderId && {
                    direction: { S: 'OUTGOING' },
                }),

            // If this is a receiver's transaction, add direction information
            ...(this.receiverId &&
                this.receiverType &&
                entityType === this.receiverType &&
                entityId === this.receiverId && {
                    direction: { S: 'INCOMING' },
                }),

            // Add counterparty information for easier listing
            ...(this.senderId &&
                this.receiverType === entityType &&
                this.receiverId === entityId && {
                    counterpartyId: { S: this.senderId },
                    counterpartyType: { S: this.senderType || 'USER' },
                    ...(this.senderName && { counterpartyName: { S: this.senderName } }),
                }),

            ...(this.receiverId &&
                this.senderType === entityType &&
                this.senderId === entityId && {
                    counterpartyId: { S: this.receiverId },
                    counterpartyType: { S: this.receiverType || 'USER' },
                    ...(this.receiverName && { counterpartyName: { S: this.receiverName } }),
                }),

            // Add sender role entry
            ...(this.senderId &&
                this.senderType && {
                    EntityRoleKey: { S: `ENTITY#${this.senderId}#ROLE#SENDER` },
                    TimeSortKey: { S: `DATE#${this.dateString}#TRANSACTION#${this.transactionId}` },
                }),

            // Add receiver role entry with DIFFERENT ATTRIBUTES
            ...(this.receiverId &&
                this.receiverType && {
                    ReceiverRoleKey: { S: `ENTITY#${this.receiverId}#ROLE#RECEIVER` },
                    ReceiverTimeSortKey: { S: `DATE#${this.dateString}#TRANSACTION#${this.transactionId}` },
                }),

            // Core attributes
            transactionId: { S: this.transactionId },
            type: { S: this.type },
            status: { S: this.status },
            amount: { S: this.amount.toString() },
            currency: { S: this.currency },

            // Sender information
            ...(this.senderId && { senderId: { S: this.senderId } }),
            ...(this.senderType && { senderType: { S: this.senderType } }),
            ...(this.senderName && { senderName: { S: this.senderName } }),

            // Receiver information
            ...(this.receiverId && { receiverId: { S: this.receiverId } }),
            ...(this.receiverType && { receiverType: { S: this.receiverType } }),
            ...(this.receiverName && { receiverName: { S: this.receiverName } }),

            // Additional fields
            ...(this.balanceBefore && { balanceBefore: { S: this.balanceBefore } }),
            ...(this.balanceAfter && { balanceAfter: { S: this.balanceAfter } }),
            ...(this.providerType && { providerType: { S: this.providerType } }),
            ...(this.providerId && { providerId: { S: this.providerId } }),
            ...(this.providerTransactionId && { providerTransactionId: { S: this.providerTransactionId } }),
            ...(this.providerTransactionId && { ProviderTransactionIdKey: { S: this.providerTransactionId } }),
            ...(this.providerReference && { providerReference: { S: this.providerReference } }),
            ...(this.metadata && { metadata: { M: this.marshallMetadata(this.metadata) } }),
            ...(this.metadata?.description && { description: { S: this.metadata.description } }),

            // Timestamps
            createdAt: { S: this.createdAt },
            updatedAt: { S: this.updatedAt },
            ...(this.completedAt && { completedAt: { S: this.completedAt } }),
        };
    }

    /**
     * Create provider transaction reference for querying by provider
     */
    toProviderReferenceItem(): Record<string, AttributeValue> | null {
        if (!this.providerId) return null;

        return {
            PK: { S: `PROVIDER#${this.providerId}` },
            SK: { S: `TRANSACTION#${this.transactionId}` },

            // ProviderTimeKey for provider time-based queries
            ProviderTimeKey: { S: `PROVIDER#${this.providerId}` },
            ProviderTimeSortKey: { S: `DATE#${this.dateString}#TRANSACTION#${this.transactionId}` },

            // ExternalIdKey for external ID lookups (if applicable)
            ...(this.providerTransactionId && {
                ExternalIdKey: { S: `EXTERNAL#${this.providerTransactionId}` },
                ProviderIdKey: { S: `PROVIDER#${this.providerId}` },
            }),

            // Core attributes
            transactionId: { S: this.transactionId },
            status: { S: this.status },
            amount: { S: this.amount.toString() },
            currency: { S: this.currency },
            type: { S: this.type },

            // Entity information
            ...(this.senderId && { senderId: { S: this.senderId } }),
            ...(this.senderType && { senderType: { S: this.senderType } }),
            ...(this.receiverId && { receiverId: { S: this.receiverId } }),
            ...(this.receiverType && { receiverType: { S: this.receiverType } }),

            // Provider-specific details
            ...(this.providerType && { providerType: { S: this.providerType } }),
            ...(this.providerTransactionId && { providerTransactionId: { S: this.providerTransactionId } }),

            // Timestamps
            createdAt: { S: this.createdAt },
            ...(this.completedAt && { completedAt: { S: this.completedAt } }),
        };
    }

    /**
     * Create status index item for filtering by status
     */
    toStatusIndexItem(): Record<string, AttributeValue> {
        return {
            PK: { S: `STATUS#${this.status}` },
            SK: { S: `TRANSACTION#${this.transactionId}` },

            // Status information
            transactionId: { S: this.transactionId },
            status: { S: this.status },
            createdAt: { S: this.createdAt },
            type: { S: this.type },
        };
    }

    /**
     * Helper method to marshall metadata to DynamoDB format
     */
    private marshallMetadata(metadata: TransactionMetadata): Record<string, AttributeValue> {
        const result: Record<string, AttributeValue> = {};
        for (const [key, value] of Object.entries(metadata)) {
            if (value !== undefined && value !== null) {
                if (typeof value === 'number') {
                    result[key] = { N: value.toString() };
                } else if (typeof value === 'boolean') {
                    result[key] = { BOOL: value };
                } else if (typeof value === 'object') {
                    result[key] = { S: JSON.stringify(value) };
                } else {
                    result[key] = { S: String(value) };
                }
            }
        }
        return result;
    }

    /**
     * Create a Transaction object from a DynamoDB item
     */
    static fromItem(item?: Record<string, AttributeValue>): Transaction {
        if (!item) throw new Error('No transaction item found!');

        const metadata: TransactionMetadata = {};
        if (item.metadata && item.metadata.M) {
            for (const [key, value] of Object.entries(item.metadata.M)) {
                if (value.S) {
                    metadata[key] = value.S;
                } else if (value.N) {
                    metadata[key] = parseFloat(value.N);
                } else if (value.BOOL !== undefined) {
                    metadata[key] = value.BOOL;
                }
            }
        }

        // Prepare sender and receiver data if available
        const sender = item.senderId?.S
            ? {
                  id: item.senderId.S,
                  type: (item.senderType?.S as EntityType) || 'USER',
                  name: item.senderName?.S,
              }
            : undefined;

        const receiver = item.receiverId?.S
            ? {
                  id: item.receiverId.S,
                  type: (item.receiverType?.S as EntityType) || 'USER',
                  name: item.receiverName?.S,
              }
            : undefined;

        // Create Money object from stored amount
        const amount = new Money(item.amount.S || item.amount.N || '0', item.currency.S);

        return new Transaction(
            item.type.S as TransactionType,
            amount,
            item.currency.S,
            item.status.S as TransactionStatus,
            {
                transactionId: item.transactionId.S,
                sender,
                receiver,
                balanceBefore: item.balanceBefore?.S,
                balanceAfter: item.balanceAfter?.S,
                providerType: item.providerType?.S as ProviderType | undefined,
                providerId: item.providerId?.S,
                providerTransactionId: item.providerTransactionId?.S,
                providerReference: item.providerReference?.S,
                metadata: Object.keys(metadata).length > 0 ? metadata : undefined,
                completedAt: item.completedAt?.S,
                createdAt: item.createdAt.S,
                updatedAt: item.updatedAt.S,
            },
        );
    }

    /**
     * Create a new transaction with all necessary records
     */
    async create(): Promise<Transaction> {
        const client = getClient();
        const txnItem = this.toItem();

        // Create transaction items for atomic write
        const transactItems = [
            {
                Put: {
                    TableName: TABLE_NAME,
                    Item: txnItem,
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                },
            },
        ];

        // Add provider reference if applicable - keep this for provider queries
        const providerItem = this.toProviderReferenceItem();
        if (providerItem) {
            transactItems.push({
                Put: {
                    TableName: TABLE_NAME,
                    Item: providerItem,
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                },
            });
        }

        // Add status index item - only for non-COMPLETED statuses to avoid hot partitions
        if (this.status !== TransactionStatus.COMPLETED) {
            transactItems.push({
                Put: {
                    TableName: TABLE_NAME,
                    Item: this.toStatusIndexItem(),
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                },
            });
        }

        try {
            await client.send(
                new TransactWriteItemsCommand({
                    TransactItems: transactItems,
                }),
            );

            return this;
        } catch (error) {
            logger.error('Error creating transaction:', { error, transactionId: this.transactionId });
            throw error;
        }
    }

    /**
     * Update an existing transaction and all related records
     */
    async update(): Promise<Transaction> {
        const client = getClient();
        this.updatedAt = new Date().toISOString();

        const txnItem = this.toItem();

        // Create update transaction items
        const transactItems = [
            {
                Put: {
                    TableName: TABLE_NAME,
                    Item: txnItem,
                },
            },
        ];

        // Update provider reference if applicable - keep this for provider queries
        const providerItem = this.toProviderReferenceItem();
        if (providerItem) {
            transactItems.push({
                Put: {
                    TableName: TABLE_NAME,
                    Item: providerItem,
                },
            });
        }

        // Add status index item - only for non-COMPLETED statuses to avoid hot partitions
        if (this.status !== TransactionStatus.COMPLETED) {
            transactItems.push({
                Put: {
                    TableName: TABLE_NAME,
                    Item: this.toStatusIndexItem(),
                },
            });
        }

        try {
            await client.send(
                new TransactWriteItemsCommand({
                    TransactItems: transactItems,
                }),
            );

            return this;
        } catch (error) {
            logger.error('Error updating transaction:', { error, transactionId: this.transactionId });
            throw error;
        }
    }

    /**
     * Mark transaction as complete and update wallet balance if needed
     * @param balanceAfter Optional wallet balance after transaction
     * @param updateWallet Whether to update the wallet balance (for deposits/withdrawals)
     */
    async complete(balanceAfter?: string, updateWallet: boolean = true): Promise<Transaction> {
        // Check if transaction is already completed to ensure idempotency
        if (this.status === TransactionStatus.COMPLETED) {
            logger.info('Transaction already completed, skipping duplicate completion', {
                transactionId: this.transactionId,
                type: this.type,
                idempotencyCheck: true
            });
            return this;
        }

        // Create an idempotency key for this completion
        const idempotencyKey = `complete:${this.transactionId}`;
        
        // Check if we've already attempted to process this completion
        if (this.metadata?.processedOperations?.includes(idempotencyKey)) {
            logger.info('This completion operation was already processed, skipping for idempotency', {
                transactionId: this.transactionId,
                idempotencyKey,
                processedOperations: this.metadata?.processedOperations
            });
            return this;
        }
        
        // Initialize metadata if it doesn't exist
        if (!this.metadata) {
            this.metadata = {};
        }
        
        // Initialize processedOperations array if it doesn't exist
        if (!this.metadata.processedOperations) {
            this.metadata.processedOperations = [];
        }
        
        // Add this operation to the list of processed operations
        this.metadata.processedOperations.push(idempotencyKey);
        
        // Set completion details
        this.status = TransactionStatus.COMPLETED;
        this.completedAt = new Date().toISOString();

        if (balanceAfter) {
            this.balanceAfter = balanceAfter;
        }

        // If this is a deposit, withdrawal, P2P, or P2B transaction, update the wallet balance
        if (
            updateWallet &&
            (this.type === TransactionType.DEPOSIT ||
                this.type === TransactionType.WITHDRAWAL ||
                this.type === TransactionType.P2P ||
                this.type === TransactionType.P2B)
        ) {
            try {
                // For deposits, update receiver wallet
                if (this.type === TransactionType.DEPOSIT && this.receiverId && this.receiverType) {
                    // Add record of wallet update attempt to metadata
                    this.metadata.walletUpdateAttempted = true;
                    this.metadata.walletUpdateType = 'deposit';
                    this.metadata.walletUpdateTimestamp = new Date().toISOString();
                    
                    await WalletService.deposit(
                        this.receiverId,
                        this.receiverType,
                        this.amount,
                        this.transactionId,
                        this.currency as CurrencyCode,
                    );

                    this.metadata.walletUpdateSuccess = true;

                    logger.info('Updated wallet balance for deposit', {
                        entityId: this.receiverId,
                        entityType: this.receiverType,
                        amount: this.amount.toString(),
                        transactionId: this.transactionId,
                    });
                }

                // For withdrawals, update sender wallet
                if (this.type === TransactionType.WITHDRAWAL && this.senderId && this.senderType) {
                    // Add record of wallet update attempt to metadata
                    this.metadata.walletUpdateAttempted = true;
                    this.metadata.walletUpdateType = 'withdrawal';
                    this.metadata.walletUpdateTimestamp = new Date().toISOString();
                    
                    await WalletService.withdraw(
                        this.senderId,
                        this.senderType,
                        this.amount,
                        this.transactionId,
                        this.currency as CurrencyCode,
                    );

                    this.metadata.walletUpdateSuccess = true;

                    logger.info('Updated wallet balance for withdrawal', {
                        entityId: this.senderId,
                        entityType: this.senderType,
                        amount: this.amount.toString(),
                        transactionId: this.transactionId,
                    });
                }

                // For P2P and P2B transfers, always credit the receiver's wallet
                // For both wallet and card payments, the receiver should receive the funds
                if (
                    (this.type === TransactionType.P2P || this.type === TransactionType.P2B) &&
                    this.receiverId &&
                    this.receiverType
                ) {
                    // Add record of wallet update attempt to metadata
                    this.metadata.walletUpdateAttempted = true;
                    this.metadata.walletUpdateType = 'transfer_credit';
                    this.metadata.walletUpdateTimestamp = new Date().toISOString();
                    
                    // Always credit the receiver's wallet regardless of payment method
                    await WalletService.deposit(
                        this.receiverId,
                        this.receiverType,
                        this.amount,
                        this.transactionId,
                        this.currency as CurrencyCode,
                    );

                    this.metadata.walletUpdateSuccess = true;

                    logger.info(`Updated receiver wallet balance for ${this.type}`, {
                        entityId: this.receiverId,
                        entityType: this.receiverType,
                        amount: this.amount.toString(),
                        transactionId: this.transactionId,
                        paymentMethod: this.metadata?.paymentMethod || 'unknown',
                    });
                }
            } catch (error) {
                logger.error('Failed to update wallet balance during transaction completion', {
                    transactionId: this.transactionId,
                    error: error instanceof Error ? error.message : 'Unknown error',
                    stack: error instanceof Error ? error.stack : undefined,
                });
                
                // Record wallet update failure in metadata
                this.metadata.walletUpdateSuccess = false;
                this.metadata.walletUpdateError = error instanceof Error ? error.message : 'Unknown error';
                
                // Continue with transaction update even if wallet update fails
                // This avoids transaction getting stuck
            }
        }

        return this.update();
    }

    /**
     * Mark transaction as failed and handle refunds if needed
     * @param reason Optional reason for failure
     * @param refundWallet Whether to refund the sender's wallet for wallet payments
     */
    async fail(reason?: string, refundWallet: boolean = true): Promise<Transaction> {
        // Check if transaction is already failed to ensure idempotency
        if (this.status === TransactionStatus.FAILED) {
            logger.info('Transaction already failed, skipping duplicate failure handling', {
                transactionId: this.transactionId,
                type: this.type,
                idempotencyCheck: true
            });
            return this;
        }

        // Check if transaction is already completed - can't fail a completed transaction
        if (this.status === TransactionStatus.COMPLETED) {
            logger.warn('Cannot fail a completed transaction', {
                transactionId: this.transactionId,
                type: this.type,
                currentStatus: this.status,
            });
            return this;
        }
        
        // Create an idempotency key for this failure
        const idempotencyKey = `fail:${this.transactionId}:${reason || 'no-reason'}`;
        
        // Initialize metadata if it doesn't exist
        if (!this.metadata) {
            this.metadata = {};
        }
        
        // Initialize processedOperations array if it doesn't exist
        if (!this.metadata.processedOperations) {
            this.metadata.processedOperations = [];
        }
        
        // Check if we've already attempted to process this failure
        if (this.metadata.processedOperations.includes(idempotencyKey)) {
            logger.info('This failure operation was already processed, skipping for idempotency', {
                transactionId: this.transactionId,
                idempotencyKey,
                processedOperations: this.metadata.processedOperations
            });
            return this;
        }
        
        // Add this operation to the list of processed operations
        this.metadata.processedOperations.push(idempotencyKey);

        this.status = TransactionStatus.FAILED;

        if (reason) {
            this.metadata.failureReason = reason;
        }

        // For P2P and P2B transactions that used wallet balance, refund the sender's wallet
        if (
            refundWallet &&
            (this.type === TransactionType.P2P || this.type === TransactionType.P2B) &&
            this.metadata?.paymentMethod === 'wallet' &&
            this.senderId &&
            this.senderType
        ) {
            try {
                // Check if already refunded
                if (this.metadata?.refunded) {
                    logger.warn('Transaction already refunded, skipping duplicate refund', {
                        transactionId: this.transactionId,
                        idempotencyCheck: true
                    });
                } else {
                    // Add record of refund attempt to metadata
                    this.metadata.refundAttempted = true;
                    this.metadata.refundTimestamp = new Date().toISOString();
                    
                    // Refund the sender's wallet by depositing the amount back
                    await WalletService.deposit(
                        this.senderId,
                        this.senderType,
                        this.amount,
                        this.transactionId,
                        this.currency as CurrencyCode,
                    );

                    logger.info('Refunded sender wallet for failed transaction', {
                        transactionId: this.transactionId,
                        senderId: this.senderId,
                        amount: this.amount.toString(),
                        type: this.type,
                    });

                    // Add refund information to metadata
                    this.metadata.refunded = true;
                    this.metadata.refundedAt = new Date().toISOString();
                }
            } catch (error) {
                logger.error('Failed to refund sender wallet for failed transaction', {
                    transactionId: this.transactionId,
                    senderId: this.senderId,
                    error: error instanceof Error ? error.message : 'Unknown error',
                });

                // Add refund failure information to metadata
                this.metadata.refundFailed = true;
                this.metadata.refundFailureReason = error instanceof Error ? error.message : 'Unknown error';
                this.metadata.refundFailureTimestamp = new Date().toISOString();
            }
        }

        return this.update();
    }

    /**
     * Mark transaction as reversed
     */
    async reverse(reason?: string): Promise<Transaction> {
        this.status = TransactionStatus.REVERSED;

        if (reason && !this.metadata) {
            this.metadata = {};
        }

        if (reason && this.metadata) {
            this.metadata.reversalReason = reason;
        }

        return this.update();
    }

    /**
     * Get a transaction by its transaction ID
     */
    static async getByTransactionId(transactionId: string): Promise<Transaction> {
        const client = getClient();

        try {
            const response = await client.send(
                new GetItemCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: { S: `TRANSACTION#${transactionId}` },
                        SK: { S: 'DETAILS' },
                    },
                }),
            );

            if (!response.Item) {
                throw new Error(`Transaction ${transactionId} not found`);
            }

            return Transaction.fromItem(response.Item);
        } catch (error) {
            logger.error('Error getting transaction by transaction ID:', { error, transactionId });
            throw error;
        }
    }

    /**
     * List transactions for a specific entity with various filtering options
     */
    static async listByEntity(
        entityId: string,
        entityType: EntityType,
        options: {
            limit?: number;
            startKey?: Record<string, AttributeValue>;
            status?: TransactionStatus;
            type?: TransactionType;
            startDate?: string;
            endDate?: string;
            fetchFullDetails?: boolean; // New option to control whether to fetch full details
        } = {},
    ): Promise<{ transactions: Transaction[]; lastEvaluatedKey?: Record<string, AttributeValue> }> {
        const client = getClient();
        const { limit = 50, startKey, status, type, startDate, endDate, fetchFullDetails = false } = options;

        try {
            // If date range is specified, use EntityTimeIndex for time-based query
            if (startDate || endDate) {
                return Transaction.listByDateRange(
                    entityId,
                    entityType,
                    startDate || '2000-01-01',
                    endDate || '9999-12-31',
                    {
                        limit,
                        startKey,
                        status,
                        type,
                        fetchFullDetails,
                    },
                );
            }

            // If we don't use date range filtering, we'll query directly using EntityTimeIndex
            // since we've moved away from reference items
            const expressionAttributeValues: Record<string, AttributeValue> = {
                ':entityTimeKey': { S: `${entityType}#${entityId}` },
            };

            // Build filter expression for status and type
            let filterExpression = '';
            const expressionAttributeNames: Record<string, string> = {};

            if (status) {
                filterExpression += filterExpression ? ' AND ' : '';
                filterExpression += '#status = :status';
                expressionAttributeValues[':status'] = { S: status };
                expressionAttributeNames['#status'] = 'status';
            }

            if (type) {
                filterExpression += filterExpression ? ' AND ' : '';
                filterExpression += '#type = :type';
                expressionAttributeValues[':type'] = { S: type };
                expressionAttributeNames['#type'] = 'type';
            }

            const queryParams: any = {
                TableName: TABLE_NAME,
                IndexName: 'EntityTimeIndex',
                KeyConditionExpression: 'EntityTimeKey = :entityTimeKey',
                ExpressionAttributeValues: expressionAttributeValues,
                ScanIndexForward: false, // Most recent first
                Limit: limit,
            };

            if (Object.keys(expressionAttributeNames).length > 0) {
                queryParams.ExpressionAttributeNames = expressionAttributeNames;
            }

            if (filterExpression) {
                queryParams.FilterExpression = filterExpression;
            }

            if (startKey) {
                queryParams.ExclusiveStartKey = startKey;
            }

            const response = await client.send(new QueryCommand(queryParams));

            if (!response.Items || response.Items.length === 0) {
                return { transactions: [] };
            }

            let transactions: Transaction[];

            // If full details are requested, fetch them for each transaction
            if (fetchFullDetails) {
                // Batch get all full transaction details
                const transactionIds = response.Items.map((item) => {
                    if (item.transactionId && item.transactionId.S) {
                        return item.transactionId.S;
                    }

                    // If transactionId is not directly available, try to extract from TimeSortKey
                    if (item.TimeSortKey && item.TimeSortKey.S) {
                        const match = item.TimeSortKey.S.match(/TRANSACTION#([^#]+)$/);
                        return match ? match[1] : null;
                    }

                    return null;
                }).filter(Boolean);

                transactions = [];

                if (transactionIds.length > 0) {
                    // Get transactions in batches of 25 (DynamoDB batch limit)
                    for (let i = 0; i < transactionIds.length; i += 25) {
                        const batchIds = transactionIds.slice(i, i + 25);

                        // Query the main transaction details
                        const batchResponses = await Promise.all(
                            batchIds.map((txnId) =>
                                client.send(
                                    new GetItemCommand({
                                        TableName: TABLE_NAME,
                                        Key: {
                                            PK: { S: `TRANSACTION#${txnId}` },
                                            SK: { S: 'DETAILS' },
                                        },
                                    }),
                                ),
                            ),
                        );

                        // Process each response and add to transactions array
                        batchResponses.forEach((batchResponse) => {
                            if (batchResponse.Item) {
                                transactions.push(Transaction.fromItem(batchResponse.Item));
                            }
                        });
                    }
                }
            } else {
                // Use the projected data from the GSI directly (no secondary lookups)
                transactions = response.Items.map((item) => {
                    // Convert the GSI item to a transaction using only projected attributes
                    // This is more efficient but has fewer fields available
                    return new Transaction(
                        item.type.S as TransactionType,
                        item.amount.S || '0',
                        item.currency.S || 'USD',
                        item.status.S as TransactionStatus,
                        {
                            transactionId: item.transactionId.S,
                            sender: item.senderId?.S
                                ? {
                                      id: item.senderId.S,
                                      type: (item.senderType?.S as EntityType) || 'USER',
                                      name: item.senderName?.S,
                                  }
                                : undefined,
                            receiver: item.receiverId?.S
                                ? {
                                      id: item.receiverId.S,
                                      type: (item.receiverType?.S as EntityType) || 'USER',
                                      name: item.receiverName?.S,
                                  }
                                : undefined,
                            metadata: item.description?.S ? { description: item.description.S } : undefined,
                            createdAt: item.createdAt.S,
                            updatedAt: item.updatedAt?.S || item.createdAt.S,
                            completedAt: item.completedAt?.S,
                        },
                    );
                });
            }

            return {
                transactions,
                lastEvaluatedKey: response.LastEvaluatedKey,
            };
        } catch (error) {
            logger.error('Error listing transactions by entity:', { error, entityId, entityType });
            throw error;
        }
    }

    /**
     * List transactions for an entity within a specific date range
     */
    static async listByDateRange(
        entityId: string,
        entityType: EntityType,
        startDate: string,
        endDate: string,
        options: {
            limit?: number;
            startKey?: Record<string, AttributeValue>;
            status?: TransactionStatus;
            type?: TransactionType;
            fetchFullDetails?: boolean; // New option to control whether to fetch full details
        } = {},
    ): Promise<{ transactions: Transaction[]; lastEvaluatedKey?: Record<string, AttributeValue> }> {
        const client = getClient();
        const { limit = 50, startKey, status, type, fetchFullDetails = false } = options;

        try {
            // Build filter expression for status and type
            let filterExpression = '';
            const expressionAttributeValues: Record<string, AttributeValue> = {
                ':entityTimeKey': { S: `${entityType}#${entityId}` },
                ':startSk': { S: `DATE#${startDate}` },
                ':endSk': { S: `DATE#${endDate}#TRANSACTION#zzzzzzzzzzzzzzzzzzz` }, // Upper bound
            };
            const expressionAttributeNames: Record<string, string> = {};

            if (status) {
                filterExpression += filterExpression ? ' AND ' : '';
                filterExpression += '#status = :status';
                expressionAttributeValues[':status'] = { S: status };
                expressionAttributeNames['#status'] = 'status';
            }

            if (type) {
                filterExpression += filterExpression ? ' AND ' : '';
                filterExpression += '#type = :type';
                expressionAttributeValues[':type'] = { S: type };
                expressionAttributeNames['#type'] = 'type';
            }

            const queryParams: any = {
                TableName: TABLE_NAME,
                IndexName: 'EntityTimeIndex',
                KeyConditionExpression: 'EntityTimeKey = :entityTimeKey AND TimeSortKey BETWEEN :startSk AND :endSk',
                ExpressionAttributeValues: expressionAttributeValues,
                ScanIndexForward: false, // Most recent first
                Limit: limit,
            };

            if (Object.keys(expressionAttributeNames).length > 0) {
                queryParams.ExpressionAttributeNames = expressionAttributeNames;
            }

            if (filterExpression) {
                queryParams.FilterExpression = filterExpression;
            }

            if (startKey) {
                queryParams.ExclusiveStartKey = startKey;
            }

            const response = await client.send(new QueryCommand(queryParams));

            if (!response.Items || response.Items.length === 0) {
                return { transactions: [] };
            }

            let transactions: Transaction[];

            // If full details are requested, fetch them for each transaction
            if (fetchFullDetails) {
                // Batch get all full transaction details
                const transactionIds = response.Items.map((item) => {
                    if (item.transactionId && item.transactionId.S) {
                        return item.transactionId.S;
                    }

                    // If transactionId is not directly available, try to extract from TimeSortKey
                    if (item.TimeSortKey && item.TimeSortKey.S) {
                        const match = item.TimeSortKey.S.match(/TRANSACTION#([^#]+)$/);
                        return match ? match[1] : null;
                    }

                    return null;
                }).filter(Boolean);

                transactions = [];

                if (transactionIds.length > 0) {
                    // Get transactions in batches of 25 (DynamoDB batch limit)
                    for (let i = 0; i < transactionIds.length; i += 25) {
                        const batchIds = transactionIds.slice(i, i + 25);

                        // Query the main transaction details
                        const batchResponses = await Promise.all(
                            batchIds.map((txnId) =>
                                client.send(
                                    new GetItemCommand({
                                        TableName: TABLE_NAME,
                                        Key: {
                                            PK: { S: `TRANSACTION#${txnId}` },
                                            SK: { S: 'DETAILS' },
                                        },
                                    }),
                                ),
                            ),
                        );

                        // Process each response and add to transactions array
                        batchResponses.forEach((batchResponse) => {
                            if (batchResponse.Item) {
                                transactions.push(Transaction.fromItem(batchResponse.Item));
                            }
                        });
                    }
                }
            } else {
                // Use the projected data from the GSI directly (no secondary lookups)
                transactions = response.Items.map((item) => {
                    // Convert the GSI item to a transaction using only projected attributes
                    return new Transaction(
                        item.type.S as TransactionType,
                        item.amount.S || '0',
                        item.currency.S || 'USD',
                        item.status.S as TransactionStatus,
                        {
                            transactionId: item.transactionId.S,
                            sender: item.senderId?.S
                                ? {
                                      id: item.senderId.S,
                                      type: (item.senderType?.S as EntityType) || 'USER',
                                      name: item.senderName?.S,
                                  }
                                : undefined,
                            receiver: item.receiverId?.S
                                ? {
                                      id: item.receiverId.S,
                                      type: (item.receiverType?.S as EntityType) || 'USER',
                                      name: item.receiverName?.S,
                                  }
                                : undefined,
                            metadata: item.description?.S ? { description: item.description.S } : undefined,
                            createdAt: item.createdAt.S,
                            updatedAt: item.updatedAt?.S || item.createdAt.S,
                            completedAt: item.completedAt?.S,
                        },
                    );
                });
            }

            return {
                transactions,
                lastEvaluatedKey: response.LastEvaluatedKey,
            };
        } catch (error) {
            logger.error('Error listing transactions by date range:', {
                error,
                entityId,
                entityType,
                startDate,
                endDate,
            });
            throw error;
        }
    }

    /**
     * List transactions for a business
     */
    static async listForBusiness(
        businessId: string,
        options: {
            limit?: number;
            startKey?: Record<string, AttributeValue>;
            status?: TransactionStatus;
            type?: TransactionType;
        } = {},
    ): Promise<{ transactions: Transaction[]; lastEvaluatedKey?: Record<string, AttributeValue> }> {
        return Transaction.listByEntity(businessId, 'BUSINESS', options);
    }

    /**
     * Get revenue for a business in a given date range
     */
    static async getBusinessRevenue(
        businessId: string,
        startDate: string,
        endDate: string,
    ): Promise<{ totalAmount: string; transactionCount: number }> {
        const { transactions } = await Transaction.listByDateRange(businessId, 'BUSINESS', startDate, endDate, {
            status: TransactionStatus.COMPLETED,
            limit: 1000, // Use a higher limit to get more accurate calculations
        });

        // Only include incoming transactions (received money)
        const incomingTransactions = transactions.filter(
            (t) =>
                t.receiverId === businessId &&
                t.receiverType === 'BUSINESS' &&
                t.status === TransactionStatus.COMPLETED,
        );

        // Use Money for precise summation
        const zero = new Money(0, 'USD');
        const totalAmount = incomingTransactions.reduce((sum, t) => sum.add(t.amount), zero);

        return {
            totalAmount: totalAmount.toString(), // Return as string for precision
            transactionCount: incomingTransactions.length,
        };
    }

    static async getTransactionsByPaymentProviderId(providerTransactionId: string): Promise<Transaction[]> {
        const client = getClient();

        try {
            logger.info('Looking up transactions by provider ID', { providerTransactionId });

            // Use the ProviderTransactionIndex GSI instead of a scan
            const queryResponse = await client.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'ProviderTransactionIndex',
                    KeyConditionExpression: 'ProviderTransactionIdKey = :providerTxnId',
                    ExpressionAttributeValues: {
                        ':providerTxnId': { S: providerTransactionId },
                    },
                }),
            );

            if (!queryResponse.Items || queryResponse.Items.length === 0) {
                logger.info('No transactions found with provider ID', { providerTransactionId });
                return [];
            }

            // Process and return transactions with matching provider ID
            const transactions = queryResponse.Items.map((item) => Transaction.fromItem(item));

            logger.info('Found transactions by provider ID', {
                count: transactions.length,
                transactionIds: transactions.map((t) => t.transactionId),
            });

            return transactions;
        } catch (error) {
            logger.error('Error querying transactions by provider ID', {
                error: error instanceof Error ? error.message : 'Unknown error',
                providerTransactionId,
            });
            throw error;
        }
    }

    /**
     * Get transactions by provider transaction ID directly
     */
    static async getByProviderTransactionId(providerTransactionId: string): Promise<Transaction[]> {
        const client = getClient();

        try {
            logger.info('Looking up transactions by provider transaction ID directly', { providerTransactionId });

            // Query transactions with the specific provider transaction ID
            const response = await client.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'ProviderTransactionIndex',
                    KeyConditionExpression: 'ProviderTransactionIdKey = :providerTxnId',
                    ExpressionAttributeValues: {
                        ':providerTxnId': { S: providerTransactionId },
                    },
                }),
            );

            if (!response.Items || response.Items.length === 0) {
                logger.info('No transactions found with provider transaction ID', { providerTransactionId });
                return [];
            }

            // Convert items to Transaction objects
            const transactions = response.Items.map((item) => Transaction.fromItem(item));

            logger.info('Found transactions by provider transaction ID', {
                count: transactions.length,
                transactionIds: transactions.map((t) => t.transactionId),
            });

            return transactions;
        } catch (error) {
            logger.error('Error getting transactions by provider transaction ID', {
                error: error instanceof Error ? error.message : 'Unknown error',
                providerTransactionId,
            });
            throw error;
        }
    }

    /**
     * List all transactions for an entity (both sent and received) using the role-based GSI
     */
    static async listAllTransactionsByEntity(
        entityId: string,
        options: {
            limit?: number;
            startKey?: Record<string, AttributeValue>;
            status?: TransactionStatus;
            type?: TransactionType;
            startDate?: string;
            endDate?: string;
        } = {},
    ): Promise<{
        transactions: Transaction[];
        lastEvaluatedKey?: Record<string, AttributeValue>;
    }> {
        const client = getClient();
        const { limit = 50, status, type, startDate, endDate } = options;

        try {
            // Query transactions where entity is SENDER
            const senderParams = {
                TableName: TABLE_NAME,
                IndexName: 'EntityRoleTransactionIndex',
                KeyConditionExpression: 'EntityRoleKey = :senderKey',
                ExpressionAttributeValues: {
                    ':senderKey': { S: `ENTITY#${entityId}#ROLE#SENDER` },
                },
                // Add date range, status, type filtering if needed
                ScanIndexForward: false,
                Limit: limit,
            };

            // Query transactions where entity is RECEIVER
            const receiverParams = {
                TableName: TABLE_NAME,
                IndexName: 'ReceiverRoleTransactionIndex', // Using the receiver index!
                KeyConditionExpression: 'ReceiverRoleKey = :receiverKey',
                ExpressionAttributeValues: {
                    ':receiverKey': { S: `ENTITY#${entityId}#ROLE#RECEIVER` },
                },
                // Add date range, status, type filtering if needed
                ScanIndexForward: false,
                Limit: limit,
            };

            // Execute both queries in parallel
            const [senderResponse, receiverResponse] = await Promise.all([
                client.send(new QueryCommand(senderParams)),
                client.send(new QueryCommand(receiverParams)),
            ]);

            // Process and combine results
            const senderTransactions = senderResponse.Items?.map((item) => Transaction.fromItem(item)) || [];

            const receiverTransactions = receiverResponse.Items?.map((item) => Transaction.fromItem(item)) || [];

            // Combine, sort by date, and limit to requested amount
            const allTransactions = [...senderTransactions, ...receiverTransactions]
                .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
                .slice(0, limit);

            return {
                transactions: allTransactions,
                // Include lastEvaluatedKey from either query that has more results
                lastEvaluatedKey: senderResponse.LastEvaluatedKey || receiverResponse.LastEvaluatedKey,
            };
        } catch (error) {
            logger.error('Error listing all transactions for entity:', { error, entityId });
            throw error;
        }
    }
}

// Convenient wrapper functions for common transaction operations

/**
 * Create a new transaction
 */
export const createTransaction = async (transaction: Transaction): Promise<Transaction> => {
    return transaction.create();
};

/**
 * Create a deposit transaction
 */
export const createDeposit = async (
    receiverId: string,
    receiverType: EntityType,
    amount: string | number | Money,
    status: TransactionStatus = TransactionStatus.PENDING,
    senderId = '',
): Promise<Transaction> => {
    const transaction = new Transaction(TransactionType.DEPOSIT, amount, 'USD', status, {
        receiver: { id: receiverId, type: receiverType },
        ...(senderId && { sender: { id: senderId, type: 'USER' } }),
    });

    return transaction.create();
};

/**
 * Create a withdrawal transaction
 */
export const createWithdrawal = async (
    senderId: string,
    senderType: EntityType,
    amount: string | number | Money,
    receiverId = '',
    receiverType: EntityType = 'USER',
    status: TransactionStatus = TransactionStatus.PENDING,
    options: {
        senderName?: string;
        providerType?: ProviderType;
        providerId?: string;
        providerTransactionId?: string;
        metadata?: TransactionMetadata;
    } = {},
): Promise<Transaction> => {
    // For withdrawal transactions, we should not set the sender as the receiver
    // This avoids duplicate transactions when querying by entity
    const transaction = new Transaction(TransactionType.WITHDRAWAL, amount, 'USD', status, {
        sender: { id: senderId, type: senderType, name: options.senderName },
        // Only set receiver if it's different from sender
        ...(receiverId && receiverId !== senderId ? { receiver: { id: receiverId, type: receiverType } } : {}),
        providerType: options.providerType,
        providerId: options.providerId,
        providerTransactionId: options.providerTransactionId,
        metadata: {
            ...options.metadata,
            // Add a withdrawal flag to make these transactions easily identifiable
            isWithdrawal: true,
            // If this is a self-withdrawal (common case), add a note in metadata
            ...(!receiverId || receiverId === senderId ? { selfWithdrawal: true } : {}),
        },
    });

    return transaction.create();
};

/**
 * Create a transfer between two users/businesses
 */
export const createTransfer = async (
    senderId: string,
    senderType: EntityType,
    receiverId: string,
    receiverType: EntityType,
    amount: string | number | Money,
    status: TransactionStatus = TransactionStatus.PENDING,
    options: {
        senderName?: string;
        receiverName?: string;
        metadata?: TransactionMetadata;
    } = {},
): Promise<{ senderTransaction: Transaction; receiverTransaction: Transaction }> => {
    const transferType = receiverType === 'BUSINESS' ? TransactionType.P2B : TransactionType.P2P;
    const amountObj = amount instanceof Money ? amount : new Money(amount, 'USD');

    // Create outgoing transaction for sender
    const senderTransaction = new Transaction(transferType, amountObj, 'USD', status, {
        sender: {
            id: senderId,
            type: senderType,
            name: options.senderName,
        },
        receiver: {
            id: receiverId,
            type: receiverType,
            name: options.receiverName,
        },
        metadata: options.metadata,
    });

    // Create incoming transaction for receiver - will be linked
    const receiverTransaction = new Transaction(transferType, amountObj, 'USD', status, {
        sender: {
            id: senderId,
            type: senderType,
            name: options.senderName,
        },
        receiver: {
            id: receiverId,
            type: receiverType,
            name: options.receiverName,
        },
        metadata: {
            ...options.metadata,
        },
    });

    // Add cross-reference between the two transactions
    if (!senderTransaction.metadata) senderTransaction.metadata = {};
    if (!receiverTransaction.metadata) receiverTransaction.metadata = {};

    senderTransaction.metadata.counterTransactionId = receiverTransaction.transactionId;
    receiverTransaction.metadata.counterTransactionId = senderTransaction.transactionId;

    // Save both transactions
    await senderTransaction.create();
    await receiverTransaction.create();

    return { senderTransaction, receiverTransaction };
};

/**
 * Get a transaction by ID for a specific entity
 * @deprecated Use getTransactionById instead
 */
export const getTransaction = async (
    _entityId: string, // Unused parameter, prefixed with underscore
    _entityType: EntityType, // Unused parameter, prefixed with underscore
    transactionId: string,
): Promise<Transaction> => {
    // Simply use getTransactionById now
    return getTransactionById(transactionId);
};

/**
 * Get a transaction by its transaction ID
 */
export const getTransactionById = async (transactionId: string): Promise<Transaction> => {
    return Transaction.getByTransactionId(transactionId);
};

/**
 * List transactions for an entity
 */
export const listEntityTransactions = async (
    entityId: string,
    entityType: EntityType,
    options: Parameters<typeof Transaction.listByEntity>[2] = {},
): Promise<ReturnType<typeof Transaction.listByEntity>> => {
    return Transaction.listByEntity(entityId, entityType, options);
};

/**
 * List transactions for a business
 */
export const listBusinessTransactions = async (
    businessId: string,
    options: Parameters<typeof Transaction.listForBusiness>[1] = {},
): Promise<ReturnType<typeof Transaction.listForBusiness>> => {
    return Transaction.listForBusiness(businessId, options);
};

/**
 * Get business revenue in a date range
 */
export const getBusinessRevenue = async (
    businessId: string,
    startDate: string,
    endDate: string,
): Promise<ReturnType<typeof Transaction.getBusinessRevenue>> => {
    return Transaction.getBusinessRevenue(businessId, startDate, endDate);
};

/**
 * Get transactions by provider transaction ID
 */
export const getTransactionsByProviderTransactionId = async (providerTransactionId: string): Promise<Transaction[]> => {
    return Transaction.getByProviderTransactionId(providerTransactionId);
};

/**
 * List all transactions for an entity (both sent and received)
 */
export const listAllEntityTransactions = async (
    entityId: string,
    options: Parameters<typeof Transaction.listAllTransactionsByEntity>[1] = {},
): Promise<ReturnType<typeof Transaction.listAllTransactionsByEntity>> => {
    return Transaction.listAllTransactionsByEntity(entityId, options);
};

// After all the existing exports, add this class for backward compatibility
export class TransactionService {
    static async createTransaction(transaction: any): Promise<Transaction> {
        const {
            type,
            amount,
            currency,
            status,
            // Unused parameters, kept for backward compatibility
            // primaryEntityId,
            // primaryEntityType,
            senderEntityId,
            sender_entity_type,
            sender_name,
            recipientEntityId,
            recipient_entity_type,
            recipient_name,
            memo,
        } = transaction;

        const newTransaction = new Transaction(type, amount, currency || 'USD', status, {
            sender: senderEntityId
                ? {
                      id: senderEntityId,
                      type: (sender_entity_type as EntityType) || 'USER',
                      name: sender_name,
                  }
                : undefined,
            receiver: recipientEntityId
                ? {
                      id: recipientEntityId,
                      type: (recipient_entity_type as EntityType) || 'USER',
                      name: recipient_name,
                  }
                : undefined,
            metadata: memo ? { description: memo } : undefined,
        });

        await newTransaction.create();
        return newTransaction;
    }

    static async updateTransaction(
        transactionId: string,
        updates: Partial<Omit<Transaction, 'transactionId' | 'createdAt'>>,
    ): Promise<Transaction> {
        const transaction = await getTransactionById(transactionId);

        // Apply all updates to the transaction object
        Object.assign(transaction, updates);

        // Save changes
        await transaction.update();
        return transaction;
    }

    static async getTransaction(transactionId: string): Promise<Transaction | null> {
        try {
            return await getTransactionById(transactionId);
        } catch (error) {
            return null;
        }
    }

    static async getUserTransactions(userId: string, limit = 50): Promise<Transaction[]> {
        const result = await listEntityTransactions(userId, 'USER', { limit });
        return result.transactions;
    }

    static async createDeposit(
        entityId: string,
        type: EntityType,
        status: TransactionStatus,
        amount: string,
        senderId: string,
    ): Promise<Transaction> {
        return createDeposit(entityId, type, amount, status, senderId);
    }

    static createWithdrawal(
        senderId: string,
        senderType: EntityType,
        status: TransactionStatus,
        amount: string,
        receiverId: string,
        receiverType: EntityType,
        options: {
            senderName?: string;
            providerType?: ProviderType;
            providerId?: string;
            providerTransactionId?: string;
            metadata?: any;
        } = {},
    ): Promise<Transaction> {
        return createWithdrawal(senderId, senderType, amount, receiverId, receiverType, status, options);
    }

    static async createTransfer(
        senderId: string,
        senderType: EntityType,
        status: TransactionStatus,
        amount: string,
        receiverId: string,
        receiverType: EntityType,
        options: {
            senderName?: string;
            receiverName?: string;
            metadata?: any;
        } = {},
    ): Promise<{ senderTransaction: Transaction; receiverTransaction: Transaction }> {
        return createTransfer(senderId, senderType, receiverId, receiverType, amount, status, {
            senderName: options.senderName,
            receiverName: options.receiverName,
            metadata: options.metadata,
        });
    }

    static async getTransactionsByProviderTransactionId(providerTransactionId: string): Promise<Transaction[]> {
        return Transaction.getByProviderTransactionId(providerTransactionId);
    }
}
</file>

<file path="layers/commons/data/entities/wallet.test.ts">
import {
    Wallet,
    WalletService,
    CurrencyCode,
    EntityType,
    createWallet,
    getWallet,
    getOrCreateWallet,
    adjustWalletBalance,
} from './wallet';
import { Money } from './money';
import {
    GetItemCommand,
    PutItemCommand,
    UpdateItemCommand,
    QueryCommand,
    TransactWriteItemsCommand,
} from '@aws-sdk/client-dynamodb';
import { v4 as uuidv4 } from 'uuid';

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn().mockReturnValue('mocked-uuid'),
}));

// Mock the AWS SDK client
jest.mock('../client', () => ({
    getClient: jest.fn().mockReturnValue({
        send: jest.fn(),
    }),
}));

// Import mocked module
import { getClient } from '../client';
const mockedGetClient = getClient as jest.MockedFunction<typeof getClient>;
const mockedSend = mockedGetClient().send as jest.MockedFunction<any>;

describe('Wallet', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    // Constructor tests
    describe('constructor', () => {
        it('should create a new Wallet instance with default values', () => {
            const wallet = new Wallet('user123', 'USER');

            expect(wallet.entityId).toBe('user123');
            expect(wallet.entityType).toBe('USER');
            expect(wallet.balance).toBe('0.00');
            expect(wallet.availableBalance).toBe('0.00');
            expect(wallet.pendingBalance).toBe('0.00');
            expect(wallet.currency).toBe('USD');
            expect(wallet.version).toBe(0);
            expect(wallet.walletId).toBe('mocked-uuid'); // From mocked uuid
            expect(wallet.createdAt).toBeDefined();
            expect(wallet.updatedAt).toBeDefined();
        });

        it('should create a Wallet instance with custom options', () => {
            const wallet = new Wallet('business123', 'BUSINESS', {
                walletId: 'custom-wallet-id',
                balance: '100.50',
                availableBalance: '75.25',
                pendingBalance: '25.25',
                currency: 'EUR',
                version: 5,
                createdAt: '2023-01-01T00:00:00Z',
                updatedAt: '2023-01-02T00:00:00Z',
            });

            expect(wallet.entityId).toBe('business123');
            expect(wallet.entityType).toBe('BUSINESS');
            expect(wallet.walletId).toBe('custom-wallet-id');
            expect(wallet.balance).toBe('100.50');
            expect(wallet.availableBalance).toBe('75.25');
            expect(wallet.pendingBalance).toBe('25.25');
            expect(wallet.currency).toBe('EUR');
            expect(wallet.version).toBe(5);
            expect(wallet.createdAt).toBe('2023-01-01T00:00:00Z');
            expect(wallet.updatedAt).toBe('2023-01-02T00:00:00Z');
        });
    });

    // Getter tests
    describe('getters', () => {
        it('should return the correct PK and SK values', () => {
            const wallet = new Wallet('user123', 'USER', {
                walletId: 'wallet123',
                currency: 'USD',
            });

            expect(wallet.pk).toBe('USER#user123');
            expect(wallet.sk).toBe('WALLET#USD');
            expect(wallet.gsi1pk).toBe('WALLET#wallet123');
            expect(wallet.gsi1sk).toBe('USER#user123');
            expect(wallet.gsi2pk).toBe('WALLET_CURRENCY#USD');
            expect(wallet.gsi2sk).toBe('BALANCE#0000000.00'); // Padded balance format
        });

        it('should convert balance to Money object', () => {
            const wallet = new Wallet('user123', 'USER', {
                balance: '100.50',
                currency: 'EUR',
            });

            const balanceMoney = wallet.getBalance();
            expect(balanceMoney).toBeInstanceOf(Money);
            expect(balanceMoney.toString()).toBe('100.50');
            expect(balanceMoney.currency).toBe('EUR');
        });

        it('should convert available balance to Money object', () => {
            const wallet = new Wallet('user123', 'USER', {
                availableBalance: '75.25',
                currency: 'EUR',
            });

            const availableBalanceMoney = wallet.getAvailableBalance();
            expect(availableBalanceMoney).toBeInstanceOf(Money);
            expect(availableBalanceMoney.toString()).toBe('75.25');
            expect(availableBalanceMoney.currency).toBe('EUR');
        });

        it('should convert pending balance to Money object', () => {
            const wallet = new Wallet('user123', 'USER', {
                pendingBalance: '25.25',
                currency: 'EUR',
            });

            const pendingBalanceMoney = wallet.getPendingBalance();
            expect(pendingBalanceMoney).toBeInstanceOf(Money);
            expect(pendingBalanceMoney.toString()).toBe('25.25');
            expect(pendingBalanceMoney.currency).toBe('EUR');
        });

        it('should pad balance correctly for sorting', () => {
            const wallet = new Wallet('user123', 'USER', {
                balance: '123.45',
            });

            expect(wallet.getPaddedBalance()).toBe('0000123.45');
        });
    });

    // sufficient funds test
    describe('hasSufficientFunds', () => {
        it('should return true when available balance is greater than required amount', () => {
            const wallet = new Wallet('user123', 'USER', {
                availableBalance: '100.00',
            });

            expect(wallet.hasSufficientFunds('50.00')).toBe(true);
            expect(wallet.hasSufficientFunds(new Money('50.00', 'USD'))).toBe(true);
        });

        it('should return true when available balance is equal to required amount', () => {
            const wallet = new Wallet('user123', 'USER', {
                availableBalance: '100.00',
            });

            expect(wallet.hasSufficientFunds('100.00')).toBe(true);
            expect(wallet.hasSufficientFunds(new Money('100.00', 'USD'))).toBe(true);
        });

        it('should return false when available balance is less than required amount', () => {
            const wallet = new Wallet('user123', 'USER', {
                availableBalance: '100.00',
            });

            expect(wallet.hasSufficientFunds('150.00')).toBe(false);
            expect(wallet.hasSufficientFunds(new Money('150.00', 'USD'))).toBe(false);
        });
    });

    // DynamoDB conversion tests
    describe('toDynamoItem and fromDynamoItem', () => {
        it('should convert wallet to DynamoDB item', () => {
            const wallet = new Wallet('user123', 'USER', {
                walletId: 'wallet123',
                balance: '100.50',
                availableBalance: '75.25',
                pendingBalance: '25.25',
                currency: 'EUR',
                version: 5,
                createdAt: '2023-01-01T00:00:00Z',
                updatedAt: '2023-01-02T00:00:00Z',
            });

            const item = wallet.toDynamoItem();

            expect(item.PK.S).toBe('USER#user123');
            expect(item.SK.S).toBe('WALLET#EUR');
            expect(item.GSI1PK.S).toBe('WALLET#wallet123');
            expect(item.GSI1SK.S).toBe('USER#user123');
            expect(item.GSI2PK.S).toBe('WALLET_CURRENCY#EUR');
            expect(item.GSI2SK.S).toBe('BALANCE#0000100.50');
            expect(item.entityId.S).toBe('user123');
            expect(item.entityType.S).toBe('USER');
            expect(item.walletId.S).toBe('wallet123');
            expect(item.balance.S).toBe('100.50');
            expect(item.availableBalance.S).toBe('75.25');
            expect(item.pendingBalance.S).toBe('25.25');
            expect(item.currency.S).toBe('EUR');
            expect(item.version.N).toBe('5');
            expect(item.createdAt.S).toBe('2023-01-01T00:00:00Z');
            expect(item.updatedAt.S).toBe('2023-01-02T00:00:00Z');
        });

        it('should convert DynamoDB item to wallet', () => {
            const item = {
                PK: { S: 'USER#user123' },
                SK: { S: 'WALLET#EUR' },
                GSI1PK: { S: 'WALLET#wallet123' },
                GSI1SK: { S: 'USER#user123' },
                GSI2PK: { S: 'WALLET_CURRENCY#EUR' },
                GSI2SK: { S: 'BALANCE#0000100.50' },
                id: { S: 'wallet123' },
                type: { S: 'WALLET' },
                entityId: { S: 'user123' },
                entityType: { S: 'USER' },
                walletId: { S: 'wallet123' },
                balance: { S: '100.50' },
                availableBalance: { S: '75.25' },
                pendingBalance: { S: '25.25' },
                currency: { S: 'EUR' },
                version: { N: '5' },
                createdAt: { S: '2023-01-01T00:00:00Z' },
                updatedAt: { S: '2023-01-02T00:00:00Z' },
            };

            const wallet = Wallet.fromDynamoItem(item);

            expect(wallet.entityId).toBe('user123');
            expect(wallet.entityType).toBe('USER');
            expect(wallet.walletId).toBe('wallet123');
            expect(wallet.balance).toBe('100.50');
            expect(wallet.availableBalance).toBe('75.25');
            expect(wallet.pendingBalance).toBe('25.25');
            expect(wallet.currency).toBe('EUR');
            expect(wallet.version).toBe(5);
            expect(wallet.createdAt).toBe('2023-01-01T00:00:00Z');
            expect(wallet.updatedAt).toBe('2023-01-02T00:00:00Z');
        });

        it('should throw error when item is undefined', () => {
            expect(() => Wallet.fromDynamoItem(undefined as any)).toThrow('No wallet item found!');
        });
    });

    describe('ledger item creation', () => {
        it('should create a properly formatted ledger item', () => {
            const wallet = new Wallet('user123', 'USER', {
                walletId: 'wallet123',
                currency: 'USD',
            });

            // Mock date for consistent testing
            const originalDate = global.Date;
            const mockDate = new Date('2023-01-01T00:00:00Z');
            global.Date = class extends Date {
                constructor() {
                    super();
                    return mockDate;
                }
                static now() {
                    return mockDate.getTime();
                }
                toISOString() {
                    return mockDate.toISOString();
                }
            } as any;

            const ledgerItem = wallet.createLedgerItem(
                50.25,
                'CREDIT',
                '100.00',
                '150.25',
                'txn-123',
                'Test transaction',
            );

            // Restore original Date
            global.Date = originalDate;

            expect(ledgerItem.PK.S).toBe('USER#user123');
            expect(ledgerItem.SK.S).toBe('LEDGER#2023-01-01T00:00:00Z#txn-123');
            expect(ledgerItem.GSI1PK.S).toBe('TXN#txn-123');
            expect(ledgerItem.GSI1SK.S).toBe('LEDGER#user123');
            expect(ledgerItem.GSI3PK.S).toBe('USER#user123');
            expect(ledgerItem.GSI3SK.S).toBe('DATE#2023-01-01#LEDGER#2023-01-01T00:00:00Z');
            expect(ledgerItem.id.S).toBe('user123_txn-123_2023-01-01T00:00:00Z');
            expect(ledgerItem.type.S).toBe('LEDGER');
            expect(ledgerItem.entityId.S).toBe('user123');
            expect(ledgerItem.walletId.S).toBe('wallet123');
            expect(ledgerItem.amount.S).toBe('50.25');
            expect(ledgerItem.operationType.S).toBe('CREDIT');
            expect(ledgerItem.balanceBefore.S).toBe('100.00');
            expect(ledgerItem.balanceAfter.S).toBe('150.25');
            expect(ledgerItem.description.S).toBe('Test transaction');
            expect(ledgerItem.currency.S).toBe('USD');
            expect(ledgerItem.transactionId.S).toBe('txn-123');
            expect(ledgerItem.createdAt.S).toBe('2023-01-01T00:00:00Z');
        });
    });

    // WalletService tests
    describe('WalletService', () => {
        // Mock dates for consistent testing
        const mockDate = new Date('2023-01-01T00:00:00Z');
        let originalDate: DateConstructor;

        beforeEach(() => {
            originalDate = global.Date;
            global.Date = class extends Date {
                constructor() {
                    super();
                    return mockDate;
                }
                static now() {
                    return mockDate.getTime();
                }
                toISOString() {
                    return mockDate.toISOString();
                }
            } as DateConstructor;

            // Set up environment variables
            process.env.TABLE_NAME = 'TestTable';
        });

        afterEach(() => {
            global.Date = originalDate;
            delete process.env.TABLE_NAME;
        });

        it('should create a wallet in the database', async () => {
            mockedSend.mockResolvedValueOnce({});

            const wallet = await WalletService.createWallet('user123', 'USER', 'USD');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Item: expect.objectContaining({
                            PK: { S: 'USER#user123' },
                            SK: { S: 'WALLET#USD' },
                        }),
                        ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                    }),
                }),
            );

            expect(wallet.entityId).toBe('user123');
            expect(wallet.entityType).toBe('USER');
            expect(wallet.currency).toBe('USD');
            expect(wallet.balance).toBe('0.00');
        });

        it('should throw error when create fails', async () => {
            const error = new Error('DynamoDB error');
            mockedSend.mockRejectedValueOnce(error);

            await expect(WalletService.createWallet('user123', 'USER')).rejects.toThrow(error);

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should get a wallet from the database', async () => {
            mockedSend.mockResolvedValueOnce({
                Item: {
                    PK: { S: 'USER#user123' },
                    SK: { S: 'WALLET#USD' },
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    walletId: { S: 'wallet123' },
                    balance: { S: '100.00' },
                    availableBalance: { S: '100.00' },
                    pendingBalance: { S: '0.00' },
                    currency: { S: 'USD' },
                    version: { N: '1' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                    updatedAt: { S: '2023-01-01T00:00:00Z' },
                },
            });

            const wallet = await WalletService.getWallet('user123', 'USER', 'USD');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        Key: {
                            PK: { S: 'USER#user123' },
                            SK: { S: 'WALLET#USD' },
                        },
                    }),
                }),
            );

            expect(wallet).toBeInstanceOf(Wallet);
            expect(wallet?.entityId).toBe('user123');
            expect(wallet?.walletId).toBe('wallet123');
            expect(wallet?.balance).toBe('100.00');
        });

        it('should return null when wallet is not found', async () => {
            mockedSend.mockResolvedValueOnce({
                Item: undefined,
            });

            const wallet = await WalletService.getWallet('user123', 'USER', 'USD');

            expect(wallet).toBeNull();
            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalled();
        });

        it('should deposit to a wallet', async () => {
            // Mock getting existing wallet
            mockedSend.mockResolvedValueOnce({
                Item: {
                    PK: { S: 'USER#user123' },
                    SK: { S: 'WALLET#USD' },
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    walletId: { S: 'wallet123' },
                    balance: { S: '100.00' },
                    availableBalance: { S: '100.00' },
                    pendingBalance: { S: '0.00' },
                    currency: { S: 'USD' },
                    version: { N: '1' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                    updatedAt: { S: '2023-01-01T00:00:00Z' },
                },
            });

            // Mock the update and ledger writes
            mockedSend.mockResolvedValueOnce({});
            mockedSend.mockResolvedValueOnce({});

            const wallet = await WalletService.deposit('user123', 'USER', 50, 'txn-123', 'USD');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledTimes(3);

            // Verify the update operation
            expect(mockedSend.mock.calls[1][0].input.Key).toEqual({
                PK: { S: 'USER#user123' },
                SK: { S: 'WALLET#USD' },
            });

            // Check wallet properties
            expect(wallet.balance).toBe('150.00');
            expect(wallet.availableBalance).toBe('150.00');
            expect(wallet.lastTransactionId).toBe('txn-123');
            expect(wallet.version).toBe(2);
        });

        it('should withdraw from a wallet', async () => {
            // Mock getting existing wallet
            mockedSend.mockResolvedValueOnce({
                Item: {
                    PK: { S: 'USER#user123' },
                    SK: { S: 'WALLET#USD' },
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    walletId: { S: 'wallet123' },
                    balance: { S: '100.00' },
                    availableBalance: { S: '100.00' },
                    pendingBalance: { S: '0.00' },
                    currency: { S: 'USD' },
                    version: { N: '1' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                    updatedAt: { S: '2023-01-01T00:00:00Z' },
                },
            });

            // Mock the update and ledger writes
            mockedSend.mockResolvedValueOnce({});
            mockedSend.mockResolvedValueOnce({});

            const wallet = await WalletService.withdraw('user123', 'USER', 50, 'txn-123', 'USD');

            expect(mockedGetClient).toHaveBeenCalled();
            expect(mockedSend).toHaveBeenCalledTimes(3);

            // Verify the update operation
            expect(mockedSend.mock.calls[1][0].input.Key).toEqual({
                PK: { S: 'USER#user123' },
                SK: { S: 'WALLET#USD' },
            });

            // Check wallet properties
            expect(wallet.balance).toBe('50.00');
            expect(wallet.availableBalance).toBe('50.00');
            expect(wallet.lastTransactionId).toBe('txn-123');
            expect(wallet.version).toBe(2);
        });

        it('should throw error for insufficient funds during withdrawal', async () => {
            // Mock getting existing wallet with low balance
            mockedSend.mockResolvedValueOnce({
                Item: {
                    PK: { S: 'USER#user123' },
                    SK: { S: 'WALLET#USD' },
                    entityId: { S: 'user123' },
                    entityType: { S: 'USER' },
                    walletId: { S: 'wallet123' },
                    balance: { S: '30.00' },
                    availableBalance: { S: '30.00' },
                    pendingBalance: { S: '0.00' },
                    currency: { S: 'USD' },
                    version: { N: '1' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                    updatedAt: { S: '2023-01-01T00:00:00Z' },
                },
            });

            await expect(WalletService.withdraw('user123', 'USER', 50, 'txn-123', 'USD')).rejects.toThrow(
                'Insufficient funds',
            );

            // Should get the wallet but not try to update it
            expect(mockedSend).toHaveBeenCalledTimes(1);
        });

        it('should transfer between wallets', async () => {
            // Mock sender withdrawal (get + update + ledger)
            mockedSend.mockResolvedValueOnce({
                Item: {
                    PK: { S: 'USER#sender123' },
                    SK: { S: 'WALLET#USD' },
                    entityId: { S: 'sender123' },
                    entityType: { S: 'USER' },
                    walletId: { S: 'wallet-sender' },
                    balance: { S: '100.00' },
                    availableBalance: { S: '100.00' },
                    pendingBalance: { S: '0.00' },
                    currency: { S: 'USD' },
                    version: { N: '1' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                    updatedAt: { S: '2023-01-01T00:00:00Z' },
                },
            });
            mockedSend.mockResolvedValueOnce({});
            mockedSend.mockResolvedValueOnce({});

            // Mock receiver deposit (get + create + update + ledger)
            mockedSend.mockResolvedValueOnce({
                Item: {
                    PK: { S: 'USER#receiver123' },
                    SK: { S: 'WALLET#USD' },
                    entityId: { S: 'receiver123' },
                    entityType: { S: 'USER' },
                    walletId: { S: 'wallet-receiver' },
                    balance: { S: '50.00' },
                    availableBalance: { S: '50.00' },
                    pendingBalance: { S: '0.00' },
                    currency: { S: 'USD' },
                    version: { N: '1' },
                    createdAt: { S: '2023-01-01T00:00:00Z' },
                    updatedAt: { S: '2023-01-01T00:00:00Z' },
                },
            });
            mockedSend.mockResolvedValueOnce({});
            mockedSend.mockResolvedValueOnce({});

            // Mock transfer record creation
            mockedSend.mockResolvedValueOnce({});

            const result = await WalletService.transfer(
                'sender123',
                'USER',
                'receiver123',
                'USER',
                50.0,
                'sender-txn-123',
                'receiver-txn-123',
                'USD',
            );

            expect(result.senderWallet.balance).toBe('50.00');
            expect(result.receiverWallet.balance).toBe('100.00');

            // Check that all the expected operations were called
            expect(mockedSend).toHaveBeenCalledTimes(7);
        });

        it('should find wallets by balance range', async () => {
            // Mock the query response
            mockedSend.mockResolvedValueOnce({
                Items: [
                    {
                        PK: { S: 'USER#user1' },
                        SK: { S: 'WALLET#USD' },
                        entityId: { S: 'user1' },
                        entityType: { S: 'USER' },
                        walletId: { S: 'wallet1' },
                        balance: { S: '200.00' },
                        availableBalance: { S: '200.00' },
                        pendingBalance: { S: '0.00' },
                        currency: { S: 'USD' },
                        version: { N: '1' },
                        createdAt: { S: '2023-01-01T00:00:00Z' },
                        updatedAt: { S: '2023-01-01T00:00:00Z' },
                    },
                    {
                        PK: { S: 'USER#user2' },
                        SK: { S: 'WALLET#USD' },
                        entityId: { S: 'user2' },
                        entityType: { S: 'USER' },
                        walletId: { S: 'wallet2' },
                        balance: { S: '300.00' },
                        availableBalance: { S: '300.00' },
                        pendingBalance: { S: '0.00' },
                        currency: { S: 'USD' },
                        version: { N: '1' },
                        createdAt: { S: '2023-01-01T00:00:00Z' },
                        updatedAt: { S: '2023-01-01T00:00:00Z' },
                    },
                ],
            });

            const wallets = await WalletService.findWalletsByBalanceRange('USD', 100, 500);

            expect(wallets.length).toBe(2);
            expect(wallets[0].entityId).toBe('user1');
            expect(wallets[1].entityId).toBe('user2');

            // Verify the query operation
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        IndexName: 'GSI2',
                        KeyConditionExpression: 'GSI2PK = :currencyKey AND GSI2SK BETWEEN :minBal AND :maxBal',
                        ExpressionAttributeValues: {
                            ':currencyKey': { S: 'WALLET_CURRENCY#USD' },
                            ':minBal': { S: 'BALANCE#0000100.00' },
                            ':maxBal': { S: 'BALANCE#0000500.00' },
                        },
                    }),
                }),
            );
        });

        it('should get wallet transaction history', async () => {
            // Mock the query response
            mockedSend.mockResolvedValueOnce({
                Items: [
                    {
                        PK: { S: 'USER#user1' },
                        SK: { S: 'LEDGER#2023-01-01T00:00:00Z#txn1' },
                        type: { S: 'LEDGER' },
                        entityId: { S: 'user1' },
                        walletId: { S: 'wallet1' },
                        amount: { S: '50.00' },
                        operationType: { S: 'CREDIT' },
                        balanceBefore: { S: '100.00' },
                        balanceAfter: { S: '150.00' },
                        description: { S: 'Test transaction 1' },
                        createdAt: { S: '2023-01-01T00:00:00Z' },
                    },
                    {
                        PK: { S: 'USER#user1' },
                        SK: { S: 'LEDGER#2023-01-02T00:00:00Z#txn2' },
                        type: { S: 'LEDGER' },
                        entityId: { S: 'user1' },
                        walletId: { S: 'wallet1' },
                        amount: { S: '25.00' },
                        operationType: { S: 'DEBIT' },
                        balanceBefore: { S: '150.00' },
                        balanceAfter: { S: '125.00' },
                        description: { S: 'Test transaction 2' },
                        createdAt: { S: '2023-01-02T00:00:00Z' },
                    },
                ],
            });

            const history = await WalletService.getWalletHistory('user1', 'USER', '2023-01-01', '2023-01-03');

            expect(history.length).toBe(2);

            // Verify the query operation
            expect(mockedSend).toHaveBeenCalledWith(
                expect.objectContaining({
                    input: expect.objectContaining({
                        TableName: 'TestTable',
                        IndexName: 'GSI3',
                        KeyConditionExpression: 'GSI3PK = :entityKey AND GSI3SK BETWEEN :startDate AND :endDate',
                        ExpressionAttributeValues: {
                            ':entityKey': { S: 'USER#user1' },
                            ':startDate': { S: 'DATE#2023-01-01' },
                            ':endDate': { S: 'DATE#2023-01-03#LEDGER#z' },
                        },
                    }),
                }),
            );
        });
    });

    // Wallet instance method tests
    describe('Wallet instance methods', () => {
        const mockDate = new Date('2023-01-01T00:00:00Z');
        let originalDate: DateConstructor;

        beforeEach(() => {
            originalDate = global.Date;
            global.Date = class extends Date {
                constructor() {
                    super();
                    return mockDate;
                }
                static now() {
                    return mockDate.getTime();
                }
                toISOString() {
                    return mockDate.toISOString();
                }
            } as DateConstructor;

            process.env.TABLE_NAME = 'TestTable';
        });

        afterEach(() => {
            global.Date = originalDate;
            delete process.env.TABLE_NAME;
        });

        it('should hold funds (move from available to pending)', async () => {
            const wallet = new Wallet('user123', 'USER', {
                walletId: 'wallet123',
                balance: '100.00',
                availableBalance: '100.00',
                pendingBalance: '0.00',
                version: 1,
            });

            mockedSend.mockResolvedValueOnce({});
            mockedSend.mockResolvedValueOnce({});

            const updatedWallet = await wallet.holdFunds('50', 'Hold for purchase');

            // Check that balances are updated correctly
            expect(updatedWallet.availableBalance).toBe('50.00');
            expect(updatedWallet.pendingBalance).toBe('50.00');
            expect(updatedWallet.version).toBe(2);

            // Verify that the update was called with correct parameters
            expect(mockedSend).toHaveBeenCalledTimes(2);
            expect(mockedSend.mock.calls[0][0].input.Key).toEqual({
                PK: { S: 'USER#user123' },
                SK: { S: 'WALLET#USD' },
            });
        });

        it('should throw error if insufficient funds for hold', async () => {
            const wallet = new Wallet('user123', 'USER', {
                walletId: 'wallet123',
                balance: '100.00',
                availableBalance: '30.00', // Less than requested hold
                pendingBalance: '70.00',
                version: 1,
            });

            await expect(wallet.holdFunds('50.00', 'Hold for payment')).rejects.toThrow(
                'Insufficient available balance for hold',
            );

            expect(mockedSend).not.toHaveBeenCalled();
        });

        it('should release held funds (move from pending to available)', async () => {
            const wallet = new Wallet('user123', 'USER', {
                walletId: 'wallet123',
                balance: '100.00',
                availableBalance: '70.00',
                pendingBalance: '30.00',
                version: 1,
            });

            mockedSend.mockResolvedValueOnce({});
            mockedSend.mockResolvedValueOnce({});

            const updatedWallet = await wallet.releaseFunds('30', 'Release hold');

            // Check that balances are updated correctly
            expect(updatedWallet.availableBalance).toBe('100.00');
            expect(updatedWallet.pendingBalance).toBe('0.00');
            expect(updatedWallet.version).toBe(2);

            // Verify that the update was called with correct parameters
            expect(mockedSend).toHaveBeenCalledTimes(2);
        });

        it('should throw error if insufficient pending balance for release', async () => {
            const wallet = new Wallet('user123', 'USER', {
                walletId: 'wallet123',
                balance: '100.00',
                availableBalance: '80.00',
                pendingBalance: '20.00', // Less than requested release
                version: 1,
            });

            await expect(wallet.releaseFunds('30.00', 'Release hold')).rejects.toThrow(
                'Insufficient pending balance for release',
            );

            expect(mockedSend).not.toHaveBeenCalled();
        });
    });

    // Convenience function tests
    describe('Convenience functions', () => {
        beforeEach(() => {
            jest.spyOn(WalletService, 'createWallet').mockImplementation(async (entityId, entityType, currency) => {
                return new Wallet(entityId, entityType, {
                    currency,
                    walletId: 'mock-wallet-id',
                });
            });

            jest.spyOn(WalletService, 'getWallet').mockImplementation(async (entityId, entityType, currency) => {
                if (entityId === 'existing-user') {
                    return new Wallet(entityId, entityType, {
                        currency,
                        walletId: 'existing-wallet-id',
                        balance: '100.00',
                    });
                }
                return null;
            });

            jest.spyOn(WalletService, 'deposit').mockImplementation(
                async (entityId, entityType, amount, txnId, currency) => {
                    return new Wallet(entityId, entityType, {
                        currency,
                        balance: amount.toString(),
                        availableBalance: amount.toString(),
                    });
                },
            );

            jest.spyOn(WalletService, 'withdraw').mockImplementation(
                async (entityId, entityType, amount, txnId, currency) => {
                    return new Wallet(entityId, entityType, {
                        currency,
                        balance: '50.00', // After withdrawal
                        availableBalance: '50.00',
                    });
                },
            );
        });

        afterEach(() => {
            jest.restoreAllMocks();
        });

        it('should create a wallet using createWallet function', async () => {
            const wallet = await createWallet('user123', 'USER', { currency: 'EUR' });

            expect(WalletService.createWallet).toHaveBeenCalledWith('user123', 'USER', 'EUR');
            expect(wallet.entityId).toBe('user123');
            expect(wallet.entityType).toBe('USER');
            expect(wallet.currency).toBe('EUR');
        });

        it('should get a wallet using getWallet function', async () => {
            const wallet = await getWallet('existing-user', 'USER', 'USD');

            expect(WalletService.getWallet).toHaveBeenCalledWith('existing-user', 'USER', 'USD');
            expect(wallet?.entityId).toBe('existing-user');
            expect(wallet?.balance).toBe('100.00');
        });

        it('should get or create a wallet using getOrCreateWallet function', async () => {
            // First test with existing wallet
            const existingWallet = await getOrCreateWallet('existing-user', 'USER', 'USD');
            expect(WalletService.getWallet).toHaveBeenCalledWith('existing-user', 'USER', 'USD');
            expect(WalletService.createWallet).not.toHaveBeenCalled();
            expect(existingWallet.entityId).toBe('existing-user');

            // Reset mocks
            jest.clearAllMocks();

            // Test with non-existing wallet
            const newWallet = await getOrCreateWallet('new-user', 'USER', 'USD');
            expect(WalletService.getWallet).toHaveBeenCalledWith('new-user', 'USER', 'USD');
            expect(WalletService.createWallet).toHaveBeenCalledWith('new-user', 'USER', 'USD');
            expect(newWallet.entityId).toBe('new-user');
        });

        it('should adjust wallet balance with positive amount', async () => {
            const wallet = await adjustWalletBalance('user123', 'USER', 100, 'Test deposit', 'txn-123', 'USD');

            expect(WalletService.deposit).toHaveBeenCalledWith('user123', 'USER', 100, 'txn-123', 'USD');
            expect(wallet.balance).toBe('100');
        });

        it('should adjust wallet balance with negative amount', async () => {
            const wallet = await adjustWalletBalance('user123', 'USER', -50, 'Test withdrawal', 'txn-123', 'USD');

            expect(WalletService.withdraw).toHaveBeenCalledWith('user123', 'USER', 50, 'txn-123', 'USD');
            expect(wallet.balance).toBe('50.00');
        });

        it('should get or create wallet with zero amount', async () => {
            const wallet = await adjustWalletBalance('existing-user', 'USER', 0, 'No change', 'txn-123', 'USD');

            expect(WalletService.deposit).not.toHaveBeenCalled();
            expect(WalletService.withdraw).not.toHaveBeenCalled();
            expect(wallet.entityId).toBe('existing-user');
        });
    });
});
</file>

<file path="layers/commons/data/entities/wallet.ts">
import {
    GetItemCommand,
    QueryCommand,
    PutItemCommand,
    TransactWriteItemsCommand,
    AttributeValue,
} from '@aws-sdk/client-dynamodb';
import { getClient } from '../client';
import { v4 as uuidv4 } from 'uuid';
import { Money } from './money';
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'wallet-service' });
const TABLE_NAME = process.env.TABLE_NAME || 'clkk-app-table-dev';

import { EntityTypeString as EntityType } from './entity';

/**
 * Normalize entity type to ensure case consistency
 * @param entityType - The entity type to normalize
 * @returns The normalized entity type (uppercase)
 */
function normalizeEntityType(entityType: string): string {
    return entityType.toUpperCase();
}
export type CurrencyCode = 'USD' | 'EUR' | 'GBP';

/**
 * Represents a wallet (balance container) for a user or business
 */
export class Wallet {
    walletId: string;
    entityId: string;
    entityType: EntityType;
    balance: string; // String representation of decimal
    availableBalance: string; // Balance available for transactions
    pendingBalance: string; // Balance pending settlement
    currency: CurrencyCode;
    version: number; // For optimistic concurrency control
    createdAt: string;
    updatedAt: string;
    lastTransactionId?: string;

    /**
     * Create a new Wallet instance
     */
    constructor(
        entityId: string,
        entityType: EntityType,
        options: {
            walletId?: string;
            balance?: string;
            availableBalance?: string;
            pendingBalance?: string;
            currency?: CurrencyCode;
            version?: number;
            lastTransactionId?: string;
            createdAt?: string;
            updatedAt?: string;
        } = {},
    ) {
        this.walletId = options.walletId || uuidv4();
        this.entityId = entityId;
        this.entityType = normalizeEntityType(entityType) as EntityType;
        this.balance = options.balance || '0.00';
        this.availableBalance = options.availableBalance || this.balance;
        this.pendingBalance = options.pendingBalance || '0.00';
        this.currency = options.currency || ('USD' as CurrencyCode);
        this.version = options.version || 0;
        this.lastTransactionId = options.lastTransactionId;

        const now = new Date().toISOString();
        this.createdAt = options.createdAt || now;
        this.updatedAt = options.updatedAt || now;
    }

    /**
     * Primary key for wallet record
     */
    get pk(): string {
        return `${normalizeEntityType(this.entityType)}#${this.entityId}`;
    }

    /**
     * Sort key for wallet record
     */
    get sk(): string {
        return `WALLET#${this.currency}`;
    }

    /**
     * GSI1 primary key for wallet lookup by ID
     */
    /**
     * WalletLookupKey - Used for looking up wallets by ID (GSI1-PK)
     */
    get walletLookupKey(): string {
        return `WALLET#${this.walletId}`;
    }

    /**
     * WalletEntityKey - Used for associating wallets with entities (GSI1-SK)
     */
    get walletEntityKey(): string {
        return `${normalizeEntityType(this.entityType)}#${this.entityId}`;
    }

    /**
     * CurrencyIndexKey - Used for looking up wallets by currency (GSI2-PK)
     */
    get currencyIndexKey(): string {
        return `WALLET_CURRENCY#${this.currency}`;
    }

    /**
     * BalanceSortKey - Used for sorting wallets by balance (GSI2-SK)
     */
    get balanceSortKey(): string {
        // Padded balance for range queries
        return `BALANCE#${this.getPaddedBalance()}`;
    }

    /**
     * EntityTimeKey - Used for entity-based time queries (GSI3-PK)
     * Matches the same key pattern as Transaction for consistent queries
     */
    get entityTimeKey(): string {
        return `${normalizeEntityType(this.entityType)}#${this.entityId}`;
    }

    /**
     * WalletTimeSortKey - Used for time-based sorting of wallet records (GSI3-SK)
     */
    get walletTimeSortKey(): string {
        const dateString = this.updatedAt.split('T')[0];
        return `WALLET#${this.currency}#${this.updatedAt}`;
    }

    /**
     * Get balance as Money object
     */
    getBalance(): Money {
        return new Money(this.balance, this.currency);
    }

    /**
     * Get available balance as Money object
     */
    getAvailableBalance(): Money {
        return new Money(this.availableBalance, this.currency);
    }

    /**
     * Get pending balance as Money object
     */
    getPendingBalance(): Money {
        return new Money(this.pendingBalance, this.currency);
    }

    /**
     * Get balance padded for sorting
     */
    getPaddedBalance(): string {
        return new Money(this.balance, this.currency).toString(2).padStart(10, '0');
    }

    /**
     * Check if wallet has sufficient available balance for a transaction
     */
    hasSufficientFunds(amount: Money | string | number): boolean {
        const requiredAmount = amount instanceof Money ? amount : new Money(amount, this.currency);

        return (
            this.getAvailableBalance().greaterThan(requiredAmount) || this.getAvailableBalance().equals(requiredAmount)
        );
    }

    /**
     * Convert wallet to DynamoDB item
     * Uses meaningful attribute names for GSIs instead of generic GSI1PK, GSI1SK, etc.
     */
    toDynamoItem(): Record<string, AttributeValue> {
        return {
            PK: { S: this.pk },
            SK: { S: this.sk },
            WalletLookupKey: { S: this.walletLookupKey },
            WalletEntityKey: { S: this.walletEntityKey },
            CurrencyIndexKey: { S: this.currencyIndexKey },
            BalanceSortKey: { S: this.balanceSortKey },
            EntityTimeKey: { S: this.entityTimeKey },
            WalletTimeSortKey: { S: this.walletTimeSortKey },

            id: { S: this.walletId },
            type: { S: 'WALLET' },
            entityId: { S: this.entityId },
            entityType: { S: normalizeEntityType(this.entityType) },
            walletId: { S: this.walletId },
            balance: { S: this.balance },
            availableBalance: { S: this.availableBalance },
            pendingBalance: { S: this.pendingBalance },
            currency: { S: this.currency },
            version: { N: this.version.toString() },

            createdAt: { S: this.createdAt },
            updatedAt: { S: this.updatedAt },
            ...(this.lastTransactionId && { lastTransactionId: { S: this.lastTransactionId } }),
        };
    }

    /**
     * Create ledger item for DynamoDB
     */
    /**
     * Create a ledger entry as a DynamoDB item
     * @param amount The amount involved in the operation
     * @param type The type of operation (e.g., DEPOSIT, WITHDRAWAL)
     * @param balanceBefore Balance before the operation
     * @param balanceAfter Balance after the operation
     * @param txnId Transaction ID associated with this ledger entry
     * @param description Human-readable description of the operation
     */
    createLedgerItem(
        amount: number,
        type: string,
        balanceBefore: string,
        balanceAfter: string,
        txnId: string,
        description: string,
    ): Record<string, AttributeValue> {
        const timestamp = new Date().toISOString();
        const dateString = timestamp.split('T')[0];

        return {
            PK: { S: this.pk },
            SK: { S: `LEDGER#${timestamp}#${txnId}` },

            TransactionLookupKey: { S: `TRANSACTION#${txnId}` },
            LedgerEntityKey: { S: `LEDGER#${this.entityId}` },

            // Entity-time based query support
            EntityTimeKey: { S: this.entityTimeKey },
            DateTimeSortKey: { S: `DATE#${dateString}#LEDGER#${timestamp}` },

            id: { S: `${this.entityId}_${txnId}_${timestamp}` },
            type: { S: 'LEDGER' },
            entityId: { S: this.entityId },
            walletId: { S: this.walletId },
            amount: { S: amount.toFixed(2) },
            operationType: { S: type },
            balanceBefore: { S: balanceBefore },
            balanceAfter: { S: balanceAfter },
            description: { S: description },
            currency: { S: this.currency },
            transactionId: { S: txnId },
            createdAt: { S: timestamp },
        };
    }

    /**
     * Create a wallet from DynamoDB item
     */
    static fromDynamoItem(item: Record<string, AttributeValue>): Wallet {
        if (!item) throw new Error('No wallet item found!');

        const entityId = item.entityId.S!;
        const entityType = item.entityType.S as EntityType;

        return new Wallet(entityId, entityType, {
            walletId: item.walletId.S,
            balance: item.balance.S,
            availableBalance: item.availableBalance.S,
            pendingBalance: item.pendingBalance.S,
            currency: item.currency.S as CurrencyCode,
            version: parseInt(item.version.N || '0'),
            lastTransactionId: item.lastTransactionId?.S,
            createdAt: item.createdAt.S,
            updatedAt: item.updatedAt.S,
        });
    }

    /**
     * Hold funds (move from available to pending)
     */
    async holdFunds(amount: Money | string | number, description: string, transactionId?: string): Promise<Wallet> {
        const client = getClient();
        const amountObj = amount instanceof Money ? amount : new Money(amount, this.currency);

        // Check if there are sufficient available funds
        if (!this.hasSufficientFunds(amountObj)) {
            throw new Error('Insufficient available balance for hold');
        }

        const timestamp = new Date().toISOString();
        const currentAvailableBalance = new Money(this.availableBalance, this.currency);
        const currentPendingBalance = new Money(this.pendingBalance, this.currency);

        // Calculate new balances (available decreases, pending increases)
        const newAvailableBalance = currentAvailableBalance.subtract(amountObj);
        const newPendingBalance = currentPendingBalance.add(amountObj);

        try {
            // Create the wallet update and ledger entry atomically using TransactWriteItems
            const txnId = transactionId || `hold_${uuidv4()}`;
            if (!this.entityId || !txnId) {
                logger.error('Cannot create hold ledger entry with empty keys', { entityId: this.entityId, txnId });
                throw new Error('Invalid key components for hold ledger entry');
            }

            // Prepare the ledger item
            const ledgerItem = this.createLedgerItem(
                amountObj.amount.toNumber(),
                'HOLD',
                currentAvailableBalance.toString(),
                newAvailableBalance.toString(),
                txnId,
                `Hold: ${description}`,
            );

            // Execute both operations atomically
            await client.send(
                new TransactWriteItemsCommand({
                    TransactItems: [
                        {
                            Update: {
                                TableName: TABLE_NAME,
                                Key: {
                                    PK: { S: this.pk },
                                    SK: { S: this.sk },
                                },
                                UpdateExpression:
                                    'SET availableBalance = :newAvailableBalance, pendingBalance = :newPendingBalance, ' +
                                    'updatedAt = :updatedAt, version = :newVersion, BalanceSortKey = :newBalanceSortKey',
                                ExpressionAttributeValues: {
                                    ':newAvailableBalance': { S: newAvailableBalance.toString() },
                                    ':newPendingBalance': { S: newPendingBalance.toString() },
                                    ':updatedAt': { S: timestamp },
                                    ':newVersion': { N: (this.version + 1).toString() },
                                    ':currentVersion': { N: this.version.toString() },
                                    ':newBalanceSortKey': { S: `BALANCE#${this.getPaddedBalance()}` },
                                },
                                ConditionExpression: 'version = :currentVersion',
                            },
                        },
                        {
                            Put: {
                                TableName: TABLE_NAME,
                                Item: ledgerItem,
                            },
                        },
                    ],
                }),
            );

            // Update wallet object with new values
            this.availableBalance = newAvailableBalance.toString();
            this.pendingBalance = newPendingBalance.toString();
            this.version += 1;
            this.updatedAt = timestamp;

            return this;
        } catch (error) {
            logger.error('Error holding funds', {
                entityId: this.entityId,
                amount: amountObj.toString(),
                error: error instanceof Error ? error.message : 'Unknown error',
            });
            throw error;
        }
    }

    /**
     * Release held funds (move from pending back to available)
     */
    async releaseFunds(amount: Money | string | number, description: string, transactionId?: string): Promise<Wallet> {
        const client = getClient();
        const amountObj = amount instanceof Money ? amount : new Money(amount, this.currency);
        const pendingBalance = new Money(this.pendingBalance, this.currency);

        // Check if there are sufficient pending funds
        if (pendingBalance.lessThan(amountObj)) {
            throw new Error('Insufficient pending balance for release');
        }

        const timestamp = new Date().toISOString();
        const currentAvailableBalance = new Money(this.availableBalance, this.currency);

        // Calculate new balances (available increases, pending decreases)
        const newAvailableBalance = currentAvailableBalance.add(amountObj);
        const newPendingBalance = pendingBalance.subtract(amountObj);

        try {
            // Create the wallet update and ledger entry atomically using TransactWriteItems
            const txnId = transactionId || `release_${uuidv4()}`;
            if (!this.entityId || !txnId) {
                logger.error('Cannot create release ledger entry with empty keys', { entityId: this.entityId, txnId });
                throw new Error('Invalid key components for release ledger entry');
            }

            // Prepare the ledger item
            const ledgerItem = this.createLedgerItem(
                amountObj.amount.toNumber(),
                'RELEASE',
                currentAvailableBalance.toString(),
                newAvailableBalance.toString(),
                txnId,
                `Release: ${description}`,
            );

            // Execute both operations atomically
            await client.send(
                new TransactWriteItemsCommand({
                    TransactItems: [
                        {
                            Update: {
                                TableName: TABLE_NAME,
                                Key: {
                                    PK: { S: this.pk },
                                    SK: { S: this.sk },
                                },
                                UpdateExpression:
                                    'SET availableBalance = :newAvailableBalance, pendingBalance = :newPendingBalance, ' +
                                    'updatedAt = :updatedAt, version = :newVersion, BalanceSortKey = :newBalanceSortKey',
                                ExpressionAttributeValues: {
                                    ':newAvailableBalance': { S: newAvailableBalance.toString() },
                                    ':newPendingBalance': { S: newPendingBalance.toString() },
                                    ':updatedAt': { S: timestamp },
                                    ':newVersion': { N: (this.version + 1).toString() },
                                    ':currentVersion': { N: this.version.toString() },
                                    ':newBalanceSortKey': { S: `BALANCE#${this.getPaddedBalance()}` },
                                },
                                ConditionExpression: 'version = :currentVersion',
                            },
                        },
                        {
                            Put: {
                                TableName: TABLE_NAME,
                                Item: ledgerItem,
                            },
                        },
                    ],
                }),
            );

            // Update wallet object with new values
            this.availableBalance = newAvailableBalance.toString();
            this.pendingBalance = newPendingBalance.toString();
            this.version += 1;
            this.updatedAt = timestamp;

            return this;
        } catch (error) {
            logger.error('Error releasing funds', {
                entityId: this.entityId,
                amount: amountObj.toString(),
                error: error instanceof Error ? error.message : 'Unknown error',
            });
            throw error;
        }
    }
}

/**
 * Service class for managing wallets and balance operations
 */
export class WalletService {
    /**
     * Create a new wallet for an entity
     * @param entityId - ID of the entity (user/business)
     * @param entityType - Type of entity
     * @param currency - Currency for the wallet
     * @returns The created wallet
     */
    static async createWallet(
        entityId: string,
        entityType: EntityType,
        currency: CurrencyCode = 'USD',
    ): Promise<Wallet> {
        const normalizedEntityType = normalizeEntityType(entityType) as EntityType;
        logger.info('Creating wallet', { entityId, entityType: normalizedEntityType, currency });
        const client = getClient();

        // Validate that no key components are empty
        if (!entityId || !entityType) {
            logger.error('Cannot create wallet with empty keys', { entityId, entityType });
            throw new Error('Invalid key components for wallet');
        }

        const walletId = uuidv4();
        const now = new Date().toISOString();

        // Create a new Wallet instance with initial values
        const wallet = new Wallet(entityId, normalizedEntityType, {
            walletId,
            currency,
            balance: '0.00',
            availableBalance: '0.00',
            pendingBalance: '0.00',
            createdAt: now,
            updatedAt: now,
            version: 1,
        });

        try {
            // Format data for single-table design using AttributeValue format
            await client.send(
                new PutItemCommand({
                    TableName: TABLE_NAME,
                    Item: wallet.toDynamoItem(),
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                }),
            );

            logger.info('Wallet created successfully', {
                entityId,
                entityType,
                walletId,
            });

            return wallet;
        } catch (error) {
            logger.error('Error creating wallet', {
                entityId,
                entityType,
                error: error instanceof Error ? error.message : 'Unknown error',
            });
            throw error;
        }
    }

    /**
     * Get a wallet for an entity
     * @param entityId - ID of the entity
     * @param entityType - Type of entity
     * @param currency - Currency of the wallet
     * @returns The requested wallet or null if not found
     */
    static async getWallet(
        entityId: string,
        entityType: EntityType,
        currency: CurrencyCode = 'USD',
    ): Promise<Wallet | null> {
        const normalizedEntityType = normalizeEntityType(entityType) as EntityType;
        logger.info('Getting wallet', { entityId, entityType: normalizedEntityType, currency });
        const client = getClient();

        try {
            const result = await client.send(
                new GetItemCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: { S: `${normalizedEntityType}#${entityId}` },
                        SK: { S: `WALLET#${currency}` },
                    },
                }),
            );

            logger.info('Wallet get result', {
                hasWallet: !!result.Item,
            });

            if (!result.Item) {
                return null;
            }

            return Wallet.fromDynamoItem(result.Item);
        } catch (error) {
            logger.error('Error getting wallet', {
                entityId,
                entityType: normalizedEntityType,
                currency,
                error: error instanceof Error ? error.message : 'Unknown error',
            });
            return null;
        }
    }

    /**
     * Update a wallet balance with a deposit
     * @param entityId - ID of the entity
     * @param entityType - Type of entity
     * @param amount - Amount to add to balance
     * @param transactionId - ID of the transaction causing the update
     * @param currency - Currency of the wallet
     * @returns The updated wallet
     */
    static async deposit(
        entityId: string,
        entityType: EntityType,
        amount: string | number | Money,
        transactionId: string,
        currency: CurrencyCode = 'USD',
    ): Promise<Wallet> {
        const normalizedEntityType = normalizeEntityType(entityType) as EntityType;
        logger.info('Processing deposit to wallet', { entityId, entityType: normalizedEntityType, amount, transactionId });
        const client = getClient();

        // Get current wallet or create if it doesn't exist
        let wallet = await this.getWallet(entityId, normalizedEntityType, currency);
        if (!wallet) {
            logger.info('No wallet found, creating new wallet', { entityId, entityType, currency });
            wallet = await this.createWallet(entityId, normalizedEntityType, currency);
        }

        const amountObj = amount instanceof Money ? amount : new Money(amount, currency);
        const currentBalance = new Money(wallet.balance, currency);
        const newBalance = currentBalance.add(amountObj);
        const timestamp = new Date().toISOString();

        logger.info('Updating wallet balance', {
            entityId,
            amount: amountObj.toString(),
            currentBalance: currentBalance.toString(),
            newBalance: newBalance.toString(),
            transactionId,
        });

        try {
            // Prepare for atomic update of wallet and ledger entry
            if (!entityId || !transactionId) {
                logger.error('Cannot create ledger entry with empty keys', { entityId, transactionId });
                throw new Error('Invalid key components for ledger entry');
            }

            // Create ledger entry
            const ledgerItem = wallet.createLedgerItem(
                amountObj.amount.toNumber(),
                'CREDIT',
                currentBalance.toString(),
                newBalance.toString(),
                transactionId,
                `Deposit transaction ${transactionId}`,
            );

            // Perform wallet update and ledger creation in a single atomic transaction
            await client.send(
                new TransactWriteItemsCommand({
                    TransactItems: [
                        {
                            Update: {
                                TableName: TABLE_NAME,
                                Key: {
                                    PK: { S: `${normalizedEntityType}#${entityId}` },
                                    SK: { S: `WALLET#${currency}` },
                                },
                                UpdateExpression:
                                    'SET balance = :newBalance, availableBalance = :newBalance, ' +
                                    'lastTransactionId = :txnId, updatedAt = :updatedAt, version = :newVersion, ' +
                                    'BalanceSortKey = :newBalanceSortKey',
                                ExpressionAttributeValues: {
                                    ':newBalance': { S: newBalance.toString() },
                                    ':txnId': { S: transactionId },
                                    ':updatedAt': { S: timestamp },
                                    ':newVersion': { N: (wallet.version + 1).toString() },
                                    ':currentVersion': { N: wallet.version.toString() },
                                    ':newBalanceSortKey': { S: `BALANCE#${newBalance.toString(2).padStart(10, '0')}` },
                                },
                                ConditionExpression: 'version = :currentVersion',
                            },
                        },
                        {
                            Put: {
                                TableName: TABLE_NAME,
                                Item: ledgerItem,
                            },
                        },
                    ],
                }),
            );

            logger.info('Wallet balance updated and ledger entry created', {
                entityId,
                entityType,
                oldBalance: currentBalance.toString(),
                newBalance: newBalance.toString(),
                transactionId,
            });

            // Update wallet object
            wallet.balance = newBalance.toString();
            wallet.availableBalance = newBalance.toString();
            wallet.lastTransactionId = transactionId;
            wallet.updatedAt = timestamp;
            wallet.version = wallet.version + 1;

            return wallet;
        } catch (error) {
            logger.error('Error updating wallet balance', {
                entityId,
                entityType,
                currency,
                amount: amountObj.toString(),
                error: error instanceof Error ? error.message : 'Unknown error',
                errorStack: error instanceof Error ? error.stack : undefined,
            });
            throw error;
        }
    }

    /**
     * Update a wallet balance with a withdrawal
     * @param entityId - ID of the entity
     * @param entityType - Type of entity
     * @param amount - Amount to subtract from balance
     * @param transactionId - ID of the transaction causing the update
     * @param currency - Currency of the wallet
     * @returns The updated wallet
     * @throws Error if insufficient funds
     */
    static async withdraw(
        entityId: string,
        entityType: EntityType,
        amount: string | number | Money,
        transactionId: string,
        currency: CurrencyCode = 'USD',
    ): Promise<Wallet> {
        const normalizedEntityType = normalizeEntityType(entityType) as EntityType;
        logger.info('Processing withdrawal from wallet', { entityId, entityType: normalizedEntityType, amount, transactionId });
        const client = getClient();

        // Get wallet
        const wallet = await this.getWallet(entityId, normalizedEntityType, currency);
        if (!wallet) {
            throw new Error(`Wallet not found for ${normalizedEntityType} ${entityId}`);
        }

        const amountObj = amount instanceof Money ? amount : new Money(amount, currency);
        const currentBalance = new Money(wallet.balance, currency);

        // Check for sufficient funds using Money class comparison
        if (currentBalance.lessThan(amountObj)) {
            throw new Error('Insufficient funds');
        }

        const newBalance = currentBalance.subtract(amountObj);
        const timestamp = new Date().toISOString();

        logger.info('Updating wallet balance for withdrawal', {
            entityId,
            amount: amountObj.toString(),
            currentBalance: currentBalance.toString(),
            newBalance: newBalance.toString(),
            transactionId,
        });

        try {
            // Prepare for atomic update of wallet and ledger entry
            if (!entityId || !transactionId) {
                logger.error('Cannot create ledger entry with empty keys', { entityId, transactionId });
                throw new Error('Invalid key components for ledger entry');
            }

            // Create ledger entry
            const ledgerItem = wallet.createLedgerItem(
                amountObj.amount.toNumber(),
                'DEBIT',
                currentBalance.toString(),
                newBalance.toString(),
                transactionId,
                `Withdrawal transaction ${transactionId}`,
            );

            // Perform wallet update and ledger creation in a single atomic transaction
            await client.send(
                new TransactWriteItemsCommand({
                    TransactItems: [
                        {
                            Update: {
                                TableName: TABLE_NAME,
                                Key: {
                                    PK: { S: `${normalizedEntityType}#${entityId}` },
                                    SK: { S: `WALLET#${currency}` },
                                },
                                UpdateExpression:
                                    'SET balance = :newBalance, availableBalance = :newBalance, ' +
                                    'lastTransactionId = :txnId, updatedAt = :updatedAt, version = :newVersion, ' +
                                    'BalanceSortKey = :newBalanceSortKey',
                                ExpressionAttributeValues: {
                                    ':newBalance': { S: newBalance.toString() },
                                    ':txnId': { S: transactionId },
                                    ':updatedAt': { S: timestamp },
                                    ':currentBalance': { S: currentBalance.toString() },
                                    ':newVersion': { N: (wallet.version + 1).toString() },
                                    ':currentVersion': { N: wallet.version.toString() },
                                    ':newBalanceSortKey': { S: `BALANCE#${newBalance.toString(2).padStart(10, '0')}` },
                                },
                                ConditionExpression:
                                    'version = :currentVersion AND balance = :currentBalance AND attribute_exists(PK)',
                            },
                        },
                        {
                            Put: {
                                TableName: TABLE_NAME,
                                Item: ledgerItem,
                            },
                        },
                    ],
                }),
            );

            logger.info('Wallet balance updated for withdrawal and ledger entry created', {
                entityId,
                entityType,
                oldBalance: currentBalance.toString(),
                newBalance: newBalance.toString(),
                transactionId,
            });

            // Update wallet object
            wallet.balance = newBalance.toString();
            wallet.availableBalance = newBalance.toString();
            wallet.lastTransactionId = transactionId;
            wallet.updatedAt = timestamp;
            wallet.version = wallet.version + 1;

            return wallet;
        } catch (error) {
            logger.error('Error updating wallet balance for withdrawal', {
                entityId,
                entityType,
                amount: amountObj.toString(),
                error: error instanceof Error ? error.message : 'Unknown error',
            });
            throw error;
        }
    }

    /**
     * Transfer balance between two entities
     * @param senderId - ID of sending entity
     * @param senderType - Type of sending entity
     * @param receiverId - ID of receiving entity
     * @param receiverType - Type of receiving entity
     * @param amount - Amount to transfer
     * @param senderTransactionId - ID of sender's transaction
     * @param receiverTransactionId - ID of receiver's transaction
     * @param currency - Currency of the transfer
     * @returns Object containing both updated wallets
     */
    static async transfer(
        senderId: string,
        senderType: EntityType,
        receiverId: string,
        receiverType: EntityType,
        amount: number,
        senderTransactionId: string,
        receiverTransactionId: string,
        currency: CurrencyCode = 'USD',
    ): Promise<{ senderWallet: Wallet; receiverWallet: Wallet }> {
        const normalizedSenderType = normalizeEntityType(senderType) as EntityType;
        const normalizedReceiverType = normalizeEntityType(receiverType) as EntityType;
        logger.info('Processing transfer between wallets', {
            senderId,
            senderType: normalizedSenderType,
            receiverId,
            receiverType: normalizedReceiverType,
            amount,
            senderTransactionId,
            receiverTransactionId,
        });
        const client = getClient();
        const amountObj = new Money(amount, currency);

        // First withdraw from sender (will throw error if insufficient funds)
        const senderWallet = await this.withdraw(senderId, normalizedSenderType, amount, senderTransactionId, currency);

        // Then deposit to receiver
        const receiverWallet = await this.deposit(receiverId, normalizedReceiverType, amount, receiverTransactionId, currency);

        // Create a transfer record
        const transferId = uuidv4();
        const timestamp = new Date().toISOString();
        const dateString = timestamp.split('T')[0];

        try {
            // Validate that no key components are empty
            if (!senderId || !receiverId || !transferId) {
                logger.error('Cannot create transfer record with empty keys', {
                    senderId,
                    receiverId,
                    transferId,
                });
                throw new Error('Invalid key components for transfer record');
            }

            // Create transfer record - properly formatted for the single-table design
            await client.send(
                new PutItemCommand({
                    TableName: TABLE_NAME,
                    Item: {
                        PK: { S: `TRANSFER#${transferId}` },
                        SK: { S: `TRANSFER#${transferId}` },
                        // GSI1 for sender lookup
                        GSI1PK: { S: `${normalizedSenderType}#${senderId}` },
                        GSI1SK: { S: `TRANSFER#${timestamp}` },
                        // GSI2 for recipient lookup
                        GSI2PK: { S: `${normalizedReceiverType}#${receiverId}` },
                        GSI2SK: { S: `TRANSFER#${timestamp}` },
                        // GSI3 for date-based queries
                        GSI3PK: { S: `TRANSFER` },
                        GSI3SK: { S: `DATE#${dateString}#${timestamp}` },

                        id: { S: transferId },
                        type: { S: 'TRANSFER' },
                        transferId: { S: transferId },
                        senderId: { S: senderId },
                        senderType: { S: normalizedSenderType },
                        senderTransactionId: { S: senderTransactionId },
                        receiverId: { S: receiverId },
                        receiverType: { S: normalizedReceiverType },
                        receiverTransactionId: { S: receiverTransactionId },
                        amount: { S: amountObj.toString() },
                        currency: { S: currency },
                        status: { S: 'COMPLETED' },
                        description: { S: `Transfer from ${senderId} to ${receiverId}` },
                        createdAt: { S: timestamp },
                        completedAt: { S: timestamp },
                    },
                }),
            );

            logger.info('Transfer record created', { transferId });
        } catch (error) {
            logger.error('Error creating transfer record', {
                transferId,
                error: error instanceof Error ? error.message : 'Unknown error',
            });
            // The actual transfer already happened, so we don't throw here
        }

        return { senderWallet, receiverWallet };
    }

    /**
     * Get the current balance for an entity
     * @param entityId - ID of the entity
     * @param entityType - Type of entity
     * @param currency - Currency of the wallet
     * @returns Current balance as a Money object
     */
    static async getBalance(entityId: string, entityType: EntityType, currency: CurrencyCode = 'USD'): Promise<Money> {
        const normalizedEntityType = normalizeEntityType(entityType) as EntityType;
        const wallet = await this.getWallet(entityId, normalizedEntityType, currency);
        return wallet ? new Money(wallet.balance, currency) : new Money(0, currency);
    }

    /**
     * Find wallets with balance in range
     * @param currency - Currency to filter by
     * @param minBalance - Minimum balance
     * @param maxBalance - Maximum balance
     * @param limit - Maximum number of results
     * @returns Array of wallets matching criteria
     */
    static async findWalletsByBalanceRange(
        currency: CurrencyCode,
        minBalance: number,
        maxBalance: number,
        limit = 20,
    ): Promise<Wallet[]> {
        const client = getClient();

        const minBalancePadded = minBalance.toFixed(2).padStart(10, '0');
        const maxBalancePadded = maxBalance.toFixed(2).padStart(10, '0');

        try {
            const response = await client.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'GSI2',
                    KeyConditionExpression: 'GSI2PK = :currencyKey AND GSI2SK BETWEEN :minBal AND :maxBal',
                    ExpressionAttributeValues: {
                        ':currencyKey': { S: `WALLET_CURRENCY#${currency}` },
                        ':minBal': { S: `BALANCE#${minBalancePadded}` },
                        ':maxBal': { S: `BALANCE#${maxBalancePadded}` },
                    },
                    Limit: limit,
                }),
            );

            return (response.Items || []).map((item) => Wallet.fromDynamoItem(item));
        } catch (error) {
            logger.error('Error finding wallets by balance range', {
                currency,
                minBalance,
                maxBalance,
                error: error instanceof Error ? error.message : 'Unknown error',
            });
            return [];
        }
    }

    /**
     * Get wallet transaction history
     * @param entityId - ID of the entity
     * @param entityType - Type of entity
     * @param startDate - Start date in YYYY-MM-DD format
     * @param endDate - End date in YYYY-MM-DD format
     * @param limit - Maximum number of results
     * @returns Array of ledger entries
     */
    static async getWalletHistory(
        entityId: string,
        entityType: EntityType,
        startDate: string,
        endDate: string,
        limit = 50,
    ): Promise<any[]> {
        const client = getClient();

        try {
            const response = await client.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'GSI3',
                    KeyConditionExpression: 'GSI3PK = :entityKey AND GSI3SK BETWEEN :startDate AND :endDate',
                    ExpressionAttributeValues: {
                        ':entityKey': { S: `${normalizeEntityType(entityType)}#${entityId}` },
                        ':startDate': { S: `DATE#${startDate}` },
                        ':endDate': { S: `DATE#${endDate}#LEDGER#z` },
                    },
                    ScanIndexForward: false, // Most recent first
                    Limit: limit,
                }),
            );

            return response.Items || [];
        } catch (error) {
            logger.error('Error getting wallet history', {
                entityId,
                entityType,
                startDate,
                endDate,
                error: error instanceof Error ? error.message : 'Unknown error',
            });
            return [];
        }
    }
}

// Convenience functions

/**
 * Create a new wallet for an entity
 */
export const createWallet = async (
    entityId: string,
    entityType: string,
    options: {
        currency?: string;
        initialBalance?: string;
    } = {},
): Promise<Wallet> => {
    return WalletService.createWallet(entityId, entityType as EntityType, (options.currency || 'USD') as CurrencyCode);
};

/**
 * Get a wallet
 */
export const getWallet = async (entityId: string, entityType: string, currency = 'USD'): Promise<Wallet | null> => {
    const normalizedEntityType = normalizeEntityType(entityType) as EntityType;
    return WalletService.getWallet(entityId, normalizedEntityType, currency as CurrencyCode);
};

/**
 * Helper function to get the wallet service instance
 * Used to avoid circular dependencies when importing from other modules
 */
export function getWalletService(): WalletService {
    return new WalletService();
}

/**
 * Get or create an entity's wallet
 */
export const getOrCreateWallet = async (entityId: string, entityType: string, currency = 'USD'): Promise<Wallet> => {
    const normalizedEntityType = normalizeEntityType(entityType) as EntityType;
    const wallet = await getWallet(entityId, normalizedEntityType, currency);

    if (wallet) {
        return wallet;
    }

    return WalletService.createWallet(entityId, normalizedEntityType, currency as CurrencyCode);
};

/**
 * Adjust wallet balance
 */
export const adjustWalletBalance = async (
    entityId: string,
    entityType: string,
    amount: string | number,
    description: string,
    transactionId: string,
    currency = 'USD',
): Promise<Wallet> => {
    const normalizedEntityType = normalizeEntityType(entityType) as EntityType;
    const amountObj = new Money(amount, currency);

    if (amountObj.isPositive()) {
        return WalletService.deposit(
            entityId,
            normalizedEntityType,
            amountObj.toString(),
            transactionId,
            currency as CurrencyCode,
        );
    } else if (amountObj.isNegative()) {
        return WalletService.withdraw(
            entityId,
            normalizedEntityType,
            amountObj.abs().toString(),
            transactionId,
            currency as CurrencyCode,
        );
    }

    // If amount is 0, just return the current wallet
    return getOrCreateWallet(entityId, entityType, currency);
};
</file>

<file path="layers/commons/data/base.ts">
import { AttributeValue } from '@aws-sdk/client-dynamodb';

export abstract class Item {
    abstract get pk(): string;
    abstract get sk(): string;

    public keys(): Record<string, AttributeValue> {
        return {
            PK: { S: this.pk },
            SK: { S: this.sk },
        };
    }

    abstract toItem(): Record<string, unknown>;
}
</file>

<file path="layers/commons/data/client.ts">
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";

let client: DynamoDBClient | null = null;

export const getClient = (): DynamoDBClient => {
  if (client) return client;
  
  // AWS SDK v3 configuration
  client = new DynamoDBClient({
    region: process.env.AWS_REGION || 'us-east-1',
    maxAttempts: 3
  });
  
  return client;
};
</file>

<file path="layers/commons/data/README.md">
# Data Layer

This module provides the data access layer for the CLKK application. It implements a single-table design pattern for DynamoDB with properly structured access patterns for different entity types.

## DynamoDB Single-Table Design

The application uses a single-table approach with appropriate key design and Global Secondary Indexes (GSIs) for efficient access patterns.

### Key Structure

- **PK**: Entity type and ID (e.g., `USER#123`, `BUSINESS#456`, `TRANSACTION#789`)
- **SK**: Context-specific identifier to enable various access patterns

### GSI Structure with Meaningful Naming

We use meaningful attribute names for our GSIs rather than generic names like GSI1PK, GSI2PK, etc. This provides better readability, flexibility, and maintainability.

| Index Name               | Partition Key            | Sort Key              | Purpose                                           |
| ------------------------ | ------------------------ | --------------------- | ------------------------------------------------- |
| EntityTypeIndex          | EntityTypeKey            | EntityStatusSortKey   | Query entities by type, status, and role          |
| EmailIndex               | EmailLookupKey           | EmailValue            | Email-based lookups                               |
| PhoneIndex               | PhoneLookupKey           | PhoneValue            | Phone number lookups                              |
| KYCStatusIndex           | KYCStatusKey             | EntityTypeIdKey       | Query entities by KYC status                      |
| UsernameIndex            | UsernameIndexKey         | UsernameIndexValue    | Username-based searches and lookups               |
| TransactionIndex         | TransactionLookupKey     | TransactionDetailsKey | Transaction lookups                               |
| EntityTimeIndex          | EntityTimeKey            | TimeSortKey           | Entity time-based queries (transactions, history) |
| ProviderTimeIndex        | ProviderTimeKey          | ProviderTimeSortKey   | Provider time-based queries                       |
| ExternalIdIndex          | ExternalIdKey            | ProviderIdKey         | External provider transaction ID lookups          |
| ProviderTransactionIndex | ProviderTransactionIdKey | -                     | Direct lookup by provider transaction ID          |

### Access Patterns

Our data model supports the following access patterns:

#### Entity Access Patterns

1. **Get entity by ID**: Direct lookup on the main table with PK=`[TYPE]#[ID]` and SK=`PROFILE`
2. **Get entity by email**: Query the EmailIndex or use the email lookup item
3. **Get entity by phone number**: Query the PhoneIndex or use the phone lookup item
4. **Get entity by username**: Query the UsernameIndex or use the username lookup item
5. **List entities by type and status**: Query the EntityTypeIndex
6. **List entities by KYC status**: Query the KYCStatusIndex

#### Transaction Access Patterns

1. **Get transaction by ID**: Direct lookup on the main table with PK=`TRANSACTION#[ID]` and SK=`DETAILS`
2. **Get transaction by ID for an entity**: Query with PK=`[ENTITY_TYPE]#[ENTITY_ID]` and SK=`TRANSACTION#[TRANSACTION_ID]`
3. **List transactions for an entity**: Query with PK=`[ENTITY_TYPE]#[ENTITY_ID]` and SK begins_with `TRANSACTION#`
4. **List transactions by date range**: Query EntityTimeIndex with EntityTimeKey=`[ENTITY_TYPE]#[ENTITY_ID]` and TimeSortKey between date values
5. **Get transactions by provider**: Query ProviderTimeIndex with ProviderTimeKey=`PROVIDER#[PROVIDER_ID]`
6. **Get transaction by external provider ID**: Query ExternalIdIndex with ExternalIdKey=`EXTERNAL#[PROVIDER_TRANSACTION_ID]`
7. **Get transaction by provider transaction ID directly**: Query ProviderTransactionIndex with ProviderTransactionIdKey=[PROVIDER_TRANSACTION_ID]

### Entity Types

The data layer currently supports the following entity types:

- **USER**: Individual user accounts
- **BUSINESS**: Business accounts

### Transaction Types

The data layer supports the following transaction types:

- **DEPOSIT**: Money added to a user or business account
- **WITHDRAWAL**: Money removed from a user or business account
- **P2P**: Person-to-person transfers
- **P2B**: Person-to-business transfers
- **TRADE**: Currency exchange transactions

### Lookup Strategy

For unique constraints (email, phone, username), we maintain separate lookup items that enable:

- Cheaper reads (GetItem vs. Query)
- Enforced uniqueness at write time
- Efficient direct lookups

## Best Practices

1. **Item Collection Size**: Be cautious of the 10GB limit per partition key
2. **GSI Projections**: Use appropriate projection type based on query needs
3. **Attribute Naming**: Use meaningful attribute names for GSI keys
4. **GSI Indexes**: Use meaningful index names that describe their purpose
5. **Consistency**: Always follow the established data model patterns

## Entity Classes

The data layer provides entity classes that handle the serialization and deserialization of data:

- `Entity`: Base class for all entity types

    - `toItem()`: Converts the entity to a DynamoDB item
    - `fromItem()`: Creates an entity from a DynamoDB item
    - CRUD operations (create, update, etc.)

- `Transaction`: Class for financial transactions
    - `toItem()`: Converts the transaction to a DynamoDB item
    - `toUserReferenceItem()`: Creates reference items for entity lookups
    - `toProviderReferenceItem()`: Creates reference items for provider lookups
    - CRUD operations (create, update, complete, fail, etc.)

## DynamoDB Performance Optimizations

We've implemented several optimizations to improve the scalability and performance of our single-table design:

### 1. Efficient Transaction History Access Pattern

Rather than creating separate reference items for each user's transaction history, we now:

- Store EntityTimeKey and TimeSortKey attributes directly on the transaction items
- Query the EntityTimeIndex to retrieve transaction histories
- This approach avoids the 10GB partition limit for users with high transaction volumes

### 2. Avoiding Hot Partitions

To prevent hot partitions on frequently used status values:

- Status index items are only created for non-COMPLETED transactions
- For analysis of completed transactions, we rely on export to S3 + Athena or Streams + Kinesis
- This approach distributes write operations more evenly across the table

### 3. Optimized List Queries

We've reduced the N+1 query pattern for transaction lists:

- All necessary list display attributes are projected in the relevant GSIs
- List queries can directly use the projected attributes without secondary lookups
- A fetchFullDetails option allows retrieving complete transaction details when needed

### 4. Direct Provider Transaction ID Lookups

We've added a dedicated index for efficient provider transaction ID lookups:

- ProviderTransactionIndex allows direct query by provider transaction ID
- This replaces the previous inefficient table scan operation

## Usage Examples

### Listing Transactions Efficiently

```typescript
// Efficiently list recent transactions for a user (using only projected attributes)
const { transactions } = await listEntityTransactions('user123', 'USER', {
    limit: 20,
});

// Get complete transaction details when needed
const { transactions: detailedTransactions } = await listEntityTransactions('user123', 'USER', {
    limit: 5,
    fetchFullDetails: true,
});
```

### Finding Transactions by Provider ID

```typescript
// Efficiently find transactions by provider transaction ID
const transactions = await getTransactionsByProviderTransactionId('provider-txn-123');
```

### Entity Example

```typescript
import { createUser, getEntityByEmail } from './entities/entity';

// Create a new user
const user = await createUser('user@example.com', 'username', {
    firstName: 'John',
    lastName: 'Doe',
    phoneNumber: '+1234567890',
});

// Get user by email
const foundUser = await getEntityByEmail('user@example.com');

// Update user information
if (foundUser) {
    foundUser.userInfo.firstName = 'Jane';
    await foundUser.update();
}
```

### Transaction Example

```typescript
import { createDeposit, getTransactionById } from './entities/transaction';

// Create a deposit transaction
const transaction = await createDeposit('user123', 'USER', '100.00', 'pending');

// Get transaction by ID
const foundTransaction = await getTransactionById(transaction.transactionId);

// Mark transaction as complete
await foundTransaction.complete('1200.00'); // New balance after transaction
```
</file>

<file path="layers/commons/data/utils.ts">
import { DynamoDBClient, TransactWriteItemsCommandInput, TransactWriteItemsCommand } from "@aws-sdk/client-dynamodb";

type executeTransactWriteInput = {
  client: DynamoDBClient;
  params: TransactWriteItemsCommandInput;
};

export const executeTransactWrite = async ({
  client,
  params,
}: executeTransactWriteInput) => {
  const transactionRequest = client.send(new TransactWriteItemsCommand(params));
  
  try {
    const response = await transactionRequest;
    return response;
  } catch (err: any) {
    console.error("Transaction failed", err);
    throw err;
  }
};
</file>

<file path="layers/commons/dynamodb/db-client.ts">
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient } from "@aws-sdk/lib-dynamodb";

/**
 * Creates and configures the DynamoDB document client
 * @returns Configured DynamoDB document client
 */
export function getDocumentClient() {
  const client = new DynamoDBClient({});

  return DynamoDBDocumentClient.from(client, {
    marshallOptions: {
      // Whether to automatically convert empty strings, blobs, and sets to `null`
      convertEmptyValues: true,
      // Whether to remove undefined values while marshalling
      removeUndefinedValues: true,
      // Whether to convert typeof object to map attribute
      convertClassInstanceToMap: true,
    },
    unmarshallOptions: {
      // Whether to return numbers as strings instead of converting them to native JavaScript numbers
      wrapNumbers: false,
    },
  });
}

// Export singleton instance
export const docClient = getDocumentClient();
</file>

<file path="layers/commons/dynamodb/db-operations.ts">
import {
    GetCommand,
    QueryCommand,
    PutCommand,
    UpdateCommand,
    DeleteCommand,
    QueryCommandInput,
    GetCommandInput,
    PutCommandInput,
    UpdateCommandInput,
    DeleteCommandInput,
} from '@aws-sdk/lib-dynamodb';
import { docClient } from './db-client';
import { logger } from '../utils/logger';

// Table name from environment variable
const TABLE_NAME = process.env.TABLE_NAME || 'FireGuardTable';

/**
 * Gets an item from DynamoDB by partition key and sort key
 * @param pk - Partition key
 * @param sk - Sort key
 * @returns The found item or null
 */
export async function getItem<T>(pk: string, sk: string): Promise<T | null> {
    try {
        const params: GetCommandInput = {
            TableName: TABLE_NAME,
            Key: { PK: pk, SK: sk },
        };

        const result = await docClient.send(new GetCommand(params));
        return (result.Item as T) || null;
    } catch (error) {
        logger.error('Error in getItem', { error, pk, sk });
        throw error;
    }
}

/**
 * Queries items from DynamoDB using partition key and optional sort key condition
 * @param pk - Partition key
 * @param skCondition - Optional sort key condition
 * @param filterExpression - Optional filter expression
 * @param expressionValues - Values for the conditions
 * @param indexName - Optional secondary index name
 * @param limit - Optional limit for the query
 * @param exclusiveStartKey - Optional start key for pagination
 * @returns Query result with items and last evaluated key
 */
export async function queryItems<T>({
    pk,
    skCondition,
    filterExpression,
    expressionValues,
    indexName,
    limit,
    exclusiveStartKey,
}: {
    pk: string;
    skCondition?: string;
    filterExpression?: string;
    expressionValues?: Record<string, any>;
    indexName?: string;
    limit?: number;
    exclusiveStartKey?: Record<string, any>;
}): Promise<{ items: T[]; lastEvaluatedKey?: Record<string, any> }> {
    try {
        const keyCondition = skCondition ? `PK = :pk AND ${skCondition}` : 'PK = :pk';

        const params: QueryCommandInput = {
            TableName: TABLE_NAME,
            KeyConditionExpression: keyCondition,
            ExpressionAttributeValues: {
                ':pk': pk,
                ...expressionValues,
            },
            Limit: limit,
            ExclusiveStartKey: exclusiveStartKey,
        };

        if (indexName) {
            params.IndexName = indexName;
        }

        if (filterExpression) {
            params.FilterExpression = filterExpression;
        }

        const result = await docClient.send(new QueryCommand(params));

        return {
            items: (result.Items || []) as T[],
            lastEvaluatedKey: result.LastEvaluatedKey,
        };
    } catch (error) {
        logger.error('Error in queryItems', { error, pk });
        throw error;
    }
}

/**
 * Queries items using a GSI
 * @param indexName - Index name
 * @param pkName - Partition key attribute name
 * @param pkValue - Partition key value
 * @param skName - Optional sort key attribute name
 * @param skCondition - Optional sort key condition
 * @param expressionValues - Values for the conditions
 * @param filterExpression - Optional filter expression
 * @param limit - Optional limit for the query
 * @param exclusiveStartKey - Optional start key for pagination
 * @returns Query result with items and last evaluated key
 */
export async function queryByIndex<T>({
    indexName,
    pkName,
    pkValue,
    skName,
    skCondition,
    expressionValues,
    filterExpression,
    limit,
    exclusiveStartKey,
}: {
    indexName: string;
    pkName: string;
    pkValue: string;
    skName?: string;
    skCondition?: string;
    expressionValues?: Record<string, any>;
    filterExpression?: string;
    limit?: number;
    exclusiveStartKey?: Record<string, any>;
}): Promise<{ items: T[]; lastEvaluatedKey?: Record<string, any> }> {
    try {
        const keyCondition = skName && skCondition ? `${pkName} = :pkValue AND ${skCondition}` : `${pkName} = :pkValue`;

        const params: QueryCommandInput = {
            TableName: TABLE_NAME,
            IndexName: indexName,
            KeyConditionExpression: keyCondition,
            ExpressionAttributeValues: {
                ':pkValue': pkValue,
                ...expressionValues,
            },
            Limit: limit,
            ExclusiveStartKey: exclusiveStartKey,
        };

        if (filterExpression) {
            params.FilterExpression = filterExpression;
        }

        const result = await docClient.send(new QueryCommand(params));

        return {
            items: (result.Items || []) as T[],
            lastEvaluatedKey: result.LastEvaluatedKey,
        };
    } catch (error) {
        logger.error('Error in queryByIndex', { error, indexName, pkValue });
        throw error;
    }
}

/**
 * Puts an item in DynamoDB
 * @param item - The item to put
 * @returns Success status
 */
export async function putItem<T extends Record<string, any>>(item: T): Promise<boolean> {
    try {
        const params: PutCommandInput = {
            TableName: TABLE_NAME,
            Item: item,
        };

        await docClient.send(new PutCommand(params));
        return true;
    } catch (error) {
        logger.error('Error in putItem', { error, item });
        throw error;
    }
}

/**
 * Updates an item in DynamoDB
 * @param pk - Partition key
 * @param sk - Sort key
 * @param updateExpression - Update expression
 * @param expressionValues - Expression attribute values
 * @param expressionNames - Expression attribute names
 * @param conditionExpression - Optional condition expression
 * @returns Updated attributes
 */
export async function updateItem<T>({
    pk,
    sk,
    updateExpression,
    expressionValues,
    expressionNames,
    conditionExpression,
}: {
    pk: string;
    sk: string;
    updateExpression: string;
    expressionValues: Record<string, any>;
    expressionNames?: Record<string, string>;
    conditionExpression?: string;
}): Promise<T | null> {
    try {
        const params: UpdateCommandInput = {
            TableName: TABLE_NAME,
            Key: { PK: pk, SK: sk },
            UpdateExpression: updateExpression,
            ExpressionAttributeValues: expressionValues,
            ReturnValues: 'ALL_NEW',
        };

        if (expressionNames) {
            params.ExpressionAttributeNames = expressionNames;
        }

        if (conditionExpression) {
            params.ConditionExpression = conditionExpression;
        }

        const result = await docClient.send(new UpdateCommand(params));
        return result.Attributes as T;
    } catch (error) {
        logger.error('Error in updateItem', { error, pk, sk });
        throw error;
    }
}

/**
 * Deletes an item from DynamoDB
 * @param pk - Partition key
 * @param sk - Sort key
 * @param conditionExpression - Optional condition expression
 * @param expressionValues - Optional expression attribute values
 * @returns Success status
 */
export async function deleteItem({
    pk,
    sk,
    conditionExpression,
    expressionValues,
}: {
    pk: string;
    sk: string;
    conditionExpression?: string;
    expressionValues?: Record<string, any>;
}): Promise<boolean> {
    try {
        const params: DeleteCommandInput = {
            TableName: TABLE_NAME,
            Key: { PK: pk, SK: sk },
        };

        if (conditionExpression) {
            params.ConditionExpression = conditionExpression;
        }

        if (expressionValues) {
            params.ExpressionAttributeValues = expressionValues;
        }

        await docClient.send(new DeleteCommand(params));
        return true;
    } catch (error) {
        logger.error('Error in deleteItem', { error, pk, sk });
        throw error;
    }
}

/**
 * Increments an attribute in an item
 * @param pk - Partition key
 * @param sk - Sort key
 * @param attributeName - Attribute to increment
 * @param incrementBy - Amount to increment by
 * @param conditionExpression - Optional condition expression
 * @returns The updated value
 */
export async function incrementAttribute({
    pk,
    sk,
    attributeName,
    incrementBy = 1,
    conditionExpression,
}: {
    pk: string;
    sk: string;
    attributeName: string;
    incrementBy?: number;
    conditionExpression?: string;
}): Promise<number | null> {
    try {
        const params: UpdateCommandInput = {
            TableName: TABLE_NAME,
            Key: { PK: pk, SK: sk },
            UpdateExpression: `SET ${attributeName} = if_not_exists(${attributeName}, :zero) + :increment`,
            ExpressionAttributeValues: {
                ':zero': 0,
                ':increment': incrementBy,
            },
            ReturnValues: 'UPDATED_NEW',
        };

        if (conditionExpression) {
            params.ConditionExpression = conditionExpression;
        }

        const result = await docClient.send(new UpdateCommand(params));
        return result.Attributes ? (result.Attributes[attributeName] as number) : null;
    } catch (error) {
        logger.error('Error in incrementAttribute', {
            error,
            pk,
            sk,
            attributeName,
        });
        throw error;
    }
}
</file>

<file path="layers/commons/dynamodb/dynamodb-types.ts">
/**
 * Centralized exports for AWS SDK DynamoDB types and commands
 * This module provides all commonly used DynamoDB types to avoid duplicating imports
 */

// Lower-level client and commands from client-dynamodb
export {
  DynamoDBClient,
  GetItemCommand,
  QueryCommand,
  PutItemCommand,
  DeleteItemCommand,
  UpdateItemCommand,
  BatchWriteItemCommand,
  BatchGetItemCommand,
  ScanCommand,
  // Command output types
  GetItemCommandOutput,
  QueryCommandOutput,
  PutItemCommandOutput,
  DeleteItemCommandOutput,
  UpdateItemCommandOutput,
  BatchWriteItemCommandOutput,
  BatchGetItemCommandOutput,
  ScanCommandOutput,
  // Attribute value and other common types
  AttributeValue
} from '@aws-sdk/client-dynamodb';

// Higher-level document client and commands from lib-dynamodb
export {
  DynamoDBDocumentClient,
  GetCommand,
  QueryCommand as QueryDocCommand,
  PutCommand,
  DeleteCommand,
  UpdateCommand,
  BatchWriteCommand,
  BatchGetCommand,
  ScanCommand as ScanDocCommand,
  // Command input types
  GetCommandInput,
  QueryCommandInput,
  PutCommandInput,
  DeleteCommandInput,
  UpdateCommandInput,
  BatchWriteCommandInput,
  BatchGetCommandInput,
  ScanCommandInput
} from '@aws-sdk/lib-dynamodb';
</file>

<file path="layers/commons/services/cybrid/cybrid-service.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import {
    type AccountBankModel,
    type CustomerBankModel,
    type ExternalBankAccountBankModel,
    type IdentityVerificationBankModel,
    type PostAccountBankModel,
    type PostCustomerBankModel,
    type PostExternalBankAccountBankModel,
    type PostIdentityVerificationBankModel,
} from '@cybrid/cybrid-api-bank-typescript';
import axios, { type AxiosError } from 'axios';
import { SecretsManagerClient } from '@aws-sdk/client-secrets-manager';

import { CybridConfig, CybridEndpoints, getCybridUrl } from '../../utils/cybrid';
import { getCybridToken } from '../../utils/cybrid-auth';

const logger = new Logger({
    logLevel: 'INFO',
    serviceName: 'cybrid-service',
});

const secretsClient = new SecretsManagerClient({ region: process.env.AWS_REGION });

interface CybridCredentials {
    client_id: string;
    client_secret: string;
    customer_id: string;
}

export interface Balance {
    account_guid: string;
    asset: string;
    amount: string;
    updated_at: string;
    type: 'fiat' | 'digital';
}

export class CybridService {
    private async getToken(): Promise<string> {
        // Explicit return type
        try {
            return await getCybridToken();
        } catch (error) {
            logger.error('Error getting Cybrid token', { error });
            throw new Error('Failed to get Cybrid authentication token');
        }
    }

    // Customer Methods
    async createCustomer(data: PostCustomerBankModel): Promise<CustomerBankModel> {
        try {
            const cybridToken = await this.getToken();
            const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}${CybridEndpoints.PATHS.CUSTOMERS}`;
            logger.info('API URL', { apiUrl });
            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
            };
            const response = await axios.post<CustomerBankModel>(apiUrl, data, { headers });
            logger.info('Response from cybrid', { response: response.data });
            return response.data;
        } catch (error: any) {
            throw this.handleError(error);
        }
    }

    async getCustomer(customerId: string): Promise<CustomerBankModel> {
        try {
            const cybridToken = await this.getToken();
            const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}${CybridEndpoints.PATHS.CUSTOMERS}/${customerId}`;
            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
            };
            const response = await axios.get<CustomerBankModel>(apiUrl, { headers });
            return response.data;
        } catch (error: any) {
            throw this.handleError(error);
        }
    }

    // Account Methods
    async createAccount(customerId: string, data: PostAccountBankModel): Promise<AccountBankModel> {
        try {
            const cybridToken = await this.getToken();
            const apiUrl = getCybridUrl.customers();
            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
            };
            const response = await axios.post<AccountBankModel>(
                apiUrl,
                { ...data, customer_guid: customerId },
                { headers },
            );
            return response.data;
        } catch (error: any) {
            throw this.handleError(error);
        }
    }

    async getAccount(accountId: string): Promise<AccountBankModel> {
        try {
            const cybridToken = await this.getToken();
            const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}${CybridEndpoints.PATHS.ACCOUNTS}/${accountId}`;
            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
            };
            const response = await axios.get<AccountBankModel>(apiUrl, { headers });
            return response.data;
        } catch (error: any) {
            throw this.handleError(error);
        }
    }

    // Identity Verification Methods
    async createIdentityVerification(
        customerId: string,
        data: PostIdentityVerificationBankModel,
    ): Promise<IdentityVerificationBankModel> {
        try {
            const cybridToken = await this.getToken();
            const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}${CybridEndpoints.PATHS.IDENTITY_VERIFICATIONS}`;
            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
            };
            const response = await axios.post<IdentityVerificationBankModel>(
                apiUrl,
                { ...data, customer_guid: customerId },
                { headers },
            );
            return response.data;
        } catch (error: any) {
            throw this.handleError(error);
        }
    }

    // Bank Account Methods
    async createBankAccount(
        customerId: string,
        data: PostExternalBankAccountBankModel,
    ): Promise<ExternalBankAccountBankModel> {
        try {
            const cybridToken = await this.getToken();
            const apiUrl = `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}${CybridEndpoints.PATHS.EXTERNAL_BANK_ACCOUNTS}`;
            const headers = {
                Authorization: `Bearer ${cybridToken}`,
                'Content-Type': 'application/json',
            };
            const response = await axios.post<ExternalBankAccountBankModel>(
                apiUrl,
                { ...data, customer_guid: customerId },
                { headers },
            );
            return response.data;
        } catch (error: any) {
            throw this.handleError(error);
        }
    }

    private handleError(error: any) {
        if (axios.isAxiosError(error)) {
            const axiosError = error as AxiosError;
            logger.error('Cybrid API error', {
                status: axiosError.response?.status,
                message: (axiosError.response?.data as any)?.message || axiosError.message,
                code: (axiosError.response?.data as any)?.code,
                data: axiosError.response?.data,
            });
            return {
                status: axiosError.response?.status,
                message: (axiosError.response?.data as any)?.message || axiosError.message,
                code: (axiosError.response?.data as any)?.code,
                data: axiosError.response?.data,
            };
        }
        logger.error('An unexpected error occurred', { error });
        return {
            status: 500,
            message: 'An unexpected error occurred',
            error: error instanceof Error ? error.message : String(error),
        };
    }

    async getCybridBalances(userId: string): Promise<Balance[]> {
        const cybridToken = await this.getToken();

        const customerId = await this.getCustomerId(userId);

        const response = await this.retryableRequest(
            `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}${CybridEndpoints.PATHS.ACCOUNTS}?customer_id=${customerId}`,
            {
                headers: {
                    Authorization: `Bearer ${cybridToken}`,
                    'Content-Type': 'application/json',
                },
            },
        );

        return response.data.results.map((account: any) => ({
            account_guid: account.guid,
            asset: account.asset,
            amount: account.platform_balance.amount,
            updated_at: account.platform_balance.last_updated_at,
            type: account.type,
        }));
    }

    private async getCustomerId(userId: string): Promise<string> {
        const cybridToken = await this.getToken();
        const customerId = await this.getCustomer(userId);
        return customerId.guid || '';
    }

    private async retryableRequest(url: string, config: any) {
        return this.exponentialBackoff(() => axios.get(url, config), {
            maxRetries: 3,
            initialDelay: 1000,
        });
    }

    //TODO: Move to commons
    private async exponentialBackoff(fn: () => Promise<any>, options: { maxRetries: number; initialDelay: number }) {
        const { maxRetries, initialDelay } = options;
        let delay = initialDelay;

        for (let i = 0; i < maxRetries; i++) {
            try {
                return await fn();
            } catch (error) {
                if (i === maxRetries - 1) {
                    throw error;
                }
                await new Promise((resolve) => setTimeout(resolve, delay));
                delay *= 2;
            }
        }
    }
}
</file>

<file path="layers/commons/services/nmi/nmi-customer.ts">
import {
    GetItemCommand,
    QueryCommand,
    PutItemCommand,
    DeleteItemCommand,
    AttributeValue,
    GetItemCommandOutput,
    QueryCommandOutput,
} from '../../dynamodb/dynamodb-types';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from '@aws-lambda-powertools/logger';
import { Entity, EntityTypeString } from '../../data/entities/entity';
import { getClient } from '../../data/client';

const logger = new Logger({ serviceName: 'nmi-customer-service' });
const client = getClient();
const TABLE_NAME = process.env.TABLE_NAME || 'clkk-app-table-dev';

/**
 * NmiCustomer class for handling NMI customer vault data in the single-table design
 * This class follows DynamoDB single-table design principles with appropriate
 * keys for efficient access patterns
 */
export class NmiCustomer {
    id: string;
    entityId: string;
    entityType: EntityTypeString;
    customerVaultId: string;
    ccType?: string;
    ccNumber?: string; // Last 4 digits only for display purposes
    createdAt: string;
    updatedAt: string;

    constructor(
        entityId: string,
        entityType: EntityTypeString,
        customerVaultId: string,
        options: {
            id?: string;
            ccType?: string;
            ccNumber?: string;
            createdAt?: string;
            updatedAt?: string;
        } = {},
    ) {
        this.id = options.id || uuidv4();
        this.entityId = entityId;
        this.entityType = entityType;
        this.customerVaultId = customerVaultId;
        this.ccType = options.ccType;
        this.ccNumber = options.ccNumber;

        const now = new Date().toISOString();
        this.createdAt = options.createdAt || now;
        this.updatedAt = options.updatedAt || now;
    }

    /**
     * Primary key for NMI customer record
     */
    get pk(): string {
        return Entity.getEntityPk(this.entityId, this.entityType);
    }

    /**
     * Sort key for NMI customer record
     * Using the vault ID as part of the sort key to prevent duplicates
     */
    get sk(): string {
        return `NMI#VAULT#${this.customerVaultId}`;
    }

    /**
     * EntityTypeKey for EntityTypeIndex partition key
     */
    get entityTypeKey(): string {
        return 'NMI_CUSTOMER';
    }

    /**
     * EntityStatusSortKey for EntityTypeIndex sort key
     */
    get entityStatusSortKey(): string {
        return `VAULT#${this.customerVaultId}`;
    }

    /**
     * Convert NmiCustomer to DynamoDB item for storage
     */
    toItem(): Record<string, AttributeValue> {
        return {
            PK: { S: this.pk },
            SK: { S: this.sk },
            EntityTypeKey: { S: this.entityTypeKey },
            EntityStatusSortKey: { S: this.entityStatusSortKey },
            ID: { S: this.id },
            EntityId: { S: this.entityId },
            EntityType: { S: this.entityType },
            CustomerVaultId: { S: this.customerVaultId },
            ...(this.ccType ? { CCType: { S: this.ccType } } : {}),
            ...(this.ccNumber ? { CCNumber: { S: this.ccNumber } } : {}),
            CreatedAt: { S: this.createdAt },
            UpdatedAt: { S: this.updatedAt },
            ItemType: { S: 'NMI_CUSTOMER' },
        };
    }

    /**
     * Create NmiCustomer object from DynamoDB item
     */
    static fromItem(item?: Record<string, AttributeValue>): NmiCustomer | null {
        if (!item) return null;

        const entityId = item.EntityId?.S;
        const entityType = item.EntityType?.S as EntityTypeString;
        const customerVaultId = item.CustomerVaultId?.S;

        if (!entityId || !entityType || !customerVaultId) {
            logger.error('Invalid NMI customer data from DynamoDB', { item });
            return null;
        }

        return new NmiCustomer(entityId, entityType, customerVaultId, {
            id: item.ID?.S,
            ccType: item.CCType?.S,
            ccNumber: item.CCNumber?.S,
            createdAt: item.CreatedAt?.S,
            updatedAt: item.UpdatedAt?.S,
        });
    }

    /**
     * Create a new NMI customer record
     * Checks first if a customer with the same vault ID already exists
     */
    async create(): Promise<NmiCustomer> {
        // First check if customer with this vault ID already exists
        try {
            const existingCustomer = await NmiCustomer.getByCustomerVaultId(this.customerVaultId);

            if (existingCustomer) {
                logger.warn('NMI customer with this vault ID already exists', {
                    customerVaultId: this.customerVaultId,
                    existingCustomerId: existingCustomer.id,
                });
                throw new Error(`NMI customer with vault ID ${this.customerVaultId} already exists`);
            }

            const item = this.toItem();

            await client.send(
                new PutItemCommand({
                    TableName: TABLE_NAME,
                    Item: item,
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                }),
            );

            logger.info('NMI customer record created', {
                entityId: this.entityId,
                customerVaultId: this.customerVaultId,
            });

            return this;
        } catch (error) {
            logger.error('Error creating NMI customer record', {
                error,
                entityId: this.entityId,
                customerVaultId: this.customerVaultId,
            });
            throw error;
        }
    }

    /**
     * Update an existing NMI customer record
     */
    async update(): Promise<NmiCustomer> {
        this.updatedAt = new Date().toISOString();
        const item = this.toItem();

        try {
            await client.send(
                new PutItemCommand({
                    TableName: TABLE_NAME,
                    Item: item,
                    ConditionExpression: 'attribute_exists(PK) AND attribute_exists(SK)',
                }),
            );

            logger.info('NMI customer record updated', {
                entityId: this.entityId,
                customerVaultId: this.customerVaultId,
            });

            return this;
        } catch (error) {
            logger.error('Error updating NMI customer record', {
                error,
                entityId: this.entityId,
                customerVaultId: this.customerVaultId,
            });
            throw error;
        }
    }

    /**
     * Delete an NMI customer record
     */
    async delete(): Promise<void> {
        try {
            await client.send(
                new DeleteItemCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: { S: this.pk },
                        SK: { S: this.sk },
                    },
                }),
            );

            logger.info('NMI customer record deleted', {
                entityId: this.entityId,
                customerVaultId: this.customerVaultId,
            });
        } catch (error) {
            logger.error('Error deleting NMI customer record', {
                error,
                entityId: this.entityId,
                customerVaultId: this.customerVaultId,
            });
            throw error;
        }
    }

    /**
     * Get NMI customer record by entity ID and NMI record ID
     */
    static async getById(entityId: string, nmiId: string): Promise<NmiCustomer | null> {
        try {
            const response = (await client.send(
                new GetItemCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: { S: Entity.getEntityPk(entityId, 'USER') },
                        SK: { S: nmiId.startsWith('NMI#VAULT#') ? nmiId : `NMI#${nmiId}` },
                    },
                }),
            )) as GetItemCommandOutput;

            if (!response.Item) {
                return null;
            }

            return NmiCustomer.fromItem(response.Item);
        } catch (error) {
            logger.error('Error getting NMI customer by ID', {
                error,
                entityId,
                nmiId,
            });
            throw error;
        }
    }

    /**
     * Get NMI customer record by customer vault ID
     */
    static async getByCustomerVaultId(customerVaultId: string): Promise<NmiCustomer | null> {
        try {
            const response = (await client.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'EntityTypeIndex',
                    KeyConditionExpression:
                        'EntityTypeKey = :entityTypeKey AND EntityStatusSortKey = :entityStatusSortKey',
                    ExpressionAttributeValues: {
                        ':entityTypeKey': { S: 'NMI_CUSTOMER' },
                        ':entityStatusSortKey': { S: `VAULT#${customerVaultId}` },
                    },
                    Limit: 1,
                }),
            )) as QueryCommandOutput;

            if (!response.Items || response.Items.length === 0) {
                return null;
            }

            return NmiCustomer.fromItem(response.Items[0]);
        } catch (error) {
            logger.error('Error getting NMI customer by vault ID', {
                error,
                customerVaultId,
            });
            throw error;
        }
    }

    /**
     * Get all NMI customer records for an entity
     */
    static async listByEntity(entityId: string): Promise<NmiCustomer[]> {
        try {
            const response = (await client.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk)',
                    ExpressionAttributeValues: {
                        ':pk': { S: Entity.getEntityPk(entityId, 'USER') },
                        ':sk': { S: 'NMI#' },
                    },
                }),
            )) as QueryCommandOutput;

            if (!response.Items || response.Items.length === 0) {
                return [];
            }

            return response.Items.map((item: Record<string, AttributeValue>) => NmiCustomer.fromItem(item)).filter(
                Boolean,
            ) as NmiCustomer[];
        } catch (error) {
            logger.error('Error listing NMI customers by entity', {
                error,
                entityId,
            });
            throw error;
        }
    }

    /**
     * List all NMI customer records (admin function)
     */
    static async listAll(
        limit = 50,
        startKey?: Record<string, AttributeValue>,
    ): Promise<{
        customers: NmiCustomer[];
        lastEvaluatedKey?: Record<string, AttributeValue>;
    }> {
        try {
            const response = (await client.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'EntityTypeIndex',
                    KeyConditionExpression: 'EntityTypeKey = :entityTypeKey',
                    ExpressionAttributeValues: {
                        ':entityTypeKey': { S: 'NMI_CUSTOMER' },
                    },
                    Limit: limit,
                    ExclusiveStartKey: startKey,
                }),
            )) as QueryCommandOutput;

            if (!response.Items || response.Items.length === 0) {
                return { customers: [] };
            }

            const customers = response.Items.map((item: Record<string, AttributeValue>) =>
                NmiCustomer.fromItem(item),
            ).filter(Boolean) as NmiCustomer[];

            return {
                customers,
                lastEvaluatedKey: response.LastEvaluatedKey,
            };
        } catch (error) {
            logger.error('Error listing all NMI customers', { error });
            throw error;
        }
    }
}

// Convenience functions

/**
 * Create a new NMI customer record
 */
export async function createNmiCustomer(
    entityId: string,
    entityType: EntityTypeString,
    customerVaultId: string,
    options: {
        ccType?: string;
        ccNumber?: string;
    } = {},
): Promise<NmiCustomer> {
    const nmiCustomer = new NmiCustomer(entityId, entityType, customerVaultId, options);
    return await nmiCustomer.create();
}

/**
 * Get NMI customer record by entity ID and NMI record ID
 */
export async function getNmiCustomerById(entityId: string, nmiId: string): Promise<NmiCustomer | null> {
    return await NmiCustomer.getById(entityId, nmiId);
}

/**
 * Get NMI customer record by customer vault ID
 */
export async function getNmiCustomerByVaultId(customerVaultId: string): Promise<NmiCustomer | null> {
    return await NmiCustomer.getByCustomerVaultId(customerVaultId);
}

/**
 * Get all NMI customer records for an entity
 */
export async function listNmiCustomersByEntity(entityId: string): Promise<NmiCustomer[]> {
    return await NmiCustomer.listByEntity(entityId);
}

/**
 * List all NMI customer records (admin function)
 */
export async function listAllNmiCustomers(
    limit = 50,
    startKey?: Record<string, AttributeValue>,
): Promise<{
    customers: NmiCustomer[];
    lastEvaluatedKey?: Record<string, AttributeValue>;
}> {
    return await NmiCustomer.listAll(limit, startKey);
}
</file>

<file path="layers/commons/services/email.service.ts">
import { SendEmailCommand, type SendEmailCommandInput, SESClient } from '@aws-sdk/client-ses';

import { logger } from '../utils/logger';

type EmailParams = {
    to: string | string[];
    cc?: string | string[];
    bcc?: string | string[];
    replyTo?: string | string[];
    from: string;
};

type TemplateData = Record<string, string | number>;
type TemplateRegistry = Record<string, { subject: string; html: string; text?: string }>;

export class EmailService {
    private ses: SESClient;
    private templateRegistry: TemplateRegistry;

    constructor(templateRegistry: TemplateRegistry, region: string = process.env.AWS_REGION || '') {
        this.ses = new SESClient({ region });
        this.templateRegistry = templateRegistry;
    }

    async sendEmail(templateId: string, params: EmailParams, data: TemplateData): Promise<void> {
        const template = this.templateRegistry[templateId];

        if (!template) {
            throw new Error(`Template ${templateId} not found in registry`);
        }

        try {
            const processedHtml = this.replacePlaceholders(template.html, data);
            const processedText = template.text ? this.replacePlaceholders(template.text, data) : undefined;
            const processedSubject = this.replacePlaceholders(template.subject, data);

            const commandInput: SendEmailCommandInput = {
                Source: params.from,
                Destination: {
                    ToAddresses: Array.isArray(params.to) ? params.to : [params.to],
                    CcAddresses: params.cc ? (Array.isArray(params.cc) ? params.cc : [params.cc]) : undefined,
                    BccAddresses: params.bcc ? (Array.isArray(params.bcc) ? params.bcc : [params.bcc]) : undefined,
                },
                Message: {
                    Subject: { Data: processedSubject },
                    Body: {
                        Html: { Data: processedHtml },
                        ...(processedText && { Text: { Data: processedText } }),
                    },
                },
                ReplyToAddresses: params.replyTo
                    ? Array.isArray(params.replyTo)
                        ? params.replyTo
                        : [params.replyTo]
                    : undefined,
                ConfigurationSetName: process.env.SES_CONFIGURATION_SET,
            };

            await this.ses.send(new SendEmailCommand(commandInput));
            logger.info('Email sent successfully', { templateId, to: params.to });
        } catch (error) {
            logger.error('Failed to send email', {
                error,
                templateId,
                to: params.to,
            });
            throw new Error(`Email sending failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    private replacePlaceholders(content: string, data: TemplateData): string {
        return Object.entries(data).reduce((acc, [key, value]) => {
            const regex = new RegExp(`{{${key}}}`, 'g');
            return acc.replace(regex, String(value));
        }, content);
    }
}
</file>

<file path="layers/commons/services/KmsService.ts">
import { KMS, EncryptCommandInput, DecryptCommandInput } from '@aws-sdk/client-kms';
import { createLogger } from '../utils/logger_v2';

/**
 * Service for AWS KMS encryption operations
 */
export class KmsService {
    private logger = createLogger('KmsService');
    private kms: KMS;
    private keyId: string;

    /**
     * Initialize the KMS Service
     * @param keyId - KMS Key ID for encryption/decryption
     */
    constructor(keyId: string) {
        this.kms = new KMS();
        this.keyId = keyId;
    }

    /**
     * Encrypt data using AWS KMS
     * @param data - Data to encrypt (plaintext)
     * @returns Encrypted data as base64 string
     */
    async encryptData(data: string): Promise<string | null> {
        if (!data) {
            this.logger.warn('No data provided for encryption');
            return null;
        }

        try {
            this.logger.info('Encrypting data with KMS');

            const params: EncryptCommandInput = {
                KeyId: this.keyId,
                Plaintext: Buffer.from(data),
            };

            const result = await this.kms.encrypt(params);

            if (!result.CiphertextBlob) {
                throw new Error('Encryption failed - no CiphertextBlob in response');
            }

            // Convert the encrypted buffer to base64 for storage
            return Buffer.from(result.CiphertextBlob).toString('base64');
        } catch (error) {
            this.logger.error('Error encrypting data with KMS', error);
            throw error;
        }
    }

    /**
     * Decrypt data using AWS KMS
     * @param encryptedData - Base64 encoded encrypted data
     * @returns Decrypted data as string
     */
    async decryptData(encryptedData: string): Promise<string | null> {
        if (!encryptedData) {
            this.logger.warn('No encrypted data provided for decryption');
            return null;
        }

        try {
            this.logger.info('Decrypting data with KMS');

            const params: DecryptCommandInput = {
                CiphertextBlob: Buffer.from(encryptedData, 'base64'),
            };

            const result = await this.kms.decrypt(params);

            if (!result.Plaintext) {
                throw new Error('Decryption failed - no Plaintext in response');
            }

            // Convert the decrypted buffer to string
            return Buffer.from(result.Plaintext).toString('utf-8');
        } catch (error) {
            this.logger.error('Error decrypting data with KMS', error);
            throw error;
        }
    }
}
</file>

<file path="layers/commons/services/snsService.ts">
import { PublishCommand, SNSClient } from '@aws-sdk/client-sns';

import { logger } from '../utils/logger';

export class SNSService {
    private snsClient: SNSClient;

    constructor() {
        this.snsClient = new SNSClient();
    }

    async publishMessage<T>(topicArn: string, message: T, messageGroupId?: string): Promise<string | null> {
        logger.info('Publishing SNS message', { topicArn, message, messageGroupId });
        try {
            const isFifoTopic = topicArn.endsWith('.fifo');
            const params: any = {
                TopicArn: topicArn,
                Message: JSON.stringify(message),
            };

            if (isFifoTopic && messageGroupId) {
                params.MessageGroupId = messageGroupId;
                params.MessageDeduplicationId = `${messageGroupId}-${Date.now()}`;
            }

            const command = new PublishCommand(params);
            const result = await this.snsClient.send(command);
            logger.info('Result', { result });
            logger.info('Successfully published SNS message', { messageId: result.MessageId });
            return result.MessageId || null;
        } catch (error) {
            logger.error('Error publishing SNS message', { error, topicArn });
            throw error;
        }
    }

    static createMessage<T>(body: T, source: string, type: string) {
        return {
            Message: JSON.stringify(body),
            MessageAttributes: {
                eventType: { DataType: 'String', StringValue: type },
                eventSource: { DataType: 'String', StringValue: source },
            },
        };
    }
}
</file>

<file path="layers/commons/types/cybrid/cybrid.i.ts">
export interface CreateFiatAccountRequest {
    type: string;
    asset: string;
    customer_guid: string;
    name: string;
    labels: string[];
}
</file>

<file path="layers/commons/types/f-labs/index.ts">
import { type Entity } from 'f-labs';
import { type CustomerCreateResponse } from 'f-labs';

export type { CustomerCreateResponse, Entity };
</file>

<file path="layers/commons/types/records/dynamoRecords.i.ts">
export interface CybridFiatAccount {
    userId: string;
    accountId: string;
    customerId: string;
    asset: string;
    name: string;
    state: string;
    balance: number;
    createdAt: string;
}

export interface IdentityVerificationRecord {
    identityVerificationId: string;
    customerId: string;
    userId: string;
    personaInquiryId?: string; // Optional, as it might not be available initially
    personaUrl?: string; // Optional
    status: string;
    createdAt: string;
    updatedAt?: string;
}
</file>

<file path="layers/commons/types/shared/graphql.ts">
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  AWSJSON: { input: any; output: any; }
};

export type BusinessDashboardData = {
  __typename?: 'BusinessDashboardData';
  recentTransactions?: Maybe<Array<Maybe<Transaction>>>;
  revenueTrends?: Maybe<Array<Maybe<RevenueTrend>>>;
  totalRevenue: Scalars['Float']['output'];
  totalTransactions: Scalars['Int']['output'];
  transactionsByStatus?: Maybe<Array<Maybe<TransactionByStatus>>>;
  transactionsByType?: Maybe<Array<Maybe<TransactionByType>>>;
};

export type CybridBalance = {
  __typename?: 'CybridBalance';
  accountId: Scalars['ID']['output'];
  asset: Scalars['String']['output'];
  balance: Scalars['Float']['output'];
  createdAt: Scalars['String']['output'];
  customerId: Scalars['String']['output'];
  name: Scalars['String']['output'];
  state: Scalars['String']['output'];
  updatedAt: Scalars['String']['output'];
};

export type DeviceToken = {
  __typename?: 'DeviceToken';
  platform: Scalars['String']['output'];
  token: Scalars['String']['output'];
  updatedAt: Scalars['String']['output'];
};

export type DisplaySettings = {
  __typename?: 'DisplaySettings';
  currency?: Maybe<Scalars['String']['output']>;
  language?: Maybe<Scalars['String']['output']>;
  theme?: Maybe<Scalars['String']['output']>;
};

export type Fee = {
  __typename?: 'Fee';
  fixedFee: Scalars['Float']['output'];
  rate: Scalars['Float']['output'];
  spreadFee: Scalars['Float']['output'];
  type: Scalars['String']['output'];
};

export type FinancialData = {
  __typename?: 'FinancialData';
  cybridBalances?: Maybe<Array<Maybe<CybridBalance>>>;
  plaidAccounts?: Maybe<Array<Maybe<PlaidAccount>>>;
  preferences?: Maybe<UserPreferences>;
  recentTransactions?: Maybe<Array<Maybe<Transaction>>>;
  userProfile?: Maybe<UserProfile>;
};

export enum KycStatus {
  InProgress = 'IN_PROGRESS',
  NotStarted = 'NOT_STARTED',
  Rejected = 'REJECTED',
  Verified = 'VERIFIED'
}

export type NotificationSettings = {
  __typename?: 'NotificationSettings';
  emailEnabled?: Maybe<Scalars['Boolean']['output']>;
  pushEnabled?: Maybe<Scalars['Boolean']['output']>;
  smsEnabled?: Maybe<Scalars['Boolean']['output']>;
};

export type PlaidAccount = {
  __typename?: 'PlaidAccount';
  id: Scalars['String']['output'];
  institutionName: Scalars['String']['output'];
  mask: Scalars['String']['output'];
  name: Scalars['String']['output'];
  subtype: Scalars['String']['output'];
  type: Scalars['String']['output'];
  verificationStatus: Scalars['String']['output'];
};

export type Query = {
  __typename?: 'Query';
  getBusinessDashboardData?: Maybe<BusinessDashboardData>;
  getBusinessTransaction?: Maybe<Transaction>;
  getBusinessTransactions?: Maybe<Array<Maybe<Transaction>>>;
  getFinancialData?: Maybe<FinancialData>;
  getTransaction?: Maybe<Transaction>;
  getUserTransactions?: Maybe<Array<Maybe<Transaction>>>;
};


export type QueryGetBusinessDashboardDataArgs = {
  businessId: Scalars['ID']['input'];
};


export type QueryGetBusinessTransactionArgs = {
  transactionId: Scalars['ID']['input'];
};


export type QueryGetBusinessTransactionsArgs = {
  businessId: Scalars['ID']['input'];
  filter?: InputMaybe<TransactionFilterInput>;
};


export type QueryGetFinancialDataArgs = {
  userId: Scalars['String']['input'];
};


export type QueryGetTransactionArgs = {
  transactionId: Scalars['ID']['input'];
};


export type QueryGetUserTransactionsArgs = {
  filter?: InputMaybe<TransactionFilterInput>;
  userId: Scalars['ID']['input'];
};

export type RevenueTrend = {
  __typename?: 'RevenueTrend';
  amount: Scalars['Float']['output'];
  date: Scalars['String']['output'];
};

export type Transaction = {
  __typename?: 'Transaction';
  amount: Scalars['Float']['output'];
  asset: Scalars['String']['output'];
  businessId?: Maybe<Scalars['ID']['output']>;
  createdAt: Scalars['String']['output'];
  customerId?: Maybe<Scalars['ID']['output']>;
  destinationAccountId?: Maybe<Scalars['String']['output']>;
  failureCode?: Maybe<Scalars['String']['output']>;
  feeAmount?: Maybe<Scalars['Float']['output']>;
  feePercentage?: Maybe<Scalars['Float']['output']>;
  isBusinessPayment?: Maybe<Scalars['Boolean']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Scalars['AWSJSON']['output']>;
  netAmount?: Maybe<Scalars['Float']['output']>;
  paymentProviderId?: Maybe<Scalars['String']['output']>;
  quoteGuid?: Maybe<Scalars['String']['output']>;
  recipientClkktag?: Maybe<Scalars['String']['output']>;
  recipientId?: Maybe<Scalars['ID']['output']>;
  recipientName?: Maybe<Scalars['String']['output']>;
  returnCode?: Maybe<Scalars['String']['output']>;
  senderClkktag?: Maybe<Scalars['String']['output']>;
  senderId?: Maybe<Scalars['ID']['output']>;
  senderName?: Maybe<Scalars['String']['output']>;
  settlementDate?: Maybe<Scalars['String']['output']>;
  settlementStatus?: Maybe<Scalars['String']['output']>;
  sourceAccountId?: Maybe<Scalars['String']['output']>;
  status: TransactionStatus;
  transactionId: Scalars['ID']['output'];
  transferState?: Maybe<Scalars['String']['output']>;
  type: TransactionType;
  updatedAt?: Maybe<Scalars['String']['output']>;
};

export type TransactionByStatus = {
  __typename?: 'TransactionByStatus';
  amount: Scalars['Float']['output'];
  count: Scalars['Int']['output'];
  status: Scalars['String']['output'];
};

export type TransactionByType = {
  __typename?: 'TransactionByType';
  amount: Scalars['Float']['output'];
  count: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type TransactionFilterInput = {
  businessId?: InputMaybe<Scalars['ID']['input']>;
  endDate?: InputMaybe<Scalars['String']['input']>;
  maxAmount?: InputMaybe<Scalars['Float']['input']>;
  minAmount?: InputMaybe<Scalars['Float']['input']>;
  searchText?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<TransactionStatus>;
  type?: InputMaybe<TransactionType>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum TransactionStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  Pending = 'PENDING'
}

export enum TransactionType {
  Deposit = 'DEPOSIT',
  P2BTransfer = 'P2B_TRANSFER',
  P2PTransfer = 'P2P_TRANSFER',
  Trade = 'TRADE',
  Withdrawal = 'WITHDRAWAL'
}

export type UserPreferences = {
  __typename?: 'UserPreferences';
  deviceTokens?: Maybe<Array<Maybe<DeviceToken>>>;
  displaySettings?: Maybe<DisplaySettings>;
  notificationSettings?: Maybe<NotificationSettings>;
};

export type UserProfile = {
  __typename?: 'UserProfile';
  accountState: Scalars['String']['output'];
  clkkTag: Scalars['String']['output'];
  createdAt: Scalars['String']['output'];
  email: Scalars['String']['output'];
  firstName: Scalars['String']['output'];
  kycStatus: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
  phoneNumber: Scalars['String']['output'];
  profileImageUrl: Scalars['String']['output'];
  updatedAt: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;



/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  AWSJSON: ResolverTypeWrapper<Scalars['AWSJSON']['output']>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  BusinessDashboardData: ResolverTypeWrapper<BusinessDashboardData>;
  CybridBalance: ResolverTypeWrapper<CybridBalance>;
  DeviceToken: ResolverTypeWrapper<DeviceToken>;
  DisplaySettings: ResolverTypeWrapper<DisplaySettings>;
  Fee: ResolverTypeWrapper<Fee>;
  FinancialData: ResolverTypeWrapper<FinancialData>;
  Float: ResolverTypeWrapper<Scalars['Float']['output']>;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  KYCStatus: KycStatus;
  NotificationSettings: ResolverTypeWrapper<NotificationSettings>;
  PlaidAccount: ResolverTypeWrapper<PlaidAccount>;
  Query: ResolverTypeWrapper<{}>;
  RevenueTrend: ResolverTypeWrapper<RevenueTrend>;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  Transaction: ResolverTypeWrapper<Transaction>;
  TransactionByStatus: ResolverTypeWrapper<TransactionByStatus>;
  TransactionByType: ResolverTypeWrapper<TransactionByType>;
  TransactionFilterInput: TransactionFilterInput;
  TransactionStatus: TransactionStatus;
  TransactionType: TransactionType;
  UserPreferences: ResolverTypeWrapper<UserPreferences>;
  UserProfile: ResolverTypeWrapper<UserProfile>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  AWSJSON: Scalars['AWSJSON']['output'];
  Boolean: Scalars['Boolean']['output'];
  BusinessDashboardData: BusinessDashboardData;
  CybridBalance: CybridBalance;
  DeviceToken: DeviceToken;
  DisplaySettings: DisplaySettings;
  Fee: Fee;
  FinancialData: FinancialData;
  Float: Scalars['Float']['output'];
  ID: Scalars['ID']['output'];
  Int: Scalars['Int']['output'];
  NotificationSettings: NotificationSettings;
  PlaidAccount: PlaidAccount;
  Query: {};
  RevenueTrend: RevenueTrend;
  String: Scalars['String']['output'];
  Transaction: Transaction;
  TransactionByStatus: TransactionByStatus;
  TransactionByType: TransactionByType;
  TransactionFilterInput: TransactionFilterInput;
  UserPreferences: UserPreferences;
  UserProfile: UserProfile;
}>;

export interface AwsjsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['AWSJSON'], any> {
  name: 'AWSJSON';
}

export type BusinessDashboardDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessDashboardData'] = ResolversParentTypes['BusinessDashboardData']> = ResolversObject<{
  recentTransactions?: Resolver<Maybe<Array<Maybe<ResolversTypes['Transaction']>>>, ParentType, ContextType>;
  revenueTrends?: Resolver<Maybe<Array<Maybe<ResolversTypes['RevenueTrend']>>>, ParentType, ContextType>;
  totalRevenue?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  totalTransactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  transactionsByStatus?: Resolver<Maybe<Array<Maybe<ResolversTypes['TransactionByStatus']>>>, ParentType, ContextType>;
  transactionsByType?: Resolver<Maybe<Array<Maybe<ResolversTypes['TransactionByType']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CybridBalanceResolvers<ContextType = any, ParentType extends ResolversParentTypes['CybridBalance'] = ResolversParentTypes['CybridBalance']> = ResolversObject<{
  accountId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  asset?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  balance?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  customerId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeviceTokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeviceToken'] = ResolversParentTypes['DeviceToken']> = ResolversObject<{
  platform?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DisplaySettingsResolvers<ContextType = any, ParentType extends ResolversParentTypes['DisplaySettings'] = ResolversParentTypes['DisplaySettings']> = ResolversObject<{
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  theme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FeeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Fee'] = ResolversParentTypes['Fee']> = ResolversObject<{
  fixedFee?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  rate?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  spreadFee?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FinancialDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialData'] = ResolversParentTypes['FinancialData']> = ResolversObject<{
  cybridBalances?: Resolver<Maybe<Array<Maybe<ResolversTypes['CybridBalance']>>>, ParentType, ContextType>;
  plaidAccounts?: Resolver<Maybe<Array<Maybe<ResolversTypes['PlaidAccount']>>>, ParentType, ContextType>;
  preferences?: Resolver<Maybe<ResolversTypes['UserPreferences']>, ParentType, ContextType>;
  recentTransactions?: Resolver<Maybe<Array<Maybe<ResolversTypes['Transaction']>>>, ParentType, ContextType>;
  userProfile?: Resolver<Maybe<ResolversTypes['UserProfile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NotificationSettingsResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationSettings'] = ResolversParentTypes['NotificationSettings']> = ResolversObject<{
  emailEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  pushEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  smsEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlaidAccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['PlaidAccount'] = ResolversParentTypes['PlaidAccount']> = ResolversObject<{
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  institutionName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mask?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subtype?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verificationStatus?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  getBusinessDashboardData?: Resolver<Maybe<ResolversTypes['BusinessDashboardData']>, ParentType, ContextType, RequireFields<QueryGetBusinessDashboardDataArgs, 'businessId'>>;
  getBusinessTransaction?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<QueryGetBusinessTransactionArgs, 'transactionId'>>;
  getBusinessTransactions?: Resolver<Maybe<Array<Maybe<ResolversTypes['Transaction']>>>, ParentType, ContextType, RequireFields<QueryGetBusinessTransactionsArgs, 'businessId'>>;
  getFinancialData?: Resolver<Maybe<ResolversTypes['FinancialData']>, ParentType, ContextType, RequireFields<QueryGetFinancialDataArgs, 'userId'>>;
  getTransaction?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<QueryGetTransactionArgs, 'transactionId'>>;
  getUserTransactions?: Resolver<Maybe<Array<Maybe<ResolversTypes['Transaction']>>>, ParentType, ContextType, RequireFields<QueryGetUserTransactionsArgs, 'userId'>>;
}>;

export type RevenueTrendResolvers<ContextType = any, ParentType extends ResolversParentTypes['RevenueTrend'] = ResolversParentTypes['RevenueTrend']> = ResolversObject<{
  amount?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  date?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TransactionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Transaction'] = ResolversParentTypes['Transaction']> = ResolversObject<{
  amount?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  asset?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  businessId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  customerId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  destinationAccountId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feeAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  feePercentage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  isBusinessPayment?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metadata?: Resolver<Maybe<ResolversTypes['AWSJSON']>, ParentType, ContextType>;
  netAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  paymentProviderId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quoteGuid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  recipientClkktag?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  recipientId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  recipientName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  returnCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  senderClkktag?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  senderId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  senderName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  settlementDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  settlementStatus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sourceAccountId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['TransactionStatus'], ParentType, ContextType>;
  transactionId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  transferState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['TransactionType'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TransactionByStatusResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionByStatus'] = ResolversParentTypes['TransactionByStatus']> = ResolversObject<{
  amount?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TransactionByTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionByType'] = ResolversParentTypes['TransactionByType']> = ResolversObject<{
  amount?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserPreferencesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserPreferences'] = ResolversParentTypes['UserPreferences']> = ResolversObject<{
  deviceTokens?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeviceToken']>>>, ParentType, ContextType>;
  displaySettings?: Resolver<Maybe<ResolversTypes['DisplaySettings']>, ParentType, ContextType>;
  notificationSettings?: Resolver<Maybe<ResolversTypes['NotificationSettings']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserProfileResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserProfile'] = ResolversParentTypes['UserProfile']> = ResolversObject<{
  accountState?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  clkkTag?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  firstName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  kycStatus?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phoneNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  profileImageUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  AWSJSON?: GraphQLScalarType;
  BusinessDashboardData?: BusinessDashboardDataResolvers<ContextType>;
  CybridBalance?: CybridBalanceResolvers<ContextType>;
  DeviceToken?: DeviceTokenResolvers<ContextType>;
  DisplaySettings?: DisplaySettingsResolvers<ContextType>;
  Fee?: FeeResolvers<ContextType>;
  FinancialData?: FinancialDataResolvers<ContextType>;
  NotificationSettings?: NotificationSettingsResolvers<ContextType>;
  PlaidAccount?: PlaidAccountResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  RevenueTrend?: RevenueTrendResolvers<ContextType>;
  Transaction?: TransactionResolvers<ContextType>;
  TransactionByStatus?: TransactionByStatusResolvers<ContextType>;
  TransactionByType?: TransactionByTypeResolvers<ContextType>;
  UserPreferences?: UserPreferencesResolvers<ContextType>;
  UserProfile?: UserProfileResolvers<ContextType>;
}>;
</file>

<file path="layers/commons/types/users/entities.i.ts">
interface Entity {
    entityId: string; // Unique identifier (UUID recommended)
    entityType: EntityType; // "user" or "business"
    clkktag?: string; // Unique tag (formerly username) - should be unique across all entities
    name: string; // "firstName lastName" for users, business name for businesses
    email?: string; // Optional email
    phoneNumber?: string; // Optional phone number
    status?: EntityStatus; // Optional status (e.g., active, inactive, pending)
    kyc?: KYC;
    metadata?: {
        clerk?: {
            userId?: string;
            emailId?: string;
            phoneId?: string;
        };
        cybrid?: {
            fiatAccountId?: string;
            customerId?: string;
        };
    };

    // User-specific properties (optional)
    firstName?: string;
    lastName?: string;
    profileImageUrl?: string;

    // Business-specific properties (optional)
    businessName?: string; // Redundant with `name` but can be useful for clarity
    businessDescription?: string;
    businessCategory?: string;
    businessLogoUrl?: string;
    businessAddress?: Address;

    // Common properties
    createdAt?: Date | string;
    updatedAt?: Date | string;
}

interface KYC {
    status: KYCStatus;
    verificationId: string;
    verifiedBy: string;
    verifiedAt: string;
    updatedAt: string;
}

enum KYCStatus {
    Storing = 'storing',
    Waiting = 'waiting',
    Completed = 'completed',
    Failed = 'failed',
    Expired = 'expired',
    Success = 'success',
}

interface Address {
    street: string;
    city: string;
    state: string;
    postalCode: string;
    country: string;
}

enum EntityType {
    User = 'user',
    Business = 'business',
}

enum EntityStatus {
    Active = 'active',
    Inactive = 'inactive',
    Pending = 'pending',
    Suspended = 'suspended',
}

export { Address, Entity, EntityStatus, EntityType, KYCStatus };
</file>

<file path="layers/commons/types/identities.i.ts">
/**
 * Types for identity verification
 */

/**
 * Status of an identity verification
 */
export type IdentityVerificationStatus = 'storing' | 'waiting' | 'completed' | 'failed' | 'expired';

/**
 * Type of identity verification
 */
export type IdentityVerificationType = 'individual' | 'business' | 'watchlists';

/**
 * Identity verification item stored in DynamoDB
 */
export interface IdentityVerificationDynamoItem {
    // Primary key
    identityVerificationId: string;

    // User ID (GSI)
    userId: string;

    // Customer ID (GSI)
    customerId: string;

    // Status - represents the current state of the verification
    status: IdentityVerificationStatus;

    // Verification type - individual, business, watchlists
    verificationType: IdentityVerificationType;

    // Creation and modification timestamps
    createdAt: string;
    updatedAt?: string;

    // Persona-specific fields (if applicable)
    personaInquiryId?: string;
    personaUrl?: string;

    // Cybrid-specific fields
    outcome?: string;
    method?: string;

    // Error information (if applicable)
    error?: {
        code: string;
        message: string;
    };
}

/**
 * Response interface for identity verification endpoints
 */
export interface IdentityVerificationResponse {
    // Status of the verification
    status: string;

    // Type of the verification
    type: IdentityVerificationType;

    // Identification information
    identityVerificationId: string;
    customerId: string;

    // URLs for verification (if applicable)
    personaUrl?: string;

    // Other metadata
    createdAt?: string;
    updatedAt?: string;
    message?: string;
}

/**
 * Interface for business verification fields
 */
export interface BusinessVerificationDetails {
    // Business information
    name: {
        full: string;
    };
    address: {
        street: string;
        street2?: string;
        city: string;
        postal_code: string;
        country_code: string;
        subdivision: string;
    };
    phone_number: string;
    email_address: string;
    website?: string;

    // Business identification
    nature_of_business: string;
    identification_numbers: Array<{
        type: 'business_registration_number' | 'employer_identification_number' | 'tax_identification_number';
        issuing_country_code: string;
        identification_number: string;
    }>;

    // Related entities
    director_customer_guids: string[];
    ultimate_beneficial_owners: Array<{
        customer_guid: string;
        ownership_percentage: number;
    }>;

    // Supporting documentation
    supporting_file_guids: string[];
}
</file>

<file path="layers/commons/types/index.ts">
export * from './records/dynamoRecords.i';
export * from './users/entities.i';
</file>

<file path="layers/commons/utils/api-responses.ts">
import { APIGatewayProxyResult } from "aws-lambda";

/**
 * Creates a standardized API Gateway response
 * @param statusCode - HTTP status code
 * @param body - Response body (will be JSON-stringified)
 * @param headers - Optional additional headers
 * @returns Formatted API Gateway response
 */
export function createResponse<T>(
  statusCode: number,
  body: T,
  headers: Record<string, string> = {}
): APIGatewayProxyResult {
  return {
    statusCode,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Credentials": "true",
      ...headers,
    },
    body: JSON.stringify(body),
  };
}

/**
 * Creates a success response (200 OK)
 * @param body - Response body
 * @param headers - Optional additional headers
 * @returns API Gateway success response
 */
export function createSuccessResponse<T>(
  body: T,
  headers: Record<string, string> = {}
): APIGatewayProxyResult {
  return createResponse(200, body, headers);
}

/**
 * Creates a created response (201 Created)
 * @param body - Response body
 * @param headers - Optional additional headers
 * @returns API Gateway created response
 */
export function createCreatedResponse<T>(
  body: T,
  headers: Record<string, string> = {}
): APIGatewayProxyResult {
  return createResponse(201, body, headers);
}

/**
 * Creates a bad request response (400 Bad Request)
 * @param message - Error message
 * @param errorCode - Error code
 * @param details - Optional error details
 * @returns API Gateway bad request response
 */
export function createBadRequestResponse(
  message: string,
  errorCode: string,
  details?: any
): APIGatewayProxyResult {
  return createResponse(400, {
    message,
    errorCode,
    details,
  });
}

/**
 * Creates a not found response (404 Not Found)
 * @param message - Error message
 * @param errorCode - Error code
 * @param details - Optional error details
 * @returns API Gateway not found response
 */
export function createNotFoundResponse(
  message: string,
  errorCode: string,
  details?: any
): APIGatewayProxyResult {
  return createResponse(404, {
    message,
    errorCode,
    details,
  });
}

/**
 * Creates a server error response (500 Internal Server Error)
 * @param message - Error message
 * @param errorCode - Error code
 * @param details - Optional error details
 * @returns API Gateway server error response
 */
export function createServerErrorResponse(
  message: string,
  errorCode: string,
  details?: any
): APIGatewayProxyResult {
  return createResponse(500, {
    message,
    errorCode,
    details,
  });
}
</file>

<file path="layers/commons/utils/config.ts">
/**
 * Configuration constants for the application
 */

// Environment
export const ENVIRONMENT = process.env.NODE_ENV || 'dev';

// DynamoDB Tables
export const DYNAMO_TABLES = {
    ENTITIES: process.env.TABLE_NAME || 'clkk-app-table-dev',
};

// AWS Secrets
export const AWS_SECRETS = {
    CLERK: {
        SECRET_NAME: 'clerk-secrets',
        KEYS: {
            WEBHOOK_SECRET: 'webhookSecret',
        },
    },
} as const;

// Export default config object
export default {
    ENVIRONMENT,
    DYNAMO_TABLES,
    AWS_SECRETS,
};
</file>

<file path="layers/commons/utils/constants.ts">
export const AWS_SECRETS = {
    CLERK: {
        SECRET_NAME: 'clerk-secrets',
        KEYS: {
            WEBHOOK_SECRET: 'webhookSecret',
        },
    },
    CYBRID: {
        SECRET_NAME: 'cybrid-secrets',
        KEYS: {
            SIGNING_KEY: 'signingKey',
        },
    },
    PLAID: {
        SECRET_NAME: 'plaid-secrets',
        KEYS: {
            CLIENT_ID: 'clientId',
            SECRET: 'secret',
        },
    },
    APPLE_PUSH_NOTIFICATION_KEY: {
        SECRET_NAME: 'apple-push-notification-key',
        KEYS: {
            KEY_ID: 'keyId',
            TEAM_ID: 'teamId',
            AUTH_KEY: 'authKey',
        },
    },
} as const;

export const DYNAMO_TABLES = {
    ENTITIES: 'Entities',
    CYBRID_IDENTITY_VERIFICATIONS: 'CybridIdentityVerifications',
    CYBRID_FIAT_ACCOUNTS: 'CybridFiatAccounts',
    PLAID_ACCESS_TOKENS: 'PlaidAccessToken',
    CLKK_TRANSACTIONS: 'CLKKTransactions',
    CYBRID_CUSTOMERS: 'CybridCustomers',
    CHECKBOOK_USERS: 'CheckbookUsers',
    CYBRID_EXTERNAL_BANK_ACCOUNTS: 'CybridExternalBankAccounts',
    PLATFORM_REVENUE: 'PlatformRevenue',
} as const;

export const PERSONA = {
    BASE_URL: 'https://withpersona.com/verify?inquiry-id=',
} as const;

export const PLAID = {
    BASE_URL: 'https://sandbox.plaid.com',
} as const;
export const PLAID_IDENTITY_URL = `${PLAID.BASE_URL}/identity/get`;

export const CYBRID = {
    BASE_URL: 'https://api.cybrid.app',
    QUOTE_URL: '/quotes',
    ACCOUNT_URL: '/accounts',
    TRANSACTION_URL: '/transactions',
} as const;
export const PLAID_TOKEN_URL = `${PLAID.BASE_URL}/processor/token/create`;

export const PLAID_TRANSACTIONS_URL = `${PLAID.BASE_URL}/transactions/get`;
</file>

<file path="layers/commons/utils/cybrid-auth.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';
import axios from 'axios';

const logger = new Logger({
    serviceName: 'cybrid-auth',
    logLevel: 'INFO',
});

const secretsClient = new SecretsManagerClient({ region: process.env.AWS_REGION });

interface Secret {
    client_id: string;
    client_secret: string;
}

export const getCybridToken = async (): Promise<string> => {
    const secretName = process.env.CYBRID_SECRET_NAME;
    if (!secretName) {
        logger.error('CYBRID_SECRET_NAME environment variable not set.');
        throw new Error('Failed to get Cybrid client credentials');
    }

    try {
        // Fetch the secret
        const command = new GetSecretValueCommand({ SecretId: secretName });
        const data = await secretsClient.send(command);
        logger.info('Cybrid secret response', { response: data }); // Log the entire response for debugging

        if (!data.SecretString) {
            logger.error('Cybrid secret value is empty or not a string.');
            throw new Error('Failed to get Cybrid client credentials');
        }

        const secret: Secret = JSON.parse(data.SecretString);

        // Validate the secret structure
        if (!secret.client_id || !secret.client_secret) {
            logger.error('Cybrid secret is missing client_id or client_secret.');
            throw new Error('Failed to get Cybrid client credentials');
        }

        const authUrl = `${process.env.CYBRID_URL_SCHEME}://id.${process.env.CYBRID_BASE_URL}/oauth/token`;
        const scopes = [
            'accounts:read',
            'accounts:execute',
            'banks:read',
            'banks:write',
            'customers:read',
            'customers:write',
            'customers:execute',
            'identity_verifications:read',
            'identity_verifications:execute',
            'prices:read',
            'quotes:read',
            'quotes:execute',
            'trades:read',
            'trades:execute',
            'transfers:read',
            'transfers:execute',
            'external_wallets:read',
            'external_wallets:execute',
            'external_bank_accounts:execute',
        ];

        // Prepare request for token
        const requestData = {
            grant_type: 'client_credentials',
            client_id: secret.client_id,
            client_secret: secret.client_secret,
            scope: scopes.join(' '),
        };

        const config = {
            headers: {
                'Content-Type': 'application/json',
            },
        };

        // Make the request to get a new token
        logger.info('Requesting access token from Cybrid', { authUrl });
        const response = await axios.post(authUrl, requestData, config);

        logger.info('Successfully obtained access token from Cybrid.');

        return response.data.access_token;
    } catch (error) {
        logger.error('Error retrieving or using Cybrid secret', { error });
        throw new Error('Failed to get Cybrid authentication token');
    }
};
</file>

<file path="layers/commons/utils/cybrid.ts">
export enum Currency {
    USD = 2,
    BTC = 8,
    ETH = 18,
}

export const toBaseUnit = (amount: number, currency: Currency): number => {
    return amount * Math.pow(10, currency);
};

export const fromBaseUnit = (amount: number, currency: Currency): number => {
    return amount / Math.pow(10, currency);
};

export const CybridConfig = {
    URL_SCHEME: process.env.CYBRID_URL_SCHEME || 'https',
    BASE_URL: process.env.CYBRID_BASE_URL || 'api.cybrid.dev',
    TIMEOUT: 30000, // 30 seconds
} as const;

export const CybridEndpoints = {
    BASE: {
        SANDBOX: 'sandbox.cybrid.app/api',
        PRODUCTION: 'production.cybrid.app/api',
    },
    URL_SCHEME: 'https',
    PATHS: {
        ACCOUNTS: '/api/accounts',
        CUSTOMERS: '/api/customers',
        EXTERNAL_BANK_ACCOUNTS: '/api/external_bank_accounts',
        IDENTITY_VERIFICATIONS: '/api/identity_verifications',
    },
    getBaseUrl: () => `${CybridConfig.URL_SCHEME}://bank.${CybridConfig.BASE_URL}`,
    getFullUrl: (path: string) => `${CybridEndpoints.getBaseUrl()}${path}`,
};

// Helper functions for common URL constructions
export const getCybridUrl = {
    accounts: () => CybridEndpoints.getFullUrl(CybridEndpoints.PATHS.ACCOUNTS),
    customers: () => CybridEndpoints.getFullUrl(CybridEndpoints.PATHS.CUSTOMERS),
    externalBankAccounts: () => CybridEndpoints.getFullUrl(CybridEndpoints.PATHS.EXTERNAL_BANK_ACCOUNTS),
    identityVerifications: () => CybridEndpoints.getFullUrl(CybridEndpoints.PATHS.IDENTITY_VERIFICATIONS),
    // Add specific account/customer/etc by ID
    accountById: (id: string) => `${getCybridUrl.accounts()}/${id}`,
    customerById: (id: string) => `${getCybridUrl.customers()}/${id}`,
    externalBankAccountById: (id: string) => `${getCybridUrl.externalBankAccounts()}/${id}`,
};
</file>

<file path="layers/commons/utils/date.ts">
import { z } from 'zod';

export const dateSchema = z.string().datetime();

export class DateUtil {
    static now(): string {
        return new Date().toISOString();
    }

    static formatDate(date: Date | string): string {
        return new Date(date).toISOString();
    }

    static isValidDate(date: string): boolean {
        return dateSchema.safeParse(date).success;
    }

    static addDays(date: Date | string, days: number): string {
        const newDate = new Date(date);
        newDate.setDate(newDate.getDate() + days);
        return newDate.toISOString();
    }
}

// Export commonly used date constants
export const DATE_FORMATS = {
    ISO: 'YYYY-MM-DDTHH:mm:ss.SSSZ',
    SHORT: 'YYYY-MM-DD',
    DISPLAY: 'MMM DD, YYYY',
} as const;
</file>

<file path="layers/commons/utils/dynamo.ts">
import { Logger } from '@aws-lambda-powertools/logger';
import { DynamoDB } from '@aws-sdk/client-dynamodb';
import {
    type DeleteCommandInput,
    DynamoDBDocument,
    type GetCommandInput,
    type PutCommandInput,
    type QueryCommandInput,
    type ScanCommandInput,
    type UpdateCommandInput,
} from '@aws-sdk/lib-dynamodb';

export class DynamoDBService {
    private readonly docClient: DynamoDBDocument;
    private readonly logger: Logger;

    constructor(loggerName = 'DynamoDBService') {
        this.docClient = DynamoDBDocument.from(new DynamoDB({}));
        this.logger = new Logger({ serviceName: loggerName });
    }

    async get<T>(params: GetCommandInput): Promise<T | null> {
        try {
            const { Item } = await this.docClient.get(params);
            return (Item as T) || null;
        } catch (error) {
            this.logger.error('Error in DynamoDB get operation', { error, params });
            throw error;
        }
    }

    async put(params: PutCommandInput): Promise<void> {
        try {
            await this.docClient.put(params);
        } catch (error) {
            this.logger.error('Error in DynamoDB put operation', { error, params });
            throw error;
        }
    }

    async update<T>(params: UpdateCommandInput): Promise<T | null> {
        try {
            const { Attributes } = await this.docClient.update({
                ...params,
                ReturnValues: 'ALL_NEW',
            });
            return (Attributes as T) || null;
        } catch (error) {
            this.logger.error('Error in DynamoDB update operation', { error, params });
            throw error;
        }
    }

    async delete(params: DeleteCommandInput): Promise<void> {
        try {
            await this.docClient.delete(params);
        } catch (error) {
            this.logger.error('Error in DynamoDB delete operation', { error, params });
            throw error;
        }
    }

    async query<T>(params: QueryCommandInput): Promise<T[]> {
        try {
            const { Items = [] } = await this.docClient.query(params);

            this.logger.info('Query result', { Items });
            return Items as T[];
        } catch (error) {
            this.logger.error('Error in DynamoDB query operation', { error, params });
            throw error;
        }
    }

    async transactWrite(params: { TransactItems: any[] }): Promise<void> {
        try {
            await this.docClient.transactWrite(params);
        } catch (error) {
            this.logger.error('Error in DynamoDB transactWrite operation', { error, params });
            throw error;
        }
    }

    async scan<T>(params: ScanCommandInput): Promise<T[]> {
        try {
            const { Items = [] } = await this.docClient.scan(params);
            return Items as T[];
        } catch (error) {
            this.logger.error('Error in DynamoDB scan operation', { error, params });
            throw error;
        }
    }
}

// Export a singleton instance
export const dynamoDB = new DynamoDBService();
</file>

<file path="layers/commons/utils/dynamoUtils.ts">
interface DynamoUpdateParams {
    TableName: string;
    Key: Record<string, any>;
    UpdateExpression: string;
    ExpressionAttributeNames: Record<string, string>;
    ExpressionAttributeValues: Record<string, any>;
}

export function buildUpdateExpression(updates: Record<string, any>): string {
    const expressions: string[] = [];
    const flattenedUpdates = flattenObject(updates);

    for (const key of Object.keys(flattenedUpdates)) {
        if (flattenedUpdates[key] !== undefined) {
            // Replace dots with underscores in the expression
            const expressionKey = key.replace(/\./g, '_');
            expressions.push(`#${expressionKey} = :${expressionKey}`);
        }
    }

    return `SET ${expressions.join(', ')}`;
}

export function buildExpressionAttributeNames(updates: Record<string, any>): Record<string, string> {
    const names: Record<string, string> = {};
    const flattenedUpdates = flattenObject(updates);

    for (const key of Object.keys(flattenedUpdates)) {
        if (flattenedUpdates[key] !== undefined) {
            // Split the nested path and create nested attribute names
            const parts = key.split('.');
            let currentPath = '';

            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                const expressionKey = parts.slice(0, i + 1).join('_');
                currentPath = currentPath ? `${currentPath}.${part}` : part;
                names[`#${expressionKey}`] = part;
            }
        }
    }

    return names;
}

export function buildExpressionAttributeValues(updates: Record<string, any>): Record<string, any> {
    const values: Record<string, any> = {};
    const flattenedUpdates = flattenObject(updates);

    for (const [key, value] of Object.entries(flattenedUpdates)) {
        if (value !== undefined) {
            // Replace dots with underscores in the value key
            const expressionKey = key.replace(/\./g, '_');
            values[`:${expressionKey}`] = value;
        }
    }

    return values;
}

function flattenObject(obj: Record<string, any>, prefix = ''): Record<string, any> {
    const flattened: Record<string, any> = {};

    for (const [key, value] of Object.entries(obj)) {
        const newKey = prefix ? `${prefix}.${key}` : key;

        if (value && typeof value === 'object' && !Array.isArray(value)) {
            Object.assign(flattened, flattenObject(value, newKey));
        } else if (value !== undefined) {
            flattened[newKey] = value;
        }
    }

    return flattened;
}

export function createDynamoUpdateParams(
    tableName: string,
    key: Record<string, any>,
    updates: Record<string, any>,
): DynamoUpdateParams {
    return {
        TableName: tableName,
        Key: key,
        UpdateExpression: buildUpdateExpression(updates),
        ExpressionAttributeNames: buildExpressionAttributeNames(updates),
        ExpressionAttributeValues: buildExpressionAttributeValues(updates),
    };
}
</file>

<file path="layers/commons/utils/getSecret.ts">
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'secrets-manager' });
const secretsManager = new SecretsManagerClient({ region: process.env.AWS_REGION });

interface SecretError extends Error {
    code?: string;
}

export async function getSecret(secretName: string, key: string): Promise<string> {
    logger.info('Fetching secret called', { secretName, key });
    try {
        logger.info('Fetching secret called', { secretName, key });

        const command = new GetSecretValueCommand({
            SecretId: secretName,
            VersionStage: 'AWSCURRENT',
        });

        const response = await secretsManager.send(command);

        if (!response.SecretString) {
            throw new Error(`Secret ${secretName} not found`);
        }

        const secretObject = JSON.parse(response.SecretString);
        logger.info('Secret fetched successfully', { secretObject });

        if (!(key in secretObject)) {
            throw new Error(`Key ${key} not found in secret ${secretName}`);
        }

        logger.info('Secret fetched successfully');
        return secretObject[key];
    } catch (error) {
        logger.error('Error fetching secret', { error });
        const secretError = error as SecretError;

        // Handle specific AWS errors
        if (secretError.code === 'DecryptionFailureException') {
            logger.error('Could not decrypt the secret', { secretName, error: secretError });
            throw new Error('Secret decryption failed');
        }

        if (secretError.code === 'ResourceNotFoundException') {
            logger.error('Secret not found', { secretName, error: secretError });
            throw new Error(`Secret ${secretName} not found`);
        }

        if (secretError.code === 'InvalidParameterException') {
            logger.error('Invalid parameter provided', { secretName, error: secretError });
            throw new Error('Invalid parameter provided to Secrets Manager');
        }

        // Log any other unexpected errors
        logger.error('Error fetching secret', {
            secretName,
            errorMessage: secretError.message,
            errorCode: secretError.code,
        });

        throw new Error('Failed to fetch secret');
    }
}
</file>

<file path="layers/commons/utils/logger_v2.ts">
/**
 * Logging utility for AWS Lambda functions
 * This provides consistent logging format across all Lambda functions
 */

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

interface LogMessage {
    level: LogLevel;
    service: string;
    message: string;
    timestamp: string;
    data?: any;
}

/**
 * Creates a logger instance with the specified service name
 * @param serviceName - Name of the service for log context
 * @returns Logger object with methods for different log levels
 */
export const createLogger = (serviceName: string) => {
    const log = (level: LogLevel, message: string, data?: any) => {
        const logObject: LogMessage = {
            level,
            service: serviceName,
            message,
            timestamp: new Date().toISOString(),
        };

        if (data) {
            // Remove sensitive data or large objects before logging
            const sanitizedData = sanitizeLogData(data);
            logObject.data = sanitizedData;
        }

        // Log using appropriate method based on level
        switch (level) {
            case 'debug':
                console.debug(JSON.stringify(logObject));
                break;
            case 'info':
                console.info(JSON.stringify(logObject));
                break;
            case 'warn':
                console.warn(JSON.stringify(logObject));
                break;
            case 'error':
                console.error(JSON.stringify(logObject));
                break;
        }

        return logObject;
    };

    return {
        debug: (message: string, data?: any) => log('debug', message, data),
        info: (message: string, data?: any) => log('info', message, data),
        warn: (message: string, data?: any) => log('warn', message, data),
        error: (message: string, data?: any) => log('error', message, data),
    };
};

/**
 * Sanitize log data to prevent logging sensitive information
 * @param data - Data to be sanitized
 * @returns Sanitized data
 */
function sanitizeLogData(data: any): any {
    if (!data) return data;

    // For arrays, sanitize each item
    if (Array.isArray(data)) {
        return data.map((item) => sanitizeLogData(item));
    }

    // For objects, process each property
    if (typeof data === 'object' && data !== null) {
        const sanitized: Record<string, any> = {};

        Object.keys(data).forEach((key) => {
            // Skip Error object stack traces to avoid verbose logs
            if (data instanceof Error && key === 'stack') {
                sanitized[key] = '[TRUNCATED]';
                return;
            }

            // Mask sensitive fields
            if (['ssn', 'password', 'secret', 'token', 'key', 'authorization'].includes(key.toLowerCase())) {
                sanitized[key] = '[REDACTED]';
            } else if (key.toLowerCase().includes('ssn') || key.toLowerCase().includes('password')) {
                sanitized[key] = '[REDACTED]';
            } else {
                sanitized[key] = sanitizeLogData(data[key]);
            }
        });

        return sanitized;
    }

    return data;
}
</file>

<file path="layers/commons/utils/logger.ts">
/**
 * Logger utility for consistent logging across the application
 */

// Define log levels
type LogLevel = 'debug' | 'info' | 'warn' | 'error';

/**
 * Simple logger that formats output consistently and can be easily replaced with a more robust solution
 */
class Logger {
    /**
     * Log a debug message
     * @param message - The log message
     * @param context - Optional context object to include with the log
     */
    debug(message: string, context?: Record<string, any>): void {
        this.log('debug', message, context);
    }

    /**
     * Log an info message
     * @param message - The log message
     * @param context - Optional context object to include with the log
     */
    info(message: string, context?: Record<string, any>): void {
        this.log('info', message, context);
    }

    /**
     * Log a warning message
     * @param message - The log message
     * @param context - Optional context object to include with the log
     */
    warn(message: string, context?: Record<string, any>): void {
        this.log('warn', message, context);
    }

    /**
     * Log an error message
     * @param message - The log message
     * @param context - Optional context object to include with the log
     */
    error(message: string, context?: Record<string, any>): void {
        this.log('error', message, context);
    }

    /**
     * Internal log method
     * @param level - Log level
     * @param message - Log message
     * @param context - Optional context
     */
    private log(level: LogLevel, message: string, context?: Record<string, any>): void {
        const timestamp = new Date().toISOString();
        const logObject = {
            timestamp,
            level,
            message,
            ...(context && { context }),
        };

        // Use console methods based on log level
        switch (level) {
            case 'debug':
                console.debug(JSON.stringify(logObject));
                break;
            case 'info':
                console.info(JSON.stringify(logObject));
                break;
            case 'warn':
                console.warn(JSON.stringify(logObject));
                break;
            case 'error':
                console.error(JSON.stringify(logObject));
                break;
        }
    }
}

// Export singleton instance
export const logger = new Logger();
</file>

<file path="layers/commons/utils/responseBuilder.ts">
type ResponseData = string | Record<string, any>;

export const responseBuilder = (
    response: ResponseData,
    statusCode: number = 200,
    headers: Record<string, string> = { 'Content-Type': 'application/json' },
) => {
    const body = typeof response === 'string' ? { message: response } : response;

    return {
        statusCode,
        headers,
        body: JSON.stringify(body),
    };
};
</file>

<file path="layers/commons/utils/secretManager.ts">
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';
import { createLogger } from './logger_v2';

interface SecretCacheItem {
    data: any;
    expiry: number;
}

/**
 * Service to handle fetching and caching secrets from AWS Secrets Manager
 */
export class SecretManagerService {
    private static instance: SecretManagerService;
    private client: SecretsManagerClient;
    private cache: Map<string, SecretCacheItem> = new Map();
    private readonly cacheTTL: number = 15 * 60 * 1000; // 15 minutes
    private logger = createLogger('SecretManagerService');

    /**
     * Private constructor for singleton pattern
     */
    private constructor() {
        this.client = new SecretsManagerClient({ region: process.env.AWS_REGION });
    }

    /**
     * Get the singleton instance
     */
    public static getInstance(): SecretManagerService {
        if (!SecretManagerService.instance) {
            SecretManagerService.instance = new SecretManagerService();
        }
        return SecretManagerService.instance;
    }

    /**
     * Get a secret value from Secrets Manager with caching
     * @param secretArn The ARN or name of the secret to fetch
     * @param forceRefresh Force a refresh of the cache
     * @returns The secret value as a parsed object
     */
    public async getSecret<T = Record<string, any>>(secretArn: string, forceRefresh = false): Promise<T> {
        if (!secretArn) {
            throw new Error('Secret ARN is required');
        }

        const now = Date.now();
        const cacheKey = secretArn;
        const cachedItem = this.cache.get(cacheKey);

        // Return cached value if not expired and not forcing refresh
        if (!forceRefresh && cachedItem && cachedItem.expiry > now) {
            this.logger.debug('Using cached secret', { secretArn });
            return cachedItem.data as T;
        }

        try {
            this.logger.info('Fetching secret from Secrets Manager', { secretArn });

            const command = new GetSecretValueCommand({ SecretId: secretArn });
            const response = await this.client.send(command);

            if (!response.SecretString) {
                throw new Error('Secret value is empty');
            }

            const secretData = JSON.parse(response.SecretString) as T;

            // Cache the result
            this.cache.set(cacheKey, {
                data: secretData,
                expiry: now + this.cacheTTL,
            });

            return secretData;
        } catch (error) {
            this.logger.error('Error fetching secret', {
                secretArn,
                errorMessage: error instanceof Error ? error.message : String(error),
            });
            throw error;
        }
    }

    /**
     * Get a specific key from a secret
     * @param secretArn The ARN or name of the secret
     * @param key The key to retrieve from the secret JSON
     * @param forceRefresh Force a refresh of the cache
     * @returns The value for the specified key
     */
    public async getSecretKey<T = string>(secretArn: string, key: string, forceRefresh = false): Promise<T> {
        const secretData = await this.getSecret(secretArn, forceRefresh);

        if (!(key in secretData)) {
            throw new Error(`Key ${key} not found in secret ${secretArn}`);
        }

        return secretData[key] as T;
    }

    /**
     * Clear all cached secrets
     */
    public clearCache(): void {
        this.cache.clear();
        this.logger.info('Secret cache cleared');
    }

    /**
     * Clear a specific secret from cache
     * @param secretArn The ARN of the secret to clear
     */
    public clearCacheItem(secretArn: string): void {
        this.cache.delete(secretArn);
        this.logger.info('Secret removed from cache', { secretArn });
    }
}
</file>

<file path="layers/commons/utils/sqsService.ts">
import {
    SQSClient,
    SendMessageCommand,
    SendMessageCommandInput,
    SendMessageBatchCommand,
    SendMessageBatchRequestEntry,
    SendMessageBatchResultEntry,
    BatchResultErrorEntry,
} from '@aws-sdk/client-sqs';
import { Logger } from '@aws-lambda-powertools/logger';

const logger = new Logger({ serviceName: 'sqs-service' });

export interface QueueMessage {
    body: string | Record<string, unknown>;
    attributes?: Record<
        string,
        {
            DataType: string;
            StringValue?: string;
            BinaryValue?: Uint8Array;
        }
    >;
    groupId?: string;
    deduplicationId?: string;
}

export class SQSService {
    private sqs: SQSClient;
    private queueUrl: string;

    constructor(queueUrl: string) {
        this.sqs = new SQSClient({});
        this.queueUrl = queueUrl;
    }

    async sendMessage(message: QueueMessage): Promise<string> {
        try {
            const params: SendMessageCommandInput = {
                QueueUrl: this.queueUrl,
                MessageBody: typeof message.body === 'string' ? message.body : JSON.stringify(message.body),
                MessageAttributes: message.attributes,
            };

            // Add FIFO queue specific attributes if provided
            if (message.groupId) {
                params.MessageGroupId = message.groupId;
            }
            if (message.deduplicationId) {
                params.MessageDeduplicationId = message.deduplicationId;
            }

            const command = new SendMessageCommand(params);
            const result = await this.sqs.send(command);

            logger.info('Message sent successfully', {
                messageId: result.MessageId,
                queueUrl: this.queueUrl,
            });

            return result.MessageId || '';
        } catch (error) {
            logger.error('Error sending message to SQS', {
                error,
                queueUrl: this.queueUrl,
            });
            throw error;
        }
    }

    async sendBatchMessages(messages: QueueMessage[]): Promise<{
        successful: string[];
        failed: string[];
    }> {
        try {
            const entries: SendMessageBatchRequestEntry[] = messages.map((msg, index) => ({
                Id: index.toString(),
                MessageBody: typeof msg.body === 'string' ? msg.body : JSON.stringify(msg.body),
                MessageAttributes: msg.attributes,
                MessageGroupId: msg.groupId,
                MessageDeduplicationId: msg.deduplicationId,
            }));

            const command = new SendMessageBatchCommand({
                QueueUrl: this.queueUrl,
                Entries: entries,
            });

            const result = await this.sqs.send(command);

            const successful = result.Successful?.map((s: SendMessageBatchResultEntry) => s.MessageId || '') || [];
            const failed = result.Failed?.map((f: BatchResultErrorEntry) => f.Id || '') || [];

            logger.info('Batch messages sent', {
                successful: successful.length,
                failed: failed.length,
                queueUrl: this.queueUrl,
            });

            return { successful, failed };
        } catch (error) {
            logger.error('Error sending batch messages to SQS', {
                error,
                queueUrl: this.queueUrl,
            });
            throw error;
        }
    }

    static createMessage(
        body: string | Record<string, unknown>,
        eventSource: string,
        eventType: string,
        additionalAttributes: Record<string, string> = {},
    ): QueueMessage {
        return {
            body,
            attributes: {
                eventSource: {
                    DataType: 'String',
                    StringValue: eventSource,
                },
                eventType: {
                    DataType: 'String',
                    StringValue: eventType,
                },
                ...Object.entries(additionalAttributes).reduce(
                    (acc, [key, value]) => ({
                        ...acc,
                        [key]: {
                            DataType: 'String',
                            StringValue: value,
                        },
                    }),
                    {},
                ),
            },
        };
    }
}
</file>

<file path="layers/commons/utils/variables.ts">
/**
 * Environment configuration and constants
 */

/**
 * CORS allowed origins based on environment
 */
export const allowedOrigins = process.env.ALLOWED_ORIGINS
    ? process.env.ALLOWED_ORIGINS.split(',')
    : ['http://localhost:3000', 'https://app.clkk.com'];

/**
 * AWS KMS Key ID for encryption
 */
export const kmsKeyId = process.env.KMS_KEY_ID || '';

/**
 * Prove API configuration
 */
export const proveApiConfig = {
    clientId: process.env.PROVE_CLIENT_ID || '',
    clientSecret: process.env.PROVE_CLIENT_SECRET || '',
    apiKey: process.env.PROVE_API_KEY || '',
    environment: process.env.PROVE_ENVIRONMENT || 'sandbox',
};

/**
 * API rate limiting configuration
 */
export const rateLimitConfig = {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: process.env.RATE_LIMIT_MAX_REQUESTS ? parseInt(process.env.RATE_LIMIT_MAX_REQUESTS, 10) : 10,
};
</file>

<file path="layers/commons/index.ts">
export * from './data/base';
export * from './utils/config';
export * from './utils/logger';
export * from './data/entities/entity';
export * from './utils/getSecret';
export * from './data/entities/wallet';
export * from './data/entities/transaction';
export * from './data/client';
export * from './utils/logger_v2';
export * from './utils/secretManager';
export * from './data/entities/revenue';
export * from './data/entities/money';
export * from './data/entities/provider';
export * from './utils/responseBuilder';
export * from './utils/sqsService';
export * from './utils/dynamoUtils';
export * from './utils/cybrid';

export * from './utils/cybrid';
export * from './utils/cybrid-auth';
export * from './utils/date';
export * from './utils/dynamo';
export * from './utils/dynamoUtils';
export * from './utils/getSecret';
export * from './utils/logger';
export * from './utils/responseBuilder';
export * from './utils/sqsService';

//Types
export * from './types/cybrid/cybrid.i';
export * from './types/records/dynamoRecords.i';
//Export packages
export * from '@aws-sdk/client-secrets-manager';

/******** Services */
export * from './services/snsService';
export * from './services/nmi/nmi-customer';
export * from './services/KmsService';

/******** Constants */
export * from './dynamodb/db-client';
export * from './dynamodb/db-operations';
export * from './dynamodb/dynamodb-types';

import { type IdentityVerificationRecord } from './types';

//TODO: Move over
interface IdentityVerificationDynamoItem extends IdentityVerificationRecord {
    identityVerificationId: string;
    customerId: string;
    personaInquiryId: string;
    personaUrl: string;
    status: 'waiting' | 'completed' | 'failed' | 'expired';
    createdAt: string;
    updatedAt?: string;
    entityId: string;
    source: string;
    state: string;
}

interface KYC {
    identityVerificationId: string;
    personaInquiryId: string;
    personaUrl: string;
    status: string;
    createdAt: string;
    updatedAt: string;
}

interface CybridMetadata {
    cybrid: {
        customerId: string;
    };
}

interface ClerkMetadata {
    clerk: {
        emailId: string;
        phoneId: string;
        userId: string;
    };
}

export type { ClerkMetadata, CybridMetadata, IdentityVerificationDynamoItem, KYC };

//Services
export * from './services/cybrid/cybrid-service';
export * from './services/email.service';
export * from './services/snsService';
</file>

<file path="layers/commons/Makefile">
# Lambda Layer build process for Commons library
# This Makefile is used by AWS SAM to build the Lambda layer

# Make all targets .PHONY since they don't represent actual files
.PHONY: build-LayerCommons clean clean-deps

# Define colors for better output formatting
GREEN=\033[0;32m
YELLOW=\033[1;33m
RED=\033[0;31m
NC=\033[0m # No Color

# Build the Lambda Layer
build-LayerCommons:
	@echo "${YELLOW}Starting build process for CommonJS Layer...${NC}"
	# Install dependencies if node_modules doesn't exist or package.json has changed
	@if [ ! -d "node_modules" ] || [ package.json -nt node_modules ]; then \
		echo "${YELLOW}Installing dependencies...${NC}"; \
		npm ci || npm install; \
	else \
		echo "${GREEN}Dependencies already installed, skipping.${NC}"; \
	fi
	
	@echo "${YELLOW}Building TypeScript code...${NC}"
	npm run build
	
	@echo "${YELLOW}Preparing layer distribution...${NC}"
	# Create directories needed for the layer
	mkdir -p "$(ARTIFACTS_DIR)/nodejs/node_modules"
	
	# Copy package files required for production install
	cp package.json package-lock.json "$(ARTIFACTS_DIR)/nodejs/"
	
	@echo "${YELLOW}Installing production dependencies in layer...${NC}"
	# Install only production dependencies in the layer
	npm install --production --prefer-offline --no-audit --prefix "$(ARTIFACTS_DIR)/nodejs/"
	
	# Remove package.json to prevent conflicts with function package.json files
	rm "$(ARTIFACTS_DIR)/nodejs/package.json"
	
	# Copy the compiled commons library to the node_modules folder
	cp -r commons "$(ARTIFACTS_DIR)/nodejs/node_modules"
	
	@echo "${GREEN}Layer build completed successfully!${NC}"

# Clean build artifacts
clean:
	@echo "${YELLOW}Cleaning build artifacts...${NC}"
	rm -rf "$(ARTIFACTS_DIR)" 2>/dev/null || true
	rm -rf dist 2>/dev/null || true
	@echo "${GREEN}Clean completed.${NC}"

# Clean dependencies (use with caution)
clean-deps:
	@echo "${YELLOW}Cleaning dependencies...${NC}"
	rm -rf node_modules 2>/dev/null || true
	@echo "${GREEN}Dependencies cleaned.${NC}"

# Help target
help:
	@echo "${GREEN}Commons Layer Makefile Targets:${NC}"
	@echo "  ${YELLOW}build-LayerCommons${NC} - Build the Lambda layer for commons library"
	@echo "  ${YELLOW}clean${NC}             - Remove build artifacts"
	@echo "  ${YELLOW}clean-deps${NC}        - Remove node_modules (use with caution)"
	@echo "  ${YELLOW}help${NC}              - Show this help message"
</file>

<file path="layers/commons/package.json">
{
    "description": "Lambda layer with common utils",
    "main": "index.ts",
    "name": "layer-commons",
    "version": "1.0.0",
    "dependencies": {
        "@aws-lambda-powertools/logger": "^2.11.0",
        "@aws-sdk/client-dynamodb": "^3.705.0",
        "@aws-sdk/client-kms": "^3.782.0",
        "@aws-sdk/client-secrets-manager": "^3.699.0",
        "@aws-sdk/client-ses": "^3.734.0",
        "@aws-sdk/client-sns": "^3.734.0",
        "@aws-sdk/client-sqs": "^3.716.0",
        "@aws-sdk/lib-dynamodb": "^3.705.0",
        "@clerk/types": "^4.40.2",
        "@cybrid/cybrid-api-bank-typescript": "^0.123.137",
        "aws-lambda": "^1.0.7",
        "axios": "^1.7.9",
        "decimal.js": "^10.5.0",
        "f-labs": "^1.0.7",
        "joi": "^17.13.3",
        "graphql": "^16.10.0",
        "zod": "^3.24.1"
    },
    "devDependencies": {
        "@types/aws-lambda": "^8.10.148",
        "@types/jest": "^29.5.14",
        "@types/node": "^16.18.126",
        "@types/uuid": "^10.0.0",
        "typescript": "^5.0.3"
    },
    "scripts": {
        "build": "node_modules/typescript/bin/tsc",
        "test": "jest",
        "test:watch": "jest --watch",
        "test:coverage": "jest --coverage"
    }
}
</file>

<file path="layers/commons/tsconfig.json">
{
  "compilerOptions": {
    "strict": true,
    "target": "es2021",
    "preserveConstEnums": true,
    "resolveJsonModule": true,
    "noEmit": false,
    "sourceMap": false,
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./commons"
  },
  "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="layers/prove-identity/package.json">
{
    "name": "prove-identity-layer",
    "version": "1.0.0",
    "description": "Lambda layer for Prove Identity verification dependencies",
    "author": "CLKK",
    "private": true,
    "dependencies": {
        "@prove-identity/prove-api": "^1.0.0",
        "aws-sdk": "^2.1430.0",
        "firebase-admin": "^11.9.0",
        "http-status-codes": "^2.2.0",
        "joi": "^17.9.2"
    },
    "engines": {
        "node": ">=18.0.0"
    }
}
</file>

<file path="stacks/services/clerk/hello-world/tests/unit/test-handler.test.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { lambdaHandler } from '../../app';
import { expect, describe, it } from '@jest/globals';

describe('Unit test for app handler', function () {
    it('verifies successful response', async () => {
        const event: APIGatewayProxyEvent = {
            httpMethod: 'get',
            body: '',
            headers: {},
            isBase64Encoded: false,
            multiValueHeaders: {},
            multiValueQueryStringParameters: {},
            path: '/hello',
            pathParameters: {},
            queryStringParameters: {},
            requestContext: {
                accountId: '123456789012',
                apiId: '1234',
                authorizer: {},
                httpMethod: 'get',
                identity: {
                    accessKey: '',
                    accountId: '',
                    apiKey: '',
                    apiKeyId: '',
                    caller: '',
                    clientCert: {
                        clientCertPem: '',
                        issuerDN: '',
                        serialNumber: '',
                        subjectDN: '',
                        validity: { notAfter: '', notBefore: '' },
                    },
                    cognitoAuthenticationProvider: '',
                    cognitoAuthenticationType: '',
                    cognitoIdentityId: '',
                    cognitoIdentityPoolId: '',
                    principalOrgId: '',
                    sourceIp: '',
                    user: '',
                    userAgent: '',
                    userArn: '',
                },
                path: '/hello',
                protocol: 'HTTP/1.1',
                requestId: 'c6af9ac6-7b61-11e6-9a41-93e8deadbeef',
                requestTimeEpoch: 1428582896000,
                resourceId: '123456',
                resourcePath: '/hello',
                stage: 'dev',
            },
            resource: '',
            stageVariables: {},
        };
        const result: APIGatewayProxyResult = await lambdaHandler(event);

        expect(result.statusCode).toEqual(200);
        expect(result.body).toEqual(
            JSON.stringify({
                message: 'hello world',
            }),
        );
    });
});
</file>

<file path="stacks/services/clerk/hello-world/app.ts">
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';

/**
 *
 * Event doc: https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-input-format
 * @param {Object} event - API Gateway Lambda Proxy Input Format
 *
 * Return doc: https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html
 * @returns {Object} object - API Gateway Lambda Proxy Output Format
 *
 */

export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    try {
        return {
            statusCode: 200,
            body: JSON.stringify({
                message: 'hello world',
            }),
        };
    } catch (err) {
        console.log(err);
        return {
            statusCode: 500,
            body: JSON.stringify({
                message: 'some error happened',
            }),
        };
    }
};
</file>

<file path="tasks/cybrid-transaction-integration-prd.md">
# Cybrid Transaction Integration PRD

## Overview

This document outlines the implementation plan for integrating Cybrid transactions into the CLKK backend system, fixing critical Plaid integration issues, and implementing a new NMI webhook processing flow that uses Cybrid book transfers.

## Background

Currently, the system has several integration points that need alignment:
1. Plaid identity verification queries are failing due to field name mismatches
2. Cybrid transactions are not being stored in the single-table format like NMI transactions
3. NMI webhook processing manually credits wallets instead of using proper book transfers

## Goals

1. Fix immediate critical issues preventing Plaid verification status from working
2. Standardize transaction creation across all payment providers (Cybrid, NMI)
3. Implement modular, reusable transaction services
4. Replace manual wallet crediting with Cybrid book transfers for NMI payments

## Implementation Tasks

### Phase 1: Critical Fixes âœ…

#### Task 1.1: Fix Plaid Verification Status Query
- **Status**: âœ… Completed
- **Description**: Fix field name mismatch in Plaid verification status query
- **Details**: 
  - Change `verificationType` to `source` in filter expression
  - Update corresponding attribute values
  - Ensure queries can find Plaid-sourced verifications
- **Files Modified**:
  - `lambdas/plaid/verificationStatus/app.ts`

#### Task 1.2: Fix Fiat Account Customer ID Resolution
- **Status**: âœ… Completed  
- **Description**: Ensure fiat account creation can find customer ID in both possible locations
- **Details**:
  - Check both `metadata.cybrid.customerId` and `metadata.cybrid.customer.guid`
  - Add proper null checks and error handling
- **Files Modified**:
  - `lambdas/cybrid/accounts/cybrid-accounts.ts`

### Phase 2: Cybrid Transaction Standardization

#### Task 2.1: Create Shared Transaction Service
- **Status**: âœ… Completed
- **Description**: Create a unified transaction service that all payment providers can use
- **Details**:
  - Extract common transaction creation logic
  - Ensure single-table design compliance
  - Support both user and business transactions
  - Include proper TypeScript types
- **New Files**:
  - `lambdas/shared/services/unified-transaction-service.ts` âœ…
  - `lambdas/shared/types/transaction.types.ts` âœ…
  - `lambdas/shared/services/unified-transaction-service.test.ts` âœ…

#### Task 2.2: Update Cybrid Deposit Flow
- **Status**: âœ… Completed
- **Description**: Modify Cybrid deposit handler to use unified transaction service
- **Details**:
  - Create transaction record when deposit quote is created
  - Update transaction with quote GUID
  - Update transaction with transfer GUID when transfer is initiated
  - Ensure GSI keys are properly set
- **Files Modified**:
  - `lambdas/cybrid/quotes/app.ts` âœ…

#### Task 2.3: Update Cybrid P2P Transfer Flow
- **Status**: âœ… Completed
- **Description**: Modify P2P transfer handler to use unified transaction service
- **Details**:
  - Create transaction record with proper sender/recipient entities
  - Store both user transactions (sender and recipient)
  - Include all GSI keys for querying
  - Maintain existing business logic
- **Files Modified**:
  - `lambdas/cybrid/quotes/app.ts` (P2P section) âœ…

#### Task 2.4: Update Cybrid P2B Transfer Flow
- **Status**: âœ… Completed
- **Description**: Modify P2B transfer handler to use unified transaction service
- **Details**:
  - Create transaction with business as recipient
  - Calculate and store fees properly
  - Store transaction under both user and business partitions
  - Include all necessary metadata
- **Files Modified**:
  - `lambdas/cybrid/quotes/app.ts` (P2B section) âœ…

#### Task 2.5: Update Cybrid Transfer Webhook Processor
- **Status**: âœ… Completed
- **Description**: Ensure webhook processor updates transactions correctly
- **Details**:
  - Find transaction by payment provider ID (transfer GUID)
  - Update transaction status based on transfer state
  - Handle all transfer states (pending, completed, failed)
  - Maintain audit trail with timestamps
- **Files Modified**:
  - `lambdas/cybrid/transfers/webhooks/transfer-processor.ts` âœ…

### Phase 3: NMI Webhook Enhancement

#### Task 3.1: Create Book Transfer Service
- **Status**: âœ… Completed
- **Description**: Create modular service for initiating Cybrid book transfers
- **Details**:
  - Accept source and destination account IDs
  - Handle master account transfers
  - Return transfer details
  - Include comprehensive error handling
- **New Files**:
  - `lambdas/shared/services/book-transfer-service.ts` âœ…

#### Task 3.2: Use Platform Bank GUID
- **Status**: âœ… Completed
- **Description**: Use existing platform bank GUID for book transfers
- **Details**:
  - Use PLATFORM_BANK_GUID from processPlatformFee.ts
  - Platform bank acts as source for NMI deposit transfers
  - No additional configuration needed
- **Changes**:
  - Updated book transfer service to support bank-to-customer transfers
  - Uses hardcoded PLATFORM_BANK_GUID = '59d6b3a8cd8274024cde9e1cba94af28'

#### Task 3.3: Update NMI Webhook Processor
- **Status**: âœ… Completed
- **Description**: Replace manual wallet crediting with Cybrid book transfers
- **Details**:
  - On successful NMI payment webhook:
    1. Retrieve original transaction details
    2. Identify recipient from transaction
    3. Initiate book transfer from master account to recipient
    4. Update transaction with book transfer details
    5. Handle transfer success/failure
- **Files Modified**:
  - `lambdas/nmi/webhooks/services/webhook-service.ts` âœ… (Updated existing service)

#### Task 3.4: Add Transaction Lookup Service
- **Status**: â¬œ Pending
- **Description**: Create service to efficiently find transactions by provider ID
- **Details**:
  - Use TransactionIdIndex GSI when possible
  - Support lookup by NMI transaction ID
  - Return full transaction details
  - Handle not found scenarios
- **New Files**:
  - `lambdas/shared/services/transaction-lookup-service.ts`

### Phase 4: Testing & Validation

#### Task 4.1: Create Unit Tests
- **Status**: â¬œ Pending
- **Description**: Comprehensive unit tests for all new services
- **Details**:
  - Test unified transaction service
  - Test book transfer service
  - Test transaction lookup service
  - Mock all external dependencies

#### Task 4.2: Integration Testing
- **Status**: â¬œ Pending
- **Description**: End-to-end testing of complete flows
- **Details**:
  - Test Cybrid deposit with transaction creation
  - Test P2P transfer with dual transaction storage
  - Test NMI webhook to book transfer flow
  - Verify GSI queries work correctly

## Technical Details

### Transaction Data Model

```typescript
interface UnifiedTransaction {
  // Primary identifiers
  userId: string;
  transactionId: string;
  
  // Type and status
  type: TransactionType;
  status: TransactionStatus;
  
  // Amounts
  amount: number;
  asset: string;
  fees?: number;
  net_amount?: number;
  
  // Entities
  senderEntityId: string;
  senderEntityType: EntityType;
  recipientEntityId: string;
  recipientEntityType: EntityType;
  
  // Provider details
  paymentProviderId?: string; // Cybrid transfer GUID or NMI transaction ID
  quoteGuid?: string;
  
  // Metadata
  memo?: string;
  createdAt: string;
  updatedAt: string;
  
  // GSI Keys
  TransactionIdKey: string;
  SenderIdKey: string;
  RecipientIdKey: string;
}
```

### Book Transfer Flow for NMI

```mermaid
sequenceDiagram
    participant NMI
    participant Webhook
    participant TransactionService
    participant BookTransferService
    participant Cybrid
    
    NMI->>Webhook: Payment Success Webhook
    Webhook->>TransactionService: Lookup Transaction by NMI ID
    TransactionService-->>Webhook: Transaction Details
    Webhook->>BookTransferService: Initiate Transfer (Masterâ†’Recipient)
    BookTransferService->>Cybrid: Create Book Transfer
    Cybrid-->>BookTransferService: Transfer Created
    BookTransferService-->>Webhook: Transfer Details
    Webhook->>TransactionService: Update Transaction Status
```

### Key Principles

1. **Modularity**: Each service should be independent and reusable
2. **Type Safety**: All functions must have proper TypeScript types
3. **Error Handling**: Comprehensive error handling with meaningful messages
4. **Idempotency**: Support repeated webhook calls without side effects
5. **Audit Trail**: Maintain complete history of all transactions
6. **Performance**: Use GSI indexes for efficient queries

## Success Criteria

1. Plaid verification status queries return correct results
2. All Cybrid transactions are stored in single-table format
3. NMI payments trigger automatic Cybrid book transfers
4. No manual wallet crediting required
5. All services have >90% test coverage
6. System handles all edge cases gracefully

## Future Considerations

1. Add Plaid webhook handler for real-time updates
2. Implement transaction reconciliation service
3. Add monitoring and alerting for failed transfers
4. Create admin tools for transaction management
</file>

<file path="types/users.ts">
/**
 * User status enum
 */
export enum UserStatus {
    PENDING = 'pending',
    ACTIVE = 'active',
    INACTIVE = 'inactive',
    SUSPENDED = 'suspended',
    VERIFICATION_REQUIRED = 'verification_required',
}

/**
 * User address interface
 */
export interface UserAddress {
    street: string;
    extendedAddress?: string;
    city: string;
    region: string;
    postalCode: string;
}

/**
 * User profile interface
 */
export interface UserProfile {
    userId: string;
    email: string;
    firstName?: string;
    lastName?: string;
    displayName?: string;
    phoneNumber?: string;
    dob?: string;
    ssn?: string;
    address?: UserAddress;
    isVerified: boolean;
    verifiedAt?: Date | null;
    status: UserStatus;
    createdAt: Date;
    updatedAt: Date;
}

/**
 * User verification result interface
 */
export interface UserVerificationResult {
    userId: string;
    success: boolean;
    verifiedAt?: Date | null;
    status: UserStatus;
    correlationId?: string;
    errorMessage?: string;
}
</file>

<file path=".eslintignore">
node_modules
.aws-sam
</file>

<file path=".eslintrc.js">
module.exports = {
    parser: "@typescript-eslint/parser",
    parserOptions: {
      ecmaVersion: 2020, // Allows for the parsing of modern ECMAScript features
      sourceType: "module" 
    },
    extends: [
      "plugin:@typescript-eslint/recommended", // recommended rules from the @typescript-eslint/eslint-plugin
      "plugin:prettier/recommended" // Enables eslint-plugin-prettier and eslint-config-prettier. This will display prettier errors as ESLint errors. Make sure this is always the last configuration in the extends array.
    ],
    rules: {
      // Place to specify ESLint rules. Can be used to overwrite rules specified from the extended configs
      // e.g. "@typescript-eslint/explicit-function-return-type": "off",
    }
  };
</file>

<file path=".gitignore">
# Created by https://www.toptal.com/developers/gitignore/api/osx,node,linux,windows,sam
# Edit at https://www.toptal.com/developers/gitignore?templates=osx,node,linux,windows,sam

### Linux ###
*~

# temporary files which can be created if a process still has a handle open of a deleted file
.fuse_hidden*

# KDE directory preferences
.directory

# Linux trash folder which might appear on any partition or disk
.Trash-*

# .nfs files are created when an open file is removed but is still being accessed
.nfs*

### Node ###
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env*.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Storybook build outputs
.out
.storybook-out
storybook-static

# rollup.js default build output
dist/

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# Temporary folders
tmp/
temp/

### OSX ###
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

### SAM ###
# Ignore build directories for the AWS Serverless Application Model (SAM)
# Info: https://aws.amazon.com/serverless/sam/
# Docs: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-reference.html

**/.aws-sam

### Windows ###
# Windows thumbnail cache files
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db

# Dump file
*.stackdump

# Folder config file
[Dd]esktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk

# End of https://www.toptal.com/developers/gitignore/api/osx,node,linux,windows,sam


.cursorrules
private
.qodo
</file>

<file path=".npmignore">
tests/*
</file>

<file path=".prettierrc.js">
module.exports = {
    semi: true,
    trailingComma: "all",
    singleQuote: true,
    printWidth: 120,
    tabWidth: 4
  };
</file>

<file path="CLAUDE.local.md">
## Development Notes

- Use --profile=clkk-mobile-dev While making requests to API for development profile.
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

CLKK is a serverless payment processing platform built on AWS using SAM (Serverless Application Model). The backend handles user authentication, KYC verification, payment processing, and transaction management.

## Key Commands

### Development
```bash
# Install dependencies
npm install

# Build the project
npm run build

# Run tests
npm test

# Run tests in watch mode
npm run test:watch

# Run a specific test file
npm test path/to/test.test.ts

# Lint code
npm run lint

# Type check
npm run typecheck

# Local development with SAM
sam build
sam local start-api --env-vars env.json
```

### Deployment
```bash
# Deploy to AWS (requires proper AWS credentials)
sam deploy --guided

# Deploy with specific profile
sam deploy --profile <profile-name>
```

## Architecture

### Lambda Functions Structure
- Each Lambda function is in `src/lambdas/<function-name>/`
- Handler files follow the pattern: `<function-name>Handler.ts`
- Functions export a `handler` that processes API Gateway events

### Database Design
The application uses a single-table DynamoDB design with composite keys:
- **Primary Key**: `PK` (partition key), `SK` (sort key)
- **GSI1**: `GSI1PK`, `GSI1SK` - For user-based queries
- **GSI2**: `GSI2PK`, `GSI2SK` - For transaction queries
- **LSI1**: `PK`, `LSI1SK` - For timestamp-based queries

Entity patterns:
- User: `PK=USER#<userId>`, `SK=USER#<userId>`
- Account: `PK=USER#<userId>`, `SK=ACCOUNT#<accountId>`
- Transaction: `PK=USER#<userId>`, `SK=TXN#<timestamp>#<txnId>`
- Bank: `PK=USER#<userId>`, `SK=BANK#<bankId>`

### Shared Layer
Common utilities are in `src/layers/shared/nodejs/`:
- `dynamodb.ts` - DynamoDB client and operations
- `auth.ts` - Authentication utilities
- `logger.ts` - Structured logging
- `schemas.ts` - Data validation schemas
- `errors.ts` - Custom error classes

### Payment Integrations
- **NMI** (`src/services/nmi/`) - ACH payment processing
- **Checkbook** (`src/services/checkbook/`) - Digital check processing
- **Transfix** (`src/services/transfix/`) - Payment routing

### Security
- All sensitive data encrypted using AWS KMS
- Clerk JWT verification for authentication
- KYC verification through Prove
- Environment-specific configurations

## Environment Variables

Required environment variables:
- `DYNAMODB_TABLE_NAME` - Main DynamoDB table
- `CLERK_PUBLIC_KEY` - Clerk authentication
- `PROVE_API_KEY`, `PROVE_CLIENT_ID`, `PROVE_CLIENT_SECRET` - KYC verification
- `NMI_USERNAME`, `NMI_PASSWORD` - NMI payment processing
- `CHECKBOOK_API_KEY`, `CHECKBOOK_API_SECRET` - Checkbook integration
- `KMS_KEY_ID` - AWS KMS key for encryption

## Testing Approach

- Unit tests alongside source files (`*.test.ts`)
- Mock AWS services using `aws-sdk-client-mock`
- Test utilities in `src/test-utils/`
- Coverage reports generated in `coverage/`

## Common Development Tasks

### Adding a New Lambda Function
1. Create directory: `src/lambdas/<function-name>/`
2. Create handler: `<function-name>Handler.ts`
3. Add to `template.yaml` under Resources
4. Update API Gateway routes if needed

### Working with DynamoDB
- Use the shared DynamoDB client from the layer
- Follow the single-table design patterns
- Always include proper error handling for DynamoDB operations

### Adding Environment Variables
1. Add to `template.yaml` in the Globals section
2. Update `env.json` for local development
3. Update `src/types/environment.d.ts` for TypeScript support

## Troubleshooting

### Common Issues
- **Module not found**: Ensure you've run `npm install` and `npm run build`
- **DynamoDB errors**: Check table name and AWS credentials
- **Type errors**: Run `npm run typecheck` to identify issues
- **Test failures**: Check mock data matches current schemas

### Local Development
- Use `sam local start-api` with proper `env.json`
- Ensure Docker is running for SAM CLI
- Check Lambda function logs in console output

## Important Notes

- Always maintain backward compatibility for API changes
- Update tests when modifying business logic
- Use structured logging with correlation IDs
- Follow the existing code patterns and conventions
- Validate all external inputs using the schema validators
</file>

<file path="jest.config.ts">
/*
 * For a detailed explanation regarding each configuration property and type check, visit:
 * https://jestjs.io/docs/configuration
 */

export default {
    transform: {
        '^.+\\.ts?$': 'ts-jest',
    },
    clearMocks: true,
    collectCoverage: true,
    coverageDirectory: 'coverage',
    coverageProvider: 'v8',
    testMatch: ['**/*.test.ts'],
};
</file>

<file path="package.json">
{
  "name": "hello_world",
  "version": "1.0.0",
  "description": "hello world sample for NodeJS",
  "main": "app.js",
  "repository": "https://github.com/awslabs/aws-sam-cli/tree/develop/samcli/local/init/templates/cookiecutter-aws-sam-hello-nodejs",
  "author": "SAM CLI",
  "license": "MIT",
  "scripts": {
    "unit": "jest",
    "jest": "jest --watchAll",
    "lint": "eslint '*.ts' --quiet --fix",
    "compile": "tsc",
    "test": "npm run compile && npm run unit",
    "sam:build": "sam build --use-container --cached"
  },
  "dependencies": {
    "@aws-lambda-powertools/logger": "^2.17.0",
    "@aws-sdk/client-secrets-manager": "^3.782.0",
    "@aws-sdk/client-ssm": "^3.787.0"
  },
  "devDependencies": {
    "@jest/globals": "^29.2.0",
    "esbuild": "^0.14.14",
    "@types/aws-lambda": "^8.10.114",
    "@types/jest": "^29.5.1",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^18.16.3",
    "@types/uuid": "^9.0.2",
    "@typescript-eslint/eslint-plugin": "^6.3.0",
    "@typescript-eslint/parser": "^6.3.0",
    "aws-sdk-client-mock": "^3.1.0",
    "eslint": "^8.47.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.1",
    "ts-jest": "^29.1.0",
    "ts-node": "^10.9.1",
    "typescript": "^5.0.4"
  }
}
</file>

<file path="README.md">
# clkk-backend

This project contains source code and supporting files for a serverless application that you can deploy with the SAM CLI. It includes the following files and folders.

- hello-world - Code for the application's Lambda function written in TypeScript.
- events - Invocation events that you can use to invoke the function.
- hello-world/tests - Unit tests for the application code.
- template.yaml - A template that defines the application's AWS resources.

The application uses several AWS resources, including Lambda functions and an API Gateway API. These resources are defined in the `template.yaml` file in this project. You can update the template to add AWS resources through the same deployment process that updates your application code.

If you prefer to use an integrated development environment (IDE) to build and test your application, you can use the AWS Toolkit.  
The AWS Toolkit is an open source plug-in for popular IDEs that uses the SAM CLI to build and deploy serverless applications on AWS. The AWS Toolkit also adds a simplified step-through debugging experience for Lambda function code. See the following links to get started.

- [CLion](https://docs.aws.amazon.com/toolkit-for-jetbrains/latest/userguide/welcome.html)
- [GoLand](https://docs.aws.amazon.com/toolkit-for-jetbrains/latest/userguide/welcome.html)
- [IntelliJ](https://docs.aws.amazon.com/toolkit-for-jetbrains/latest/userguide/welcome.html)
- [WebStorm](https://docs.aws.amazon.com/toolkit-for-jetbrains/latest/userguide/welcome.html)
- [Rider](https://docs.aws.amazon.com/toolkit-for-jetbrains/latest/userguide/welcome.html)
- [PhpStorm](https://docs.aws.amazon.com/toolkit-for-jetbrains/latest/userguide/welcome.html)
- [PyCharm](https://docs.aws.amazon.com/toolkit-for-jetbrains/latest/userguide/welcome.html)
- [RubyMine](https://docs.aws.amazon.com/toolkit-for-jetbrains/latest/userguide/welcome.html)
- [DataGrip](https://docs.aws.amazon.com/toolkit-for-jetbrains/latest/userguide/welcome.html)
- [VS Code](https://docs.aws.amazon.com/toolkit-for-vscode/latest/userguide/welcome.html)
- [Visual Studio](https://docs.aws.amazon.com/toolkit-for-visual-studio/latest/user-guide/welcome.html)

## Deploy the sample application

The Serverless Application Model Command Line Interface (SAM CLI) is an extension of the AWS CLI that adds functionality for building and testing Lambda applications. It uses Docker to run your functions in an Amazon Linux environment that matches Lambda. It can also emulate your application's build environment and API.

To use the SAM CLI, you need the following tools.

- SAM CLI - [Install the SAM CLI](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html)
- Node.js - [Install Node.js 22](https://nodejs.org/en/), including the NPM package management tool.
- Docker - [Install Docker community edition](https://hub.docker.com/search/?type=edition&offering=community)

To build and deploy your application for the first time, run the following in your shell:

```bash
sam build
sam deploy --guided
```

The first command will build the source of your application. The second command will package and deploy your application to AWS, with a series of prompts:

- **Stack Name**: The name of the stack to deploy to CloudFormation. This should be unique to your account and region, and a good starting point would be something matching your project name.
- **AWS Region**: The AWS region you want to deploy your app to.
- **Confirm changes before deploy**: If set to yes, any change sets will be shown to you before execution for manual review. If set to no, the AWS SAM CLI will automatically deploy application changes.
- **Allow SAM CLI IAM role creation**: Many AWS SAM templates, including this example, create AWS IAM roles required for the AWS Lambda function(s) included to access AWS services. By default, these are scoped down to minimum required permissions. To deploy an AWS CloudFormation stack which creates or modifies IAM roles, the `CAPABILITY_IAM` value for `capabilities` must be provided. If permission isn't provided through this prompt, to deploy this example you must explicitly pass `--capabilities CAPABILITY_IAM` to the `sam deploy` command.
- **Save arguments to samconfig.toml**: If set to yes, your choices will be saved to a configuration file inside the project, so that in the future you can just re-run `sam deploy` without parameters to deploy changes to your application.

You can find your API Gateway Endpoint URL in the output values displayed after deployment.

## Use the SAM CLI to build and test locally

Build your application with the `sam build` command.

```bash
clkk-backend$ sam build
```

The SAM CLI installs dependencies defined in `hello-world/package.json`, compiles TypeScript with esbuild, creates a deployment package, and saves it in the `.aws-sam/build` folder.

Test a single function by invoking it directly with a test event. An event is a JSON document that represents the input that the function receives from the event source. Test events are included in the `events` folder in this project.

Run functions locally and invoke them with the `sam local invoke` command.

```bash
clkk-backend$ sam local invoke HelloWorldFunction --event events/event.json
```

The SAM CLI can also emulate your application's API. Use the `sam local start-api` to run the API locally on port 3000.

```bash
clkk-backend$ sam local start-api
clkk-backend$ curl http://localhost:3000/
```

The SAM CLI reads the application template to determine the API's routes and the functions that they invoke. The `Events` property on each function's definition includes the route and method for each path.

```yaml
Events:
    HelloWorld:
        Type: Api
        Properties:
            Path: /hello
            Method: get
```

## Add a resource to your application

The application template uses AWS Serverless Application Model (AWS SAM) to define application resources. AWS SAM is an extension of AWS CloudFormation with a simpler syntax for configuring common serverless application resources such as functions, triggers, and APIs. For resources not included in [the SAM specification](https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md), you can use standard [AWS CloudFormation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) resource types.

## Fetch, tail, and filter Lambda function logs

To simplify troubleshooting, SAM CLI has a command called `sam logs`. `sam logs` lets you fetch logs generated by your deployed Lambda function from the command line. In addition to printing the logs on the terminal, this command has several nifty features to help you quickly find the bug.

`NOTE`: This command works for all AWS Lambda functions; not just the ones you deploy using SAM.

```bash
clkk-backend$ sam logs -n HelloWorldFunction --stack-name clkk-backend --tail
```

You can find more information and examples about filtering Lambda function logs in the [SAM CLI Documentation](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-logging.html).

## Unit tests

Tests are defined in the `hello-world/tests` folder in this project. Use NPM to install the [Jest test framework](https://jestjs.io/) and run unit tests.

```bash
clkk-backend$ cd hello-world
hello-world$ npm install
hello-world$ npm run test
```

## Cleanup

To delete the sample application that you created, use the AWS CLI. Assuming you used your project name for the stack name, you can run the following:

```bash
sam delete --stack-name clkk-backend
```

## Resources

See the [AWS SAM developer guide](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html) for an introduction to SAM specification, the SAM CLI, and serverless application concepts.

Next, you can use AWS Serverless Application Repository to deploy ready to use Apps that go beyond hello world samples and learn how authors developed their applications: [AWS Serverless Application Repository main page](https://aws.amazon.com/serverless/serverlessrepo/)

## Single-Table Design Migration

We've implemented a single-table design for DynamoDB to improve performance and reduce costs. This design allows for efficient querying with minimal round trips to the database.

### Key Changes

- **Consolidated Data Model**: All entities (users, businesses, transactions, etc.) are now stored in a single table with appropriate key design.
- **Access Patterns**: Optimized access patterns using GSIs for different query requirements.
- **Compatibility Layer**: Added backward compatibility to support existing code during migration.

### Table Structure

The single table uses the following structure:

- **Primary Key**:

    - `PK`: Entity type and ID (e.g., `USER#123`, `BUSINESS#456`, `TRANSACTION#789`)
    - `SK`: Context-specific identifier for various access patterns

- **Global Secondary Indexes**:
    - `GSI1`: General lookups, entity types, transaction details
    - `GSI2`: Date-based queries, entity filtering, time-ordered data
    - `GSI3`: External ID lookups (provider transaction IDs, KYC statuses, phone numbers)

### Entity Access Patterns

Our application now supports efficient entity lookups by various attributes:

- **By ID**: Direct lookup using primary key
- **By Email**: Using GSI2 with email as the key (exact match only)
- **By Phone Number**: Using GSI3 with normalized phone number as the key (exact match only)
- **By Username**:
    - Exact match: Using direct lookup with username
    - Partial match: Using GSI1 with `contains` filtering for substring searches
- **By KYC Status**: Using GSI3 to find entities with specific verification status

All lookups maintain uniqueness constraints for email, username, and phone number across the entire user base. Username searches can be performed with partial strings, making it easy to implement autocomplete or search features, while still ensuring uniqueness for account creation.

### Migration Plan

1. **Phase 1** âœ…: Update entity and transaction classes to use single-table design
2. **Phase 2** âœ…: Add compatibility layer for existing code
3. **Phase 3**: Gradually update all services to use the new data access patterns
4. **Phase 4**: Migrate existing data from legacy tables to the single table
5. **Phase 5**: Remove compatibility layer and legacy tables

## Building and Deploying

To build and deploy the backend:

```bash
npm install
npm run build
sam deploy
```

## DynamoDB Data Model Design

The application uses a single-table design pattern for DynamoDB to store different entity types (Users, Businesses, etc.) with optimized access patterns through Global Secondary Indexes (GSIs).

### Recent DynamoDB Design Improvements

We've implemented the following improvements to our DynamoDB data model:

#### 1. Improved GSI Key Attribute Naming

Instead of using generic attribute names like `GSI1PK`, `GSI1SK`, etc., we've adopted meaningful attribute names that convey the purpose of the data they hold:

- Changed `GSI1PK/GSI1SK` to `EntityTypeKey/EntityStatusSortKey` for entity type and status queries
- Changed `GSI2PK/GSI2SK` to `EmailLookupKey/EmailValue` for email lookups
- Changed `GSI3PK/GSI3SK` to `KYCStatusKey/EntityTypeIdKey` for KYC status queries

Benefits:

- Better code readability and self-documenting data model
- Increased flexibility for future schema changes
- Improved maintainability through meaningful attribute names

#### 2. Optimized GSI Projections for List Queries

- Ensured that GSIs project the necessary attributes needed for list views to avoid N+1 query patterns
- Reduced the need for fetching full entity details when only summary information is needed

#### 3. Smart Lookup Strategy

- Maintained the use of lookup items for unique constraints (email, phone, username) as they offer:
    - Cheaper reads (GetItem vs Query)
    - Enforced uniqueness at write time
    - Efficient direct lookups

#### 4. Index Naming Convention

- Adopted a clear naming convention for GSIs based on their purpose:
    - `EntityTypeIndex` - For querying entities by type and status
    - `EmailIndex` - For email lookups
    - `UsernameIndex` - For username lookups
    - `PhoneIndex` - For phone number lookups
    - `KYCStatusIndex` - For KYC status queries

These improvements ensure better scalability, maintainability, and performance of our DynamoDB data model.
</file>

<file path="samconfig.toml">
version = 0.1

[default.global.parameters]
stack_name = "clkk-backend"

[default.build.parameters]
cached = true
parallel = true

[default.validate.parameters]
lint = true

[default.deploy.parameters]
capabilities = "CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND"
confirm_changeset = true
resolve_s3 = true
s3_prefix = "clkk-backend"
region = "us-east-1"
disable_rollback = true
image_repositories = []

[default.package.parameters]
resolve_s3 = true

[default.sync.parameters]
watch = true

[default.local_start_api.parameters]
warm_containers = "EAGER"

[default.local_start_lambda.parameters]
warm_containers = "EAGER"


[dev.deploy.parameters]
parameter_overrides = "Environment=dev HostedZoneId=Z098588615LHSE8YCMDOU"

[test.deploy.parameters]
parameter_overrides = "Environment=test HostedZoneId=Z098588615LHSE8YCMDOU"
</file>

<file path="template.yaml">
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Root stack for CLKK Mobile App Backend

Parameters:
    Environment:
        Type: String
        Default: dev
        AllowedValues:
            - dev
            - staging
            - prod
        Description: Deployment environment
    ProveEnvironment:
        Type: String
        Default: sandbox
        AllowedValues:
            - sandbox
            - production
        Description: Prove environment
    HostedZoneId:
        Type: String
        Description: Route 53 Hosted Zone ID for clkk.io
        Default: Z098588615LHSE8YCMDOU

    NmiApiUrl:
        Type: String
        Default: 'https://rytepay.transactiongateway.com/api'
        Description: NMI API URL
    NmiMainApiUrl:
        Type: String
        Default: 'https://secure.nmi.com/api/v4'
        Description: NMI Main API URL

Conditions:
    IsProd: !Equals [!Ref Environment, 'prod']
    IsProdOrStaging: !Or [!Equals [!Ref Environment, 'prod'], !Equals [!Ref Environment, 'staging']]

Resources:
    # Networking and infrastructure stack
    NetworkingStack:
        Type: AWS::Serverless::Application
        Properties:
            Location: ./iac/shared/networking.yaml
            Parameters:
                Environment: !Ref Environment
            TimeoutInMinutes: 30
            Tags:
                Project: CLKK
                Environment: !Ref Environment

    PlaidStack:
        Type: AWS::Serverless::Application
        DependsOn: SharedStack
        Properties:
            Location: ./iac/plaid/plaid-stack.yaml
            Parameters:
                Environment: !Ref Environment
                ClerkAuthorizerArn: !GetAtt SharedStack.Outputs.ClerkAuthorizerArn
                PlaidAccessTokensTableArn: !GetAtt SharedStack.Outputs.PlaidAccessTokensTableArn
                EntitiesTableArn: !GetAtt DatabaseStack.Outputs.TableArn
                EntitiesTable: !GetAtt DatabaseStack.Outputs.TableName
                LayerCommons: !GetAtt SharedStack.Outputs.LayerCommons
                CreateExternalBankAccountFunction: !GetAtt CybridStack.Outputs.CreateExternalBankAccountFunction
                CreateExternalBankAccountFunctionArn: !GetAtt CybridStack.Outputs.CreateExternalBankAccountFunctionArn
                CybridSecretName: !GetAtt CybridStack.Outputs.CybridSecretName
                CybridBaseUrl: !GetAtt CybridStack.Outputs.CybridBaseUrl
                CybridIdentityVerificationsTableArn: !GetAtt CybridStack.Outputs.CybridIdentityVerificationsTableArn

    CybridStack:
        Type: AWS::Serverless::Application
        DependsOn: SharedStack
        Properties:
            Location: ./iac/cybrid/cybrid-stack.yaml
            Parameters:
                Environment: !Ref Environment
                EntitiesTable: !GetAtt DatabaseStack.Outputs.TableName
                ClerkAuthorizerArn: !GetAtt SharedStack.Outputs.ClerkAuthorizerArn
                PlaidAccessTokensTable: !GetAtt SharedStack.Outputs.PlaidAccessTokensTable
                LayerCommons: !GetAtt SharedStack.Outputs.LayerCommons
                EntitiesTableArn: !GetAtt DatabaseStack.Outputs.TableArn
                EntitiesTableStreamArn: !GetAtt DatabaseStack.Outputs.TableStreamArn

    # DomainStack:
    #     Type: AWS::Serverless::Application
    #     Properties:
    #         Location: ./iac/shared/domain-stack.yaml
    #         Parameters:
    #             Environment: !Ref Environment
    #             HostedZoneId: !Ref HostedZoneId
    #         TimeoutInMinutes: 30
    #         Tags:
    #             Project: CLKK
    #             Environment: !Ref Environment

    # IAM Policies stack
    IAMPoliciesStack:
        Type: AWS::CloudFormation::Stack

        Properties:
            TemplateURL: ./iac/shared/iam-policies.yaml
            Parameters:
                Environment: !Ref Environment
                KmsKeyId: !Ref EncryptionKey

    # Database stack
    DatabaseStack:
        Type: AWS::Serverless::Application
        Properties:
            Location: ./iac/database-stack.yaml
            Parameters:
                Environment: !Ref Environment
            Tags:
                Project: CLKK
                Environment: !Ref Environment

    # KMS Key for encryption
    EncryptionKey:
        Type: AWS::KMS::Key
        Properties:
            Description: KMS key for encrypting sensitive data
            KeyPolicy:
                Version: '2012-10-17'
                Id: key-policy
                Statement:
                    - Sid: Enable IAM User Permissions
                      Effect: Allow
                      Principal:
                          AWS: !Sub arn:aws:iam::${AWS::AccountId}:root
                      Action: kms:*
                      Resource: '*'
            Tags:
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    EncryptionKeyAlias:
        Type: AWS::KMS::Alias
        Properties:
            AliasName: !Sub alias/clkk-encryption-${Environment}
            TargetKeyId: !Ref EncryptionKey

    # # Prove Identity Verification Stack
    # ProveIdentityStack:
    #     Type: AWS::CloudFormation::Stack
    #     DependsOn:
    #         - NetworkingStack
    #         - IAMPoliciesStack
    #     Properties:
    #         TemplateURL: ./iac/prove/identity-stack.yaml
    #         Parameters:
    #             NetworkingStackName: !GetAtt NetworkingStack.Outputs.StackName
    #             KmsKeyId: !Ref EncryptionKey
    #             ProveClientId: '{{resolve:secretsmanager:prove/credentials:SecretString:clientId}}'
    #             ProveClientSecret: '{{resolve:secretsmanager:prove/credentials:SecretString:clientSecret}}'
    #             ProveEnvironment: !Ref ProveEnvironment
    #             ClerkAuthorizerArn: !GetAtt SharedStack.Outputs.ClerkAuthorizerArn
    #         TimeoutInMinutes: 30
    #         Tags:
    #             - Key: Project
    #               Value: CLKK
    #             - Key: Environment
    #               Value: !Ref Environment

    # Shared components stack
    SharedStack:
        Type: AWS::CloudFormation::Stack
        Properties:
            TemplateURL: ./iac/shared/shared-stack.yaml
            Parameters:
                Environment: !Ref Environment
                KmsKeyId: !Ref EncryptionKey
            TimeoutInMinutes: 30
            Tags:
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    ClerkUsersStack:
        Type: AWS::Serverless::Application
        Properties:
            Location: ./iac/users/users-stack.yaml
            Parameters:
                Environment: !Ref Environment
                LayerCommons: !GetAtt SharedStack.Outputs.LayerCommons
                ApplicationTable: !GetAtt DatabaseStack.Outputs.TableName
                ApplicationTableArn: !GetAtt DatabaseStack.Outputs.TableArn
                ClerkAuthorizerArn: !GetAtt SharedStack.Outputs.ClerkAuthorizerArn

    # NMI Payment Gateway Stack
    NmiPaymentStack:
        Type: AWS::CloudFormation::Stack
        Properties:
            TemplateURL: ./iac/nmi/nmi-stack.yaml
            Parameters:
                Stage: !Ref Environment
                NetworkingStackName: !GetAtt NetworkingStack.Outputs.StackName
                KmsKeyId: !Ref EncryptionKey
                NmiApiUrl: !Ref NmiApiUrl
                NmiPrivateKey: '{{resolve:secretsmanager:nmi/credentials:SecretString:NMI_PRIVATE_KEY}}'
                ClerkAuthorizerArn: !GetAtt SharedStack.Outputs.ClerkAuthorizerArn
                LayerCommons: !GetAtt SharedStack.Outputs.LayerCommons
                NmiMainApiUrl: !Ref NmiMainApiUrl
                ApplicationTableName: !GetAtt DatabaseStack.Outputs.TableName
                ApplicationTableArn: !GetAtt DatabaseStack.Outputs.TableArn
            TimeoutInMinutes: 30
            Tags:
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment

    # Checkbook Payment Integration Stack
    CheckbookStack:
        Type: AWS::CloudFormation::Stack
        Properties:
            TemplateURL: ./iac/checkbook/checkbook-stack.yaml
            Parameters:
                Environment: !Ref Environment
                NetworkingStackName: !GetAtt NetworkingStack.Outputs.StackName
                ApplicationTableName: !GetAtt DatabaseStack.Outputs.TableName
                CheckbookEnvironment:
                    Fn::If:
                        - 'IsProdOrStaging'
                        - 'PRODUCTION'
                        - 'SANDBOX'
                CheckbookPublishableApiKeyArn: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
                CheckbookSecretApiKeyArn: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:checkbook/credentials'
                ClerkAuthorizerArn: !GetAtt SharedStack.Outputs.ClerkAuthorizerArn
                LayerCommons: !GetAtt SharedStack.Outputs.LayerCommons
                KmsKeyId: !Ref EncryptionKey
            TimeoutInMinutes: 30
            Tags:
                - Key: Project
                  Value: CLKK
                - Key: Environment
                  Value: !Ref Environment


    AppSyncStack:
        Type: AWS::CloudFormation::Stack
        DependsOn: 
            - SharedStack
            - CybridStack
        Properties:
            TemplateURL: ./iac/appSync/app-sync.yaml
            Parameters:
                Environment: !Ref Environment
                ApplicationTableStreamArn: !GetAtt DatabaseStack.Outputs.TableStreamArn
                TableName: !GetAtt DatabaseStack.Outputs.TableName
                LayerCommons: !GetAtt SharedStack.Outputs.LayerCommons
                # Parameters for GraphQL API integration
                EntitiesTable: !GetAtt DatabaseStack.Outputs.TableName
                EntitiesTableArn: !GetAtt DatabaseStack.Outputs.TableArn
                PlaidAccessTokensTable: !GetAtt SharedStack.Outputs.PlaidAccessTokensTable
                PlaidAccessTokensTableArn: !GetAtt SharedStack.Outputs.PlaidAccessTokensTableArn
                CybridFiatAccountsTable: !GetAtt CybridStack.Outputs.CybridFiatAccountsTable
                CybridFiatAccountsTableArn: !GetAtt CybridStack.Outputs.CybridFiatAccountsTableArn
                CybridIdentityVerificationsTable: !GetAtt CybridStack.Outputs.CybridIdentityVerificationsTable
                CybridIdentityVerificationsTableArn: !GetAtt CybridStack.Outputs.CybridIdentityVerificationsTableArn
                CLKKTransactionsTable: !GetAtt CybridStack.Outputs.CLKKTransactionsTable
                CLKKTransactionsTableArn: !GetAtt CybridStack.Outputs.CLKKTransactionsTableArn

    # # Test data stack
    # TestDataStack:
    #     Type: AWS::CloudFormation::Stack
    #     Properties:
    #         TemplateURL: ./iac/shared/test-data-bucket.yaml
    #         Parameters:
    #             Environment: !Ref Environment

Outputs:
    # APIEndpoint:
    #     Description: API Gateway Endpoint
    #     Value: !GetAtt ProveIdentityStack.Outputs.ApiEndpoint

    # StaticOutboundIP:
    #     Description: Static outbound IP for API calls
    #     Value: !GetAtt ProveIdentityStack.Outputs.NatGatewayIp

    TableName:
        Description: 'DynamoDB Table Name'
        Value: !GetAtt DatabaseStack.Outputs.TableName
    TableArn:
        Description: 'DynamoDB Table ARN'
        Value: !GetAtt DatabaseStack.Outputs.TableArn

    NmiApiEndpoint:
        Description: 'NMI Payment API Gateway Endpoint'
        Value: !GetAtt NmiPaymentStack.Outputs.ApiEndpoint

    ClerkWebhookEndpoint:
        Description: 'Clerk Webhook Endpoint'
        Value: !GetAtt ClerkUsersStack.Outputs.ClerkWebhookEndpoint

    CheckbookApiEndpoint:
        Description: 'Checkbook Payment API Gateway Endpoint'
        Value: !GetAtt CheckbookStack.Outputs.ApiEndpoint

    AppSyncGraphQLEndpoint:
        Description: 'Unified GraphQL API Endpoint (Queries, Mutations, and Subscriptions)'
        Value: !GetAtt AppSyncStack.Outputs.AppSyncApiEndpoint

    AppSyncWebSocketUrl:
        Description: 'WebSocket URL for GraphQL Subscriptions'
        Value: !GetAtt AppSyncStack.Outputs.WebSocketUrl

    CurrentEnvironment:
        Description: Current environment
        Value: !Ref Environment
</file>

</files>

import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, GetCommand, PutCommand, UpdateCommand, DeleteCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';
import { User, UserData } from 'entities';
import { ATTRIBUTES, KEY_BUILDERS, INDEXES } from 'constants';

export class UserRepository {
  private client: DynamoDBDocumentClient;
  private tableName: string;

  constructor() {
    const dynamoDbClient = new DynamoDBClient({});
    this.client = DynamoDBDocumentClient.from(dynamoDbClient);
    this.tableName = process.env.TABLE_NAME || '';
  }

  async get(userId: string): Promise<UserData | null> {
    const keys = KEY_BUILDERS.user(userId);
    const command = new GetCommand({
      TableName: this.tableName,
      Key: keys,
    });

    const result = await this.client.send(command);
    return result.Item ? User.fromDynamoDBItem(result.Item) : null;
  }

  async getByExternalId(provider: string, externalId: string): Promise<UserData | null> {
    const externalIdKey = KEY_BUILDERS.externalId(provider, externalId)[ATTRIBUTES.EXTERNAL_ID_KEY];
    
    const command = new QueryCommand({
      TableName: this.tableName,
      IndexName: INDEXES.EXTERNAL_ID_INDEX,
      KeyConditionExpression: `${ATTRIBUTES.EXTERNAL_ID_KEY} = :externalId`,
      ExpressionAttributeValues: {
        ':externalId': externalIdKey,
      },
      Limit: 1,
    });

    const result = await this.client.send(command);
    return result.Items && result.Items.length > 0 
      ? User.fromDynamoDBItem(result.Items[0]) 
      : null;
  }

  async getByEmail(email: string): Promise<UserData | null> {
    const command = new QueryCommand({
      TableName: this.tableName,
      IndexName: INDEXES.EMAIL_INDEX,
      KeyConditionExpression: `${ATTRIBUTES.EMAIL_KEY} = :email`,
      ExpressionAttributeValues: {
        ':email': email,
      },
      Limit: 1,
    });

    const result = await this.client.send(command);
    return result.Items && result.Items.length > 0 
      ? User.fromDynamoDBItem(result.Items[0]) 
      : null;
  }

  async getByClkkTag(clkkTag: string): Promise<UserData | null> {
    const command = new QueryCommand({
      TableName: this.tableName,
      IndexName: INDEXES.CLKK_TAG_INDEX,
      KeyConditionExpression: `${ATTRIBUTES.CLKK_TAG_KEY} = :clkkTag`,
      ExpressionAttributeValues: {
        ':clkkTag': clkkTag,
      },
      Limit: 1,
    });

    const result = await this.client.send(command);
    return result.Items && result.Items.length > 0 
      ? User.fromDynamoDBItem(result.Items[0]) 
      : null;
  }

  async create(userData: Omit<UserData, 'userId' | 'createdAt' | 'updatedAt'>): Promise<UserData> {
    const user = new User({
      ...userData,
      userId: undefined as any, // Will be generated by User constructor
    });

    const item = user.toDynamoDBItem();

    const command = new PutCommand({
      TableName: this.tableName,
      Item: item,
      ConditionExpression: 'attribute_not_exists(PK)',
    });

    try {
      await this.client.send(command);
      return user;
    } catch (error: any) {
      if (error.name === 'ConditionalCheckFailedException') {
        throw new Error('User already exists');
      }
      throw error;
    }
  }

  async update(userId: string, updates: Partial<Omit<UserData, 'userId' | 'createdAt'>>): Promise<UserData> {
    const updateExpressions: string[] = [];
    const expressionAttributeNames: Record<string, string> = {};
    const expressionAttributeValues: Record<string, any> = {};

    // Build update expression
    Object.entries(updates).forEach(([key, value]) => {
      if (value !== undefined && key !== 'userId' && key !== 'createdAt') {
        const attrName = `#${key}`;
        const attrValue = `:${key}`;
        
        // Map to DynamoDB attribute names
        let dbAttribute = key.charAt(0).toUpperCase() + key.slice(1);
        updateExpressions.push(`${attrName} = ${attrValue}`);
        expressionAttributeNames[attrName] = dbAttribute;
        expressionAttributeValues[attrValue] = value;
      }
    });

    // Always update the updatedAt timestamp
    updateExpressions.push('#updatedAt = :updatedAt');
    expressionAttributeNames['#updatedAt'] = ATTRIBUTES.UPDATED_AT;
    expressionAttributeValues[':updatedAt'] = new Date().toISOString();

    const keys = KEY_BUILDERS.user(userId);
    const command = new UpdateCommand({
      TableName: this.tableName,
      Key: keys,
      UpdateExpression: `SET ${updateExpressions.join(', ')}`,
      ExpressionAttributeNames: expressionAttributeNames,
      ExpressionAttributeValues: expressionAttributeValues,
      ConditionExpression: 'attribute_exists(PK)',
      ReturnValues: 'ALL_NEW',
    });

    try {
      const result = await this.client.send(command);
      return User.fromDynamoDBItem(result.Attributes!);
    } catch (error: any) {
      if (error.name === 'ConditionalCheckFailedException') {
        throw new Error('User not found');
      }
      throw error;
    }
  }

  async delete(userId: string): Promise<void> {
    const keys = KEY_BUILDERS.user(userId);
    const command = new DeleteCommand({
      TableName: this.tableName,
      Key: keys,
    });

    await this.client.send(command);
  }
}